{
  "info": {
    "version": "5.8.0",
    "title": "EMQX API"
  },
  "components": {
    "parameters": {
      "api_key.name": {
        "in": "path",
        "name": "name",
        "description": "^[A-Za-z]+[A-Za-z0-9-_]*$",
        "required": true,
        "schema": {
          "type": "string"
        },
        "example": "EMQX-API-KEY-1"
      },
      "cluster.node": {
        "in": "path",
        "name": "node",
        "description": "node name",
        "required": true,
        "schema": {
          "type": "string"
        },
        "example": "emqx2@127.0.0.1"
      },
      "emqx_authz_api_mnesia.clientid": {
        "in": "path",
        "name": "clientid",
        "description": "ClientID",
        "required": true,
        "schema": {
          "type": "string"
        },
        "example": "client1"
      },
      "emqx_authz_api_mnesia.username": {
        "in": "path",
        "name": "username",
        "description": "Username",
        "required": true,
        "schema": {
          "type": "string"
        },
        "example": "user1"
      },
      "emqx_mgmt_api_clients.requested_client_fields": {
        "in": "query",
        "name": "fields",
        "description": "Comma separated list of client fields to return in the response",
        "required": false,
        "schema": {
          "default": "all",
          "oneOf": [
            {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "client_attrs",
                  "awaiting_rel_cnt",
                  "awaiting_rel_max",
                  "clean_start",
                  "clientid",
                  "connected",
                  "connected_at",
                  "created_at",
                  "disconnected_at",
                  "expiry_interval",
                  "heap_size",
                  "inflight_cnt",
                  "inflight_max",
                  "ip_address",
                  "is_bridge",
                  "is_expired",
                  "keepalive",
                  "mailbox_len",
                  "mqueue_dropped",
                  "mqueue_len",
                  "mqueue_max",
                  "node",
                  "port",
                  "proto_name",
                  "proto_ver",
                  "recv_cnt",
                  "recv_msg",
                  "recv_msg.dropped",
                  "recv_msg.dropped.await_pubrel_timeout",
                  "recv_msg.qos0",
                  "recv_msg.qos1",
                  "recv_msg.qos2",
                  "recv_oct",
                  "recv_pkt",
                  "reductions",
                  "send_cnt",
                  "send_msg",
                  "send_msg.dropped",
                  "send_msg.dropped.expired",
                  "send_msg.dropped.queue_full",
                  "send_msg.dropped.too_large",
                  "send_msg.qos0",
                  "send_msg.qos1",
                  "send_msg.qos2",
                  "send_oct",
                  "send_pkt",
                  "subscriptions_cnt",
                  "subscriptions_max",
                  "username",
                  "mountpoint",
                  "durable",
                  "n_streams",
                  "seqno_q1_comm",
                  "seqno_q1_dup",
                  "seqno_q1_next",
                  "seqno_q2_comm",
                  "seqno_q2_dup",
                  "seqno_q2_rec",
                  "seqno_q2_next"
                ]
              }
            },
            {
              "type": "string",
              "enum": [
                "all"
              ]
            }
          ]
        }
      },
      "emqx_mgmt_api_nodes.node_name": {
        "in": "path",
        "name": "node",
        "description": "Node name",
        "required": true,
        "schema": {
          "type": "string"
        },
        "example": "emqx@127.0.0.1"
      },
      "emqx_mgmt_api_stats.aggregate": {
        "in": "query",
        "name": "aggregate",
        "description": "Calculation aggregate for all nodes",
        "required": false,
        "schema": {
          "type": "boolean"
        },
        "example": false
      },
      "emqx_prometheus_api.mode": {
        "in": "query",
        "name": "mode",
        "description": "<br/>Metrics format mode.<br/><br/>`node`:<br/>Return metrics from local node. And it is the default behaviour if `mode` not specified.<br/><br/>`all_nodes_aggregated`:<br/>Return metrics for all nodes.<br/>And if possible, calculate the arithmetic sum or logical sum of the indicators of all nodes.<br/><br/>`all_nodes_unaggregated`:<br/>Return metrics from all nodes, and the metrics are not aggregated.<br/>The node name will be included in the returned results to<br/>indicate that certain metrics were returned on a certain node.<br/>",
        "required": false,
        "schema": {
          "default": "node",
          "type": "string",
          "enum": [
            "node",
            "all_nodes_aggregated",
            "all_nodes_unaggregated"
          ]
        },
        "example": "node"
      },
      "listeners.listener_id": {
        "in": "path",
        "name": "id",
        "description": "Listener id",
        "required": true,
        "schema": {
          "type": "string"
        },
        "example": "tcp:demo"
      },
      "plugins.name": {
        "in": "path",
        "name": "name",
        "description": "^[A-Za-z]+[A-Za-z0-9-_.]*$",
        "required": true,
        "schema": {
          "type": "string"
        },
        "example": "emqx_plugin_template-5.0-rc.1"
      },
      "public.cursor": {
        "in": "query",
        "name": "cursor",
        "description": "Opaque value representing the current iteration state.",
        "schema": {
          "default": "none",
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "string",
              "enum": [
                "none"
              ]
            }
          ]
        }
      },
      "public.limit": {
        "in": "query",
        "name": "limit",
        "description": "Results per page(max 10000)",
        "schema": {
          "default": 100,
          "maximum": 10000,
          "type": "integer",
          "minimum": 1
        },
        "example": 50
      },
      "public.page": {
        "in": "query",
        "name": "page",
        "description": "Page number of the results to fetch.",
        "schema": {
          "default": 1,
          "type": "integer",
          "minimum": 1
        },
        "example": 1
      },
      "public.position": {
        "in": "query",
        "name": "position",
        "description": "An opaque token that can then be in subsequent requests to get  the next chunk of results: \"?position={prev_response.meta.position}\"<br/>It is used instead of \"page\" parameter to traverse highly volatile data.<br/>Can be omitted or set to \"none\" to get the first chunk of data.",
        "required": false,
        "schema": {
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "string",
              "enum": [
                "end_of_data"
              ]
            },
            {
              "type": "string",
              "enum": [
                "none"
              ]
            }
          ]
        },
        "example": "none"
      },
      "relup.node_name": {
        "in": "path",
        "name": "node",
        "description": "The node to be upgraded",
        "required": true,
        "schema": {
          "default": "all",
          "type": "string"
        },
        "example": "emqx@127.0.0.1"
      },
      "trace.bytes": {
        "in": "query",
        "name": "bytes",
        "description": "Maximum number of bytes to send in response",
        "required": false,
        "schema": {
          "default": 1000,
          "maximum": 2147483647,
          "type": "integer",
          "minimum": 0
        }
      },
      "trace.name": {
        "in": "path",
        "name": "name",
        "description": "[a-zA-Z0-9-_]",
        "required": true,
        "schema": {
          "type": "string"
        },
        "example": "EMQX-TRACE-1"
      },
      "trace.node": {
        "in": "query",
        "name": "node",
        "description": "Node name",
        "required": false,
        "schema": {
          "type": "string"
        },
        "example": "emqx@127.0.0.1"
      },
      "trace.position": {
        "in": "query",
        "name": "position",
        "description": "Offset from the current trace position.",
        "required": false,
        "schema": {
          "default": 0,
          "type": "integer"
        }
      }
    },
    "schemas": {
      "emqx_gateway_api.gateway_listener_overview": {
        "properties": {
          "id": {
            "type": "string",
            "description": "Listener ID"
          },
          "running": {
            "type": "boolean",
            "description": "Listener Running status"
          },
          "type": {
            "type": "string",
            "enum": [
              "tcp",
              "ssl",
              "udp",
              "dtls"
            ],
            "description": "Listener Type"
          }
        },
        "type": "object"
      },
      "emqx.console_handler": {
        "properties": {
          "level": {
            "default": "warning",
            "type": "string",
            "enum": [
              "debug",
              "info",
              "notice",
              "warning",
              "error",
              "critical",
              "alert",
              "emergency",
              "all"
            ],
            "description": "The log level for the current log handler.<br/>Defaults to warning."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable this log handler."
          },
          "formatter": {
            "default": "text",
            "type": "string",
            "enum": [
              "text",
              "json"
            ],
            "description": "Choose log formatter. <code>text</code> for free text, and <code>json</code> for structured logging."
          },
          "timestamp_format": {
            "default": "auto",
            "type": "string",
            "enum": [
              "auto",
              "epoch",
              "rfc3339"
            ],
            "description": "Pick a timestamp format:<br/>- `auto`: automatically choose the best format based on log formatter. `epoch` for JSON and `rfc3339` for text.<br/>- `epoch`: Unix epoch time in microseconds.<br/>- `rfc3339`: RFC3339 format."
          },
          "time_offset": {
            "default": "system",
            "type": "string",
            "description": "The time offset to be used when formatting the timestamp.<br/>Can be one of:<br/>  - <code>system</code>: the time offset used by the local system<br/>  - <code>utc</code>: the UTC time offset<br/>  - <code>+-[hh]:[mm]</code>: user specified time offset, such as \"-02:00\" or \"+00:00\"<br/>Defaults to: <code>system</code>.<br/>This config has no effect for when formatter is <code>json</code> as the timestamp in JSON is milliseconds since epoch."
          },
          "payload_encode": {
            "default": "text",
            "type": "string",
            "enum": [
              "hex",
              "text",
              "hidden"
            ],
            "description": "Determine the format of the payload format in the trace file.<br/><br/>`text`: Text-based protocol or plain text protocol.<br/> It is recommended when payload is JSON encoded.<br/><br/>`hex`: Binary hexadecimal encode. It is recommended when payload is a custom binary protocol.<br/><br/>`hidden`: payload is obfuscated as `******`"
          }
        },
        "type": "object"
      },
      "bridge_http.get_connector": {
        "required": [
          "name",
          "type",
          "url"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "http"
            ],
            "description": "The action type."
          },
          "name": {
            "type": "string",
            "description": "Action name, used as a human-readable identifier."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this connector."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "url": {
            "type": "string",
            "description": "The URL of the HTTP action.<br/><br/>Template with variables is allowed in the path, but variables cannot be used in the scheme, host,<br/>or port part.<br/><br/>For example, <code> http://localhost:9901/${topic} </code> is allowed, but<br/><code> http://${host}:9901/message </code> or <code> http://localhost:${port}/message </code><br/>is not allowed."
          },
          "headers": {
            "default": {
              "accept": "application/json",
              "cache-control": "no-cache",
              "connection": "keep-alive",
              "content-type": "application/json",
              "keep-alive": "timeout=5"
            },
            "type": "object",
            "description": "The headers of the HTTP request.<br/><br/>Template with variables is allowed.",
            "example": {},
            "is_template": true
          },
          "connect_timeout": {
            "default": "15s",
            "type": "string",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s"
          },
          "retry_interval": {
            "type": "string",
            "deprecated": true,
            "example": "12m"
          },
          "pool_type": {
            "default": "random",
            "type": "string",
            "enum": [
              "random",
              "hash"
            ],
            "description": "The type of the pool. Can be one of `random`, `hash`."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "The pool size.",
            "minimum": 1
          },
          "enable_pipelining": {
            "default": 100,
            "type": "integer",
            "description": "The maximum number of HTTP requests that can be sent before an HTTP response is received.<br/><br/>Setting this to 1 is equivalent to turning off HTTP pipelining, and the EMQX must receive a response to the previous HTTP request before sending the next HTTP request.",
            "minimum": 1
          },
          "request": {
            "type": "object",
            "deprecated": true,
            "description": "This field is never used, so we deprecated it since 5.3.2.",
            "example": {}
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_http.connector_resource_opts"
          }
        },
        "type": "object"
      },
      "modules.rewrite": {
        "required": [
          "action",
          "dest_topic",
          "re",
          "source_topic"
        ],
        "properties": {
          "action": {
            "type": "string",
            "enum": [
              "subscribe",
              "publish",
              "all"
            ],
            "description": "Topic rewriting takes effect on the type of operation:<br/>  - `subscribe`: Rewrite topic when client do subscribe.<br/>  - `publish`: Rewrite topic when client do publish.<br/>  - `all`: Both",
            "example": "publish"
          },
          "source_topic": {
            "type": "string",
            "description": "Source topic, specified by the client.",
            "example": "x/#"
          },
          "dest_topic": {
            "type": "string",
            "description": "Destination topic.",
            "example": "z/y/$1"
          },
          "re": {
            "type": "string",
            "description": "Regular expressions",
            "example": "^x/y/(.+)$"
          }
        },
        "type": "object"
      },
      "emqx.mqtt": {
        "properties": {
          "idle_timeout": {
            "default": "15s",
            "description": "Configure the duration of time that a connection can remain idle (i.e., without any data transfer) before being:<br/>  - Automatically disconnected  if no CONNECT package is received from the client yet.<br/>  - Put into hibernation mode to save resources if some CONNECT packages are already received.<br/>Note: Please set the parameter with caution as long idle time will lead to resource waste.",
            "oneOf": [
              {
                "type": "string",
                "example": "12m"
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "max_packet_size": {
            "default": "1MB",
            "type": "string",
            "description": "Maximum MQTT packet size allowed. Default: 1 MB, Maximum: 256 MB",
            "example": "32MB"
          },
          "max_clientid_len": {
            "default": 65535,
            "maximum": 65535,
            "type": "integer",
            "description": "Maximum allowed length of MQTT Client ID.",
            "minimum": 23
          },
          "max_topic_levels": {
            "default": 128,
            "maximum": 65535,
            "type": "integer",
            "description": "Maximum topic levels allowed.",
            "minimum": 1
          },
          "max_topic_alias": {
            "default": 65535,
            "maximum": 65535,
            "type": "integer",
            "description": "Maximum topic alias, 0 means no topic alias supported.",
            "minimum": 0
          },
          "retain_available": {
            "default": true,
            "type": "boolean",
            "description": "Whether to enable support for MQTT retained message."
          },
          "wildcard_subscription": {
            "default": true,
            "type": "boolean",
            "description": "Whether to enable support for MQTT wildcard subscription."
          },
          "shared_subscription": {
            "default": true,
            "type": "boolean",
            "description": "Whether to enable support for MQTT shared subscription."
          },
          "shared_subscription_strategy": {
            "default": "round_robin",
            "type": "string",
            "enum": [
              "random",
              "round_robin",
              "round_robin_per_group",
              "sticky",
              "local",
              "hash_topic",
              "hash_clientid"
            ],
            "description": "Dispatch strategy for shared subscription.<br/> - `random`: Randomly select a subscriber for dispatch;<br/> - `round_robin`: Clients in a shared subscription group will consume messages in turn, and the progress of the loop is recorded independently in each publisher, so two adjacent messages from **different publishers** may be consumed by the same client in the subscription group;<br/> - `round_robin_per_group`: Clients in a shared subscription group will consume messages in turn, and the progress of the loop is recorded independently in each node, so two adjacent messages from **different nodes** may be consumed by the same client in the subscription group;<br/> - `local`: Randomly select a subscriber on the current node, if there are no subscribers on the current node, then randomly select within the cluster;<br/> - `sticky`: Continuously dispatch messages to the initially selected subscriber until their session ends;<br/> - `hash_clientid`: Hash the publisher's client ID to select a subscriber;<br/> - `hash_topic`: Hash the publishing topic to select a subscriber."
          },
          "exclusive_subscription": {
            "default": false,
            "type": "boolean",
            "description": "Whether to enable support for MQTT exclusive subscription."
          },
          "ignore_loop_deliver": {
            "default": false,
            "type": "boolean",
            "description": "Whether the messages sent by the MQTT v3.1.1/v3.1.0 client will be looped back to the publisher itself, similar to <code>No Local</code> in MQTT 5.0."
          },
          "strict_mode": {
            "default": false,
            "type": "boolean",
            "description": "Whether to parse MQTT messages in strict mode.<br/>In strict mode, invalid utf8 strings in for example client ID, topic name, etc. will cause the client to be disconnected."
          },
          "response_information": {
            "default": "",
            "type": "string",
            "description": "UTF-8 string, for creating the response topic, for example, if set to <code>reqrsp/</code>, the publisher/subscriber will communicate using the topic prefix <code>reqrsp/</code>.<br/>To disable this feature, input <code>\"\"</code> in the text box below. Only applicable to MQTT 5.0 clients."
          },
          "server_keepalive": {
            "default": "disabled",
            "description": "The keep alive duration required by EMQX. To use the setting from the client side, choose disabled from the drop-down list. Only applicable to MQTT 5.0 clients.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "disabled"
                ]
              },
              {
                "type": "integer",
                "minimum": 1
              }
            ]
          },
          "keepalive_multiplier": {
            "default": 1.5,
            "type": "number",
            "description": "Keep-Alive Timeout = Keep-Alive interval × Keep-Alive Multiplier.<br/>The default value 1.5 is following the MQTT 5.0 specification. This multiplier is adjustable, providing system administrators flexibility for tailoring to their specific needs. For instance, if a client's 10-second Keep-Alive interval PINGREQ gets delayed by an extra 10 seconds, changing the multiplier to 2 lets EMQX tolerate this delay."
          },
          "keepalive_check_interval": {
            "default": "30s",
            "type": "string",
            "description": "The frequency of checking for incoming MQTT packets determines how often the server will check for new MQTT packets.<br/>If a certain amount of time passes without any packets being sent from the client, this time will be added up.<br/>Once the accumulated time exceeds `keepalive-interval * keepalive-multiplier`, the connection will be terminated.<br/>The default is set to 30 seconds, with a minimum value of 1 second and a maximum value of `keepalive-interval / 2`.",
            "example": "12m"
          },
          "retry_interval": {
            "default": "infinity",
            "description": "Retry interval for QoS 1/2 message delivering.",
            "oneOf": [
              {
                "type": "string",
                "example": "12m"
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "use_username_as_clientid": {
            "default": false,
            "type": "boolean",
            "description": "Whether to use Username as Client ID.<br/>This setting takes effect later than `peer_cert_as_username` and `peer_cert_as_clientid`."
          },
          "peer_cert_as_username": {
            "default": "disabled",
            "type": "string",
            "enum": [
              "disabled",
              "cn",
              "dn",
              "crt",
              "pem",
              "md5"
            ],
            "description": "Use the CN, DN field in the peer certificate or the entire certificate content as Username. Only works for the TLS connection.<br/>Supported configurations are the following:<br/>- <code>cn</code>: CN field of the certificate<br/>- <code>dn</code>: DN field of the certificate<br/>- <code>crt</code>: Content of the <code>DER</code> or <code>PEM</code> certificate<br/>- <code>pem</code>: Convert <code>DER</code> certificate content to <code>PEM</code> format and use as Username<br/>- <code>md5</code>: MD5 value of the <code>DER</code> or <code>PEM</code> certificate"
          },
          "peer_cert_as_clientid": {
            "default": "disabled",
            "type": "string",
            "enum": [
              "disabled",
              "cn",
              "dn",
              "crt",
              "pem",
              "md5"
            ],
            "description": "Use the CN, DN field in the peer certificate or the entire certificate content as Client ID. Only works for the TLS connection.<br/>Supported configurations are the following:<br/>- <code>cn</code>: CN field of the certificate<br/>- <code>dn</code>: DN field of the certificate<br/>- <code>crt</code>: <code>DER</code> or <code>PEM</code> certificate<br/>- <code>pem</code>: Convert <code>DER</code> certificate content to <code>PEM</code> format and use as Client ID<br/>- <code>md5</code>: MD5 value of the <code>DER</code> or <code>PEM</code> certificate"
          },
          "client_attrs_init": {
            "default": [],
            "type": "array",
            "description": "Specify how to initialize client attributes.<br/>Each client attribute can be initialized as `client_attrs.{NAME}`,<br/>where `{NAME}` is the name of the attribute specified in the config field `set_as_attr`.<br/>The initialized client attribute will be stored in the `client_attrs` property with the specified name,<br/>and can be used as a placeholder in a template for authentication and authorization.<br/>For example, use `${client_attrs.alias}` to render an HTTP POST body when `set_as_attr = alias`,<br/>or render listener config `moutpoint = devices/${client_attrs.alias}/` to initialize a per-client topic namespace.",
            "items": {
              "$ref": "#/components/schemas/emqx.client_attrs_init"
            }
          },
          "session_expiry_interval": {
            "default": "2h",
            "type": "string",
            "description": "Specifies how long the session will expire after the connection is disconnected, only for non-MQTT 5.0 connections.",
            "example": "12m"
          },
          "message_expiry_interval": {
            "default": "infinity",
            "description": "The expiry interval of MQTT messages. For MQTT 5.0 clients, this configuration will only take effect when the `Message-Expiry-Interval` property is not set in the message; otherwise, the value of the `Message-Expiry-Interval` property will be used. For MQTT versions older than 5.0, this configuration will always take effect. Please note that setting `message_expiry_interval` greater than `session_expiry_interval` is meaningless, as all messages will be cleared when the session expires.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "string",
                "example": "12m"
              }
            ]
          },
          "max_awaiting_rel": {
            "default": 100,
            "description": "For each publisher session, the maximum number of outstanding QoS 2 messages pending on the client to send PUBREL. After reaching this limit, new QoS 2 PUBLISH requests will be rejected with `147(0x93)` until either PUBREL is received or timed out.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "integer",
                "minimum": 0
              }
            ]
          },
          "max_qos_allowed": {
            "default": 2,
            "maximum": 2,
            "type": "integer",
            "description": "Maximum QoS allowed.",
            "minimum": 0,
            "example": 0
          },
          "mqueue_priorities": {
            "default": "disabled",
            "description": "Topic priority list. Prioritize messages in the message queue by topic. The priority range is `[1, 255]`.<br/><br/>The larger the value, the higher the priority. Messages with higher priority will be sent first.<br/><br/>Topics not in this list will use the default priority (specified by `mqueue_default_priority`).<br/><br/>By default, this list is empty, which means all topics have the same priority.<br/><br/>Note: commas and equal signs are not supported in topic names.<br/><br/>For example, if you want `topic/1` to have a higher priority than `topic/2`, you can configure it like this:<br/><br/>`mqueue_priorities: {\\\"topic/1\\\": 10, \\\"topic/2\\\": 8}`",
            "oneOf": [
              {
                "type": "object",
                "example": {}
              },
              {
                "type": "string",
                "enum": [
                  "disabled"
                ]
              }
            ]
          },
          "mqueue_default_priority": {
            "default": "lowest",
            "type": "string",
            "enum": [
              "highest",
              "lowest"
            ],
            "description": "Default topic priority, which will be used by topics not in <code>Topic Priorities</code> (<code>mqueue_priorities</code>)."
          },
          "mqueue_store_qos0": {
            "default": true,
            "type": "boolean",
            "description": "Specifies whether to store QoS 0 messages in the message queue while the connection is down but the session remains."
          },
          "max_mqueue_len": {
            "default": 1000,
            "description": "Maximum queue length. Enqueued messages when persistent client disconnected, or inflight window is full.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "integer",
                "minimum": 0
              }
            ]
          },
          "max_inflight": {
            "default": 32,
            "maximum": 65535,
            "type": "integer",
            "description": "Maximum number of QoS 1 and QoS 2 messages that are allowed to be delivered simultaneously before completing the acknowledgment.",
            "minimum": 1
          },
          "max_subscriptions": {
            "default": "infinity",
            "description": "Maximum number of subscriptions allowed per client.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "integer",
                "minimum": 1
              }
            ]
          },
          "upgrade_qos": {
            "default": false,
            "type": "boolean",
            "description": "Force upgrade of QoS level according to subscription."
          },
          "await_rel_timeout": {
            "default": "300s",
            "type": "string",
            "description": "For client to broker QoS 2 message, the time limit for the broker to wait before the `PUBREL` message is received. The wait is aborted after timed out, meaning the packet ID is freed for new `PUBLISH` requests. Receiving a stale `PUBREL` causes a warning level log. Note, the message is delivered to subscribers before entering the wait for PUBREL.",
            "example": "12m"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_publish.publish_ok": {
        "properties": {
          "id": {
            "type": "string",
            "description": "A globally unique message ID for correlation/tracing."
          }
        },
        "type": "object"
      },
      "rule_engine.ctx_pub": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "type": "string",
            "enum": [
              "message_publish"
            ],
            "description": "Event Type"
          },
          "id": {
            "type": "string",
            "description": "Message ID"
          },
          "clientid": {
            "type": "string",
            "description": "The Client ID"
          },
          "username": {
            "type": "string",
            "description": "Username"
          },
          "payload": {
            "type": "string",
            "description": "The Message Payload"
          },
          "peerhost": {
            "type": "string",
            "description": "The IP Address of the Peer Client"
          },
          "topic": {
            "type": "string",
            "description": "Message Topic"
          },
          "publish_received_at": {
            "type": "integer",
            "description": "The Time that this Message is Received"
          },
          "qos": {
            "maximum": 2,
            "type": "integer",
            "description": "The Message QoS",
            "minimum": 0,
            "example": 0
          }
        },
        "type": "object"
      },
      "rule_engine.builtin_action_republish": {
        "properties": {
          "function": {
            "type": "string",
            "enum": [
              "republish"
            ],
            "description": "Republish the message as a new MQTT message"
          },
          "args": {
            "default": {},
            "$ref": "#/components/schemas/rule_engine.republish_args"
          }
        },
        "type": "object"
      },
      "dashboard.http": {
        "properties": {
          "bind": {
            "default": 0,
            "type": "string",
            "description": "Bind the listener to a specified address and port number, for example `127.0.0.1:18083`.<br/>If configured with just the port number (e.g. `18083`) it's equivalent to binding to all addresses `0.0.0.0`.<br/>The listener is disabled if `bind` is `0`.",
            "example": "0.0.0.0:18083"
          },
          "num_acceptors": {
            "default": 20,
            "type": "integer",
            "description": "Socket acceptor pool size for TCP protocols. Default is the number of schedulers online"
          },
          "max_connections": {
            "default": 512,
            "type": "integer",
            "description": "The maximum number of concurrent connections allowed by the listener."
          },
          "backlog": {
            "default": 1024,
            "type": "integer",
            "description": "Defines the maximum length that the queue of pending connections can grow to."
          },
          "send_timeout": {
            "default": "10s",
            "type": "string",
            "description": "Send timeout for the socket.",
            "example": "12m"
          },
          "inet6": {
            "default": false,
            "type": "boolean",
            "description": "Enable IPv6 support, default is false, which means IPv4 only."
          },
          "ipv6_v6only": {
            "default": false,
            "type": "boolean",
            "description": "Disable IPv4-to-IPv6 mapping for the listener.<br/>The configuration is only valid when the inet6 is true."
          },
          "proxy_header": {
            "default": false,
            "type": "boolean",
            "description": "Enable support for `HAProxy` header. Be aware once enabled regular HTTP requests can't be handled anymore."
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.update_exproto": {
        "required": [
          "handler",
          "server"
        ],
        "properties": {
          "server": {
            "description": "Configurations for starting the <code>ConnectionAdapter</code> service",
            "$ref": "#/components/schemas/gateway.exproto_grpc_server"
          },
          "handler": {
            "description": "Configurations for request to <code>ConnectionHandler</code> service",
            "$ref": "#/components/schemas/gateway.exproto_grpc_handler"
          },
          "mountpoint": {
            "default": "",
            "type": "string",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message is delivered to the subscriber.<br/>The mountpoint is a way that users can use to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,<br/>then the client actually subscribes to the topic `some_tenant/t`.<br/>Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,<br/>the message is routed to all the clients subscribed `some_tenant/t`,<br/>so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.<br/>Supported placeholders in mountpoint string:<br/><br/>  - <code>${clientid}</code>: clientid<br/><br/>  - <code>${username}</code>: username<br/><br/>  - <code>${endpoint_name}</code>: endpoint name"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Whether to enable this gateway"
          },
          "enable_stats": {
            "default": true,
            "type": "boolean",
            "description": "Whether to enable client process statistic"
          },
          "idle_timeout": {
            "default": "30s",
            "type": "string",
            "description": "The idle time of the client connection process. It has two purposes:<br/>  1. A newly created client process that does not receive any client requests after that time will be closed directly.<br/>  2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.",
            "example": "12m"
          },
          "clientinfo_override": {
            "description": "ClientInfo override.",
            "$ref": "#/components/schemas/gateway.clientinfo_override"
          }
        },
        "type": "object"
      },
      "emqx_authn_api.request_user_create": {
        "required": [
          "password",
          "user_id"
        ],
        "properties": {
          "user_id": {
            "type": "string"
          },
          "password": {
            "type": "string"
          },
          "is_superuser": {
            "default": false,
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_stats.per_node_data": {
        "properties": {
          "node": {
            "type": "string",
            "description": "Node name",
            "example": "emqx@127.0.0.1"
          },
          "durable_subscriptions.count": {
            "type": "integer",
            "description": "Number of current subscriptions from durable sessions in the cluster",
            "minimum": 0,
            "example": 0
          },
          "channels.count": {
            "type": "integer",
            "description": "sessions.count",
            "minimum": 0,
            "example": 0
          },
          "channels.max": {
            "type": "integer",
            "description": "session.max",
            "minimum": 0,
            "example": 0
          },
          "connections.count": {
            "type": "integer",
            "description": "Number of current connections",
            "minimum": 0,
            "example": 0
          },
          "connections.max": {
            "type": "integer",
            "description": "Historical maximum number of connections",
            "minimum": 0,
            "example": 0
          },
          "delayed.count": {
            "type": "integer",
            "description": "Number of delayed messages",
            "minimum": 0,
            "example": 0
          },
          "delayed.max": {
            "type": "integer",
            "description": "Historical maximum number of delayed messages",
            "minimum": 0,
            "example": 0
          },
          "live_connections.count": {
            "type": "integer",
            "description": "Number of current live connections",
            "minimum": 0,
            "example": 0
          },
          "live_connections.max": {
            "type": "integer",
            "description": "Historical maximum number of live connections",
            "minimum": 0,
            "example": 0
          },
          "cluster_sessions.count": {
            "type": "integer",
            "description": "Number of sessions in the cluster",
            "minimum": 0,
            "example": 0
          },
          "cluster_sessions.max": {
            "type": "integer",
            "description": "Historical maximum number of sessions in the cluster",
            "minimum": 0,
            "example": 0
          },
          "retained.count": {
            "type": "integer",
            "description": "Number of currently retained messages",
            "minimum": 0,
            "example": 0
          },
          "retained.max": {
            "type": "integer",
            "description": "Historical maximum number of retained messages",
            "minimum": 0,
            "example": 0
          },
          "sessions.count": {
            "type": "integer",
            "description": "Number of current sessions",
            "minimum": 0,
            "example": 0
          },
          "sessions.max": {
            "type": "integer",
            "description": "Historical maximum number of sessions",
            "minimum": 0,
            "example": 0
          },
          "suboptions.count": {
            "type": "integer",
            "description": "subscriptions.count",
            "minimum": 0,
            "example": 0
          },
          "suboptions.max": {
            "type": "integer",
            "description": "subscriptions.max",
            "minimum": 0,
            "example": 0
          },
          "subscribers.count": {
            "type": "integer",
            "description": "Number of current subscribers",
            "minimum": 0,
            "example": 0
          },
          "subscribers.max": {
            "type": "integer",
            "description": "Historical maximum number of subscribers",
            "minimum": 0,
            "example": 0
          },
          "subscriptions.count": {
            "type": "integer",
            "description": "Number of current subscriptions, including shared subscriptions, but not subscriptions from durable sessions",
            "minimum": 0,
            "example": 0
          },
          "subscriptions.max": {
            "type": "integer",
            "description": "Historical maximum number of subscriptions",
            "minimum": 0,
            "example": 0
          },
          "subscriptions.shared.count": {
            "type": "integer",
            "description": "Number of current shared subscriptions",
            "minimum": 0,
            "example": 0
          },
          "subscriptions.shared.max": {
            "type": "integer",
            "description": "Historical maximum number of shared subscriptions",
            "minimum": 0,
            "example": 0
          },
          "topics.count": {
            "type": "integer",
            "description": "Number of current topics",
            "minimum": 0,
            "example": 0
          },
          "topics.max": {
            "type": "integer",
            "description": "Historical maximum number of topics",
            "minimum": 0,
            "example": 0
          }
        },
        "type": "object"
      },
      "emqx.sys_topics": {
        "properties": {
          "sys_msg_interval": {
            "default": "1m",
            "description": "Time interval for publishing following system messages:<br/>  - `$SYS/brokers`<br/>  - `$SYS/brokers/<node>/version`<br/>  - `$SYS/brokers/<node>/sysdescr`<br/>  - `$SYS/brokers/<node>/stats/<name>`<br/>  - `$SYS/brokers/<node>/metrics/<name>`",
            "oneOf": [
              {
                "type": "string",
                "example": "12m"
              },
              {
                "type": "string",
                "enum": [
                  "disabled"
                ]
              }
            ]
          },
          "sys_heartbeat_interval": {
            "default": "30s",
            "description": "Time interval for publishing following heartbeat messages:<br/>  - `$SYS/brokers/<node>/uptime`<br/>  - `$SYS/brokers/<node>/datetime`",
            "oneOf": [
              {
                "type": "string",
                "example": "12m"
              },
              {
                "type": "string",
                "enum": [
                  "disabled"
                ]
              }
            ]
          },
          "sys_event_messages": {
            "description": "Client events messages.",
            "$ref": "#/components/schemas/emqx.event_names"
          }
        },
        "type": "object"
      },
      "connector_mqtt.put_connector": {
        "required": [
          "server"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this connector."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the pool of MQTT clients that will publish messages to the remote broker.<br/><br/>Each MQTT client will be assigned 'clientid' of the form '${clientid_prefix}:${bridge_name}:egress:${node}:${n}'<br/>where 'n' is the number of a client inside the pool.",
            "minimum": 1
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/connector_mqtt.resource_opts"
          },
          "mode": {
            "default": "cluster_shareload",
            "type": "string",
            "enum": [
              "cluster_shareload"
            ],
            "deprecated": true,
            "description": "The mode of the MQTT Bridge.<br/><br/>- cluster_shareload: create an MQTT connection on each node in the emqx cluster.<br/><br/>In 'cluster_shareload' mode, the incoming load from the remote broker is shared by<br/>using shared subscription.<br/><br/>Note that the 'clientid' is suffixed by the node name, this is to avoid<br/>clientid conflicts between different nodes. And we can only use shared subscription<br/>topic filters for <code>remote.topic</code> of ingress connections."
          },
          "server": {
            "type": "string",
            "description": "The host and port of the remote MQTT broker"
          },
          "clientid_prefix": {
            "type": "string",
            "description": "Optional prefix to prepend to the clientid used by egress bridges."
          },
          "reconnect_interval": {
            "type": "string",
            "deprecated": true
          },
          "proto_ver": {
            "default": "v4",
            "type": "string",
            "enum": [
              "v3",
              "v4",
              "v5"
            ],
            "description": "The MQTT protocol version"
          },
          "bridge_mode": {
            "default": false,
            "type": "boolean",
            "description": "If enable bridge mode.<br/>NOTE: This setting is only for MQTT protocol version older than 5.0, and the remote MQTT<br/>broker MUST support this feature.<br/>If bridge_mode is set to true, the bridge will indicate to the remote broker that it is a bridge not an ordinary client.<br/>This means that loop detection will be more effective and that retained messages will be propagated correctly."
          },
          "username": {
            "type": "string",
            "description": "The username of the MQTT protocol"
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password of the MQTT protocol",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "clean_start": {
            "default": true,
            "type": "boolean",
            "description": "Whether to start a clean session when reconnecting a remote broker for ingress bridge"
          },
          "keepalive": {
            "default": "300s",
            "type": "string",
            "description": "MQTT Keepalive. Time interval is a string that contains a number followed by time unit:<br/>- `ms` for milliseconds,<br/>- `s` for seconds,<br/>- `m` for minutes,<br/>- `h` for hours;<br/><br/>or combination of whereof: `1h5m0s`"
          },
          "retry_interval": {
            "default": "15s",
            "type": "string",
            "description": "Message retry interval. Delay for the MQTT bridge to retry sending the QoS1/QoS2 messages in case of ACK not received. Time interval is a string that contains a number followed by time unit:<br/>- `ms` for milliseconds,<br/>- `s` for seconds,<br/>- `m` for minutes,<br/>- `h` for hours;<br/><br/>or combination of whereof: `1h5m0s`"
          },
          "max_inflight": {
            "default": 32,
            "type": "integer",
            "description": "Max inflight (sent, but un-acked) messages of the MQTT protocol",
            "minimum": 0
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.update_mqttsn": {
        "required": [
          "gateway_id"
        ],
        "properties": {
          "gateway_id": {
            "default": 1,
            "type": "integer",
            "description": "MQTT-SN Gateway ID.<br/>When the <code>broadcast</code> option is enabled, the gateway will broadcast ADVERTISE message with this value"
          },
          "broadcast": {
            "default": false,
            "type": "boolean",
            "description": "Whether to periodically broadcast ADVERTISE messages"
          },
          "enable_qos3": {
            "default": true,
            "type": "boolean",
            "description": "Allows connectionless clients to publish messages with a Qos of -1.<br/>This feature is defined for very simple client implementations which do not support any other features except this one. There is no connection setup nor tear down, no registration nor subscription. The client just sends its 'PUBLISH' messages to a GW"
          },
          "subs_resume": {
            "default": false,
            "type": "boolean",
            "description": "Whether to initiate all subscribed topic name registration messages to the client after the Session has been taken over by a new channel"
          },
          "predefined": {
            "default": [],
            "type": "array",
            "description": "The pre-defined topic IDs and topic names.<br/>A 'pre-defined' topic ID is a topic ID whose mapping to a topic name is known in advance by both the client's application and the gateway",
            "items": {
              "$ref": "#/components/schemas/gateway.mqttsn_predefined"
            }
          },
          "mountpoint": {
            "default": "",
            "type": "string",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message is delivered to the subscriber.<br/>The mountpoint is a way that users can use to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,<br/>then the client actually subscribes to the topic `some_tenant/t`.<br/>Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,<br/>the message is routed to all the clients subscribed `some_tenant/t`,<br/>so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.<br/>Supported placeholders in mountpoint string:<br/><br/>  - <code>${clientid}</code>: clientid<br/><br/>  - <code>${username}</code>: username<br/><br/>  - <code>${endpoint_name}</code>: endpoint name"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Whether to enable this gateway"
          },
          "enable_stats": {
            "default": true,
            "type": "boolean",
            "description": "Whether to enable client process statistic"
          },
          "idle_timeout": {
            "default": "30s",
            "type": "string",
            "description": "The idle time of the client connection process. It has two purposes:<br/>  1. A newly created client process that does not receive any client requests after that time will be closed directly.<br/>  2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.",
            "example": "12m"
          },
          "clientinfo_override": {
            "description": "ClientInfo override.",
            "$ref": "#/components/schemas/gateway.clientinfo_override"
          }
        },
        "type": "object"
      },
      "relup.running_status": {
        "properties": {
          "node": {
            "type": "string",
            "example": "emqx@127.0.0.1"
          },
          "status": {
            "type": "string",
            "enum": [
              "in-progress",
              "idle"
            ],
            "description": "The upgrade status of a node:<br/>1. in-progress: hot upgrade is in progress.<br/>2. idle: hot upgrade is not started.<br/>"
          },
          "role": {
            "type": "string",
            "enum": [
              "core",
              "replicant"
            ],
            "description": "The role of the node",
            "example": "core"
          },
          "live_connections": {
            "type": "integer",
            "description": "The number of live connections",
            "example": 100
          },
          "current_vsn": {
            "type": "string",
            "description": "The current version of the node",
            "example": "5.8.0"
          },
          "upgrade_history": {
            "type": "array",
            "description": "The upgrade history of the node",
            "items": {
              "$ref": "#/components/schemas/relup.upgrade_history"
            },
            "example": [
              {
                "status": "finished",
                "started_at": "2024-07-15T13:48:02.648559+08:00",
                "result": "success",
                "upgrade_opts": {
                  "deploy_inplace": false
                },
                "target_vsn": "5.8.1",
                "from_vsn": "5.8.0",
                "finished_at": "2024-07-16T11:00:01.875627+08:00"
              }
            ]
          }
        },
        "type": "object"
      },
      "connector_mqtt.ingress_local": {
        "properties": {
          "topic": {
            "type": "string",
            "description": "Send messages to which topic of the local broker.<br/><br/>Template with variables is allowed."
          },
          "qos": {
            "default": "${qos}",
            "description": "The QoS of the MQTT message to be sent.<br/><br/>Template with variables is allowed.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "maximum": 2,
                "type": "integer",
                "minimum": 0,
                "example": 0
              }
            ]
          },
          "retain": {
            "default": "${retain}",
            "description": "The 'retain' flag of the MQTT message to be sent.<br/><br/>Template with variables is allowed.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "boolean"
              }
            ]
          },
          "payload": {
            "type": "string",
            "description": "The payload of the MQTT message to be sent.<br/><br/>Template with variables is allowed."
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.stomp": {
        "properties": {
          "name": {
            "type": "string",
            "enum": [
              "stomp"
            ],
            "description": "Gateway Name"
          },
          "frame": {
            "$ref": "#/components/schemas/gateway.stomp_frame"
          },
          "mountpoint": {
            "default": "",
            "type": "string",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message is delivered to the subscriber.<br/>The mountpoint is a way that users can use to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,<br/>then the client actually subscribes to the topic `some_tenant/t`.<br/>Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,<br/>the message is routed to all the clients subscribed `some_tenant/t`,<br/>so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.<br/>Supported placeholders in mountpoint string:<br/><br/>  - <code>${clientid}</code>: clientid<br/><br/>  - <code>${username}</code>: username<br/><br/>  - <code>${endpoint_name}</code>: endpoint name"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Whether to enable this gateway"
          },
          "enable_stats": {
            "default": true,
            "type": "boolean",
            "description": "Whether to enable client process statistic"
          },
          "idle_timeout": {
            "default": "30s",
            "type": "string",
            "description": "The idle time of the client connection process. It has two purposes:<br/>  1. A newly created client process that does not receive any client requests after that time will be closed directly.<br/>  2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.",
            "example": "12m"
          },
          "clientinfo_override": {
            "description": "ClientInfo override.",
            "$ref": "#/components/schemas/gateway.clientinfo_override"
          },
          "listeners": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/emqx_gateway_api.ssl_listener"
                },
                {
                  "$ref": "#/components/schemas/emqx_gateway_api.tcp_listener"
                }
              ]
            }
          }
        },
        "type": "object"
      },
      "emqx_authz_api_mnesia.rules_for_username": {
        "required": [
          "username"
        ],
        "properties": {
          "rules": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/emqx_authz_api_mnesia.rule_item"
            }
          },
          "username": {
            "type": "string",
            "description": "Username",
            "example": "user1"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api_clients.exproto_client": {
        "properties": {
          "node": {
            "type": "string",
            "description": "Name of the node to which the client is connected"
          },
          "clientid": {
            "type": "string",
            "description": "Client ID"
          },
          "username": {
            "type": "string",
            "description": "Username of client when connecting"
          },
          "mountpoint": {
            "type": "string",
            "description": "Topic mountpoint"
          },
          "proto_name": {
            "type": "string",
            "description": "Client protocol name"
          },
          "proto_ver": {
            "type": "string",
            "description": "Protocol version used by the client"
          },
          "ip_address": {
            "type": "string",
            "description": "Client's IP address"
          },
          "port": {
            "type": "integer",
            "description": "Client's port"
          },
          "is_bridge": {
            "type": "boolean",
            "description": "Indicates whether the client is connected via bridge"
          },
          "connected_at": {
            "description": "Client connection time",
            "oneOf": [
              {
                "type": "integer",
                "description": "epoch-millisecond",
                "example": 1640995200000
              },
              {
                "type": "string",
                "format": "date-time",
                "example": "2022-01-01T00:00:00.000Z"
              }
            ]
          },
          "disconnected_at": {
            "description": "Client offline time, This field is only valid and returned when connected is false",
            "oneOf": [
              {
                "type": "integer",
                "description": "epoch-millisecond",
                "example": 1640995200000
              },
              {
                "type": "string",
                "format": "date-time",
                "example": "2022-01-01T00:00:00.000Z"
              }
            ]
          },
          "connected": {
            "type": "boolean",
            "description": "Whether the client is connected"
          },
          "keepalive": {
            "type": "integer",
            "description": "Keepalive time, with the unit of second"
          },
          "clean_start": {
            "type": "boolean",
            "description": "Indicate whether the client is using a brand new session"
          },
          "expiry_interval": {
            "type": "integer",
            "description": "Session expiration interval, with the unit of second"
          },
          "created_at": {
            "description": "Session creation time",
            "oneOf": [
              {
                "type": "integer",
                "description": "epoch-millisecond",
                "example": 1640995200000
              },
              {
                "type": "string",
                "format": "date-time",
                "example": "2022-01-01T00:00:00.000Z"
              }
            ]
          },
          "subscriptions_cnt": {
            "type": "integer",
            "description": "Number of subscriptions established by this client"
          },
          "subscriptions_max": {
            "type": "integer",
            "description": "Maximum number of subscriptions allowed by this client"
          },
          "inflight_cnt": {
            "type": "integer",
            "description": "Current length of inflight"
          },
          "inflight_max": {
            "type": "integer",
            "description": "Maximum length of inflight"
          },
          "mqueue_len": {
            "type": "integer",
            "description": "Current length of message queue"
          },
          "mqueue_max": {
            "type": "integer",
            "description": "Maximum length of message queue"
          },
          "mqueue_dropped": {
            "type": "integer",
            "description": "Number of messages dropped by the message queue due to exceeding the length"
          },
          "awaiting_rel_cnt": {
            "type": "integer",
            "description": "Number of awaiting acknowledge packet"
          },
          "awaiting_rel_max": {
            "type": "integer",
            "description": "Maximum allowed number of awaiting PUBREC packet"
          },
          "recv_oct": {
            "type": "integer",
            "description": "Number of bytes received"
          },
          "recv_cnt": {
            "type": "integer",
            "description": "Number of socket packets received"
          },
          "recv_pkt": {
            "type": "integer",
            "description": "Number of protocol packets received"
          },
          "recv_msg": {
            "type": "integer",
            "description": "Number of message packets received"
          },
          "send_oct": {
            "type": "integer",
            "description": "Number of bytes sent"
          },
          "send_cnt": {
            "type": "integer",
            "description": "Number of socket packets sent"
          },
          "send_pkt": {
            "type": "integer",
            "description": "Number of protocol packets sent"
          },
          "send_msg": {
            "type": "integer",
            "description": "Number of message packets sent"
          },
          "mailbox_len": {
            "type": "integer",
            "description": "Process mailbox size"
          },
          "heap_size": {
            "type": "integer",
            "description": "Process heap size with the unit of byte"
          },
          "reductions": {
            "type": "integer",
            "description": "Erlang reduction"
          }
        },
        "type": "object"
      },
      "bridge_http.post_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "http"
            ],
            "description": "The action type."
          },
          "name": {
            "type": "string",
            "description": "Action name, used as a human-readable identifier."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "parameters": {
            "description": "The parameters for HTTP action.",
            "$ref": "#/components/schemas/bridge_http.parameters_opts"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_http.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_http.post": {
        "required": [
          "name",
          "type",
          "url"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "webhook",
              "http"
            ],
            "description": "The action type."
          },
          "name": {
            "type": "string",
            "description": "Action name, used as a human-readable identifier."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this action."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "connect_timeout": {
            "default": "15s",
            "type": "string",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s"
          },
          "retry_interval": {
            "type": "string",
            "deprecated": true,
            "example": "12m"
          },
          "pool_type": {
            "default": "random",
            "type": "string",
            "enum": [
              "random",
              "hash"
            ],
            "description": "The type of the pool. Can be one of `random`, `hash`."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "The pool size.",
            "minimum": 1
          },
          "enable_pipelining": {
            "default": 100,
            "type": "integer",
            "description": "The maximum number of HTTP requests that can be sent before an HTTP response is received.<br/><br/>Setting this to 1 is equivalent to turning off HTTP pipelining, and the EMQX must receive a response to the previous HTTP request before sending the next HTTP request.",
            "minimum": 1
          },
          "request": {
            "type": "object",
            "deprecated": true,
            "description": "This field is never used, so we deprecated it since 5.3.2.",
            "example": {}
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "url": {
            "type": "string",
            "description": "The URL of the HTTP action.<br/><br/>Template with variables is allowed in the path, but variables cannot be used in the scheme, host,<br/>or port part.<br/><br/>For example, <code> http://localhost:9901/${topic} </code> is allowed, but<br/><code> http://${host}:9901/message </code> or <code> http://localhost:${port}/message </code><br/>is not allowed."
          },
          "direction": {
            "type": "string",
            "enum": [
              "egress"
            ],
            "deprecated": true
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to the HTTP server. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: If this action is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "method": {
            "default": "post",
            "type": "string",
            "enum": [
              "post",
              "put",
              "get",
              "delete"
            ],
            "description": "The method of the HTTP request. All the available methods are: post, put, get, delete.<br/><br/>Template with variables is allowed."
          },
          "headers": {
            "default": {
              "accept": "application/json",
              "cache-control": "no-cache",
              "connection": "keep-alive",
              "content-type": "application/json",
              "keep-alive": "timeout=5"
            },
            "type": "object",
            "description": "The headers of the HTTP request.<br/><br/>Template with variables is allowed.",
            "example": {},
            "is_template": true
          },
          "body": {
            "type": "string",
            "description": "The body of the HTTP request.<br/><br/>If not provided, the body will be a JSON object of all the available fields.<br/><br/>There, 'all the available fields' means the context of a MQTT message when<br/>this webhook is triggered by receiving a MQTT message (the `local_topic` is set),<br/>or the context of the event when this webhook is triggered by a rule (i.e. this<br/>webhook is used as an action of a rule).<br/><br/>Template with variables is allowed."
          },
          "max_retries": {
            "default": 2,
            "type": "integer",
            "description": "HTTP request max retry times if failed.",
            "minimum": 0
          },
          "request_timeout": {
            "default": "15s",
            "type": "string",
            "deprecated": true,
            "description": "HTTP request timeout.",
            "example": "32s"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_http.v1_resource_opts"
          }
        },
        "type": "object"
      },
      "authz.builtin_db": {
        "required": [
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "built_in_database"
            ],
            "description": "Backend type."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Set to <code>true</code> or <code>false</code> to disable this ACL provider"
          },
          "max_rules": {
            "default": 100,
            "type": "integer",
            "description": "Maximum number of rules per client/user. Note that performance may decrease as number of rules increases.",
            "minimum": 1
          }
        },
        "type": "object"
      },
      "authn.builtin_db": {
        "required": [
          "backend",
          "mechanism",
          "user_id_type"
        ],
        "properties": {
          "password_hash_algorithm": {
            "default": {
              "name": "sha256",
              "salt_position": "prefix"
            },
            "description": "Options for password hash creation and verification.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn_hash.simple"
              },
              {
                "$ref": "#/components/schemas/authn_hash.pbkdf2"
              },
              {
                "$ref": "#/components/schemas/authn_hash.bcrypt_rw"
              }
            ]
          },
          "mechanism": {
            "type": "string",
            "enum": [
              "password_based"
            ],
            "description": "Authentication mechanism."
          },
          "backend": {
            "type": "string",
            "enum": [
              "built_in_database"
            ],
            "description": "Backend type."
          },
          "user_id_type": {
            "default": "username",
            "type": "string",
            "enum": [
              "clientid",
              "username"
            ],
            "description": "Specify whether to use `clientid` or `username` for authentication."
          },
          "bootstrap_file": {
            "default": "${EMQX_ETC_DIR}/auth-built-in-db-bootstrap.csv",
            "type": "string",
            "description": "The bootstrap file imports users into the built-in database.<br/>It will not import a user ID that already exists in the database.<br/>The file content format is determined by `bootstrap_type`."
          },
          "bootstrap_type": {
            "default": "plain",
            "type": "string",
            "enum": [
              "hash",
              "plain"
            ],
            "description": "Specify which type of content the bootstrap file has.<br/><br/>- **`plain`**:<br/>  - Expected data fields: `user_id`, `password`, `is_superuser`<br/>  - `user_id`: Can be Client ID or username, depending on built-in database authentication's `user_id_type` config.<br/>  - `password`: User's plaintext password.<br/>  - `is_superuser`: Boolean, user's administrative status.<br/><br/>- **`hash`**:<br/>  - Expected data fields: `user_id`,`password_hash`,`salt`,`is_superuser`<br/>  - Definitions similar to `plain` type, with `password_hash` and `salt` added for security.<br/><br/>The content can be either in CSV, or JSON format.<br/><br/>Here is a CSV example: `user_id,password_hash,salt,is_superuser\\nmy_user,b6c743545a7817ae8c8f624371d5f5f0373234bb0ff36b8ffbf19bce0e06ab75,de1024f462fb83910fd13151bd4bd235,true`<br/><br/>And JSON content should be decoded into an array of objects, for example: `[{\"user_id\": \"my_user\",\"password\": \"s3cr3tp@ssw0rd\",\"is_superuser\": true}]`.<br/><br/>The hash string for `password_hash` depends on how `password_hash_algorithm` is configured for the built-in database authentication mechanism. For example, if it's configured as `password_hash_algorithm {name = sha256, salt_position = suffix}`, then the salt is appended to the password before hashed. Here is the equivalent Python expression: `hashlib.sha256(password + salt).hexdigest()`."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider."
          }
        },
        "type": "object"
      },
      "bridge_http.put_bridge_v2": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "parameters": {
            "description": "The parameters for HTTP action.",
            "$ref": "#/components/schemas/bridge_http.parameters_opts"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_http.action_resource_opts"
          }
        },
        "type": "object"
      },
      "emqx.ssl_client_opts": {
        "properties": {
          "cacertfile": {
            "type": "string",
            "description": "Trusted PEM format CA certificates bundle file.<br/><br/>The certificates in this file are used to verify the TLS peer's certificates.<br/>Append new certificates to the file if new CAs are to be trusted.<br/>There is no need to restart EMQX to have the updated file loaded, because<br/>the system regularly checks if file has been updated (and reload).<br/><br/>NOTE: invalidating (deleting) a certificate from the file will not affect<br/>already established connections."
          },
          "cacerts": {
            "default": false,
            "type": "boolean",
            "deprecated": true
          },
          "certfile": {
            "type": "string",
            "description": "PEM format certificates chain file.<br/><br/>The certificates in this file should be in reversed order of the certificate<br/>issue chain. That is, the host's certificate should be placed in the beginning<br/>of the file, followed by the immediate issuer certificate and so on.<br/>Although the root CA certificate is optional, it should be placed at the end of<br/>the file if it is to be added."
          },
          "keyfile": {
            "type": "string",
            "description": "PEM format private key file."
          },
          "verify": {
            "default": "verify_none",
            "type": "string",
            "enum": [
              "verify_peer",
              "verify_none"
            ],
            "description": "Enable or disable peer verification."
          },
          "reuse_sessions": {
            "default": true,
            "type": "boolean",
            "description": "Enable TLS session reuse.<br/><br/>Has no effect when TLS version is configured (or negotiated) to 1.3"
          },
          "depth": {
            "default": 10,
            "type": "integer",
            "description": "Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path.<br/>So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly;<br/><br/>if 1 the path can be PEER, Intermediate-CA, ROOT-CA;<br/><br/>if 2 the path can be PEER, Intermediate-CA1, Intermediate-CA2, ROOT-CA.",
            "minimum": 0
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "String containing the user's password. Only used if the private key file is password-protected.",
            "example": ""
          },
          "versions": {
            "default": [
              "tlsv1.3",
              "tlsv1.2"
            ],
            "type": "array",
            "description": "All TLS/DTLS versions to be supported.<br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.<br/><br/>In case PSK cipher suites are intended, make sure to configure<br/><code>['tlsv1.2', 'tlsv1.1']</code> here.",
            "items": {
              "type": "string"
            }
          },
          "ciphers": {
            "default": [],
            "type": "array",
            "description": "This config holds TLS cipher suite names separated by comma,<br/>or as an array of strings. e.g.<br/><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or<br/><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.<br/><br/><br/>Ciphers (and their ordering) define the way in which the<br/>client and server encrypts information over the network connection.<br/>Selecting a good cipher suite is critical for the<br/>application's data security, confidentiality and performance.<br/><br/>The names should be in OpenSSL string format (not RFC format).<br/>All default values and examples provided by EMQX config<br/>documentation are all in OpenSSL format.<br/><br/><br/>NOTE: Certain cipher suites are only compatible with<br/>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')<br/>incompatible cipher suites will be silently dropped.<br/>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,<br/>configuring cipher suites for other versions will have no effect.<br/><br/><br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br/><br/>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.<br/><br/>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,<br/>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,<br/>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,<br/>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code>",
            "items": {
              "type": "string"
            }
          },
          "secure_renegotiate": {
            "default": true,
            "type": "boolean",
            "description": "Whether to reject TLS renegotiation attempts that are not compliant with [RFC 5746](http://www.ietf.org/rfc/rfc5746.txt).<br/><br/>By default, `secure_renegotiate` is set to `true`, which forces secure renegotiation.<br/>If set to `false`, secure renegotiation will still be used, but will fall back to insecure renegotiation if the peer does not support [RFC 5746](http://www.ietf.org/rfc/rfc5746.txt), which increases the risk of a MitM attack.<br/><br/>Has no effect when TLS version is configured (or negotiated) to 1.3."
          },
          "log_level": {
            "default": "notice",
            "type": "string",
            "enum": [
              "emergency",
              "alert",
              "critical",
              "error",
              "warning",
              "notice",
              "info",
              "debug",
              "none",
              "all"
            ],
            "description": "The minimum level of logging allowed for SSL output.<br/><br/>The default is `notice`, set to a lower `debug` level for more detailed logging that can be used to investigate SSL handshake issues."
          },
          "hibernate_after": {
            "default": "5s",
            "type": "string",
            "description": "Specifies the amount of time that an SSL process will hibernate after being idle, thus reducing its memory footprint.<br/><br/>The hibernating process will be woken up when a new message arrives.<br/>Hibernating and waking up too often can cause CPU utilization to increase, as they both perform garbage collection on the process.",
            "example": "12m"
          },
          "enable": {
            "default": false,
            "type": "boolean",
            "description": "Enable TLS."
          },
          "server_name_indication": {
            "description": "Specify the host name to be used in TLS Server Name Indication extension.<br/><br/>For instance, when connecting to \"server.example.net\", the genuine server<br/>which accepts the connection and performs TLS handshake may differ from the<br/>host the TLS client initially connects to, e.g. when connecting to an IP address<br/>or when the host has multiple resolvable DNS records <br/><br/>If not specified, it will default to the host name string which is used<br/>to establish the connection, unless it is IP address used.<br/><br/>The host name is then also used in the host name verification of the peer<br/>certificate.<br/> The special value 'disable' prevents the Server Name<br/>Indication extension from being sent and disables the hostname<br/>verification check.",
            "example": "disable",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "string",
                "enum": [
                  "disable"
                ]
              }
            ]
          }
        },
        "type": "object"
      },
      "rule_engine.rule_engine": {
        "properties": {
          "ignore_sys_message": {
            "default": true,
            "type": "boolean",
            "description": "When set to 'true' (default), rule-engine will ignore messages published to $SYS topics."
          },
          "jq_function_default_timeout": {
            "default": "10s",
            "type": "string",
            "description": "Default timeout for the `jq` rule engine function",
            "example": "32s"
          }
        },
        "type": "object"
      },
      "listeners.wss_required_bind": {
        "required": [
          "bind",
          "id",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "wss"
            ],
            "description": "Listener type"
          },
          "running": {
            "type": "boolean",
            "description": "Listener status"
          },
          "id": {
            "type": "string",
            "description": "Listener id"
          },
          "current_connections": {
            "type": "integer",
            "description": "Current connections",
            "minimum": 0
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable listener."
          },
          "bind": {
            "default": 8084,
            "type": "string",
            "description": "IP address and port for the listening socket.",
            "example": "127.0.0.1:80"
          },
          "acceptors": {
            "default": 16,
            "type": "integer",
            "description": "The size of the listener's receiving pool.",
            "minimum": 1
          },
          "max_connections": {
            "default": "infinity",
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "type": "string",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message<br/>is delivered to the subscriber. The mountpoint is a way that users can use<br/>to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`<br/>set to `some_tenant`, then the client actually subscribes to the topic<br/>`some_tenant/t`. Similarly, if another client B (connected to the same listener<br/>as the client A) sends a message to topic `t`, the message is routed<br/>to all the clients subscribed `some_tenant/t`, so client A will receive the<br/>message, with topic name `t`.<br/><br/>Set to `\"\"` to disable the feature.<br/><br/><br/>Variables in mountpoint string:<br/>  - <code>${clientid}</code>: clientid<br/>  - <code>${username}</code>: username"
          },
          "zone": {
            "default": "default",
            "type": "string",
            "description": "The configuration zone to which the listener belongs.<br/>Clients connected to this listener will inherit zone-settings created under this zone name.<br/><br/>A zone can override the configs under below root names:<br/>- `mqtt`<br/>- `force_shutdown`<br/>- `force_gc`<br/>- `flapping_detect`<br/>- `durable_sessions`"
          },
          "enable_authn": {
            "default": true,
            "type": "string",
            "enum": [
              true,
              false,
              "quick_deny_anonymous"
            ],
            "description": "Set <code>true</code> (default) to enable client authentication on this listener, the authentication<br/>process goes through the configured authentication chain.<br/>When set to <code>false</code>, any client (with or without username/password) is allowed to connect.<br/>When set to <code>quick_deny_anonymous</code>, it behaves like when set to <code>true</code>, but clients will be<br/>denied immediately without going through any authenticators if <code>username</code> is not provided. This is useful to fence off<br/>anonymous clients early."
          },
          "max_conn_rate": {
            "default": "infinity",
            "type": "string",
            "description": "Used to limit the rate at which the current listener accepts connections.<br/><br/>Once the limit is reached, EMQX will pause fetching connections from the Accept queue, thereby delaying or rejecting new connections.<br/><br/>For example:<br/><br/>- `1000/s`: Only accepts 1000 connections per second.<br/>- `1000/10s`: Only accepts 1000 connections every 10 seconds.",
            "example": "1000/s"
          },
          "messages_rate": {
            "type": "string",
            "description": "Used to limit the number of messages a single client can send to EMQX per second.<br/><br/>Once the limit is reached, EMQX will pause reading data from the receive-buffer, thus slowing down or even temporarily hanging the sender.<br/><br/>For example:<br/><br/>- `500/s`: Only 500 messages will be received per second, and the remaining messages will be delayed.<br/>- `500/10s`: Only 500 messages will be received every 10 seconds and the remaining messages will be delayed.",
            "example": "1000/s"
          },
          "bytes_rate": {
            "type": "string",
            "description": "Used to limit the number of bytes a single client can send to EMQX per second.<br/><br/>Once the limit is reached, EMQX will pause reading data from the receive-buffer, thus slowing down or even temporarily hanging the sender.<br/><br/>The unit of the bytes could be: B, KB, MB, GB.<br/><br/>For example:<br/><br/>- `500KB/s`: Only 500 kilobytes per second will be received, and the remaining bytes will be delayed.<br/>- `500MB/10s`: Only 500 megabytes will be received every 10 seconds, and the remaining bytes will be delayed.",
            "example": "100MB/s"
          },
          "access_rules": {
            "default": [
              "allow all"
            ],
            "type": "array",
            "description": "An access rule list consisting of string rules to restrict or allow access from some addresses. The rules that appear earlier in the list are matched first.<br/>The format is `allow | deny <address> | <CIDR> | all`.<br/><br/>For example:<br/><br/>`[\\\"deny 192.168.1.1\\\", \\\"allow 192.168.1.0/24\\\", \\\"deny, all\\\"]`",
            "items": {
              "type": "string"
            }
          },
          "proxy_protocol": {
            "default": false,
            "type": "boolean",
            "description": "Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.<br/><br/>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "type": "string",
            "description": "If a reverse proxy is deployed for EMQX, and the PROXY protocol is enabled at the proxy to pass the client's real IP, this option needs to be turned on so that EMQX can extract the client's real IP from the PROXY protocol header.<br/><br/>EMQX will automatically detect the version of the PROXY protocol and support V1 and V2.<br/><br/>For a detailed description of the PROXY protocol, please refer to: https://www.haproxy.com/blog/haproxy/proxy-protocol/",
            "example": "12m"
          },
          "tcp_options": {
            "$ref": "#/components/schemas/emqx.tcp_opts"
          },
          "ssl_options": {
            "$ref": "#/components/schemas/emqx.listener_wss_opts"
          },
          "websocket": {
            "$ref": "#/components/schemas/emqx.ws_opts"
          }
        },
        "type": "object"
      },
      "emqx.alarm": {
        "properties": {
          "actions": {
            "default": [
              "log",
              "publish"
            ],
            "type": "array",
            "description": "The actions triggered when the alarm is activated.<br/>Currently, the following actions are supported: <code>log</code> and <code>publish</code>.<br/><code>log</code> is to write the alarm to log (console or file).<br/><code>publish</code> is to publish the alarm as an MQTT message to the system topics:<br/><code>$SYS/brokers/emqx@xx.xx.xx.x/alarms/activate</code> and<br/><code>$SYS/brokers/emqx@xx.xx.xx.x/alarms/deactivate</code>",
            "items": {
              "type": "string",
              "enum": [
                "log",
                "publish"
              ]
            },
            "example": [
              "log",
              "publish"
            ]
          },
          "size_limit": {
            "default": 1000,
            "maximum": 3000,
            "type": "integer",
            "description": "The maximum number of historical alarms that can be stored.<br/><br/>When the maximum number is reached, the oldest historical alarms will be deleted to store new historical alarms.",
            "minimum": 1,
            "example": 1000
          },
          "validity_period": {
            "default": "24h",
            "type": "string",
            "description": "The validity period of historical alarms. Calculated from the time of activation of the historical alarm instead of the time of cancelation.<br/><br/>If it exists longer than the validity period, the alarm will be deleted.",
            "example": "24h"
          }
        },
        "type": "object"
      },
      "cluster.timeout": {
        "properties": {
          "timeout": {
            "type": "integer",
            "description": "Timeout in milliseconds",
            "minimum": 0,
            "example": "15000"
          }
        },
        "type": "object"
      },
      "authn.metrics_status_fields": {
        "properties": {
          "resource_metrics": {
            "description": "The metrics of the resource.",
            "$ref": "#/components/schemas/authn.resource_metrics"
          },
          "node_resource_metrics": {
            "description": "The metrics of the resource for each node.",
            "$ref": "#/components/schemas/authn.node_resource_metrics"
          },
          "metrics": {
            "description": "The metrics of the resource.",
            "$ref": "#/components/schemas/authn.metrics"
          },
          "node_metrics": {
            "description": "The metrics of the resource for each node.",
            "$ref": "#/components/schemas/authn.node_metrics"
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the resource."
          },
          "node_status": {
            "description": "The status of the resource for each node.",
            "$ref": "#/components/schemas/authn.node_status"
          },
          "node_error": {
            "description": "The error of node.",
            "$ref": "#/components/schemas/authn.node_error"
          }
        },
        "type": "object"
      },
      "cluster.core_replicants": {
        "properties": {
          "core_node": {
            "type": "string",
            "description": "Core node name",
            "example": "emqx-core@127.0.0.1"
          },
          "replicant_nodes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster.replicant_info"
            }
          }
        },
        "type": "object"
      },
      "prometheus.recommend_setting": {
        "required": [
          "enable_basic_auth"
        ],
        "properties": {
          "enable_basic_auth": {
            "default": false,
            "type": "boolean",
            "description": "Enable or disable basic authentication for prometheus scrape api, not for Push Gateway"
          },
          "push_gateway": {
            "description": "Push Gateway is optional, should not be configured if prometheus is to scrape EMQX.",
            "$ref": "#/components/schemas/prometheus.push_gateway"
          },
          "collectors": {
            "description": "The internal advanced metrics of the virtual machine are initially disabled<br/>and are usually only enabled during performance testing.<br/>Enabling them will increase the CPU load.",
            "$ref": "#/components/schemas/prometheus.collectors"
          }
        },
        "type": "object"
      },
      "bridge_http.put_connector": {
        "required": [
          "url"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this connector."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "url": {
            "type": "string",
            "description": "The URL of the HTTP action.<br/><br/>Template with variables is allowed in the path, but variables cannot be used in the scheme, host,<br/>or port part.<br/><br/>For example, <code> http://localhost:9901/${topic} </code> is allowed, but<br/><code> http://${host}:9901/message </code> or <code> http://localhost:${port}/message </code><br/>is not allowed."
          },
          "headers": {
            "default": {
              "accept": "application/json",
              "cache-control": "no-cache",
              "connection": "keep-alive",
              "content-type": "application/json",
              "keep-alive": "timeout=5"
            },
            "type": "object",
            "description": "The headers of the HTTP request.<br/><br/>Template with variables is allowed.",
            "example": {},
            "is_template": true
          },
          "connect_timeout": {
            "default": "15s",
            "type": "string",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s"
          },
          "retry_interval": {
            "type": "string",
            "deprecated": true,
            "example": "12m"
          },
          "pool_type": {
            "default": "random",
            "type": "string",
            "enum": [
              "random",
              "hash"
            ],
            "description": "The type of the pool. Can be one of `random`, `hash`."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "The pool size.",
            "minimum": 1
          },
          "enable_pipelining": {
            "default": 100,
            "type": "integer",
            "description": "The maximum number of HTTP requests that can be sent before an HTTP response is received.<br/><br/>Setting this to 1 is equivalent to turning off HTTP pipelining, and the EMQX must receive a response to the previous HTTP request before sending the next HTTP request.",
            "minimum": 1
          },
          "request": {
            "type": "object",
            "deprecated": true,
            "description": "This field is never used, so we deprecated it since 5.3.2.",
            "example": {}
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_http.connector_resource_opts"
          }
        },
        "type": "object"
      },
      "rule_engine.republish_args": {
        "required": [
          "topic"
        ],
        "properties": {
          "topic": {
            "type": "string",
            "description": "The target topic of message to be re-published.<br/>Template with variables is allowed, see description of the 'republish_args'.",
            "example": "a/1"
          },
          "qos": {
            "default": "${qos}",
            "description": "The qos of the message to be re-published.<br/>Template with variables is allowed, see description of the 'republish_args'.<br/>Defaults to ${qos}. If variable ${qos} is not found from the selected result of the rule,<br/>0 is used.",
            "example": "${qos}",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "maximum": 2,
                "type": "integer",
                "minimum": 0,
                "example": 0
              }
            ]
          },
          "retain": {
            "default": "${retain}",
            "description": "The 'retain' flag of the message to be re-published.<br/>Template with variables is allowed, see description of the 'republish_args'.<br/>Defaults to ${retain}. If variable ${retain} is not found from the selected result<br/>of the rule, false is used.",
            "example": "${retain}",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "boolean"
              }
            ]
          },
          "payload": {
            "default": "${payload}",
            "type": "string",
            "description": "The payload of the message to be re-published.<br/>Template with variables is allowed, see description of the 'republish_args'.<br/>Defaults to ${payload}. If variable ${payload} is not found from the selected result<br/>of the rule, then the string \"undefined\" is used.",
            "example": "${payload}"
          },
          "mqtt_properties": {
            "default": {},
            "description": "From which variable should the MQTT Publish Properties of the message be taken.<br/>Placeholders like <code>${.payload.content_type}</code> may be used.",
            "$ref": "#/components/schemas/rule_engine.republish_mqtt_properties"
          },
          "user_properties": {
            "default": "${user_properties}",
            "type": "string",
            "description": "From which variable should the MQTT message's User-Property pairs be taken from.<br/>The value must be a map.<br/>You may configure it to <code>${pub_props.'User-Property'}</code> or<br/>use <code>SELECT *,pub_props.'User-Property' as user_properties</code><br/>to forward the original user properties to the republished message.<br/>You may also call <code>map_put</code> function like<br/><code>map_put('my-prop-name', 'my-prop-value', user_properties) as user_properties</code><br/>to inject user properties.<br/>NOTE: MQTT spec allows duplicated user property names, but EMQX Rule-Engine does not.",
            "example": "${pub_props.'User-Property'}"
          },
          "direct_dispatch": {
            "default": false,
            "description": "Enable direct dispatch to subscribers without initiating a new message publish event.<br/>When set to `true`, this prevents the recursive processing of a message by the same action<br/>and is used when the output message does not require further processing.<br/><br/>However, enabling this feature has several limitations:<br/><br/>- The output message from this action is not retained.<br/>- It does not trigger other rules that operate based on the output topic of this action.<br/>- It does not activate rules that select from the `$events/message_publish`.<br/>- It does not trigger plugins that use the `'message.publish'` hook.<br/>- Topic metrics are not collected for the output message of this action.<br/>- Message schema validation is not applied (feature of EMQX Enterprise).<br/>- Message transformation processes are not applied (feature of EMQX Enterprise).",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "boolean"
              }
            ]
          }
        },
        "type": "object"
      },
      "authn.mysql": {
        "required": [
          "backend",
          "database",
          "mechanism",
          "query",
          "server"
        ],
        "properties": {
          "mechanism": {
            "type": "string",
            "enum": [
              "password_based"
            ],
            "description": "Authentication mechanism."
          },
          "backend": {
            "type": "string",
            "enum": [
              "mysql"
            ],
            "description": "Backend type."
          },
          "password_hash_algorithm": {
            "default": {
              "name": "sha256",
              "salt_position": "prefix"
            },
            "description": "Options for password hash verification.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn_hash.simple"
              },
              {
                "$ref": "#/components/schemas/authn_hash.pbkdf2"
              },
              {
                "$ref": "#/components/schemas/authn_hash.bcrypt"
              }
            ]
          },
          "query": {
            "type": "string",
            "description": "SQL used to query data for authentication, such as password hash."
          },
          "query_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Timeout for the SQL query.",
            "example": "32s"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider."
          },
          "server": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The MySQL default port 3306 is used if `[:Port]` is not specified."
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "default": "root",
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "authn.resource_metrics": {
        "properties": {
          "matched": {
            "type": "integer",
            "description": "Count of this resource is queried."
          },
          "success": {
            "type": "integer",
            "description": "Count of query success."
          },
          "failed": {
            "type": "integer",
            "description": "Count of query failed."
          },
          "rate": {
            "type": "number",
            "description": "The rate of matched, times/second."
          },
          "rate_max": {
            "type": "number",
            "description": "The max rate of matched, times/second."
          },
          "rate_last5m": {
            "type": "number",
            "description": "The average rate of matched in the last 5 minutes, times/second."
          }
        },
        "type": "object"
      },
      "bridge.metrics": {
        "properties": {
          "dropped": {
            "type": "integer",
            "description": "Count of messages dropped."
          },
          "dropped.other": {
            "type": "integer",
            "description": "Count of messages dropped due to other reasons."
          },
          "dropped.queue_full": {
            "type": "integer",
            "description": "Count of messages dropped due to the queue is full."
          },
          "dropped.resource_not_found": {
            "type": "integer",
            "description": "Count of messages dropped due to the resource is not found."
          },
          "dropped.resource_stopped": {
            "type": "integer",
            "description": "Count of messages dropped due to the resource is stopped."
          },
          "matched": {
            "type": "integer",
            "description": "Count of this bridge is matched and queried."
          },
          "queuing": {
            "type": "integer",
            "description": "Count of messages that are currently queuing."
          },
          "retried": {
            "type": "integer",
            "description": "Times of retried."
          },
          "failed": {
            "type": "integer",
            "description": "Count of messages that sent failed."
          },
          "inflight": {
            "type": "integer",
            "description": "Count of messages that were sent asynchronously but ACKs are not yet received."
          },
          "success": {
            "type": "integer",
            "description": "Count of messages that sent successfully."
          },
          "rate": {
            "type": "number",
            "description": "The rate of matched, times/second"
          },
          "rate_max": {
            "type": "number",
            "description": "The max rate of matched, times/second"
          },
          "rate_last5m": {
            "type": "number",
            "description": "The average rate of matched in the last 5 minutes, times/second"
          },
          "received": {
            "type": "number",
            "description": "Count of messages that is received from the remote system."
          }
        },
        "type": "object"
      },
      "cluster.invitation_status": {
        "properties": {
          "succeed": {
            "type": "array",
            "description": "A list of information about nodes which are successfully invited",
            "items": {
              "$ref": "#/components/schemas/cluster.node_invitation_succeed"
            }
          },
          "in_progress": {
            "type": "array",
            "description": "A list of information about nodes that are processing invitations",
            "items": {
              "$ref": "#/components/schemas/cluster.node_invitation_in_progress"
            }
          },
          "failed": {
            "type": "array",
            "description": "A list of information about nodes that failed to be invited",
            "items": {
              "$ref": "#/components/schemas/cluster.node_invitation_failed"
            }
          }
        },
        "type": "object"
      },
      "emqx.ocsp": {
        "properties": {
          "enable_ocsp_stapling": {
            "default": false,
            "type": "boolean",
            "description": "Whether to enable Online Certificate Status Protocol (OCSP) stapling for the listener.  If set to true, requires defining the OCSP responder URL and issuer PEM path."
          },
          "responder_url": {
            "type": "string",
            "description": "URL for the OCSP responder to check the server certificate against.",
            "example": "http://127.0.0.1"
          },
          "issuer_pem": {
            "type": "string",
            "description": "PEM-encoded certificate of the OCSP issuer for the server certificate."
          },
          "refresh_interval": {
            "default": "5m",
            "type": "string",
            "description": "The period to refresh the OCSP response for the server.",
            "example": "12m"
          },
          "refresh_http_timeout": {
            "default": "15s",
            "type": "string",
            "description": "The timeout for the HTTP request when checking OCSP responses.",
            "example": "12m"
          }
        },
        "type": "object"
      },
      "dashboard.error_code": {
        "properties": {
          "code": {
            "type": "string",
            "description": "Code Name"
          },
          "description": {
            "type": "string",
            "description": "Description"
          }
        },
        "type": "object"
      },
      "listeners.wss_not_required_bind": {
        "required": [
          "id",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "wss"
            ],
            "description": "Listener type"
          },
          "running": {
            "type": "boolean",
            "description": "Listener status"
          },
          "id": {
            "type": "string",
            "description": "Listener id"
          },
          "current_connections": {
            "type": "integer",
            "description": "Current connections",
            "minimum": 0
          },
          "bind": {
            "default": 8084,
            "type": "string",
            "description": "IP address and port for the listening socket.",
            "example": "127.0.0.1:80"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable listener."
          },
          "acceptors": {
            "default": 16,
            "type": "integer",
            "description": "The size of the listener's receiving pool.",
            "minimum": 1
          },
          "max_connections": {
            "default": "infinity",
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "type": "string",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message<br/>is delivered to the subscriber. The mountpoint is a way that users can use<br/>to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`<br/>set to `some_tenant`, then the client actually subscribes to the topic<br/>`some_tenant/t`. Similarly, if another client B (connected to the same listener<br/>as the client A) sends a message to topic `t`, the message is routed<br/>to all the clients subscribed `some_tenant/t`, so client A will receive the<br/>message, with topic name `t`.<br/><br/>Set to `\"\"` to disable the feature.<br/><br/><br/>Variables in mountpoint string:<br/>  - <code>${clientid}</code>: clientid<br/>  - <code>${username}</code>: username"
          },
          "zone": {
            "default": "default",
            "type": "string",
            "description": "The configuration zone to which the listener belongs.<br/>Clients connected to this listener will inherit zone-settings created under this zone name.<br/><br/>A zone can override the configs under below root names:<br/>- `mqtt`<br/>- `force_shutdown`<br/>- `force_gc`<br/>- `flapping_detect`<br/>- `durable_sessions`"
          },
          "enable_authn": {
            "default": true,
            "type": "string",
            "enum": [
              true,
              false,
              "quick_deny_anonymous"
            ],
            "description": "Set <code>true</code> (default) to enable client authentication on this listener, the authentication<br/>process goes through the configured authentication chain.<br/>When set to <code>false</code>, any client (with or without username/password) is allowed to connect.<br/>When set to <code>quick_deny_anonymous</code>, it behaves like when set to <code>true</code>, but clients will be<br/>denied immediately without going through any authenticators if <code>username</code> is not provided. This is useful to fence off<br/>anonymous clients early."
          },
          "max_conn_rate": {
            "default": "infinity",
            "type": "string",
            "description": "Used to limit the rate at which the current listener accepts connections.<br/><br/>Once the limit is reached, EMQX will pause fetching connections from the Accept queue, thereby delaying or rejecting new connections.<br/><br/>For example:<br/><br/>- `1000/s`: Only accepts 1000 connections per second.<br/>- `1000/10s`: Only accepts 1000 connections every 10 seconds.",
            "example": "1000/s"
          },
          "messages_rate": {
            "type": "string",
            "description": "Used to limit the number of messages a single client can send to EMQX per second.<br/><br/>Once the limit is reached, EMQX will pause reading data from the receive-buffer, thus slowing down or even temporarily hanging the sender.<br/><br/>For example:<br/><br/>- `500/s`: Only 500 messages will be received per second, and the remaining messages will be delayed.<br/>- `500/10s`: Only 500 messages will be received every 10 seconds and the remaining messages will be delayed.",
            "example": "1000/s"
          },
          "bytes_rate": {
            "type": "string",
            "description": "Used to limit the number of bytes a single client can send to EMQX per second.<br/><br/>Once the limit is reached, EMQX will pause reading data from the receive-buffer, thus slowing down or even temporarily hanging the sender.<br/><br/>The unit of the bytes could be: B, KB, MB, GB.<br/><br/>For example:<br/><br/>- `500KB/s`: Only 500 kilobytes per second will be received, and the remaining bytes will be delayed.<br/>- `500MB/10s`: Only 500 megabytes will be received every 10 seconds, and the remaining bytes will be delayed.",
            "example": "100MB/s"
          },
          "access_rules": {
            "default": [
              "allow all"
            ],
            "type": "array",
            "description": "An access rule list consisting of string rules to restrict or allow access from some addresses. The rules that appear earlier in the list are matched first.<br/>The format is `allow | deny <address> | <CIDR> | all`.<br/><br/>For example:<br/><br/>`[\\\"deny 192.168.1.1\\\", \\\"allow 192.168.1.0/24\\\", \\\"deny, all\\\"]`",
            "items": {
              "type": "string"
            }
          },
          "proxy_protocol": {
            "default": false,
            "type": "boolean",
            "description": "Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.<br/><br/>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "type": "string",
            "description": "If a reverse proxy is deployed for EMQX, and the PROXY protocol is enabled at the proxy to pass the client's real IP, this option needs to be turned on so that EMQX can extract the client's real IP from the PROXY protocol header.<br/><br/>EMQX will automatically detect the version of the PROXY protocol and support V1 and V2.<br/><br/>For a detailed description of the PROXY protocol, please refer to: https://www.haproxy.com/blog/haproxy/proxy-protocol/",
            "example": "12m"
          },
          "tcp_options": {
            "$ref": "#/components/schemas/emqx.tcp_opts"
          },
          "ssl_options": {
            "$ref": "#/components/schemas/emqx.listener_wss_opts"
          },
          "websocket": {
            "$ref": "#/components/schemas/emqx.ws_opts"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_metrics.aggregated_metrics": {
        "properties": {
          "bytes.received": {
            "type": "integer",
            "description": "Number of bytes received ",
            "minimum": 0
          },
          "bytes.sent": {
            "type": "integer",
            "description": "Number of bytes sent on this connection",
            "minimum": 0
          },
          "packets.received": {
            "type": "integer",
            "description": "Number of received packet",
            "minimum": 0
          },
          "packets.sent": {
            "type": "integer",
            "description": "Number of sent packet",
            "minimum": 0
          },
          "packets.connect.received": {
            "type": "integer",
            "description": "Number of received CONNECT packet",
            "minimum": 0
          },
          "packets.connack.sent": {
            "type": "integer",
            "description": "Number of sent CONNACK packet",
            "minimum": 0
          },
          "packets.connack.error": {
            "type": "integer",
            "description": "Number of received CONNECT packet with unsuccessful connections",
            "minimum": 0
          },
          "packets.connack.auth_error": {
            "type": "integer",
            "description": "Number of received CONNECT packet with failed Authentication",
            "minimum": 0
          },
          "packets.publish.received": {
            "type": "integer",
            "description": "Number of received PUBLISH packet",
            "minimum": 0
          },
          "packets.publish.sent": {
            "type": "integer",
            "description": "Number of sent PUBLISH packet",
            "minimum": 0
          },
          "packets.publish.inuse": {
            "type": "integer",
            "description": "Number of received PUBLISH packet with occupied identifiers",
            "minimum": 0
          },
          "packets.publish.error": {
            "type": "integer",
            "description": "Number of received PUBLISH packet that cannot be published",
            "minimum": 0
          },
          "packets.publish.auth_error": {
            "type": "integer",
            "description": "Number of received PUBLISH packets with failed the Authorization check",
            "minimum": 0
          },
          "packets.publish.dropped": {
            "type": "integer",
            "description": "Number of messages discarded due to the receiving limit",
            "minimum": 0
          },
          "packets.puback.received": {
            "type": "integer",
            "description": "Number of received PUBACK packet",
            "minimum": 0
          },
          "packets.puback.sent": {
            "type": "integer",
            "description": "Number of sent PUBACK packet",
            "minimum": 0
          },
          "packets.puback.inuse": {
            "type": "integer",
            "description": "Number of received PUBACK packet with occupied identifiers",
            "minimum": 0
          },
          "packets.puback.missed": {
            "type": "integer",
            "description": "Number of received packet with identifiers.",
            "minimum": 0
          },
          "packets.pubrec.received": {
            "type": "integer",
            "description": "Number of received PUBREC packet",
            "minimum": 0
          },
          "packets.pubrec.sent": {
            "type": "integer",
            "description": "Number of sent PUBREC packet",
            "minimum": 0
          },
          "packets.pubrec.inuse": {
            "type": "integer",
            "description": "Number of received PUBREC packet with occupied identifiers",
            "minimum": 0
          },
          "packets.pubrec.missed": {
            "type": "integer",
            "description": "Number of received PUBREC packet with unknown identifiers",
            "minimum": 0
          },
          "packets.pubrel.received": {
            "type": "integer",
            "description": "Number of received PUBREL packet",
            "minimum": 0
          },
          "packets.pubrel.sent": {
            "type": "integer",
            "description": "Number of sent PUBREL packet",
            "minimum": 0
          },
          "packets.pubrel.missed": {
            "type": "integer",
            "description": "Number of received PUBREC packet with unknown identifiers",
            "minimum": 0
          },
          "packets.pubcomp.received": {
            "type": "integer",
            "description": "Number of received PUBCOMP packet",
            "minimum": 0
          },
          "packets.pubcomp.sent": {
            "type": "integer",
            "description": "Number of sent PUBCOMP packet",
            "minimum": 0
          },
          "packets.pubcomp.inuse": {
            "type": "integer",
            "description": "Number of received PUBCOMP packet with occupied identifiers",
            "minimum": 0
          },
          "packets.pubcomp.missed": {
            "type": "integer",
            "description": "Number of missed PUBCOMP packet",
            "minimum": 0
          },
          "packets.subscribe.received": {
            "type": "integer",
            "description": "Number of received SUBSCRIBE packet",
            "minimum": 0
          },
          "packets.subscribe.error": {
            "type": "integer",
            "description": "Number of received SUBSCRIBE packet with failed subscriptions",
            "minimum": 0
          },
          "packets.subscribe.auth_error": {
            "type": "integer",
            "description": "Number of received SUBACK packet with failed Authorization check",
            "minimum": 0
          },
          "packets.suback.sent": {
            "type": "integer",
            "description": "Number of sent SUBACK packet",
            "minimum": 0
          },
          "packets.unsubscribe.received": {
            "type": "integer",
            "description": "Number of received UNSUBSCRIBE packet",
            "minimum": 0
          },
          "packets.unsubscribe.error": {
            "type": "integer",
            "description": "Number of received UNSUBSCRIBE packet with failed unsubscriptions",
            "minimum": 0
          },
          "packets.unsuback.sent": {
            "type": "integer",
            "description": "Number of sent UNSUBACK packet",
            "minimum": 0
          },
          "packets.pingreq.received": {
            "type": "integer",
            "description": "Number of received PINGREQ packet",
            "minimum": 0
          },
          "packets.pingresp.sent": {
            "type": "integer",
            "description": "Number of sent PUBRESP packet",
            "minimum": 0
          },
          "packets.disconnect.received": {
            "type": "integer",
            "description": "Number of received DISCONNECT packet",
            "minimum": 0
          },
          "packets.disconnect.sent": {
            "type": "integer",
            "description": "Number of sent DISCONNECT packet",
            "minimum": 0
          },
          "packets.auth.received": {
            "type": "integer",
            "description": "Number of received AUTH packet",
            "minimum": 0
          },
          "packets.auth.sent": {
            "type": "integer",
            "description": "Number of sent AUTH packet",
            "minimum": 0
          },
          "messages.received": {
            "type": "integer",
            "description": "Number of messages received from the client, equal to the sum of messages.qos0.received, messages.qos1.received and messages.qos2.received",
            "minimum": 0
          },
          "messages.sent": {
            "type": "integer",
            "description": "Number of messages sent to the client, equal to the sum of messages.qos0.sent, messages.qos1.sent and messages.qos2.sent",
            "minimum": 0
          },
          "messages.qos0.received": {
            "type": "integer",
            "description": "Number of QoS 0 messages received from clients",
            "minimum": 0
          },
          "messages.qos0.sent": {
            "type": "integer",
            "description": "Number of QoS 0 messages sent to clients",
            "minimum": 0
          },
          "messages.qos1.received": {
            "type": "integer",
            "description": "Number of QoS 1 messages received from clients",
            "minimum": 0
          },
          "messages.qos1.sent": {
            "type": "integer",
            "description": "Number of QoS 1 messages sent to clients",
            "minimum": 0
          },
          "messages.qos2.received": {
            "type": "integer",
            "description": "Number of QoS 2 messages received from clients",
            "minimum": 0
          },
          "messages.qos2.sent": {
            "type": "integer",
            "description": "Number of QoS 2 messages sent to clients",
            "minimum": 0
          },
          "messages.publish": {
            "type": "integer",
            "description": "Number of messages published in addition to system messages",
            "minimum": 0
          },
          "messages.dropped": {
            "type": "integer",
            "description": "Number of messages dropped before forwarding to the subscription process",
            "minimum": 0
          },
          "messages.validation_failed": {
            "type": "integer",
            "description": "Number of message validation failed",
            "minimum": 0
          },
          "messages.validation_succeeded": {
            "type": "integer",
            "description": "Number of message validation successful",
            "minimum": 0
          },
          "messages.transformation_failed": {
            "type": "integer",
            "description": "Number fo message transformation failed",
            "minimum": 0
          },
          "messages.transformation_succeeded": {
            "type": "integer",
            "description": "Number fo message transformation succeeded",
            "minimum": 0
          },
          "messages.dropped.await_pubrel_timeout": {
            "type": "integer",
            "description": "Number of messages dropped due to waiting PUBREL timeout",
            "minimum": 0
          },
          "messages.dropped.no_subscribers": {
            "type": "integer",
            "description": "Number of messages dropped due to no subscribers",
            "minimum": 0
          },
          "messages.forward": {
            "type": "integer",
            "description": "Number of messages forwarded to other nodes",
            "minimum": 0
          },
          "messages.delayed": {
            "type": "integer",
            "description": "Number of delay-published messages",
            "minimum": 0
          },
          "messages.delivered": {
            "type": "integer",
            "description": "Number of messages forwarded to the subscription process internally",
            "minimum": 0
          },
          "messages.acked": {
            "type": "integer",
            "description": "Number of received PUBACK and PUBREC packet",
            "minimum": 0
          },
          "messages.persisted": {
            "type": "integer",
            "description": "Number of message persisted",
            "minimum": 0
          },
          "delivery.dropped": {
            "type": "integer",
            "description": "Total number of discarded messages when sending",
            "minimum": 0
          },
          "delivery.dropped.no_local": {
            "type": "integer",
            "description": "Number of messages that were dropped due to the No Local subscription option when sending",
            "minimum": 0
          },
          "delivery.dropped.too_large": {
            "type": "integer",
            "description": "The number of messages that were dropped because the length exceeded the limit when sending",
            "minimum": 0
          },
          "delivery.dropped.qos0_msg": {
            "type": "integer",
            "description": "Number of messages with QoS 0 that were dropped because the message queue was full when sending",
            "minimum": 0
          },
          "delivery.dropped.queue_full": {
            "type": "integer",
            "description": "Number of messages with a non-zero QoS that were dropped because the message queue was full when sending",
            "minimum": 0
          },
          "delivery.dropped.expired": {
            "type": "integer",
            "description": "Number of messages dropped due to message expiration on sending",
            "minimum": 0
          },
          "client.connect": {
            "type": "integer",
            "description": "Number of client connections",
            "minimum": 0
          },
          "client.connack": {
            "type": "integer",
            "description": "Number of CONNACK packet sent",
            "minimum": 0
          },
          "client.connected": {
            "type": "integer",
            "description": "Number of successful client connected",
            "minimum": 0
          },
          "client.authenticate": {
            "type": "integer",
            "description": "Number of client Authentication",
            "minimum": 0
          },
          "client.auth.anonymous": {
            "type": "integer",
            "description": "Number of clients who log in anonymously",
            "minimum": 0
          },
          "client.authorize": {
            "type": "integer",
            "description": "Number of Authorization rule checks",
            "minimum": 0
          },
          "client.subscribe": {
            "type": "integer",
            "description": "Number of client subscriptions",
            "minimum": 0
          },
          "client.unsubscribe": {
            "type": "integer",
            "description": "Number of client unsubscriptions",
            "minimum": 0
          },
          "client.disconnected": {
            "type": "integer",
            "description": "Number of client disconnects",
            "minimum": 0
          },
          "session.created": {
            "type": "integer",
            "description": "Number of sessions created",
            "minimum": 0
          },
          "session.resumed": {
            "type": "integer",
            "description": "Number of sessions resumed because Clean Session or Clean Start is false",
            "minimum": 0
          },
          "session.takenover": {
            "type": "integer",
            "description": "Number of sessions takenover because Clean Session or Clean Start is false",
            "minimum": 0
          },
          "session.discarded": {
            "type": "integer",
            "description": "Number of sessions dropped because Clean Session or Clean Start is true",
            "minimum": 0
          },
          "session.terminated": {
            "type": "integer",
            "description": "Number of terminated sessions",
            "minimum": 0
          },
          "authorization.allow": {
            "type": "integer",
            "description": "Number of Authorization allow",
            "minimum": 0
          },
          "authorization.deny": {
            "type": "integer",
            "description": "Number of Authorization deny",
            "minimum": 0
          },
          "authorization.cache_hit": {
            "type": "integer",
            "description": "Number of Authorization hits the cache",
            "minimum": 0
          },
          "authorization.cache_miss": {
            "type": "integer",
            "description": "Number of Authorization cache missing",
            "minimum": 0
          },
          "authentication.success": {
            "type": "integer",
            "description": "Number of successful client Authentication",
            "minimum": 0
          },
          "authentication.success.anonymous": {
            "type": "integer",
            "description": "Number of successful client Authentication due to anonymous",
            "minimum": 0
          },
          "authentication.failure": {
            "type": "integer",
            "description": "Number of failed client Authentication",
            "minimum": 0
          },
          "overload_protection.delay.ok": {
            "type": "integer",
            "description": "Number of overload protection delayed",
            "minimum": 0
          },
          "overload_protection.delay.timeout": {
            "type": "integer",
            "description": "Number of overload protection delay timeout",
            "minimum": 0
          },
          "overload_protection.hibernation": {
            "type": "integer",
            "description": "Number of overload protection hibernation",
            "minimum": 0
          },
          "overload_protection.gc": {
            "type": "integer",
            "description": "Number of overload protection garbage collection",
            "minimum": 0
          },
          "overload_protection.new_conn": {
            "type": "integer",
            "description": "Number of overload protection close new incoming connection",
            "minimum": 0
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_clients.mqueue_message": {
        "properties": {
          "msgid": {
            "type": "string",
            "description": "Message ID."
          },
          "topic": {
            "type": "string",
            "description": "Message topic."
          },
          "qos": {
            "maximum": 2,
            "type": "integer",
            "description": "Message QoS.",
            "minimum": 0,
            "example": 0
          },
          "publish_at": {
            "type": "integer",
            "description": "Message publish time, a millisecond precision Unix epoch timestamp."
          },
          "from_clientid": {
            "type": "string",
            "description": "Message publisher's Client ID"
          },
          "from_username": {
            "type": "string",
            "description": "Message publisher's username."
          },
          "payload": {
            "type": "string"
          },
          "inserted_at": {
            "type": "string",
            "description": "A nanosecond precision Unix epoch timestamp at which a message was inserted to In-flight / Mqueue."
          },
          "mqueue_priority": {
            "description": "Message Mqueue Priority.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "integer"
              }
            ]
          }
        },
        "type": "object"
      },
      "authn.ldap": {
        "required": [
          "backend",
          "base_dn",
          "mechanism",
          "server",
          "username"
        ],
        "properties": {
          "mechanism": {
            "type": "string",
            "enum": [
              "password_based"
            ],
            "description": "Authentication mechanism."
          },
          "backend": {
            "type": "string",
            "enum": [
              "ldap"
            ],
            "description": "Backend type."
          },
          "query_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Timeout for the LDAP query.",
            "example": "32s"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider."
          },
          "server": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The LDAP default port 389 is used if `[:Port]` is not specified."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "base_dn": {
            "type": "string",
            "description": "The name of the base object entry (or possibly the root) relative to<br/>which the Search is to be performed.",
            "example": "uid=${username},ou=testdevice,dc=emqx,dc=io"
          },
          "filter": {
            "default": "(objectClass=mqttUser)",
            "type": "string",
            "description": "The filter that defines the conditions that must be fulfilled in order<br/>for the Search to match a given entry.<br><br/>The syntax of the filter follows RFC 4515 and also supports placeholders.",
            "example": "(& (objectClass=mqttUser) (uid=${username}))"
          },
          "request_timeout": {
            "default": "10s",
            "type": "string",
            "description": "Sets the maximum time in milliseconds that is used for each individual request.",
            "example": "32s"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/ldap.ssl"
          },
          "method": {
            "description": "Authentication method.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn.bind_method"
              },
              {
                "$ref": "#/components/schemas/authn.hash_method"
              }
            ]
          }
        },
        "type": "object"
      },
      "rule_engine.ctx_bridge_mqtt": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "type": "string",
            "enum": [
              "$bridges/mqtt:*"
            ],
            "description": "Event Type"
          },
          "id": {
            "type": "string",
            "description": "Message ID"
          },
          "payload": {
            "type": "string",
            "description": "The Message Payload"
          },
          "topic": {
            "type": "string",
            "description": "Message Topic"
          },
          "server": {
            "type": "string",
            "description": "The IP address (or hostname) and port of the MQTT broker, in IP:Port format"
          },
          "dup": {
            "type": "string",
            "description": "The DUP flag of the MQTT message"
          },
          "retain": {
            "type": "string",
            "description": "If is a retain message"
          },
          "message_received_at": {
            "type": "integer",
            "description": "The Time that this Message is Received"
          },
          "qos": {
            "maximum": 2,
            "type": "integer",
            "description": "The Message QoS",
            "minimum": 0,
            "example": 0
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.ws_listener": {
        "properties": {
          "id": {
            "type": "string",
            "description": "Listener ID"
          },
          "type": {
            "type": "string",
            "enum": [
              "ws"
            ],
            "description": "Listener Type"
          },
          "name": {
            "type": "string",
            "description": "Listener Name"
          },
          "running": {
            "type": "boolean",
            "description": "Listener Running status"
          },
          "acceptors": {
            "default": 16,
            "type": "integer",
            "description": "Size of the acceptor pool."
          },
          "tcp_options": {
            "description": "Setting the TCP socket options.",
            "$ref": "#/components/schemas/emqx.tcp_opts"
          },
          "proxy_protocol": {
            "default": false,
            "type": "boolean",
            "description": "If a reverse proxy is deployed for EMQX, and the PROXY protocol is enabled at the proxy to pass the client's real IP,<br/>this option needs to be turned on so that EMQX can extract the client's real IP from the PROXY protocol header.<br/>EMQX will automatically detect the version of the PROXY protocol and support V1 and V2.<br/><br/>For a detailed description of the PROXY protocol, please refer to: https://www.haproxy.com/blog/haproxy/proxy-protocol/"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "type": "string",
            "description": "Timeout for proxy protocol.<br/>EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.",
            "example": "12m"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable the listener."
          },
          "bind": {
            "type": "string",
            "description": "The IP address and port that the listener will bind.",
            "example": "127.0.0.1:80"
          },
          "max_connections": {
            "default": 1024,
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "integer",
                "minimum": 1
              }
            ]
          },
          "max_conn_rate": {
            "default": 1000,
            "type": "integer",
            "description": "Maximum connections per second."
          },
          "enable_authn": {
            "default": true,
            "type": "boolean",
            "description": "Set <code>true</code> (default) to enable client authentication on this listener.<br/>When set to <code>false</code> clients will be allowed to connect without authentication."
          },
          "mountpoint": {
            "type": "string",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message is delivered to the subscriber.<br/>The mountpoint is a way that users can use to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,<br/>then the client actually subscribes to the topic `some_tenant/t`.<br/>Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,<br/>the message is routed to all the clients subscribed `some_tenant/t`,<br/>so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.<br/>Supported placeholders in mountpoint string:<br/><br/>  - <code>${clientid}</code>: clientid<br/><br/>  - <code>${username}</code>: username<br/><br/>  - <code>${endpoint_name}</code>: endpoint name"
          },
          "access_rules": {
            "default": [],
            "type": "array",
            "description": "An access rule list consisting of string rules to restrict or allow access from some addresses.<br/>The rules that appear earlier in the list are matched first.<br/>The format is `allow | deny <address> | <CIDR> | all`.<br/><br/>For example:<br/><br/>`[\\\"deny 192.168.1.1\\\", \\\"allow 192.168.1.0/24\\\", \\\"deny, all\\\"]`",
            "items": {
              "type": "string"
            }
          },
          "websocket": {
            "$ref": "#/components/schemas/gateway.websocket"
          }
        },
        "type": "object"
      },
      "connector_mqtt.post_connector": {
        "required": [
          "name",
          "server",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "mqtt"
            ],
            "description": "The type of the connector."
          },
          "name": {
            "type": "string",
            "description": "The name of the connector."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this connector."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the pool of MQTT clients that will publish messages to the remote broker.<br/><br/>Each MQTT client will be assigned 'clientid' of the form '${clientid_prefix}:${bridge_name}:egress:${node}:${n}'<br/>where 'n' is the number of a client inside the pool.",
            "minimum": 1
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/connector_mqtt.resource_opts"
          },
          "mode": {
            "default": "cluster_shareload",
            "type": "string",
            "enum": [
              "cluster_shareload"
            ],
            "deprecated": true,
            "description": "The mode of the MQTT Bridge.<br/><br/>- cluster_shareload: create an MQTT connection on each node in the emqx cluster.<br/><br/>In 'cluster_shareload' mode, the incoming load from the remote broker is shared by<br/>using shared subscription.<br/><br/>Note that the 'clientid' is suffixed by the node name, this is to avoid<br/>clientid conflicts between different nodes. And we can only use shared subscription<br/>topic filters for <code>remote.topic</code> of ingress connections."
          },
          "server": {
            "type": "string",
            "description": "The host and port of the remote MQTT broker"
          },
          "clientid_prefix": {
            "type": "string",
            "description": "Optional prefix to prepend to the clientid used by egress bridges."
          },
          "reconnect_interval": {
            "type": "string",
            "deprecated": true
          },
          "proto_ver": {
            "default": "v4",
            "type": "string",
            "enum": [
              "v3",
              "v4",
              "v5"
            ],
            "description": "The MQTT protocol version"
          },
          "bridge_mode": {
            "default": false,
            "type": "boolean",
            "description": "If enable bridge mode.<br/>NOTE: This setting is only for MQTT protocol version older than 5.0, and the remote MQTT<br/>broker MUST support this feature.<br/>If bridge_mode is set to true, the bridge will indicate to the remote broker that it is a bridge not an ordinary client.<br/>This means that loop detection will be more effective and that retained messages will be propagated correctly."
          },
          "username": {
            "type": "string",
            "description": "The username of the MQTT protocol"
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password of the MQTT protocol",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "clean_start": {
            "default": true,
            "type": "boolean",
            "description": "Whether to start a clean session when reconnecting a remote broker for ingress bridge"
          },
          "keepalive": {
            "default": "300s",
            "type": "string",
            "description": "MQTT Keepalive. Time interval is a string that contains a number followed by time unit:<br/>- `ms` for milliseconds,<br/>- `s` for seconds,<br/>- `m` for minutes,<br/>- `h` for hours;<br/><br/>or combination of whereof: `1h5m0s`"
          },
          "retry_interval": {
            "default": "15s",
            "type": "string",
            "description": "Message retry interval. Delay for the MQTT bridge to retry sending the QoS1/QoS2 messages in case of ACK not received. Time interval is a string that contains a number followed by time unit:<br/>- `ms` for milliseconds,<br/>- `s` for seconds,<br/>- `m` for minutes,<br/>- `h` for hours;<br/><br/>or combination of whereof: `1h5m0s`"
          },
          "max_inflight": {
            "default": 32,
            "type": "integer",
            "description": "Max inflight (sent, but un-acked) messages of the MQTT protocol",
            "minimum": 0
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_banned.ban": {
        "required": [
          "as",
          "who"
        ],
        "properties": {
          "as": {
            "type": "string",
            "enum": [
              "clientid",
              "username",
              "peerhost",
              "clientid_re",
              "username_re",
              "peerhost_net"
            ],
            "description": "Ban method, which can be exact client ID, client ID regular expression, exact username, username regular expression,<br/>IP address or an IP address range.",
            "example": "username"
          },
          "who": {
            "type": "string",
            "description": "Ban object, specific client ID, username or IP address.",
            "example": "Banned name"
          },
          "by": {
            "type": "string",
            "description": "Initiator of the ban.",
            "example": "mgmt_api"
          },
          "reason": {
            "type": "string",
            "description": "Ban reason, record the reason why the current object was banned.",
            "example": "Too many requests"
          },
          "at": {
            "description": "The start time of the ban, the format is rfc3339, the default is the time when the operation was initiated.",
            "example": "2021-10-25T21:48:47+08:00",
            "oneOf": [
              {
                "type": "integer",
                "description": "epoch-second",
                "example": 1640995200
              },
              {
                "type": "string",
                "format": "date-time",
                "example": "2022-01-01T00:00:00.000Z"
              }
            ]
          },
          "until": {
            "description": "The end time of the ban, the format is rfc3339, the default is the time when the operation was initiated + 1 year.",
            "example": "2021-10-25T21:53:47+08:00",
            "oneOf": [
              {
                "type": "integer",
                "description": "epoch-second",
                "example": 1640995200
              },
              {
                "type": "string",
                "format": "date-time",
                "example": "2022-01-01T00:00:00.000Z"
              }
            ]
          }
        },
        "type": "object"
      },
      "bridge.node_status": {
        "properties": {
          "node": {
            "type": "string",
            "description": "The node name.",
            "example": "emqx@127.0.0.1"
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ]
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          }
        },
        "type": "object"
      },
      "authz.ldap": {
        "required": [
          "base_dn",
          "server",
          "type",
          "username"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "ldap"
            ],
            "description": "Backend type."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Set to <code>true</code> or <code>false</code> to disable this ACL provider"
          },
          "publish_attribute": {
            "default": "mqttPublishTopic",
            "type": "string",
            "description": "Indicates which attribute is used to represent the allowed topics list of the `publish`."
          },
          "subscribe_attribute": {
            "default": "mqttSubscriptionTopic",
            "type": "string",
            "description": "Indicates which attribute is used to represent the allowed topics list of the `subscribe`."
          },
          "all_attribute": {
            "default": "mqttPubSubTopic",
            "type": "string",
            "description": "Indicates which attribute is used to represent the both allowed topics list of  `publish` and `subscribe`."
          },
          "query_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Timeout for the LDAP query.",
            "example": "32s"
          },
          "server": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The LDAP default port 389 is used if `[:Port]` is not specified."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "base_dn": {
            "type": "string",
            "description": "The name of the base object entry (or possibly the root) relative to<br/>which the Search is to be performed.",
            "example": "uid=${username},ou=testdevice,dc=emqx,dc=io"
          },
          "filter": {
            "default": "(objectClass=mqttUser)",
            "type": "string",
            "description": "The filter that defines the conditions that must be fulfilled in order<br/>for the Search to match a given entry.<br><br/>The syntax of the filter follows RFC 4515 and also supports placeholders.",
            "example": "(& (objectClass=mqttUser) (uid=${username}))"
          },
          "request_timeout": {
            "default": "10s",
            "type": "string",
            "description": "Sets the maximum time in milliseconds that is used for each individual request.",
            "example": "32s"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/ldap.ssl"
          }
        },
        "type": "object"
      },
      "api_key.app": {
        "properties": {
          "name": {
            "type": "string",
            "description": "Unique and format by [a-zA-Z0-9-_]",
            "example": "EMQX-API-KEY-1"
          },
          "api_key": {
            "type": "string",
            "description": "TODO:uses HMAC-SHA256 for signing.",
            "example": "a4697a5c75a769f6"
          },
          "api_secret": {
            "type": "string",
            "description": "An API secret is a simple encrypted string that identifiesan application without any principal.They are useful for accessing public data anonymously,and are used to associate API requests.",
            "example": "MzAyMjk3ODMwMDk0NjIzOTUxNjcwNzQ0NzQ3MTE2NDYyMDI"
          },
          "expired_at": {
            "default": "infinity",
            "description": "No longer valid datetime",
            "example": "2021-12-05T02:01:34.186Z",
            "oneOf": [
              {
                "oneOf": [
                  {
                    "type": "integer",
                    "description": "epoch-second",
                    "example": 1640995200
                  },
                  {
                    "type": "string",
                    "format": "date-time",
                    "example": "2022-01-01T00:00:00.000Z"
                  }
                ]
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "created_at": {
            "description": "ApiKey create datetime",
            "example": "2021-12-01T00:00:00.000Z",
            "oneOf": [
              {
                "type": "integer",
                "description": "epoch-second",
                "example": 1640995200
              },
              {
                "type": "string",
                "format": "date-time",
                "example": "2022-01-01T00:00:00.000Z"
              }
            ]
          },
          "desc": {
            "type": "string",
            "example": "Note"
          },
          "enable": {
            "type": "boolean",
            "description": "Enable/Disable"
          },
          "expired": {
            "type": "boolean",
            "description": "Expired"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_publish.publish_error": {
        "properties": {
          "reason_code": {
            "type": "integer",
            "description": "The MQTT reason code, as the same ones used in PUBACK packet.<br/><br/>Currently supported codes are:<br/><br/><br/>16(0x10): No matching subscribers;<br/><br/>131(0x81): Error happened when dispatching the message. e.g. during EMQX restart;<br/><br/>144(0x90): Topic name invalid;<br/><br/>151(0x97): Publish rate limited, or message size exceeded limit. The global size limit can be configured with <code>mqtt.max_packet_size</code><br/><br/>NOTE: The message size is estimated with the received topic and payload size, meaning the actual size of serialized bytes (when sent to MQTT subscriber)<br/>might be slightly over the limit.",
            "example": 16
          },
          "message": {
            "type": "string",
            "description": "Describes the failure reason in detail.",
            "example": "no_matching_subscribers"
          }
        },
        "type": "object"
      },
      "authz.http_get": {
        "required": [
          "method",
          "type",
          "url"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "http"
            ],
            "description": "Backend type."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Set to <code>true</code> or <code>false</code> to disable this ACL provider"
          },
          "url": {
            "type": "string",
            "description": "URL of the auth server."
          },
          "request_timeout": {
            "default": "30s",
            "type": "string",
            "description": "HTTP request timeout."
          },
          "body": {
            "description": "HTTP request body.",
            "properties": {
              "$name": {
                "type": "string"
              }
            },
            "type": "object"
          },
          "connect_timeout": {
            "default": "15s",
            "type": "string",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s"
          },
          "max_retries": {
            "type": "integer",
            "deprecated": true,
            "minimum": 0
          },
          "retry_interval": {
            "type": "string",
            "deprecated": true,
            "example": "12m"
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "The pool size.",
            "minimum": 1
          },
          "enable_pipelining": {
            "default": 100,
            "type": "integer",
            "description": "The maximum number of HTTP requests that can be sent before an HTTP response is received.<br/><br/>Setting this to 1 is equivalent to turning off HTTP pipelining, and the EMQX must receive a response to the previous HTTP request before sending the next HTTP request.",
            "minimum": 1
          },
          "request": {
            "description": "Configure HTTP request parameters.",
            "$ref": "#/components/schemas/connector_http.request"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "method": {
            "type": "string",
            "enum": [
              "get"
            ],
            "description": "HTTP method."
          },
          "headers": {
            "default": {
              "accept": "application/json",
              "cache-control": "no-cache",
              "connection": "keep-alive",
              "keep-alive": "timeout=30, max=1000"
            },
            "type": "object",
            "description": "List of HTTP headers (without <code>content-type</code>).",
            "example": {}
          }
        },
        "type": "object"
      },
      "authn.jwt_hmac": {
        "required": [
          "algorithm",
          "mechanism",
          "secret"
        ],
        "properties": {
          "algorithm": {
            "type": "string",
            "enum": [
              "hmac-based"
            ],
            "description": "JWT signing algorithm, Supports HMAC (configured as <code>hmac-based</code>) and RSA, ECDSA (configured as <code>public-key</code>)."
          },
          "secret": {
            "type": "string",
            "description": "The key to verify the JWT using HMAC algorithm."
          },
          "secret_base64_encoded": {
            "default": false,
            "type": "boolean",
            "description": "Whether secret is base64 encoded."
          },
          "mechanism": {
            "type": "string",
            "enum": [
              "jwt"
            ],
            "description": "Authentication mechanism."
          },
          "acl_claim_name": {
            "default": "acl",
            "type": "string",
            "description": "The JWT claim designated for accessing ACL (Access Control List) rules can be specified,<br/>such as using the `acl` claim. A typical decoded JWT with this claim might appear as:<br/>`{\"username\": \"user1\", \"acl\": ...}`.<br/><br/>Supported ACL Rule Formats:<br/><br/>- Object Format:<br/>  Utilizes action types pub (publish), sub (subscribe), or all (both publish and subscribe).<br/>  The value is a list of topic filters.<br/>  Example: `{\"pub\": [\"topic1\"], \"sub\": [], \"all\": [\"${username}/#\"]}`.<br/>  This example signifies that the token owner can publish to topic1 and perform both publish and subscribe<br/>  actions on topics starting with their username.<br/>  Note: In this format, if no topic matches, the action is denied, and the authorization process terminates.<br/><br/>- Array Format (resembles File-Based ACL Rules):<br/>  Example: `[{\"permission\": \"allow\", \"action\": \"all\", \"topic\": \"${username}/#\"}]`.<br/>  Additionally, the `pub` or `publish` action rules can be extended with `qos` and `retain` field,<br/>  and `sub` or `subscribe` action rules can be extended with a `qos` field.<br/>  Note: Here, if no rule matches, the action is not immediately denied.<br/>  The process continues to other configured authorization sources,<br/>  and ultimately falls back to the default permission in config `authorization.no_match`.<br/><br/>The ACL claim utilizes MQTT topic wildcard matching rules for publishing or subscribing.<br/>A special syntax for the 'subscribe' action allows the use of `eq` for an exact match.<br/>For instance, `eq t/#` permits or denies subscription to `t/#`, but not to `t/1`."
          },
          "verify_claims": {
            "default": {},
            "type": "object",
            "description": "A list of custom claims to validate. The allowed formats are the following:<br/>A map where claim names are map keys and expected values are map values:<br/> <code>{ claim_name = \"${username}\", ...}</code>.<br/><br/>A list of maps with <code>name</code> (claim name) and <code>value</code> (expected claim value) keys:<br/> <code>[{name = \"claim_name\", value = \"${username}\"}, ...]</code>.<br/><br/>Values can use the following placeholders:<br/>- <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting<br/>- <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting<br/><br/>Authentication will verify that the value of claims in the JWT (taken from the Password field) matches what is required in <code>verify_claims</code>.",
            "example": {}
          },
          "disconnect_after_expire": {
            "default": true,
            "type": "boolean",
            "description": "Disconnect the client after the token expires."
          },
          "from": {
            "default": "password",
            "type": "string",
            "enum": [
              "username",
              "password"
            ],
            "description": "Field to take JWT from."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider."
          }
        },
        "type": "object"
      },
      "authz.mongo_single": {
        "required": [
          "collection",
          "database",
          "mongo_type",
          "server",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "mongodb"
            ],
            "description": "Backend type."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Set to <code>true</code> or <code>false</code> to disable this ACL provider"
          },
          "collection": {
            "type": "string",
            "description": "`MongoDB` collection containing the authorization data."
          },
          "filter": {
            "default": {},
            "type": "object",
            "description": "Conditional expression that defines the filter condition in the query.<br/>Filter supports the following placeholders<br/><br/> - <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting<br/><br/> - <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting",
            "example": {}
          },
          "mongo_type": {
            "default": "single",
            "type": "string",
            "enum": [
              "single"
            ],
            "description": "Standalone instance. Must be set to 'single' when MongoDB server is running in standalone mode."
          },
          "server": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The MongoDB default port 27017 is used if `[:Port]` is not specified."
          },
          "w_mode": {
            "default": "unsafe",
            "type": "string",
            "enum": [
              "unsafe",
              "safe"
            ],
            "description": "Write mode."
          },
          "srv_record": {
            "default": false,
            "type": "boolean",
            "description": "Use DNS SRV record."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "use_legacy_protocol": {
            "default": "auto",
            "type": "string",
            "enum": [
              "auto",
              true,
              false
            ],
            "description": "Whether to use MongoDB's legacy protocol for communicating with the database.  The default is to attempt to automatically determine if the newer protocol is supported."
          },
          "auth_source": {
            "type": "string",
            "description": "Database name associated with the user's credentials."
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "topology": {
            "$ref": "#/components/schemas/mongo.topology"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "emqx.client_attrs_init": {
        "properties": {
          "expression": {
            "type": "string",
            "description": "A one line expression to evaluate a set of predefined string functions (like in the rule engine SQL statements).<br/>The expression can be a function call with nested calls as its arguments, or direct variable reference.<br/>So far, it does not provide user-defined variable binding (like `var a=1`) or user-defined functions.<br/>As an example, to extract the prefix of client ID delimited by a dot: `nth(1, tokens(clientid, '.'))`.<br/><br/>The variables pre-bound variables are:<br/>- `cn`: Client's TLS certificate common name.<br/>- `dn`: Client's TLS certificate distinguished name (the subject).<br/>- `clientid`: MQTT Client ID.<br/>- `username`: MQTT Client's username.<br/>- `user_property.{NAME}`: User properties in the CONNECT packet.<br/><br/>You can read more about variform expressions in EMQX docs."
          },
          "set_as_attr": {
            "type": "string",
            "description": "The name of the client attribute extracted from the client data.<br/>The extracted attribute will be stored in the `client_attrs` property with this name."
          }
        },
        "type": "object"
      },
      "authn.mongo_rs": {
        "required": [
          "backend",
          "collection",
          "database",
          "mechanism",
          "mongo_type",
          "replica_set_name",
          "servers"
        ],
        "properties": {
          "mechanism": {
            "type": "string",
            "enum": [
              "password_based"
            ],
            "description": "Authentication mechanism."
          },
          "backend": {
            "type": "string",
            "enum": [
              "mongodb"
            ],
            "description": "Backend type."
          },
          "collection": {
            "type": "string",
            "description": "Collection used to store authentication data."
          },
          "filter": {
            "default": {},
            "type": "object",
            "description": "Conditional expression that defines the filter condition in the query.<br/>Filter supports the following placeholders:<br/>- <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting<br/>- <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting",
            "example": {}
          },
          "password_hash_field": {
            "default": "password_hash",
            "type": "string",
            "description": "Document field that contains password hash."
          },
          "salt_field": {
            "default": "salt",
            "type": "string",
            "description": "Document field that contains the password salt."
          },
          "is_superuser_field": {
            "default": "is_superuser",
            "type": "string",
            "description": "Document field that defines if the user has superuser privileges."
          },
          "password_hash_algorithm": {
            "default": {
              "name": "sha256",
              "salt_position": "prefix"
            },
            "description": "Options for password hash verification.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn_hash.simple"
              },
              {
                "$ref": "#/components/schemas/authn_hash.pbkdf2"
              },
              {
                "$ref": "#/components/schemas/authn_hash.bcrypt"
              }
            ]
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider."
          },
          "mongo_type": {
            "default": "rs",
            "type": "string",
            "enum": [
              "rs"
            ],
            "description": "Replica set. Must be set to 'rs' when MongoDB server is running in 'replica set' mode."
          },
          "servers": {
            "type": "string",
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The MongoDB default port 27017 is used if `[:Port]` is not specified."
          },
          "w_mode": {
            "default": "unsafe",
            "type": "string",
            "enum": [
              "unsafe",
              "safe"
            ],
            "description": "Write mode."
          },
          "r_mode": {
            "default": "master",
            "type": "string",
            "enum": [
              "master",
              "slave_ok"
            ],
            "description": "Read mode."
          },
          "replica_set_name": {
            "type": "string",
            "description": "Name of the replica set."
          },
          "srv_record": {
            "default": false,
            "type": "boolean",
            "description": "Use DNS SRV record."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "use_legacy_protocol": {
            "default": "auto",
            "type": "string",
            "enum": [
              "auto",
              true,
              false
            ],
            "description": "Whether to use MongoDB's legacy protocol for communicating with the database.  The default is to attempt to automatically determine if the newer protocol is supported."
          },
          "auth_source": {
            "type": "string",
            "description": "Database name associated with the user's credentials."
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "topology": {
            "$ref": "#/components/schemas/mongo.topology"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "emqx.listener_ssl_opts": {
        "properties": {
          "cacertfile": {
            "default": "${EMQX_ETC_DIR}/certs/cacert.pem",
            "type": "string",
            "description": "Trusted PEM format CA certificates bundle file.<br/><br/>The certificates in this file are used to verify the TLS peer's certificates.<br/>Append new certificates to the file if new CAs are to be trusted.<br/>There is no need to restart EMQX to have the updated file loaded, because<br/>the system regularly checks if file has been updated (and reload).<br/><br/>NOTE: invalidating (deleting) a certificate from the file will not affect<br/>already established connections."
          },
          "cacerts": {
            "default": false,
            "type": "boolean",
            "deprecated": true
          },
          "certfile": {
            "default": "${EMQX_ETC_DIR}/certs/cert.pem",
            "type": "string",
            "description": "PEM format certificates chain file.<br/><br/>The certificates in this file should be in reversed order of the certificate<br/>issue chain. That is, the host's certificate should be placed in the beginning<br/>of the file, followed by the immediate issuer certificate and so on.<br/>Although the root CA certificate is optional, it should be placed at the end of<br/>the file if it is to be added."
          },
          "keyfile": {
            "default": "${EMQX_ETC_DIR}/certs/key.pem",
            "type": "string",
            "description": "PEM format private key file."
          },
          "verify": {
            "default": "verify_none",
            "type": "string",
            "enum": [
              "verify_peer",
              "verify_none"
            ],
            "description": "Enable or disable peer verification."
          },
          "reuse_sessions": {
            "default": true,
            "type": "boolean",
            "description": "Enable TLS session reuse.<br/><br/>Has no effect when TLS version is configured (or negotiated) to 1.3"
          },
          "depth": {
            "default": 10,
            "type": "integer",
            "description": "Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path.<br/>So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly;<br/><br/>if 1 the path can be PEER, Intermediate-CA, ROOT-CA;<br/><br/>if 2 the path can be PEER, Intermediate-CA1, Intermediate-CA2, ROOT-CA.",
            "minimum": 0
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "String containing the user's password. Only used if the private key file is password-protected.",
            "example": ""
          },
          "versions": {
            "default": [
              "tlsv1.3",
              "tlsv1.2"
            ],
            "type": "array",
            "description": "All TLS/DTLS versions to be supported.<br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.<br/><br/>In case PSK cipher suites are intended, make sure to configure<br/><code>['tlsv1.2', 'tlsv1.1']</code> here.",
            "items": {
              "type": "string"
            }
          },
          "ciphers": {
            "default": [],
            "type": "array",
            "description": "This config holds TLS cipher suite names separated by comma,<br/>or as an array of strings. e.g.<br/><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or<br/><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.<br/><br/><br/>Ciphers (and their ordering) define the way in which the<br/>client and server encrypts information over the network connection.<br/>Selecting a good cipher suite is critical for the<br/>application's data security, confidentiality and performance.<br/><br/>The names should be in OpenSSL string format (not RFC format).<br/>All default values and examples provided by EMQX config<br/>documentation are all in OpenSSL format.<br/><br/><br/>NOTE: Certain cipher suites are only compatible with<br/>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')<br/>incompatible cipher suites will be silently dropped.<br/>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,<br/>configuring cipher suites for other versions will have no effect.<br/><br/><br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br/><br/>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.<br/><br/>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,<br/>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,<br/>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,<br/>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code>",
            "items": {
              "type": "string"
            }
          },
          "secure_renegotiate": {
            "default": true,
            "type": "boolean",
            "description": "Whether to reject TLS renegotiation attempts that are not compliant with [RFC 5746](http://www.ietf.org/rfc/rfc5746.txt).<br/><br/>By default, `secure_renegotiate` is set to `true`, which forces secure renegotiation.<br/>If set to `false`, secure renegotiation will still be used, but will fall back to insecure renegotiation if the peer does not support [RFC 5746](http://www.ietf.org/rfc/rfc5746.txt), which increases the risk of a MitM attack.<br/><br/>Has no effect when TLS version is configured (or negotiated) to 1.3."
          },
          "log_level": {
            "default": "notice",
            "type": "string",
            "enum": [
              "emergency",
              "alert",
              "critical",
              "error",
              "warning",
              "notice",
              "info",
              "debug",
              "none",
              "all"
            ],
            "description": "The minimum level of logging allowed for SSL output.<br/><br/>The default is `notice`, set to a lower `debug` level for more detailed logging that can be used to investigate SSL handshake issues."
          },
          "hibernate_after": {
            "default": "5s",
            "type": "string",
            "description": "Specifies the amount of time that an SSL process will hibernate after being idle, thus reducing its memory footprint.<br/><br/>The hibernating process will be woken up when a new message arrives.<br/>Hibernating and waking up too often can cause CPU utilization to increase, as they both perform garbage collection on the process.",
            "example": "12m"
          },
          "dhfile": {
            "type": "string",
            "description": "Path to a file containing PEM-encoded Diffie-Hellman parameters<br/>to be used by the server if a cipher suite using Diffie-Hellman<br/>key exchange is negotiated. If not specified, default parameters<br/>are used.<br/><br/>NOTE: The <code>dhfile</code> option is not supported by TLS 1.3."
          },
          "fail_if_no_peer_cert": {
            "default": false,
            "type": "boolean",
            "description": "This option is only effective if `verify` is set to `verify_peer`.<br/><br/>If set to `true`, EMQX will reject the connection if the client fails to provide a certificate.<br/><br/>If set to `false`, EMQX will accept clients which don't present a certificate."
          },
          "honor_cipher_order": {
            "default": true,
            "type": "boolean",
            "description": "An important security setting. If this setting is enabled, the server will prioritize the cipher suites it prefers most from the list of cipher suites supported by the client, thus ignoring the client's preferences.<br/><br/>The server's cipher suites are specified by `ciphers`, with preference decreasing from left to right.<br/><br/>It is often better to use the server's preferences, as it is more likely that the server will be configured correctly."
          },
          "client_renegotiation": {
            "default": true,
            "type": "boolean",
            "description": "In protocols that support client-initiated renegotiation,<br/>the cost of resources of such an operation is higher for the server than the client.<br/>This can act as a vector for denial of service attacks.<br/>The SSL application already takes measures to counter-act such attempts,<br/>but client-initiated renegotiation can be strictly disabled by setting this option to false.<br/>The default value is true. Note that disabling renegotiation can result in<br/>long-lived connections becoming unusable due to limits on<br/>the number of messages the underlying cipher suite can encipher.<br/><br/>Has no effect when TLS version is configured (or negotiated) to 1.3"
          },
          "handshake_timeout": {
            "default": "15s",
            "type": "string",
            "description": "Maximum time duration allowed for the handshake to complete",
            "example": "12m"
          },
          "gc_after_handshake": {
            "default": false,
            "type": "boolean",
            "description": "Memory usage tuning. If enabled, will immediately perform a garbage collection after the TLS/SSL handshake."
          },
          "ocsp": {
            "$ref": "#/components/schemas/emqx.ocsp"
          },
          "enable_crl_check": {
            "default": false,
            "type": "boolean",
            "description": "Whether to enable CRL verification for this listener."
          }
        },
        "type": "object"
      },
      "emqx_topic_metrics_api.reset": {
        "required": [
          "action"
        ],
        "properties": {
          "topic": {
            "type": "string",
            "description": "Topic Name. If this parameter is not present,all created topic metrics will be reset.",
            "example": "testtopic/1"
          },
          "action": {
            "type": "string",
            "description": "Action. Only support reset",
            "example": "reset"
          }
        },
        "type": "object"
      },
      "bridge_mqtt_publisher.get_source": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "mqtt"
            ]
          },
          "name": {
            "type": "string"
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "parameters": {
            "$ref": "#/components/schemas/bridge_mqtt_publisher.ingress_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_mqtt_publisher.source_resource_opts"
          }
        },
        "type": "object"
      },
      "authn_hash.bcrypt": {
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "enum": [
              "bcrypt"
            ],
            "description": "BCRYPT password hashing."
          }
        },
        "type": "object"
      },
      "rule_engine.ctx_connack": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "type": "string",
            "enum": [
              "client_connack"
            ],
            "description": "Event Type"
          },
          "reason_code": {
            "type": "string",
            "description": "The reason code"
          },
          "clientid": {
            "type": "string",
            "description": "The Client ID"
          },
          "clean_start": {
            "default": true,
            "type": "boolean",
            "description": "Clean Start"
          },
          "username": {
            "type": "string",
            "description": "Username"
          },
          "peername": {
            "type": "string",
            "description": "The IP Address and Port of the Peer Client"
          },
          "sockname": {
            "type": "string",
            "description": "The IP Address and Port of the Local Listener"
          },
          "proto_name": {
            "type": "string",
            "description": "Protocol Name"
          },
          "proto_ver": {
            "type": "string",
            "description": "Protocol Version"
          },
          "keepalive": {
            "type": "integer",
            "description": "KeepAlive"
          },
          "expiry_interval": {
            "type": "integer",
            "description": "Expiry Interval"
          },
          "connected_at": {
            "type": "integer",
            "description": "The Time that this Client is Connected"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.update_stomp": {
        "properties": {
          "frame": {
            "$ref": "#/components/schemas/gateway.stomp_frame"
          },
          "mountpoint": {
            "default": "",
            "type": "string",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message is delivered to the subscriber.<br/>The mountpoint is a way that users can use to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,<br/>then the client actually subscribes to the topic `some_tenant/t`.<br/>Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,<br/>the message is routed to all the clients subscribed `some_tenant/t`,<br/>so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.<br/>Supported placeholders in mountpoint string:<br/><br/>  - <code>${clientid}</code>: clientid<br/><br/>  - <code>${username}</code>: username<br/><br/>  - <code>${endpoint_name}</code>: endpoint name"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Whether to enable this gateway"
          },
          "enable_stats": {
            "default": true,
            "type": "boolean",
            "description": "Whether to enable client process statistic"
          },
          "idle_timeout": {
            "default": "30s",
            "type": "string",
            "description": "The idle time of the client connection process. It has two purposes:<br/>  1. A newly created client process that does not receive any client requests after that time will be closed directly.<br/>  2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.",
            "example": "12m"
          },
          "clientinfo_override": {
            "description": "ClientInfo override.",
            "$ref": "#/components/schemas/gateway.clientinfo_override"
          }
        },
        "type": "object"
      },
      "emqx.listener_quic_ssl_opts": {
        "properties": {
          "cacertfile": {
            "default": "${EMQX_ETC_DIR}/certs/cacert.pem",
            "type": "string",
            "description": "Trusted PEM format CA certificates bundle file.<br/><br/>The certificates in this file are used to verify the TLS peer's certificates.<br/>Append new certificates to the file if new CAs are to be trusted.<br/>There is no need to restart EMQX to have the updated file loaded, because<br/>the system regularly checks if file has been updated (and reload).<br/><br/>NOTE: invalidating (deleting) a certificate from the file will not affect<br/>already established connections."
          },
          "certfile": {
            "default": "${EMQX_ETC_DIR}/certs/cert.pem",
            "type": "string",
            "description": "PEM format certificates chain file.<br/><br/>The certificates in this file should be in reversed order of the certificate<br/>issue chain. That is, the host's certificate should be placed in the beginning<br/>of the file, followed by the immediate issuer certificate and so on.<br/>Although the root CA certificate is optional, it should be placed at the end of<br/>the file if it is to be added."
          },
          "keyfile": {
            "default": "${EMQX_ETC_DIR}/certs/key.pem",
            "type": "string",
            "description": "PEM format private key file."
          },
          "verify": {
            "default": "verify_none",
            "type": "string",
            "enum": [
              "verify_peer",
              "verify_none"
            ],
            "description": "Enable or disable peer verification."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "String containing the user's password. Only used if the private key file is password-protected.",
            "example": ""
          }
        },
        "type": "object"
      },
      "rule_engine.ctx_delivered": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "type": "string",
            "enum": [
              "message_delivered"
            ],
            "description": "Event Type"
          },
          "id": {
            "type": "string",
            "description": "Message ID"
          },
          "from_clientid": {
            "type": "string",
            "description": "The Client ID"
          },
          "from_username": {
            "type": "string",
            "description": "The User Name"
          },
          "clientid": {
            "type": "string",
            "description": "The Client ID"
          },
          "username": {
            "type": "string",
            "description": "Username"
          },
          "payload": {
            "type": "string",
            "description": "The Message Payload"
          },
          "peerhost": {
            "type": "string",
            "description": "The IP Address of the Peer Client"
          },
          "topic": {
            "type": "string",
            "description": "Message Topic"
          },
          "publish_received_at": {
            "type": "integer",
            "description": "The Time that this Message is Received"
          },
          "qos": {
            "maximum": 2,
            "type": "integer",
            "description": "The Message QoS",
            "minimum": 0,
            "example": 0
          }
        },
        "type": "object"
      },
      "plugins.position": {
        "properties": {
          "position": {
            "description": "<br/>             Enable auto-boot at position in the boot list, where Position could be<br/>             'front', 'rear', or 'before:other-vsn', 'after:other-vsn'<br/>             to specify a relative position.<br/>            ",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "string",
                "enum": [
                  "rear"
                ]
              },
              {
                "type": "string",
                "enum": [
                  "front"
                ]
              }
            ]
          }
        },
        "type": "object"
      },
      "bridge.node_metrics": {
        "properties": {
          "node": {
            "type": "string",
            "description": "The node name.",
            "example": "emqx@127.0.0.1"
          },
          "metrics": {
            "$ref": "#/components/schemas/bridge.metrics"
          }
        },
        "type": "object"
      },
      "connector_http.request": {
        "properties": {
          "method": {
            "type": "string",
            "description": "HTTP method."
          },
          "path": {
            "type": "string",
            "description": "URL path."
          },
          "body": {
            "type": "string",
            "description": "HTTP request body."
          },
          "headers": {
            "type": "object",
            "description": "List of HTTP headers.",
            "example": {},
            "is_template": true
          },
          "max_retries": {
            "type": "integer",
            "description": "Max retry times if error on sending request.",
            "minimum": 0
          },
          "request_timeout": {
            "type": "string",
            "description": "HTTP request timeout.",
            "example": "32s"
          }
        },
        "type": "object"
      },
      "rule_engine.ctx_dropped": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "type": "string",
            "enum": [
              "message_dropped"
            ],
            "description": "Event Type"
          },
          "id": {
            "type": "string",
            "description": "Message ID"
          },
          "reason": {
            "type": "string",
            "description": "The Reason for Dropping"
          },
          "clientid": {
            "type": "string",
            "description": "The Client ID"
          },
          "username": {
            "type": "string",
            "description": "Username"
          },
          "payload": {
            "type": "string",
            "description": "The Message Payload"
          },
          "peerhost": {
            "type": "string",
            "description": "The IP Address of the Peer Client"
          },
          "topic": {
            "type": "string",
            "description": "Message Topic"
          },
          "publish_received_at": {
            "type": "integer",
            "description": "The Time that this Message is Received"
          },
          "qos": {
            "maximum": 2,
            "type": "integer",
            "description": "The Message QoS",
            "minimum": 0,
            "example": 0
          }
        },
        "type": "object"
      },
      "bridge_mqtt_publisher.get_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "mqtt"
            ]
          },
          "name": {
            "type": "string"
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Action specific configs.",
            "$ref": "#/components/schemas/bridge_mqtt_publisher.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_mqtt_publisher.action_resource_opts"
          }
        },
        "type": "object"
      },
      "plugins.running_status": {
        "properties": {
          "node": {
            "type": "string",
            "example": "emqx@127.0.0.1"
          },
          "status": {
            "type": "string",
            "enum": [
              "running",
              "stopped"
            ],
            "description": "Install plugin status at runtime<br/>1. running: plugin is running.<br/>2. stopped: plugin is stopped.<br/>"
          }
        },
        "type": "object"
      },
      "bridge_mqtt.creation_opts": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "maximum": 1024,
            "type": "integer",
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 1
          },
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "start_after_created": {
            "default": true,
            "type": "boolean",
            "description": "Whether start the resource right after created."
          },
          "start_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "example": "32s"
          },
          "auto_restart_interval": {
            "default": "15s",
            "deprecated": true,
            "oneOf": [
              {
                "type": "string",
                "example": "32s"
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "query_mode": {
            "default": "async",
            "type": "string",
            "enum": [
              "sync",
              "async"
            ],
            "description": "Query mode. Optional 'sync/async', default 'async'."
          },
          "request_ttl": {
            "default": "45s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "string",
                "example": "32s"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "type": "integer",
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1
          },
          "enable_queue": {
            "default": false,
            "type": "boolean",
            "deprecated": true,
            "description": "Enable disk buffer queue (only applicable for egress bridges).<br/>When Enabled, messages will be buffered on disk when the bridge connection is down.<br/>When disabled the messages are buffered in RAM only."
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "type": "string",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.update_coap": {
        "properties": {
          "heartbeat": {
            "default": "30s",
            "type": "string",
            "description": "The gateway server required minimum heartbeat interval.<br/>When connection mode is enabled, this parameter is used to set the minimum heartbeat interval for the connection to be alive",
            "example": "1h"
          },
          "connection_required": {
            "default": false,
            "type": "boolean",
            "description": "Enable or disable connection mode.<br/>Connection mode is a feature of non-standard protocols. When connection mode is enabled, it is necessary to maintain the creation, authentication and alive of connection resources"
          },
          "notify_type": {
            "default": "qos",
            "type": "string",
            "enum": [
              "non",
              "con",
              "qos"
            ],
            "description": "The Notification Message will be delivered to the CoAP client if a new message received on an observed topic.<br/>The type of delivered coap message can be set to:<br/><br/>  - non: Non-confirmable;<br/><br/>  - con: Confirmable;<br/><br/>  - qos: Mapping from QoS type of received message, QoS0 -> non, QoS1,2 -> con"
          },
          "subscribe_qos": {
            "default": "coap",
            "type": "string",
            "enum": [
              "qos0",
              "qos1",
              "qos2",
              "coap"
            ],
            "description": "The Default QoS Level indicator for subscribe request.<br/>This option specifies the QoS level for the CoAP Client when establishing a subscription membership, if the subscribe request is not carried `qos` option. The indicator can be set to:<br/><br/>  - qos0, qos1, qos2: Fixed default QoS level<br/><br/>  - coap: Dynamic QoS level by the message type of subscribe request<br/><br/>    * qos0: If the subscribe request is non-confirmable<br/><br/>    * qos1: If the subscribe request is confirmable"
          },
          "publish_qos": {
            "default": "coap",
            "type": "string",
            "enum": [
              "qos0",
              "qos1",
              "qos2",
              "coap"
            ],
            "description": "The Default QoS Level indicator for publish request.<br/>This option specifies the QoS level for the CoAP Client when publishing a message to EMQX PUB/SUB system, if the publish request is not carried `qos` option. The indicator can be set to:<br/><br/>  - qos0, qos1, qos2: Fixed default QoS level<br/><br/>  - coap: Dynamic QoS level by the message type of publish request<br/><br/>    * qos0: If the publish request is non-confirmable<br/><br/>    * qos1: If the publish request is confirmable"
          },
          "mountpoint": {
            "default": "",
            "type": "string",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message is delivered to the subscriber.<br/>The mountpoint is a way that users can use to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,<br/>then the client actually subscribes to the topic `some_tenant/t`.<br/>Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,<br/>the message is routed to all the clients subscribed `some_tenant/t`,<br/>so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.<br/>Supported placeholders in mountpoint string:<br/><br/>  - <code>${clientid}</code>: clientid<br/><br/>  - <code>${username}</code>: username<br/><br/>  - <code>${endpoint_name}</code>: endpoint name"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Whether to enable this gateway"
          },
          "enable_stats": {
            "default": true,
            "type": "boolean",
            "description": "Whether to enable client process statistic"
          },
          "idle_timeout": {
            "default": "30s",
            "type": "string",
            "description": "The idle time of the client connection process. It has two purposes:<br/>  1. A newly created client process that does not receive any client requests after that time will be closed directly.<br/>  2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.",
            "example": "12m"
          },
          "clientinfo_override": {
            "description": "ClientInfo override.",
            "$ref": "#/components/schemas/gateway.clientinfo_override"
          }
        },
        "type": "object"
      },
      "emqx_authz_schema.node_status": {
        "properties": {
          "node": {
            "type": "string",
            "description": "Node name.",
            "example": "emqx@127.0.0.1"
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting"
            ],
            "description": "The status of the resource for each node."
          }
        },
        "type": "object"
      },
      "emqx.listener_wss_opts": {
        "properties": {
          "cacertfile": {
            "default": "${EMQX_ETC_DIR}/certs/cacert.pem",
            "type": "string",
            "description": "Trusted PEM format CA certificates bundle file.<br/><br/>The certificates in this file are used to verify the TLS peer's certificates.<br/>Append new certificates to the file if new CAs are to be trusted.<br/>There is no need to restart EMQX to have the updated file loaded, because<br/>the system regularly checks if file has been updated (and reload).<br/><br/>NOTE: invalidating (deleting) a certificate from the file will not affect<br/>already established connections."
          },
          "cacerts": {
            "default": false,
            "type": "boolean",
            "deprecated": true
          },
          "certfile": {
            "default": "${EMQX_ETC_DIR}/certs/cert.pem",
            "type": "string",
            "description": "PEM format certificates chain file.<br/><br/>The certificates in this file should be in reversed order of the certificate<br/>issue chain. That is, the host's certificate should be placed in the beginning<br/>of the file, followed by the immediate issuer certificate and so on.<br/>Although the root CA certificate is optional, it should be placed at the end of<br/>the file if it is to be added."
          },
          "keyfile": {
            "default": "${EMQX_ETC_DIR}/certs/key.pem",
            "type": "string",
            "description": "PEM format private key file."
          },
          "verify": {
            "default": "verify_none",
            "type": "string",
            "enum": [
              "verify_peer",
              "verify_none"
            ],
            "description": "Enable or disable peer verification."
          },
          "reuse_sessions": {
            "default": true,
            "type": "boolean",
            "description": "Enable TLS session reuse.<br/><br/>Has no effect when TLS version is configured (or negotiated) to 1.3"
          },
          "depth": {
            "default": 10,
            "type": "integer",
            "description": "Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path.<br/>So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly;<br/><br/>if 1 the path can be PEER, Intermediate-CA, ROOT-CA;<br/><br/>if 2 the path can be PEER, Intermediate-CA1, Intermediate-CA2, ROOT-CA.",
            "minimum": 0
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "String containing the user's password. Only used if the private key file is password-protected.",
            "example": ""
          },
          "versions": {
            "default": [
              "tlsv1.3",
              "tlsv1.2"
            ],
            "type": "array",
            "description": "All TLS/DTLS versions to be supported.<br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.<br/><br/>In case PSK cipher suites are intended, make sure to configure<br/><code>['tlsv1.2', 'tlsv1.1']</code> here.",
            "items": {
              "type": "string"
            }
          },
          "ciphers": {
            "default": [],
            "type": "array",
            "description": "This config holds TLS cipher suite names separated by comma,<br/>or as an array of strings. e.g.<br/><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or<br/><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.<br/><br/><br/>Ciphers (and their ordering) define the way in which the<br/>client and server encrypts information over the network connection.<br/>Selecting a good cipher suite is critical for the<br/>application's data security, confidentiality and performance.<br/><br/>The names should be in OpenSSL string format (not RFC format).<br/>All default values and examples provided by EMQX config<br/>documentation are all in OpenSSL format.<br/><br/><br/>NOTE: Certain cipher suites are only compatible with<br/>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')<br/>incompatible cipher suites will be silently dropped.<br/>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,<br/>configuring cipher suites for other versions will have no effect.<br/><br/><br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br/><br/>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.<br/><br/>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,<br/>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,<br/>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,<br/>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code>",
            "items": {
              "type": "string"
            }
          },
          "secure_renegotiate": {
            "default": true,
            "type": "boolean",
            "description": "Whether to reject TLS renegotiation attempts that are not compliant with [RFC 5746](http://www.ietf.org/rfc/rfc5746.txt).<br/><br/>By default, `secure_renegotiate` is set to `true`, which forces secure renegotiation.<br/>If set to `false`, secure renegotiation will still be used, but will fall back to insecure renegotiation if the peer does not support [RFC 5746](http://www.ietf.org/rfc/rfc5746.txt), which increases the risk of a MitM attack.<br/><br/>Has no effect when TLS version is configured (or negotiated) to 1.3."
          },
          "log_level": {
            "default": "notice",
            "type": "string",
            "enum": [
              "emergency",
              "alert",
              "critical",
              "error",
              "warning",
              "notice",
              "info",
              "debug",
              "none",
              "all"
            ],
            "description": "The minimum level of logging allowed for SSL output.<br/><br/>The default is `notice`, set to a lower `debug` level for more detailed logging that can be used to investigate SSL handshake issues."
          },
          "hibernate_after": {
            "default": "5s",
            "type": "string",
            "description": "Specifies the amount of time that an SSL process will hibernate after being idle, thus reducing its memory footprint.<br/><br/>The hibernating process will be woken up when a new message arrives.<br/>Hibernating and waking up too often can cause CPU utilization to increase, as they both perform garbage collection on the process.",
            "example": "12m"
          },
          "dhfile": {
            "type": "string",
            "description": "Path to a file containing PEM-encoded Diffie-Hellman parameters<br/>to be used by the server if a cipher suite using Diffie-Hellman<br/>key exchange is negotiated. If not specified, default parameters<br/>are used.<br/><br/>NOTE: The <code>dhfile</code> option is not supported by TLS 1.3."
          },
          "fail_if_no_peer_cert": {
            "default": false,
            "type": "boolean",
            "description": "This option is only effective if `verify` is set to `verify_peer`.<br/><br/>If set to `true`, EMQX will reject the connection if the client fails to provide a certificate.<br/><br/>If set to `false`, EMQX will accept clients which don't present a certificate."
          },
          "honor_cipher_order": {
            "default": true,
            "type": "boolean",
            "description": "An important security setting. If this setting is enabled, the server will prioritize the cipher suites it prefers most from the list of cipher suites supported by the client, thus ignoring the client's preferences.<br/><br/>The server's cipher suites are specified by `ciphers`, with preference decreasing from left to right.<br/><br/>It is often better to use the server's preferences, as it is more likely that the server will be configured correctly."
          },
          "client_renegotiation": {
            "default": true,
            "type": "boolean",
            "description": "In protocols that support client-initiated renegotiation,<br/>the cost of resources of such an operation is higher for the server than the client.<br/>This can act as a vector for denial of service attacks.<br/>The SSL application already takes measures to counter-act such attempts,<br/>but client-initiated renegotiation can be strictly disabled by setting this option to false.<br/>The default value is true. Note that disabling renegotiation can result in<br/>long-lived connections becoming unusable due to limits on<br/>the number of messages the underlying cipher suite can encipher.<br/><br/>Has no effect when TLS version is configured (or negotiated) to 1.3"
          },
          "handshake_timeout": {
            "default": "15s",
            "type": "string",
            "description": "Maximum time duration allowed for the handshake to complete",
            "example": "12m"
          }
        },
        "type": "object"
      },
      "bridge_mqtt_publisher.ingress_parameters": {
        "required": [
          "topic"
        ],
        "properties": {
          "topic": {
            "type": "string",
            "description": "Receive messages from which topic of the remote broker"
          },
          "qos": {
            "default": 1,
            "maximum": 2,
            "type": "integer",
            "description": "The QoS level to be used when subscribing to the remote broker",
            "minimum": 0,
            "example": 0
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_publish.publish_message": {
        "required": [
          "payload",
          "topic"
        ],
        "properties": {
          "payload_encoding": {
            "default": "plain",
            "type": "string",
            "enum": [
              "plain",
              "base64"
            ],
            "description": "MQTT Payload Encoding, <code>base64</code> or <code>plain</code>. When set to <code>base64</code>, the message is decoded before it is published."
          },
          "topic": {
            "type": "string",
            "description": "Topic Name",
            "example": "api/example/topic"
          },
          "qos": {
            "default": 0,
            "maximum": 2,
            "type": "integer",
            "description": "MQTT message QoS",
            "minimum": 0,
            "example": 0
          },
          "clientid": {
            "type": "string",
            "deprecated": true
          },
          "payload": {
            "type": "string",
            "description": "The MQTT message payload.",
            "example": "hello emqx api"
          },
          "properties": {
            "description": "The Properties of the PUBLISH message.",
            "$ref": "#/components/schemas/emqx_mgmt_api_publish.message_properties"
          },
          "retain": {
            "default": false,
            "type": "boolean",
            "description": "A boolean field to indicate if this message should be retained."
          }
        },
        "type": "object"
      },
      "emqx.flapping_detect": {
        "properties": {
          "enable": {
            "default": false,
            "type": "boolean",
            "description": "Enable flapping connection detection feature."
          },
          "window_time": {
            "default": "1m",
            "type": "string",
            "description": "The time window for flapping detection.",
            "example": "12m"
          },
          "max_count": {
            "default": 15,
            "type": "integer",
            "description": "The maximum number of disconnects allowed for a MQTT Client in `window_time`",
            "minimum": 0
          },
          "ban_time": {
            "default": "5m",
            "type": "string",
            "description": "How long the flapping clientid will be banned.",
            "example": "12m"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_clients.subscribe": {
        "required": [
          "topic"
        ],
        "properties": {
          "topic": {
            "type": "string",
            "description": "Topic",
            "example": "testtopic/#"
          },
          "qos": {
            "default": 0,
            "maximum": 2,
            "type": "integer",
            "description": "QoS",
            "minimum": 0,
            "example": 0
          },
          "nl": {
            "default": 0,
            "type": "integer",
            "description": "No Local"
          },
          "rap": {
            "default": 0,
            "type": "integer",
            "description": "Retain as Published"
          },
          "rh": {
            "default": 0,
            "type": "integer",
            "description": "Retain Handling"
          }
        },
        "type": "object"
      },
      "authn_hash.bcrypt_rw_api": {
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "enum": [
              "bcrypt"
            ],
            "description": "BCRYPT password hashing."
          },
          "salt_rounds": {
            "default": 10,
            "maximum": 10,
            "type": "integer",
            "description": "Work factor for BCRYPT password generation.",
            "minimum": 5,
            "example": 10
          }
        },
        "type": "object"
      },
      "bridge_mqtt_publisher.source_resource_opts": {
        "properties": {
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          }
        },
        "type": "object"
      },
      "emqx_authn_api.response_users": {
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/emqx_authn_api.response_user"
            }
          },
          "meta": {
            "$ref": "#/components/schemas/public.meta"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.tcp_listener": {
        "properties": {
          "id": {
            "type": "string",
            "description": "Listener ID"
          },
          "type": {
            "type": "string",
            "enum": [
              "tcp"
            ],
            "description": "Listener Type"
          },
          "name": {
            "type": "string",
            "description": "Listener Name"
          },
          "running": {
            "type": "boolean",
            "description": "Listener Running status"
          },
          "acceptors": {
            "default": 16,
            "type": "integer",
            "description": "Size of the acceptor pool."
          },
          "tcp_options": {
            "description": "Setting the TCP socket options.",
            "$ref": "#/components/schemas/emqx.tcp_opts"
          },
          "proxy_protocol": {
            "default": false,
            "type": "boolean",
            "description": "If a reverse proxy is deployed for EMQX, and the PROXY protocol is enabled at the proxy to pass the client's real IP,<br/>this option needs to be turned on so that EMQX can extract the client's real IP from the PROXY protocol header.<br/>EMQX will automatically detect the version of the PROXY protocol and support V1 and V2.<br/><br/>For a detailed description of the PROXY protocol, please refer to: https://www.haproxy.com/blog/haproxy/proxy-protocol/"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "type": "string",
            "description": "Timeout for proxy protocol.<br/>EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.",
            "example": "12m"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable the listener."
          },
          "bind": {
            "type": "string",
            "description": "The IP address and port that the listener will bind.",
            "example": "127.0.0.1:80"
          },
          "max_connections": {
            "default": 1024,
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "integer",
                "minimum": 1
              }
            ]
          },
          "max_conn_rate": {
            "default": 1000,
            "type": "integer",
            "description": "Maximum connections per second."
          },
          "enable_authn": {
            "default": true,
            "type": "boolean",
            "description": "Set <code>true</code> (default) to enable client authentication on this listener.<br/>When set to <code>false</code> clients will be allowed to connect without authentication."
          },
          "mountpoint": {
            "type": "string",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message is delivered to the subscriber.<br/>The mountpoint is a way that users can use to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,<br/>then the client actually subscribes to the topic `some_tenant/t`.<br/>Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,<br/>the message is routed to all the clients subscribed `some_tenant/t`,<br/>so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.<br/>Supported placeholders in mountpoint string:<br/><br/>  - <code>${clientid}</code>: clientid<br/><br/>  - <code>${username}</code>: username<br/><br/>  - <code>${endpoint_name}</code>: endpoint name"
          },
          "access_rules": {
            "default": [],
            "type": "array",
            "description": "An access rule list consisting of string rules to restrict or allow access from some addresses.<br/>The rules that appear earlier in the list are matched first.<br/>The format is `allow | deny <address> | <CIDR> | all`.<br/><br/>For example:<br/><br/>`[\\\"deny 192.168.1.1\\\", \\\"allow 192.168.1.0/24\\\", \\\"deny, all\\\"]`",
            "items": {
              "type": "string"
            }
          }
        },
        "type": "object"
      },
      "authn.builtin_db_api": {
        "required": [
          "backend",
          "mechanism",
          "user_id_type"
        ],
        "properties": {
          "password_hash_algorithm": {
            "description": "Options for password hash creation and verification through API.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn_hash.simple"
              },
              {
                "$ref": "#/components/schemas/authn_hash.pbkdf2"
              },
              {
                "$ref": "#/components/schemas/authn_hash.bcrypt_rw_api"
              }
            ]
          },
          "mechanism": {
            "type": "string",
            "enum": [
              "password_based"
            ],
            "description": "Authentication mechanism."
          },
          "backend": {
            "type": "string",
            "enum": [
              "built_in_database"
            ],
            "description": "Backend type."
          },
          "user_id_type": {
            "default": "username",
            "type": "string",
            "enum": [
              "clientid",
              "username"
            ],
            "description": "Specify whether to use `clientid` or `username` for authentication."
          },
          "bootstrap_file": {
            "default": "${EMQX_ETC_DIR}/auth-built-in-db-bootstrap.csv",
            "type": "string",
            "description": "The bootstrap file imports users into the built-in database.<br/>It will not import a user ID that already exists in the database.<br/>The file content format is determined by `bootstrap_type`."
          },
          "bootstrap_type": {
            "default": "plain",
            "type": "string",
            "enum": [
              "hash",
              "plain"
            ],
            "description": "Specify which type of content the bootstrap file has.<br/><br/>- **`plain`**:<br/>  - Expected data fields: `user_id`, `password`, `is_superuser`<br/>  - `user_id`: Can be Client ID or username, depending on built-in database authentication's `user_id_type` config.<br/>  - `password`: User's plaintext password.<br/>  - `is_superuser`: Boolean, user's administrative status.<br/><br/>- **`hash`**:<br/>  - Expected data fields: `user_id`,`password_hash`,`salt`,`is_superuser`<br/>  - Definitions similar to `plain` type, with `password_hash` and `salt` added for security.<br/><br/>The content can be either in CSV, or JSON format.<br/><br/>Here is a CSV example: `user_id,password_hash,salt,is_superuser\\nmy_user,b6c743545a7817ae8c8f624371d5f5f0373234bb0ff36b8ffbf19bce0e06ab75,de1024f462fb83910fd13151bd4bd235,true`<br/><br/>And JSON content should be decoded into an array of objects, for example: `[{\"user_id\": \"my_user\",\"password\": \"s3cr3tp@ssw0rd\",\"is_superuser\": true}]`.<br/><br/>The hash string for `password_hash` depends on how `password_hash_algorithm` is configured for the built-in database authentication mechanism. For example, if it's configured as `password_hash_algorithm {name = sha256, salt_position = suffix}`, then the salt is appended to the password before hashed. Here is the equivalent Python expression: `hashlib.sha256(password + salt).hexdigest()`."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider."
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_clients.unsubscribe": {
        "properties": {
          "topic": {
            "type": "string",
            "description": "Topic",
            "example": "testtopic/#"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_metrics.node_metrics": {
        "properties": {
          "node": {
            "type": "string",
            "description": "Node name"
          },
          "bytes.received": {
            "type": "integer",
            "description": "Number of bytes received ",
            "minimum": 0
          },
          "bytes.sent": {
            "type": "integer",
            "description": "Number of bytes sent on this connection",
            "minimum": 0
          },
          "packets.received": {
            "type": "integer",
            "description": "Number of received packet",
            "minimum": 0
          },
          "packets.sent": {
            "type": "integer",
            "description": "Number of sent packet",
            "minimum": 0
          },
          "packets.connect.received": {
            "type": "integer",
            "description": "Number of received CONNECT packet",
            "minimum": 0
          },
          "packets.connack.sent": {
            "type": "integer",
            "description": "Number of sent CONNACK packet",
            "minimum": 0
          },
          "packets.connack.error": {
            "type": "integer",
            "description": "Number of received CONNECT packet with unsuccessful connections",
            "minimum": 0
          },
          "packets.connack.auth_error": {
            "type": "integer",
            "description": "Number of received CONNECT packet with failed Authentication",
            "minimum": 0
          },
          "packets.publish.received": {
            "type": "integer",
            "description": "Number of received PUBLISH packet",
            "minimum": 0
          },
          "packets.publish.sent": {
            "type": "integer",
            "description": "Number of sent PUBLISH packet",
            "minimum": 0
          },
          "packets.publish.inuse": {
            "type": "integer",
            "description": "Number of received PUBLISH packet with occupied identifiers",
            "minimum": 0
          },
          "packets.publish.error": {
            "type": "integer",
            "description": "Number of received PUBLISH packet that cannot be published",
            "minimum": 0
          },
          "packets.publish.auth_error": {
            "type": "integer",
            "description": "Number of received PUBLISH packets with failed the Authorization check",
            "minimum": 0
          },
          "packets.publish.dropped": {
            "type": "integer",
            "description": "Number of messages discarded due to the receiving limit",
            "minimum": 0
          },
          "packets.puback.received": {
            "type": "integer",
            "description": "Number of received PUBACK packet",
            "minimum": 0
          },
          "packets.puback.sent": {
            "type": "integer",
            "description": "Number of sent PUBACK packet",
            "minimum": 0
          },
          "packets.puback.inuse": {
            "type": "integer",
            "description": "Number of received PUBACK packet with occupied identifiers",
            "minimum": 0
          },
          "packets.puback.missed": {
            "type": "integer",
            "description": "Number of received packet with identifiers.",
            "minimum": 0
          },
          "packets.pubrec.received": {
            "type": "integer",
            "description": "Number of received PUBREC packet",
            "minimum": 0
          },
          "packets.pubrec.sent": {
            "type": "integer",
            "description": "Number of sent PUBREC packet",
            "minimum": 0
          },
          "packets.pubrec.inuse": {
            "type": "integer",
            "description": "Number of received PUBREC packet with occupied identifiers",
            "minimum": 0
          },
          "packets.pubrec.missed": {
            "type": "integer",
            "description": "Number of received PUBREC packet with unknown identifiers",
            "minimum": 0
          },
          "packets.pubrel.received": {
            "type": "integer",
            "description": "Number of received PUBREL packet",
            "minimum": 0
          },
          "packets.pubrel.sent": {
            "type": "integer",
            "description": "Number of sent PUBREL packet",
            "minimum": 0
          },
          "packets.pubrel.missed": {
            "type": "integer",
            "description": "Number of received PUBREC packet with unknown identifiers",
            "minimum": 0
          },
          "packets.pubcomp.received": {
            "type": "integer",
            "description": "Number of received PUBCOMP packet",
            "minimum": 0
          },
          "packets.pubcomp.sent": {
            "type": "integer",
            "description": "Number of sent PUBCOMP packet",
            "minimum": 0
          },
          "packets.pubcomp.inuse": {
            "type": "integer",
            "description": "Number of received PUBCOMP packet with occupied identifiers",
            "minimum": 0
          },
          "packets.pubcomp.missed": {
            "type": "integer",
            "description": "Number of missed PUBCOMP packet",
            "minimum": 0
          },
          "packets.subscribe.received": {
            "type": "integer",
            "description": "Number of received SUBSCRIBE packet",
            "minimum": 0
          },
          "packets.subscribe.error": {
            "type": "integer",
            "description": "Number of received SUBSCRIBE packet with failed subscriptions",
            "minimum": 0
          },
          "packets.subscribe.auth_error": {
            "type": "integer",
            "description": "Number of received SUBACK packet with failed Authorization check",
            "minimum": 0
          },
          "packets.suback.sent": {
            "type": "integer",
            "description": "Number of sent SUBACK packet",
            "minimum": 0
          },
          "packets.unsubscribe.received": {
            "type": "integer",
            "description": "Number of received UNSUBSCRIBE packet",
            "minimum": 0
          },
          "packets.unsubscribe.error": {
            "type": "integer",
            "description": "Number of received UNSUBSCRIBE packet with failed unsubscriptions",
            "minimum": 0
          },
          "packets.unsuback.sent": {
            "type": "integer",
            "description": "Number of sent UNSUBACK packet",
            "minimum": 0
          },
          "packets.pingreq.received": {
            "type": "integer",
            "description": "Number of received PINGREQ packet",
            "minimum": 0
          },
          "packets.pingresp.sent": {
            "type": "integer",
            "description": "Number of sent PUBRESP packet",
            "minimum": 0
          },
          "packets.disconnect.received": {
            "type": "integer",
            "description": "Number of received DISCONNECT packet",
            "minimum": 0
          },
          "packets.disconnect.sent": {
            "type": "integer",
            "description": "Number of sent DISCONNECT packet",
            "minimum": 0
          },
          "packets.auth.received": {
            "type": "integer",
            "description": "Number of received AUTH packet",
            "minimum": 0
          },
          "packets.auth.sent": {
            "type": "integer",
            "description": "Number of sent AUTH packet",
            "minimum": 0
          },
          "messages.received": {
            "type": "integer",
            "description": "Number of messages received from the client, equal to the sum of messages.qos0.received, messages.qos1.received and messages.qos2.received",
            "minimum": 0
          },
          "messages.sent": {
            "type": "integer",
            "description": "Number of messages sent to the client, equal to the sum of messages.qos0.sent, messages.qos1.sent and messages.qos2.sent",
            "minimum": 0
          },
          "messages.qos0.received": {
            "type": "integer",
            "description": "Number of QoS 0 messages received from clients",
            "minimum": 0
          },
          "messages.qos0.sent": {
            "type": "integer",
            "description": "Number of QoS 0 messages sent to clients",
            "minimum": 0
          },
          "messages.qos1.received": {
            "type": "integer",
            "description": "Number of QoS 1 messages received from clients",
            "minimum": 0
          },
          "messages.qos1.sent": {
            "type": "integer",
            "description": "Number of QoS 1 messages sent to clients",
            "minimum": 0
          },
          "messages.qos2.received": {
            "type": "integer",
            "description": "Number of QoS 2 messages received from clients",
            "minimum": 0
          },
          "messages.qos2.sent": {
            "type": "integer",
            "description": "Number of QoS 2 messages sent to clients",
            "minimum": 0
          },
          "messages.publish": {
            "type": "integer",
            "description": "Number of messages published in addition to system messages",
            "minimum": 0
          },
          "messages.dropped": {
            "type": "integer",
            "description": "Number of messages dropped before forwarding to the subscription process",
            "minimum": 0
          },
          "messages.validation_failed": {
            "type": "integer",
            "description": "Number of message validation failed",
            "minimum": 0
          },
          "messages.validation_succeeded": {
            "type": "integer",
            "description": "Number of message validation successful",
            "minimum": 0
          },
          "messages.transformation_failed": {
            "type": "integer",
            "description": "Number fo message transformation failed",
            "minimum": 0
          },
          "messages.transformation_succeeded": {
            "type": "integer",
            "description": "Number fo message transformation succeeded",
            "minimum": 0
          },
          "messages.dropped.await_pubrel_timeout": {
            "type": "integer",
            "description": "Number of messages dropped due to waiting PUBREL timeout",
            "minimum": 0
          },
          "messages.dropped.no_subscribers": {
            "type": "integer",
            "description": "Number of messages dropped due to no subscribers",
            "minimum": 0
          },
          "messages.forward": {
            "type": "integer",
            "description": "Number of messages forwarded to other nodes",
            "minimum": 0
          },
          "messages.delayed": {
            "type": "integer",
            "description": "Number of delay-published messages",
            "minimum": 0
          },
          "messages.delivered": {
            "type": "integer",
            "description": "Number of messages forwarded to the subscription process internally",
            "minimum": 0
          },
          "messages.acked": {
            "type": "integer",
            "description": "Number of received PUBACK and PUBREC packet",
            "minimum": 0
          },
          "messages.persisted": {
            "type": "integer",
            "description": "Number of message persisted",
            "minimum": 0
          },
          "delivery.dropped": {
            "type": "integer",
            "description": "Total number of discarded messages when sending",
            "minimum": 0
          },
          "delivery.dropped.no_local": {
            "type": "integer",
            "description": "Number of messages that were dropped due to the No Local subscription option when sending",
            "minimum": 0
          },
          "delivery.dropped.too_large": {
            "type": "integer",
            "description": "The number of messages that were dropped because the length exceeded the limit when sending",
            "minimum": 0
          },
          "delivery.dropped.qos0_msg": {
            "type": "integer",
            "description": "Number of messages with QoS 0 that were dropped because the message queue was full when sending",
            "minimum": 0
          },
          "delivery.dropped.queue_full": {
            "type": "integer",
            "description": "Number of messages with a non-zero QoS that were dropped because the message queue was full when sending",
            "minimum": 0
          },
          "delivery.dropped.expired": {
            "type": "integer",
            "description": "Number of messages dropped due to message expiration on sending",
            "minimum": 0
          },
          "client.connect": {
            "type": "integer",
            "description": "Number of client connections",
            "minimum": 0
          },
          "client.connack": {
            "type": "integer",
            "description": "Number of CONNACK packet sent",
            "minimum": 0
          },
          "client.connected": {
            "type": "integer",
            "description": "Number of successful client connected",
            "minimum": 0
          },
          "client.authenticate": {
            "type": "integer",
            "description": "Number of client Authentication",
            "minimum": 0
          },
          "client.auth.anonymous": {
            "type": "integer",
            "description": "Number of clients who log in anonymously",
            "minimum": 0
          },
          "client.authorize": {
            "type": "integer",
            "description": "Number of Authorization rule checks",
            "minimum": 0
          },
          "client.subscribe": {
            "type": "integer",
            "description": "Number of client subscriptions",
            "minimum": 0
          },
          "client.unsubscribe": {
            "type": "integer",
            "description": "Number of client unsubscriptions",
            "minimum": 0
          },
          "client.disconnected": {
            "type": "integer",
            "description": "Number of client disconnects",
            "minimum": 0
          },
          "session.created": {
            "type": "integer",
            "description": "Number of sessions created",
            "minimum": 0
          },
          "session.resumed": {
            "type": "integer",
            "description": "Number of sessions resumed because Clean Session or Clean Start is false",
            "minimum": 0
          },
          "session.takenover": {
            "type": "integer",
            "description": "Number of sessions takenover because Clean Session or Clean Start is false",
            "minimum": 0
          },
          "session.discarded": {
            "type": "integer",
            "description": "Number of sessions dropped because Clean Session or Clean Start is true",
            "minimum": 0
          },
          "session.terminated": {
            "type": "integer",
            "description": "Number of terminated sessions",
            "minimum": 0
          },
          "authorization.allow": {
            "type": "integer",
            "description": "Number of Authorization allow",
            "minimum": 0
          },
          "authorization.deny": {
            "type": "integer",
            "description": "Number of Authorization deny",
            "minimum": 0
          },
          "authorization.cache_hit": {
            "type": "integer",
            "description": "Number of Authorization hits the cache",
            "minimum": 0
          },
          "authorization.cache_miss": {
            "type": "integer",
            "description": "Number of Authorization cache missing",
            "minimum": 0
          },
          "authentication.success": {
            "type": "integer",
            "description": "Number of successful client Authentication",
            "minimum": 0
          },
          "authentication.success.anonymous": {
            "type": "integer",
            "description": "Number of successful client Authentication due to anonymous",
            "minimum": 0
          },
          "authentication.failure": {
            "type": "integer",
            "description": "Number of failed client Authentication",
            "minimum": 0
          },
          "overload_protection.delay.ok": {
            "type": "integer",
            "description": "Number of overload protection delayed",
            "minimum": 0
          },
          "overload_protection.delay.timeout": {
            "type": "integer",
            "description": "Number of overload protection delay timeout",
            "minimum": 0
          },
          "overload_protection.hibernation": {
            "type": "integer",
            "description": "Number of overload protection hibernation",
            "minimum": 0
          },
          "overload_protection.gc": {
            "type": "integer",
            "description": "Number of overload protection garbage collection",
            "minimum": 0
          },
          "overload_protection.new_conn": {
            "type": "integer",
            "description": "Number of overload protection close new incoming connection",
            "minimum": 0
          }
        },
        "type": "object"
      },
      "listeners.quic_not_required_bind": {
        "required": [
          "id",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "quic"
            ],
            "description": "Listener type"
          },
          "running": {
            "type": "boolean",
            "description": "Listener status"
          },
          "id": {
            "type": "string",
            "description": "Listener id"
          },
          "current_connections": {
            "type": "integer",
            "description": "Current connections",
            "minimum": 0
          },
          "bind": {
            "default": 14567,
            "type": "string",
            "description": "IP address and port for the listening socket.",
            "example": "127.0.0.1:80"
          },
          "ciphers": {
            "default": [
              "TLS_AES_256_GCM_SHA384",
              "TLS_AES_128_GCM_SHA256",
              "TLS_CHACHA20_POLY1305_SHA256"
            ],
            "type": "array",
            "description": "This config holds TLS cipher suite names separated by comma,<br/>or as an array of strings. e.g.<br/><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or<br/><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.<br/><br/><br/>Ciphers (and their ordering) define the way in which the<br/>client and server encrypts information over the network connection.<br/>Selecting a good cipher suite is critical for the<br/>application's data security, confidentiality and performance.<br/><br/>The names should be in OpenSSL string format (not RFC format).<br/>All default values and examples provided by EMQX config<br/>documentation are all in OpenSSL format.<br/><br/><br/>NOTE: Certain cipher suites are only compatible with<br/>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')<br/>incompatible cipher suites will be silently dropped.<br/>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,<br/>configuring cipher suites for other versions will have no effect.<br/><br/><br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br/><br/>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.<br/><br/>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,<br/>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,<br/>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,<br/>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code><br/><br/><br/>NOTE: QUIC listener supports only 'tlsv1.3' ciphers",
            "items": {
              "type": "string"
            }
          },
          "ssl_options": {
            "description": "TLS options for QUIC transport",
            "$ref": "#/components/schemas/emqx.listener_quic_ssl_opts"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable listener."
          },
          "acceptors": {
            "default": 16,
            "type": "integer",
            "description": "The size of the listener's receiving pool.",
            "minimum": 1
          },
          "max_connections": {
            "default": "infinity",
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "type": "string",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message<br/>is delivered to the subscriber. The mountpoint is a way that users can use<br/>to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`<br/>set to `some_tenant`, then the client actually subscribes to the topic<br/>`some_tenant/t`. Similarly, if another client B (connected to the same listener<br/>as the client A) sends a message to topic `t`, the message is routed<br/>to all the clients subscribed `some_tenant/t`, so client A will receive the<br/>message, with topic name `t`.<br/><br/>Set to `\"\"` to disable the feature.<br/><br/><br/>Variables in mountpoint string:<br/>  - <code>${clientid}</code>: clientid<br/>  - <code>${username}</code>: username"
          },
          "zone": {
            "default": "default",
            "type": "string",
            "description": "The configuration zone to which the listener belongs.<br/>Clients connected to this listener will inherit zone-settings created under this zone name.<br/><br/>A zone can override the configs under below root names:<br/>- `mqtt`<br/>- `force_shutdown`<br/>- `force_gc`<br/>- `flapping_detect`<br/>- `durable_sessions`"
          },
          "enable_authn": {
            "default": true,
            "type": "string",
            "enum": [
              true,
              false,
              "quick_deny_anonymous"
            ],
            "description": "Set <code>true</code> (default) to enable client authentication on this listener, the authentication<br/>process goes through the configured authentication chain.<br/>When set to <code>false</code>, any client (with or without username/password) is allowed to connect.<br/>When set to <code>quick_deny_anonymous</code>, it behaves like when set to <code>true</code>, but clients will be<br/>denied immediately without going through any authenticators if <code>username</code> is not provided. This is useful to fence off<br/>anonymous clients early."
          },
          "max_conn_rate": {
            "default": "infinity",
            "type": "string",
            "description": "Used to limit the rate at which the current listener accepts connections.<br/><br/>Once the limit is reached, EMQX will pause fetching connections from the Accept queue, thereby delaying or rejecting new connections.<br/><br/>For example:<br/><br/>- `1000/s`: Only accepts 1000 connections per second.<br/>- `1000/10s`: Only accepts 1000 connections every 10 seconds.",
            "example": "1000/s"
          },
          "messages_rate": {
            "type": "string",
            "description": "Used to limit the number of messages a single client can send to EMQX per second.<br/><br/>Once the limit is reached, EMQX will pause reading data from the receive-buffer, thus slowing down or even temporarily hanging the sender.<br/><br/>For example:<br/><br/>- `500/s`: Only 500 messages will be received per second, and the remaining messages will be delayed.<br/>- `500/10s`: Only 500 messages will be received every 10 seconds and the remaining messages will be delayed.",
            "example": "1000/s"
          },
          "bytes_rate": {
            "type": "string",
            "description": "Used to limit the number of bytes a single client can send to EMQX per second.<br/><br/>Once the limit is reached, EMQX will pause reading data from the receive-buffer, thus slowing down or even temporarily hanging the sender.<br/><br/>The unit of the bytes could be: B, KB, MB, GB.<br/><br/>For example:<br/><br/>- `500KB/s`: Only 500 kilobytes per second will be received, and the remaining bytes will be delayed.<br/>- `500MB/10s`: Only 500 megabytes will be received every 10 seconds, and the remaining bytes will be delayed.",
            "example": "100MB/s"
          }
        },
        "type": "object"
      },
      "retainer.message": {
        "properties": {
          "payload": {
            "type": "string",
            "description": "Payload."
          },
          "msgid": {
            "type": "string",
            "description": "Message ID."
          },
          "topic": {
            "type": "string",
            "description": "Topic."
          },
          "qos": {
            "maximum": 2,
            "type": "integer",
            "description": "QoS.",
            "minimum": 0,
            "example": 0
          },
          "publish_at": {
            "type": "string",
            "description": "Message publish time, RFC 3339 format."
          },
          "from_clientid": {
            "type": "string",
            "description": "The clientid of publisher."
          },
          "from_username": {
            "type": "string",
            "description": "The username of publisher."
          }
        },
        "type": "object"
      },
      "listeners.with_name_ws_required_bind": {
        "required": [
          "bind",
          "name",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "ws"
            ],
            "description": "Listener type"
          },
          "running": {
            "type": "boolean",
            "description": "Listener status"
          },
          "name": {
            "type": "string",
            "description": "Listener name"
          },
          "current_connections": {
            "type": "integer",
            "description": "Current connections",
            "minimum": 0
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable listener."
          },
          "bind": {
            "default": 8083,
            "type": "string",
            "description": "IP address and port for the listening socket.",
            "example": "127.0.0.1:80"
          },
          "acceptors": {
            "default": 16,
            "type": "integer",
            "description": "The size of the listener's receiving pool.",
            "minimum": 1
          },
          "max_connections": {
            "default": "infinity",
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "type": "string",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message<br/>is delivered to the subscriber. The mountpoint is a way that users can use<br/>to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`<br/>set to `some_tenant`, then the client actually subscribes to the topic<br/>`some_tenant/t`. Similarly, if another client B (connected to the same listener<br/>as the client A) sends a message to topic `t`, the message is routed<br/>to all the clients subscribed `some_tenant/t`, so client A will receive the<br/>message, with topic name `t`.<br/><br/>Set to `\"\"` to disable the feature.<br/><br/><br/>Variables in mountpoint string:<br/>  - <code>${clientid}</code>: clientid<br/>  - <code>${username}</code>: username"
          },
          "zone": {
            "default": "default",
            "type": "string",
            "description": "The configuration zone to which the listener belongs.<br/>Clients connected to this listener will inherit zone-settings created under this zone name.<br/><br/>A zone can override the configs under below root names:<br/>- `mqtt`<br/>- `force_shutdown`<br/>- `force_gc`<br/>- `flapping_detect`<br/>- `durable_sessions`"
          },
          "enable_authn": {
            "default": true,
            "type": "string",
            "enum": [
              true,
              false,
              "quick_deny_anonymous"
            ],
            "description": "Set <code>true</code> (default) to enable client authentication on this listener, the authentication<br/>process goes through the configured authentication chain.<br/>When set to <code>false</code>, any client (with or without username/password) is allowed to connect.<br/>When set to <code>quick_deny_anonymous</code>, it behaves like when set to <code>true</code>, but clients will be<br/>denied immediately without going through any authenticators if <code>username</code> is not provided. This is useful to fence off<br/>anonymous clients early."
          },
          "max_conn_rate": {
            "default": "infinity",
            "type": "string",
            "description": "Used to limit the rate at which the current listener accepts connections.<br/><br/>Once the limit is reached, EMQX will pause fetching connections from the Accept queue, thereby delaying or rejecting new connections.<br/><br/>For example:<br/><br/>- `1000/s`: Only accepts 1000 connections per second.<br/>- `1000/10s`: Only accepts 1000 connections every 10 seconds.",
            "example": "1000/s"
          },
          "messages_rate": {
            "type": "string",
            "description": "Used to limit the number of messages a single client can send to EMQX per second.<br/><br/>Once the limit is reached, EMQX will pause reading data from the receive-buffer, thus slowing down or even temporarily hanging the sender.<br/><br/>For example:<br/><br/>- `500/s`: Only 500 messages will be received per second, and the remaining messages will be delayed.<br/>- `500/10s`: Only 500 messages will be received every 10 seconds and the remaining messages will be delayed.",
            "example": "1000/s"
          },
          "bytes_rate": {
            "type": "string",
            "description": "Used to limit the number of bytes a single client can send to EMQX per second.<br/><br/>Once the limit is reached, EMQX will pause reading data from the receive-buffer, thus slowing down or even temporarily hanging the sender.<br/><br/>The unit of the bytes could be: B, KB, MB, GB.<br/><br/>For example:<br/><br/>- `500KB/s`: Only 500 kilobytes per second will be received, and the remaining bytes will be delayed.<br/>- `500MB/10s`: Only 500 megabytes will be received every 10 seconds, and the remaining bytes will be delayed.",
            "example": "100MB/s"
          },
          "access_rules": {
            "default": [
              "allow all"
            ],
            "type": "array",
            "description": "An access rule list consisting of string rules to restrict or allow access from some addresses. The rules that appear earlier in the list are matched first.<br/>The format is `allow | deny <address> | <CIDR> | all`.<br/><br/>For example:<br/><br/>`[\\\"deny 192.168.1.1\\\", \\\"allow 192.168.1.0/24\\\", \\\"deny, all\\\"]`",
            "items": {
              "type": "string"
            }
          },
          "proxy_protocol": {
            "default": false,
            "type": "boolean",
            "description": "Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.<br/><br/>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "type": "string",
            "description": "If a reverse proxy is deployed for EMQX, and the PROXY protocol is enabled at the proxy to pass the client's real IP, this option needs to be turned on so that EMQX can extract the client's real IP from the PROXY protocol header.<br/><br/>EMQX will automatically detect the version of the PROXY protocol and support V1 and V2.<br/><br/>For a detailed description of the PROXY protocol, please refer to: https://www.haproxy.com/blog/haproxy/proxy-protocol/",
            "example": "12m"
          },
          "tcp_options": {
            "$ref": "#/components/schemas/emqx.tcp_opts"
          },
          "websocket": {
            "$ref": "#/components/schemas/emqx.ws_opts"
          }
        },
        "type": "object"
      },
      "authz.redis_sentinel": {
        "required": [
          "cmd",
          "sentinel",
          "servers",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "redis"
            ],
            "description": "Backend type."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Set to <code>true</code> or <code>false</code> to disable this ACL provider"
          },
          "servers": {
            "type": "string",
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The Redis default port 6379 is used if `[:Port]` is not specified."
          },
          "redis_type": {
            "default": "sentinel",
            "type": "string",
            "enum": [
              "sentinel"
            ],
            "description": "Sentinel mode. Must be set to 'sentinel' when Redis server is running in sentinel mode."
          },
          "sentinel": {
            "type": "string",
            "description": "The cluster name in Redis sentinel mode."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "database": {
            "default": 0,
            "type": "integer",
            "description": "Redis database ID.",
            "minimum": 0
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "cmd": {
            "type": "string",
            "description": "Database query used to retrieve authorization data.",
            "example": "HGETALL mqtt_authz"
          }
        },
        "type": "object"
      },
      "bridge_http.v1_resource_opts": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "maximum": 1024,
            "type": "integer",
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 1
          },
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "start_after_created": {
            "default": true,
            "type": "boolean",
            "description": "Whether start the resource right after created."
          },
          "start_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "example": "32s"
          },
          "auto_restart_interval": {
            "default": "15s",
            "deprecated": true,
            "oneOf": [
              {
                "type": "string",
                "example": "32s"
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "query_mode": {
            "default": "async",
            "type": "string",
            "enum": [
              "sync",
              "async"
            ],
            "description": "Query mode. Optional 'sync/async', default 'async'."
          },
          "request_ttl": {
            "default": "45s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "string",
                "example": "32s"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "type": "integer",
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1
          },
          "enable_queue": {
            "default": false,
            "type": "boolean",
            "deprecated": true,
            "description": "Enable disk buffer queue (only applicable for egress bridges).<br/>When Enabled, messages will be buffered on disk when the bridge connection is down.<br/>When disabled the messages are buffered in RAM only."
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "type": "string",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB"
          }
        },
        "type": "object"
      },
      "exhook.server_config": {
        "required": [
          "name",
          "url"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the exhook server",
            "example": "default"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable this Exhook server"
          },
          "url": {
            "type": "string",
            "description": "URL of the gRPC server",
            "example": "http://127.0.0.1:9000"
          },
          "request_timeout": {
            "default": "5s",
            "type": "string",
            "description": "The timeout of request gRPC server",
            "example": "12m"
          },
          "failed_action": {
            "default": "deny",
            "type": "string",
            "enum": [
              "deny",
              "ignore"
            ],
            "description": "The value that is returned when the request to the gRPC server fails for any reason"
          },
          "ssl": {
            "$ref": "#/components/schemas/exhook.ssl_conf"
          },
          "socket_options": {
            "default": {
              "keepalive": true,
              "nodelay": true
            },
            "$ref": "#/components/schemas/exhook.socket_options"
          },
          "auto_reconnect": {
            "default": "60s",
            "description": "Whether to automatically reconnect (initialize) the gRPC server.<br/>When gRPC is not available, Exhook tries to request the gRPC service at that interval and reinitialize the list of mounted hooks.",
            "oneOf": [
              {
                "type": "string",
                "example": "12m"
              },
              {
                "type": "string",
                "enum": [
                  false
                ]
              }
            ]
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "The process pool size for gRPC client",
            "minimum": 1
          }
        },
        "type": "object"
      },
      "listeners.with_name_ssl_required_bind": {
        "required": [
          "bind",
          "name",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "ssl"
            ],
            "description": "Listener type"
          },
          "running": {
            "type": "boolean",
            "description": "Listener status"
          },
          "name": {
            "type": "string",
            "description": "Listener name"
          },
          "current_connections": {
            "type": "integer",
            "description": "Current connections",
            "minimum": 0
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable listener."
          },
          "bind": {
            "default": 8883,
            "type": "string",
            "description": "IP address and port for the listening socket.",
            "example": "127.0.0.1:80"
          },
          "acceptors": {
            "default": 16,
            "type": "integer",
            "description": "The size of the listener's receiving pool.",
            "minimum": 1
          },
          "max_connections": {
            "default": "infinity",
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "type": "string",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message<br/>is delivered to the subscriber. The mountpoint is a way that users can use<br/>to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`<br/>set to `some_tenant`, then the client actually subscribes to the topic<br/>`some_tenant/t`. Similarly, if another client B (connected to the same listener<br/>as the client A) sends a message to topic `t`, the message is routed<br/>to all the clients subscribed `some_tenant/t`, so client A will receive the<br/>message, with topic name `t`.<br/><br/>Set to `\"\"` to disable the feature.<br/><br/><br/>Variables in mountpoint string:<br/>  - <code>${clientid}</code>: clientid<br/>  - <code>${username}</code>: username"
          },
          "zone": {
            "default": "default",
            "type": "string",
            "description": "The configuration zone to which the listener belongs.<br/>Clients connected to this listener will inherit zone-settings created under this zone name.<br/><br/>A zone can override the configs under below root names:<br/>- `mqtt`<br/>- `force_shutdown`<br/>- `force_gc`<br/>- `flapping_detect`<br/>- `durable_sessions`"
          },
          "enable_authn": {
            "default": true,
            "type": "string",
            "enum": [
              true,
              false,
              "quick_deny_anonymous"
            ],
            "description": "Set <code>true</code> (default) to enable client authentication on this listener, the authentication<br/>process goes through the configured authentication chain.<br/>When set to <code>false</code>, any client (with or without username/password) is allowed to connect.<br/>When set to <code>quick_deny_anonymous</code>, it behaves like when set to <code>true</code>, but clients will be<br/>denied immediately without going through any authenticators if <code>username</code> is not provided. This is useful to fence off<br/>anonymous clients early."
          },
          "max_conn_rate": {
            "default": "infinity",
            "type": "string",
            "description": "Used to limit the rate at which the current listener accepts connections.<br/><br/>Once the limit is reached, EMQX will pause fetching connections from the Accept queue, thereby delaying or rejecting new connections.<br/><br/>For example:<br/><br/>- `1000/s`: Only accepts 1000 connections per second.<br/>- `1000/10s`: Only accepts 1000 connections every 10 seconds.",
            "example": "1000/s"
          },
          "messages_rate": {
            "type": "string",
            "description": "Used to limit the number of messages a single client can send to EMQX per second.<br/><br/>Once the limit is reached, EMQX will pause reading data from the receive-buffer, thus slowing down or even temporarily hanging the sender.<br/><br/>For example:<br/><br/>- `500/s`: Only 500 messages will be received per second, and the remaining messages will be delayed.<br/>- `500/10s`: Only 500 messages will be received every 10 seconds and the remaining messages will be delayed.",
            "example": "1000/s"
          },
          "bytes_rate": {
            "type": "string",
            "description": "Used to limit the number of bytes a single client can send to EMQX per second.<br/><br/>Once the limit is reached, EMQX will pause reading data from the receive-buffer, thus slowing down or even temporarily hanging the sender.<br/><br/>The unit of the bytes could be: B, KB, MB, GB.<br/><br/>For example:<br/><br/>- `500KB/s`: Only 500 kilobytes per second will be received, and the remaining bytes will be delayed.<br/>- `500MB/10s`: Only 500 megabytes will be received every 10 seconds, and the remaining bytes will be delayed.",
            "example": "100MB/s"
          },
          "access_rules": {
            "default": [
              "allow all"
            ],
            "type": "array",
            "description": "An access rule list consisting of string rules to restrict or allow access from some addresses. The rules that appear earlier in the list are matched first.<br/>The format is `allow | deny <address> | <CIDR> | all`.<br/><br/>For example:<br/><br/>`[\\\"deny 192.168.1.1\\\", \\\"allow 192.168.1.0/24\\\", \\\"deny, all\\\"]`",
            "items": {
              "type": "string"
            }
          },
          "proxy_protocol": {
            "default": false,
            "type": "boolean",
            "description": "Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.<br/><br/>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "type": "string",
            "description": "If a reverse proxy is deployed for EMQX, and the PROXY protocol is enabled at the proxy to pass the client's real IP, this option needs to be turned on so that EMQX can extract the client's real IP from the PROXY protocol header.<br/><br/>EMQX will automatically detect the version of the PROXY protocol and support V1 and V2.<br/><br/>For a detailed description of the PROXY protocol, please refer to: https://www.haproxy.com/blog/haproxy/proxy-protocol/",
            "example": "12m"
          },
          "tcp_options": {
            "$ref": "#/components/schemas/emqx.tcp_opts"
          },
          "ssl_options": {
            "$ref": "#/components/schemas/emqx.listener_ssl_opts"
          }
        },
        "type": "object"
      },
      "gateway.clientinfo_override": {
        "properties": {
          "username": {
            "type": "string",
            "description": "Template for overriding username."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "Template for overriding password."
          },
          "clientid": {
            "type": "string",
            "description": "Template for overriding clientid."
          }
        },
        "type": "object"
      },
      "authn.scram": {
        "required": [
          "backend",
          "mechanism"
        ],
        "properties": {
          "mechanism": {
            "type": "string",
            "enum": [
              "scram"
            ],
            "description": "Authentication mechanism."
          },
          "backend": {
            "type": "string",
            "enum": [
              "built_in_database"
            ],
            "description": "Backend type."
          },
          "algorithm": {
            "default": "sha256",
            "type": "string",
            "enum": [
              "sha256",
              "sha512"
            ],
            "description": "Hashing algorithm."
          },
          "iteration_count": {
            "default": 4096,
            "type": "integer",
            "description": "Iteration count.",
            "minimum": 0
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider."
          }
        },
        "type": "object"
      },
      "rule_engine.ctx_message_transformation_failed": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "type": "string",
            "enum": [
              "message_transformation_failed"
            ],
            "description": "Event Type"
          },
          "transformation": {
            "type": "string",
            "description": "Transformation"
          },
          "clientid": {
            "type": "string",
            "description": "The Client ID"
          },
          "username": {
            "type": "string",
            "description": "Username"
          },
          "payload": {
            "type": "string",
            "description": "The Message Payload"
          },
          "peerhost": {
            "type": "string",
            "description": "The IP Address of the Peer Client"
          },
          "topic": {
            "type": "string",
            "description": "Message Topic"
          },
          "publish_received_at": {
            "type": "integer",
            "description": "The Time that this Message is Received"
          },
          "qos": {
            "maximum": 2,
            "type": "integer",
            "description": "The Message QoS",
            "minimum": 0,
            "example": 0
          }
        },
        "type": "object"
      },
      "exhook.socket_options": {
        "properties": {
          "keepalive": {
            "default": true,
            "type": "boolean",
            "description": "Enables/disables periodic transmission on a connected socket when no other data is exchanged.<br/>If the other end does not respond, the connection is considered broken and an error message is sent to the controlling process."
          },
          "nodelay": {
            "default": true,
            "type": "boolean",
            "description": "If true, option TCP_NODELAY is turned on for the socket,<br/>which means that also small amounts of data are sent immediately"
          },
          "recbuf": {
            "type": "string",
            "description": "The minimum size of receive buffer to use for the socket",
            "example": "64KB"
          },
          "sndbuf": {
            "type": "string",
            "description": "The minimum size of send buffer to use for the socket",
            "example": "16KB"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_clients.keepalive": {
        "properties": {
          "interval": {
            "maximum": 65535,
            "type": "integer",
            "description": "Keepalive time, with the unit of second",
            "minimum": 0
          }
        },
        "type": "object"
      },
      "listeners.status": {
        "required": [
          "running"
        ],
        "properties": {
          "running": {
            "description": "Listener running status",
            "oneOf": [
              {
                "type": "boolean"
              },
              {
                "type": "string",
                "enum": [
                  "inconsistent"
                ]
              }
            ]
          },
          "max_connections": {
            "description": "Max connections",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "current_connections": {
            "type": "integer",
            "description": "Current connections",
            "minimum": 0
          }
        },
        "type": "object"
      },
      "listeners.ws_not_required_bind": {
        "required": [
          "id",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "ws"
            ],
            "description": "Listener type"
          },
          "running": {
            "type": "boolean",
            "description": "Listener status"
          },
          "id": {
            "type": "string",
            "description": "Listener id"
          },
          "current_connections": {
            "type": "integer",
            "description": "Current connections",
            "minimum": 0
          },
          "bind": {
            "default": 8083,
            "type": "string",
            "description": "IP address and port for the listening socket.",
            "example": "127.0.0.1:80"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable listener."
          },
          "acceptors": {
            "default": 16,
            "type": "integer",
            "description": "The size of the listener's receiving pool.",
            "minimum": 1
          },
          "max_connections": {
            "default": "infinity",
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "type": "string",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message<br/>is delivered to the subscriber. The mountpoint is a way that users can use<br/>to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`<br/>set to `some_tenant`, then the client actually subscribes to the topic<br/>`some_tenant/t`. Similarly, if another client B (connected to the same listener<br/>as the client A) sends a message to topic `t`, the message is routed<br/>to all the clients subscribed `some_tenant/t`, so client A will receive the<br/>message, with topic name `t`.<br/><br/>Set to `\"\"` to disable the feature.<br/><br/><br/>Variables in mountpoint string:<br/>  - <code>${clientid}</code>: clientid<br/>  - <code>${username}</code>: username"
          },
          "zone": {
            "default": "default",
            "type": "string",
            "description": "The configuration zone to which the listener belongs.<br/>Clients connected to this listener will inherit zone-settings created under this zone name.<br/><br/>A zone can override the configs under below root names:<br/>- `mqtt`<br/>- `force_shutdown`<br/>- `force_gc`<br/>- `flapping_detect`<br/>- `durable_sessions`"
          },
          "enable_authn": {
            "default": true,
            "type": "string",
            "enum": [
              true,
              false,
              "quick_deny_anonymous"
            ],
            "description": "Set <code>true</code> (default) to enable client authentication on this listener, the authentication<br/>process goes through the configured authentication chain.<br/>When set to <code>false</code>, any client (with or without username/password) is allowed to connect.<br/>When set to <code>quick_deny_anonymous</code>, it behaves like when set to <code>true</code>, but clients will be<br/>denied immediately without going through any authenticators if <code>username</code> is not provided. This is useful to fence off<br/>anonymous clients early."
          },
          "max_conn_rate": {
            "default": "infinity",
            "type": "string",
            "description": "Used to limit the rate at which the current listener accepts connections.<br/><br/>Once the limit is reached, EMQX will pause fetching connections from the Accept queue, thereby delaying or rejecting new connections.<br/><br/>For example:<br/><br/>- `1000/s`: Only accepts 1000 connections per second.<br/>- `1000/10s`: Only accepts 1000 connections every 10 seconds.",
            "example": "1000/s"
          },
          "messages_rate": {
            "type": "string",
            "description": "Used to limit the number of messages a single client can send to EMQX per second.<br/><br/>Once the limit is reached, EMQX will pause reading data from the receive-buffer, thus slowing down or even temporarily hanging the sender.<br/><br/>For example:<br/><br/>- `500/s`: Only 500 messages will be received per second, and the remaining messages will be delayed.<br/>- `500/10s`: Only 500 messages will be received every 10 seconds and the remaining messages will be delayed.",
            "example": "1000/s"
          },
          "bytes_rate": {
            "type": "string",
            "description": "Used to limit the number of bytes a single client can send to EMQX per second.<br/><br/>Once the limit is reached, EMQX will pause reading data from the receive-buffer, thus slowing down or even temporarily hanging the sender.<br/><br/>The unit of the bytes could be: B, KB, MB, GB.<br/><br/>For example:<br/><br/>- `500KB/s`: Only 500 kilobytes per second will be received, and the remaining bytes will be delayed.<br/>- `500MB/10s`: Only 500 megabytes will be received every 10 seconds, and the remaining bytes will be delayed.",
            "example": "100MB/s"
          },
          "access_rules": {
            "default": [
              "allow all"
            ],
            "type": "array",
            "description": "An access rule list consisting of string rules to restrict or allow access from some addresses. The rules that appear earlier in the list are matched first.<br/>The format is `allow | deny <address> | <CIDR> | all`.<br/><br/>For example:<br/><br/>`[\\\"deny 192.168.1.1\\\", \\\"allow 192.168.1.0/24\\\", \\\"deny, all\\\"]`",
            "items": {
              "type": "string"
            }
          },
          "proxy_protocol": {
            "default": false,
            "type": "boolean",
            "description": "Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.<br/><br/>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "type": "string",
            "description": "If a reverse proxy is deployed for EMQX, and the PROXY protocol is enabled at the proxy to pass the client's real IP, this option needs to be turned on so that EMQX can extract the client's real IP from the PROXY protocol header.<br/><br/>EMQX will automatically detect the version of the PROXY protocol and support V1 and V2.<br/><br/>For a detailed description of the PROXY protocol, please refer to: https://www.haproxy.com/blog/haproxy/proxy-protocol/",
            "example": "12m"
          },
          "tcp_options": {
            "$ref": "#/components/schemas/emqx.tcp_opts"
          },
          "websocket": {
            "$ref": "#/components/schemas/emqx.ws_opts"
          }
        },
        "type": "object"
      },
      "authn.node_resource_metrics": {
        "properties": {
          "node": {
            "type": "string",
            "description": "Node name.",
            "example": "emqx@127.0.0.1"
          },
          "metrics": {
            "description": "The metrics of the resource.",
            "$ref": "#/components/schemas/authn.resource_metrics"
          }
        },
        "type": "object"
      },
      "emqx_authn_api.request_user_update": {
        "required": [
          "password"
        ],
        "properties": {
          "password": {
            "type": "string"
          },
          "is_superuser": {
            "default": false,
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api_clients.subscription": {
        "properties": {
          "topic": {
            "type": "string",
            "description": "Topic Filter/Name"
          },
          "qos": {
            "type": "integer",
            "description": "QoS level, enum: 0, 1, 2"
          },
          "nl": {
            "type": "integer",
            "description": "No Local option, enum: 0, 1"
          },
          "rap": {
            "type": "integer",
            "description": "Retain as Published option, enum: 0, 1"
          },
          "rh": {
            "type": "integer",
            "description": "Retain Handling option, enum: 0, 1, 2"
          },
          "sub_props": {
            "description": "Subscription properties",
            "$ref": "#/components/schemas/emqx_gateway_api_clients.extra_sub_props"
          }
        },
        "type": "object"
      },
      "authn.jwt_jwks": {
        "required": [
          "endpoint",
          "mechanism",
          "use_jwks"
        ],
        "properties": {
          "use_jwks": {
            "type": "string",
            "enum": [
              true
            ],
            "description": "Whether to use JWKS."
          },
          "endpoint": {
            "type": "string",
            "description": "JWKS endpoint, it's a read-only endpoint that returns the server's public key set in the JWKS format."
          },
          "headers": {
            "default": {
              "Accept": "application/json"
            },
            "type": "object",
            "description": "List of HTTP headers to send with the JWKS request.",
            "example": {}
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "refresh_interval": {
            "default": 300,
            "type": "integer",
            "description": "JWKS refresh interval."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL options.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "mechanism": {
            "type": "string",
            "enum": [
              "jwt"
            ],
            "description": "Authentication mechanism."
          },
          "acl_claim_name": {
            "default": "acl",
            "type": "string",
            "description": "The JWT claim designated for accessing ACL (Access Control List) rules can be specified,<br/>such as using the `acl` claim. A typical decoded JWT with this claim might appear as:<br/>`{\"username\": \"user1\", \"acl\": ...}`.<br/><br/>Supported ACL Rule Formats:<br/><br/>- Object Format:<br/>  Utilizes action types pub (publish), sub (subscribe), or all (both publish and subscribe).<br/>  The value is a list of topic filters.<br/>  Example: `{\"pub\": [\"topic1\"], \"sub\": [], \"all\": [\"${username}/#\"]}`.<br/>  This example signifies that the token owner can publish to topic1 and perform both publish and subscribe<br/>  actions on topics starting with their username.<br/>  Note: In this format, if no topic matches, the action is denied, and the authorization process terminates.<br/><br/>- Array Format (resembles File-Based ACL Rules):<br/>  Example: `[{\"permission\": \"allow\", \"action\": \"all\", \"topic\": \"${username}/#\"}]`.<br/>  Additionally, the `pub` or `publish` action rules can be extended with `qos` and `retain` field,<br/>  and `sub` or `subscribe` action rules can be extended with a `qos` field.<br/>  Note: Here, if no rule matches, the action is not immediately denied.<br/>  The process continues to other configured authorization sources,<br/>  and ultimately falls back to the default permission in config `authorization.no_match`.<br/><br/>The ACL claim utilizes MQTT topic wildcard matching rules for publishing or subscribing.<br/>A special syntax for the 'subscribe' action allows the use of `eq` for an exact match.<br/>For instance, `eq t/#` permits or denies subscription to `t/#`, but not to `t/1`."
          },
          "verify_claims": {
            "default": {},
            "type": "object",
            "description": "A list of custom claims to validate. The allowed formats are the following:<br/>A map where claim names are map keys and expected values are map values:<br/> <code>{ claim_name = \"${username}\", ...}</code>.<br/><br/>A list of maps with <code>name</code> (claim name) and <code>value</code> (expected claim value) keys:<br/> <code>[{name = \"claim_name\", value = \"${username}\"}, ...]</code>.<br/><br/>Values can use the following placeholders:<br/>- <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting<br/>- <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting<br/><br/>Authentication will verify that the value of claims in the JWT (taken from the Password field) matches what is required in <code>verify_claims</code>.",
            "example": {}
          },
          "disconnect_after_expire": {
            "default": true,
            "type": "boolean",
            "description": "Disconnect the client after the token expires."
          },
          "from": {
            "default": "password",
            "type": "string",
            "enum": [
              "username",
              "password"
            ],
            "description": "Field to take JWT from."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider."
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.ssl_listener": {
        "properties": {
          "id": {
            "type": "string",
            "description": "Listener ID"
          },
          "type": {
            "type": "string",
            "enum": [
              "ssl"
            ],
            "description": "Listener Type"
          },
          "name": {
            "type": "string",
            "description": "Listener Name"
          },
          "running": {
            "type": "boolean",
            "description": "Listener Running status"
          },
          "acceptors": {
            "default": 16,
            "type": "integer",
            "description": "Size of the acceptor pool."
          },
          "tcp_options": {
            "description": "Setting the TCP socket options.",
            "$ref": "#/components/schemas/emqx.tcp_opts"
          },
          "proxy_protocol": {
            "default": false,
            "type": "boolean",
            "description": "If a reverse proxy is deployed for EMQX, and the PROXY protocol is enabled at the proxy to pass the client's real IP,<br/>this option needs to be turned on so that EMQX can extract the client's real IP from the PROXY protocol header.<br/>EMQX will automatically detect the version of the PROXY protocol and support V1 and V2.<br/><br/>For a detailed description of the PROXY protocol, please refer to: https://www.haproxy.com/blog/haproxy/proxy-protocol/"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "type": "string",
            "description": "Timeout for proxy protocol.<br/>EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.",
            "example": "12m"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable the listener."
          },
          "bind": {
            "type": "string",
            "description": "The IP address and port that the listener will bind.",
            "example": "127.0.0.1:80"
          },
          "max_connections": {
            "default": 1024,
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "integer",
                "minimum": 1
              }
            ]
          },
          "max_conn_rate": {
            "default": 1000,
            "type": "integer",
            "description": "Maximum connections per second."
          },
          "enable_authn": {
            "default": true,
            "type": "boolean",
            "description": "Set <code>true</code> (default) to enable client authentication on this listener.<br/>When set to <code>false</code> clients will be allowed to connect without authentication."
          },
          "mountpoint": {
            "type": "string",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message is delivered to the subscriber.<br/>The mountpoint is a way that users can use to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,<br/>then the client actually subscribes to the topic `some_tenant/t`.<br/>Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,<br/>the message is routed to all the clients subscribed `some_tenant/t`,<br/>so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.<br/>Supported placeholders in mountpoint string:<br/><br/>  - <code>${clientid}</code>: clientid<br/><br/>  - <code>${username}</code>: username<br/><br/>  - <code>${endpoint_name}</code>: endpoint name"
          },
          "access_rules": {
            "default": [],
            "type": "array",
            "description": "An access rule list consisting of string rules to restrict or allow access from some addresses.<br/>The rules that appear earlier in the list are matched first.<br/>The format is `allow | deny <address> | <CIDR> | all`.<br/><br/>For example:<br/><br/>`[\\\"deny 192.168.1.1\\\", \\\"allow 192.168.1.0/24\\\", \\\"deny, all\\\"]`",
            "items": {
              "type": "string"
            }
          },
          "ssl_options": {
            "description": "SSL Socket options.",
            "$ref": "#/components/schemas/emqx.listener_ssl_opts"
          }
        },
        "type": "object"
      },
      "authn.mongo_sharded": {
        "required": [
          "backend",
          "collection",
          "database",
          "mechanism",
          "mongo_type",
          "servers"
        ],
        "properties": {
          "mechanism": {
            "type": "string",
            "enum": [
              "password_based"
            ],
            "description": "Authentication mechanism."
          },
          "backend": {
            "type": "string",
            "enum": [
              "mongodb"
            ],
            "description": "Backend type."
          },
          "collection": {
            "type": "string",
            "description": "Collection used to store authentication data."
          },
          "filter": {
            "default": {},
            "type": "object",
            "description": "Conditional expression that defines the filter condition in the query.<br/>Filter supports the following placeholders:<br/>- <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting<br/>- <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting",
            "example": {}
          },
          "password_hash_field": {
            "default": "password_hash",
            "type": "string",
            "description": "Document field that contains password hash."
          },
          "salt_field": {
            "default": "salt",
            "type": "string",
            "description": "Document field that contains the password salt."
          },
          "is_superuser_field": {
            "default": "is_superuser",
            "type": "string",
            "description": "Document field that defines if the user has superuser privileges."
          },
          "password_hash_algorithm": {
            "default": {
              "name": "sha256",
              "salt_position": "prefix"
            },
            "description": "Options for password hash verification.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn_hash.simple"
              },
              {
                "$ref": "#/components/schemas/authn_hash.pbkdf2"
              },
              {
                "$ref": "#/components/schemas/authn_hash.bcrypt"
              }
            ]
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider."
          },
          "mongo_type": {
            "default": "sharded",
            "type": "string",
            "enum": [
              "sharded"
            ],
            "description": "Sharded cluster. Must be set to 'sharded' when MongoDB server is running in 'sharded' mode."
          },
          "servers": {
            "type": "string",
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The MongoDB default port 27017 is used if `[:Port]` is not specified."
          },
          "w_mode": {
            "default": "unsafe",
            "type": "string",
            "enum": [
              "unsafe",
              "safe"
            ],
            "description": "Write mode."
          },
          "srv_record": {
            "default": false,
            "type": "boolean",
            "description": "Use DNS SRV record."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "use_legacy_protocol": {
            "default": "auto",
            "type": "string",
            "enum": [
              "auto",
              true,
              false
            ],
            "description": "Whether to use MongoDB's legacy protocol for communicating with the database.  The default is to attempt to automatically determine if the newer protocol is supported."
          },
          "auth_source": {
            "type": "string",
            "description": "Database name associated with the user's credentials."
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "topology": {
            "$ref": "#/components/schemas/mongo.topology"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "authz.api_file": {
        "required": [
          "rules",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "file"
            ],
            "description": "Backend type."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Set to <code>true</code> or <code>false</code> to disable this ACL provider"
          },
          "rules": {
            "type": "string",
            "example": "{allow,{username,{re,\"^dashboard$\"}},subscribe,[\"$SYS/#\"]}.\n{allow,{ipaddr,\"127.0.0.1\"},all,[\"$SYS/#\",\"#\"]}."
          }
        },
        "type": "object"
      },
      "relup.upgrade_error": {
        "properties": {
          "err_type": {
            "type": "string",
            "description": "The type of the error",
            "example": "no_write_permission"
          },
          "details": {
            "type": "object",
            "description": "The details of the error",
            "example": {
              "msg": "no write permission in dir 'emqx/relup'",
              "dir": "emqx/relup"
            }
          }
        },
        "type": "object"
      },
      "connector_mqtt.egress_remote": {
        "required": [
          "topic"
        ],
        "properties": {
          "topic": {
            "type": "string",
            "description": "Forward to which topic of the remote broker.<br/><br/>Template with variables is allowed."
          },
          "qos": {
            "default": 1,
            "description": "The QoS of the MQTT message to be sent.<br/><br/>Template with variables is allowed.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "maximum": 2,
                "type": "integer",
                "minimum": 0,
                "example": 0
              }
            ]
          },
          "retain": {
            "default": false,
            "description": "The 'retain' flag of the MQTT message to be sent.<br/><br/>Template with variables is allowed.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "boolean"
              }
            ]
          },
          "payload": {
            "type": "string",
            "description": "The payload of the MQTT message to be sent.<br/><br/>Template with variables is allowed."
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_clients.inflight_messages": {
        "properties": {
          "data": {
            "type": "array",
            "description": "Client's in-flight messages list.<br/>Messages are sorted by time at which they were inserted to the In-flight storage (from older to newer messages).",
            "items": {
              "$ref": "#/components/schemas/emqx_mgmt_api_clients.message"
            }
          },
          "meta": {
            "$ref": "#/components/schemas/public.continuation_meta"
          }
        },
        "type": "object"
      },
      "retainer.mnesia_config": {
        "properties": {
          "type": {
            "default": "built_in_database",
            "type": "string",
            "enum": [
              "built_in_database"
            ],
            "description": "Backend type."
          },
          "storage_type": {
            "default": "ram",
            "type": "string",
            "enum": [
              "ram",
              "disc"
            ],
            "description": "Specifies whether the messages are stored in RAM or persisted on disc."
          },
          "max_retained_messages": {
            "default": 0,
            "type": "integer",
            "description": "Maximum number of retained messages. 0 means no limit.",
            "minimum": 0
          },
          "index_specs": {
            "default": [
              [
                1,
                2,
                3
              ],
              [
                1,
                3
              ],
              [
                2,
                3
              ],
              [
                3
              ]
            ],
            "type": "array",
            "description": "Retainer index specifications: list of arrays of positive ascending integers. Each array specifies an index. Numbers in an index specification are 1-based word positions in topics. Words from specified positions will be used for indexing.<br/>For example, it is good to have <code>[2, 4]</code> index to optimize <code>+/X/+/Y/...</code> topic wildcard subscriptions.",
            "items": {
              "type": "integer"
            },
            "example": [
              [
                2,
                4
              ],
              [
                1,
                3
              ]
            ]
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable built-in Mnesia backend."
          }
        },
        "type": "object"
      },
      "emqx.ws_opts": {
        "properties": {
          "mqtt_path": {
            "default": "/mqtt",
            "type": "string",
            "description": "WebSocket's MQTT protocol path. By default, the full URL for the WebSocket client to connect is:<br/>`ws://{host}:{port}/mqtt`.<br/>Append `/[...]` to the end of the path to make EMQX accept any subpath.<br/>For example, specifying `mqtt/[...]` would allow clients to connect at paths like<br/>`mqtt/org1` or `mqtt/group2`, etc.<br/><br/>NOTE: An unmatched path will cause the client to be rejected immediately at the HTTP layer,<br/>meaning it will not be traceable at the MQTT layer."
          },
          "mqtt_piggyback": {
            "default": "multiple",
            "type": "string",
            "enum": [
              "single",
              "multiple"
            ],
            "description": "Whether a WebSocket message is allowed to contain multiple MQTT packets."
          },
          "compress": {
            "default": false,
            "type": "boolean",
            "description": "If <code>true</code>, compress WebSocket messages using <code>zlib</code>.<br/><br/>The configuration items under <code>deflate_opts</code> belong to the compression-related parameter configuration."
          },
          "idle_timeout": {
            "default": "7200s",
            "type": "string",
            "description": "The timeout for waiting for the WebSocket upgrade request. After the timeout, the connection will be closed.",
            "example": "12m"
          },
          "max_frame_size": {
            "default": "infinity",
            "description": "The maximum length of a single MQTT packet.",
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "fail_if_no_subprotocol": {
            "default": true,
            "type": "boolean",
            "description": "If <code>true</code>, the server will return an error when<br/> the client does not carry the <code>Sec-WebSocket-Protocol</code> field.<br/> <br/>Note: WeChat applet needs to disable this verification."
          },
          "supported_subprotocols": {
            "default": "mqtt, mqtt-v3, mqtt-v3.1.1, mqtt-v5",
            "type": "string",
            "description": "Comma-separated list of supported subprotocols.",
            "example": "item1,item2"
          },
          "check_origin_enable": {
            "default": false,
            "type": "boolean",
            "description": "If <code>true</code>, <code>origin</code> HTTP header will be<br/> validated against the list of allowed origins configured in <code>check_origins</code><br/> parameter."
          },
          "allow_origin_absence": {
            "default": true,
            "type": "boolean",
            "description": "If <code>false</code> and <code>check_origin_enable</code> is<br/> <code>true</code>, the server will reject requests that don't have <code>origin</code><br/> HTTP header."
          },
          "check_origins": {
            "default": "http://localhost:18083, http://127.0.0.1:18083",
            "type": "string",
            "description": "List of allowed origins.<br/>See <code>check_origin_enable</code>.",
            "example": "item1,item2"
          },
          "proxy_address_header": {
            "default": "x-forwarded-for",
            "type": "string",
            "description": "The HTTP request header that carries the original client's IP address, EMQX will take the leftmost IP in the header as the original client's IP.<br/><br/>This option is typically used when EMQX is deployed behind a WebSocket proxy."
          },
          "proxy_port_header": {
            "default": "x-forwarded-port",
            "type": "string",
            "description": "The HTTP request header that carries the original client's source port, EMQX will take the leftmost port in the header as the original client's source port.<br/><br/>This option is typically used when EMQX is deployed behind a WebSocket proxy."
          },
          "deflate_opts": {
            "$ref": "#/components/schemas/emqx.deflate_opts"
          },
          "validate_utf8": {
            "default": true,
            "type": "boolean",
            "description": "Whether to verify that the payload of `text` and `close` frames is valid UTF-8. Disabling it can save resources and improve performance."
          }
        },
        "type": "object"
      },
      "listeners.with_name_tcp_required_bind": {
        "required": [
          "bind",
          "name",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "tcp"
            ],
            "description": "Listener type"
          },
          "running": {
            "type": "boolean",
            "description": "Listener status"
          },
          "name": {
            "type": "string",
            "description": "Listener name"
          },
          "current_connections": {
            "type": "integer",
            "description": "Current connections",
            "minimum": 0
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable listener."
          },
          "bind": {
            "default": 1883,
            "type": "string",
            "description": "IP address and port for the listening socket.",
            "example": "127.0.0.1:80"
          },
          "acceptors": {
            "default": 16,
            "type": "integer",
            "description": "The size of the listener's receiving pool.",
            "minimum": 1
          },
          "max_connections": {
            "default": "infinity",
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "type": "string",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message<br/>is delivered to the subscriber. The mountpoint is a way that users can use<br/>to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`<br/>set to `some_tenant`, then the client actually subscribes to the topic<br/>`some_tenant/t`. Similarly, if another client B (connected to the same listener<br/>as the client A) sends a message to topic `t`, the message is routed<br/>to all the clients subscribed `some_tenant/t`, so client A will receive the<br/>message, with topic name `t`.<br/><br/>Set to `\"\"` to disable the feature.<br/><br/><br/>Variables in mountpoint string:<br/>  - <code>${clientid}</code>: clientid<br/>  - <code>${username}</code>: username"
          },
          "zone": {
            "default": "default",
            "type": "string",
            "description": "The configuration zone to which the listener belongs.<br/>Clients connected to this listener will inherit zone-settings created under this zone name.<br/><br/>A zone can override the configs under below root names:<br/>- `mqtt`<br/>- `force_shutdown`<br/>- `force_gc`<br/>- `flapping_detect`<br/>- `durable_sessions`"
          },
          "enable_authn": {
            "default": true,
            "type": "string",
            "enum": [
              true,
              false,
              "quick_deny_anonymous"
            ],
            "description": "Set <code>true</code> (default) to enable client authentication on this listener, the authentication<br/>process goes through the configured authentication chain.<br/>When set to <code>false</code>, any client (with or without username/password) is allowed to connect.<br/>When set to <code>quick_deny_anonymous</code>, it behaves like when set to <code>true</code>, but clients will be<br/>denied immediately without going through any authenticators if <code>username</code> is not provided. This is useful to fence off<br/>anonymous clients early."
          },
          "max_conn_rate": {
            "default": "infinity",
            "type": "string",
            "description": "Used to limit the rate at which the current listener accepts connections.<br/><br/>Once the limit is reached, EMQX will pause fetching connections from the Accept queue, thereby delaying or rejecting new connections.<br/><br/>For example:<br/><br/>- `1000/s`: Only accepts 1000 connections per second.<br/>- `1000/10s`: Only accepts 1000 connections every 10 seconds.",
            "example": "1000/s"
          },
          "messages_rate": {
            "type": "string",
            "description": "Used to limit the number of messages a single client can send to EMQX per second.<br/><br/>Once the limit is reached, EMQX will pause reading data from the receive-buffer, thus slowing down or even temporarily hanging the sender.<br/><br/>For example:<br/><br/>- `500/s`: Only 500 messages will be received per second, and the remaining messages will be delayed.<br/>- `500/10s`: Only 500 messages will be received every 10 seconds and the remaining messages will be delayed.",
            "example": "1000/s"
          },
          "bytes_rate": {
            "type": "string",
            "description": "Used to limit the number of bytes a single client can send to EMQX per second.<br/><br/>Once the limit is reached, EMQX will pause reading data from the receive-buffer, thus slowing down or even temporarily hanging the sender.<br/><br/>The unit of the bytes could be: B, KB, MB, GB.<br/><br/>For example:<br/><br/>- `500KB/s`: Only 500 kilobytes per second will be received, and the remaining bytes will be delayed.<br/>- `500MB/10s`: Only 500 megabytes will be received every 10 seconds, and the remaining bytes will be delayed.",
            "example": "100MB/s"
          },
          "access_rules": {
            "default": [
              "allow all"
            ],
            "type": "array",
            "description": "An access rule list consisting of string rules to restrict or allow access from some addresses. The rules that appear earlier in the list are matched first.<br/>The format is `allow | deny <address> | <CIDR> | all`.<br/><br/>For example:<br/><br/>`[\\\"deny 192.168.1.1\\\", \\\"allow 192.168.1.0/24\\\", \\\"deny, all\\\"]`",
            "items": {
              "type": "string"
            }
          },
          "proxy_protocol": {
            "default": false,
            "type": "boolean",
            "description": "Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.<br/><br/>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "type": "string",
            "description": "If a reverse proxy is deployed for EMQX, and the PROXY protocol is enabled at the proxy to pass the client's real IP, this option needs to be turned on so that EMQX can extract the client's real IP from the PROXY protocol header.<br/><br/>EMQX will automatically detect the version of the PROXY protocol and support V1 and V2.<br/><br/>For a detailed description of the PROXY protocol, please refer to: https://www.haproxy.com/blog/haproxy/proxy-protocol/",
            "example": "12m"
          },
          "tcp_options": {
            "$ref": "#/components/schemas/emqx.tcp_opts"
          }
        },
        "type": "object"
      },
      "rule_engine.node_metrics": {
        "properties": {
          "node": {
            "type": "string",
            "description": "The node name",
            "example": "emqx@127.0.0.1"
          },
          "matched": {
            "type": "integer",
            "description": "How many times the FROM clause of the SQL is matched.",
            "minimum": 0
          },
          "matched.rate": {
            "type": "number",
            "description": "The rate of matched, times/second"
          },
          "matched.rate.max": {
            "type": "number",
            "description": "The max rate of matched, times/second"
          },
          "matched.rate.last5m": {
            "type": "number",
            "description": "The average rate of matched in last 5 minutes, times/second"
          },
          "passed": {
            "type": "integer",
            "description": "How many times the SQL is passed",
            "minimum": 0
          },
          "failed": {
            "type": "integer",
            "description": "How many times the SQL statement has failed",
            "minimum": 0
          },
          "failed.exception": {
            "type": "integer",
            "description": "How many times the SQL is failed due to exceptions. This may because of a crash when calling a SQL function, or trying to do arithmetic operation on undefined variables",
            "minimum": 0
          },
          "failed.unknown": {
            "type": "integer",
            "description": "How many times the SQL is failed due to an unknown error.",
            "minimum": 0
          },
          "actions.total": {
            "type": "integer",
            "description": "How many times the actions are called by the rule. This value may several times of 'matched', depending on the number of the actions of the rule.",
            "minimum": 0
          },
          "actions.success": {
            "type": "integer",
            "description": "How many times the rule successided to call the actions.",
            "minimum": 0
          },
          "actions.failed": {
            "type": "integer",
            "description": "How many times the rule failed to call the actions.",
            "minimum": 0
          },
          "actions.failed.out_of_service": {
            "type": "integer",
            "description": "How many times the rule has failed to call actions due to the action is out of service. For example, a bridge is disabled or stopped.",
            "minimum": 0
          },
          "actions.failed.unknown": {
            "type": "integer",
            "description": "The number of action failures that have occurred due to unanticipated reasons. For more information on these errors, please refer to the EMQX log file.",
            "minimum": 0
          }
        },
        "type": "object"
      },
      "emqx.sysmon_vm": {
        "properties": {
          "process_check_interval": {
            "default": "30s",
            "type": "string",
            "description": "The time interval for the periodic process count limit check, used together with `process_high_watermark` and `process_low_watermark`.",
            "example": "12m"
          },
          "process_high_watermark": {
            "default": "80%",
            "type": "string",
            "description": "The threshold, as percentage of processes, for how many<br/> processes can simultaneously exist at the local node before the corresponding<br/> alarm is raised.",
            "example": "12%"
          },
          "process_low_watermark": {
            "default": "60%",
            "type": "string",
            "description": "The threshold, as percentage of processes, for how many<br/> processes can simultaneously exist at the local node before the corresponding<br/> alarm is cleared.",
            "example": "12%"
          },
          "long_gc": {
            "default": "disabled",
            "description": "When an Erlang process spends long time to perform garbage collection, a warning level <code>long_gc</code> log is emitted,<br/>and an MQTT message is published to the system topic <code>$SYS/sysmon/long_gc</code>.",
            "oneOf": [
              {
                "type": "string",
                "example": "12m"
              },
              {
                "type": "string",
                "enum": [
                  "disabled"
                ]
              }
            ]
          },
          "long_schedule": {
            "default": "240ms",
            "description": "When the Erlang VM detect a task scheduled for too long, a warning level 'long_schedule' log is emitted,<br/>and an MQTT message is published to the system topic <code>$SYS/sysmon/long_schedule</code>.",
            "oneOf": [
              {
                "type": "string",
                "example": "12m"
              },
              {
                "type": "string",
                "enum": [
                  "disabled"
                ]
              }
            ]
          },
          "large_heap": {
            "default": "32MB",
            "description": "When the heap memory occupied by a process exceeds the size specified by `large_heap`, the system will write a warning level `large_heap` log, and an MQTT message will be published to the system topic `$SYS/sysmon/large_heap`.",
            "oneOf": [
              {
                "type": "string",
                "example": "32MB"
              },
              {
                "type": "string",
                "enum": [
                  "disabled"
                ]
              }
            ]
          },
          "busy_dist_port": {
            "default": true,
            "type": "boolean",
            "description": "When the RPC connection used to communicate with other nodes in the cluster is overloaded,<br/>there will be a <code>busy_dist_port</code> warning log,<br/>and an MQTT message is published to system topic <code>$SYS/sysmon/busy_dist_port</code>."
          },
          "busy_port": {
            "default": true,
            "type": "boolean",
            "description": "When a port (e.g. TCP socket) is overloaded, there will be a <code>busy_port</code> warning log,<br/>and an MQTT message is published to the system topic <code>$SYS/sysmon/busy_port</code>."
          }
        },
        "type": "object"
      },
      "prometheus.legacy_deprecated_setting": {
        "required": [
          "enable",
          "interval",
          "job_name",
          "mnesia_collector",
          "push_gateway_server",
          "vm_dist_collector",
          "vm_memory_collector",
          "vm_msacc_collector",
          "vm_statistics_collector",
          "vm_system_info_collector"
        ],
        "properties": {
          "push_gateway_server": {
            "default": "http://127.0.0.1:9091",
            "type": "string",
            "description": "Deprecated since 5.4.0, use `prometheus.push_gateway.url` instead"
          },
          "interval": {
            "default": "15s",
            "type": "string",
            "description": "Deprecated since 5.4.0, use `prometheus.push_gateway.interval` instead",
            "example": "32s"
          },
          "headers": {
            "default": {},
            "type": "object",
            "description": "Deprecated since 5.4.0, use `prometheus.push_gateway.headers` instead",
            "example": {}
          },
          "job_name": {
            "default": "${name}/instance/${name}~${host}",
            "type": "string",
            "description": "Deprecated since 5.4.0, use `prometheus.push_gateway.job_name` instead"
          },
          "enable": {
            "default": false,
            "type": "boolean",
            "description": "Deprecated since 5.4.0, use `prometheus.push_gateway.url` instead"
          },
          "vm_dist_collector": {
            "default": "disabled",
            "type": "string",
            "enum": [
              "disabled",
              "enabled"
            ],
            "description": "Deprecated since 5.4.0, use `prometheus.collectors.vm_dist` instead"
          },
          "mnesia_collector": {
            "default": "disabled",
            "type": "string",
            "enum": [
              "enabled",
              "disabled"
            ],
            "description": "Deprecated since 5.4.0, use `prometheus.collectors.mnesia` instead"
          },
          "vm_statistics_collector": {
            "default": "disabled",
            "type": "string",
            "enum": [
              "enabled",
              "disabled"
            ],
            "description": "Deprecated since 5.4.0, use `prometheus.collectors.vm_statistics` instead"
          },
          "vm_system_info_collector": {
            "default": "disabled",
            "type": "string",
            "enum": [
              "enabled",
              "disabled"
            ],
            "description": "Deprecated, use `prometheus.collectors.vm_system_info` instead"
          },
          "vm_memory_collector": {
            "default": "disabled",
            "type": "string",
            "enum": [
              "enabled",
              "disabled"
            ],
            "description": "Deprecated since 5.4.0, use `prometheus.collectors.vm_memory` instead"
          },
          "vm_msacc_collector": {
            "default": "disabled",
            "type": "string",
            "enum": [
              "enabled",
              "disabled"
            ],
            "description": "Deprecated since 5.4.0, use `prometheus.collectors.vm_msacc` instead"
          }
        },
        "type": "object"
      },
      "listeners.tcp_not_required_bind": {
        "required": [
          "id",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "tcp"
            ],
            "description": "Listener type"
          },
          "running": {
            "type": "boolean",
            "description": "Listener status"
          },
          "id": {
            "type": "string",
            "description": "Listener id"
          },
          "current_connections": {
            "type": "integer",
            "description": "Current connections",
            "minimum": 0
          },
          "bind": {
            "default": 1883,
            "type": "string",
            "description": "IP address and port for the listening socket.",
            "example": "127.0.0.1:80"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable listener."
          },
          "acceptors": {
            "default": 16,
            "type": "integer",
            "description": "The size of the listener's receiving pool.",
            "minimum": 1
          },
          "max_connections": {
            "default": "infinity",
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "type": "string",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message<br/>is delivered to the subscriber. The mountpoint is a way that users can use<br/>to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`<br/>set to `some_tenant`, then the client actually subscribes to the topic<br/>`some_tenant/t`. Similarly, if another client B (connected to the same listener<br/>as the client A) sends a message to topic `t`, the message is routed<br/>to all the clients subscribed `some_tenant/t`, so client A will receive the<br/>message, with topic name `t`.<br/><br/>Set to `\"\"` to disable the feature.<br/><br/><br/>Variables in mountpoint string:<br/>  - <code>${clientid}</code>: clientid<br/>  - <code>${username}</code>: username"
          },
          "zone": {
            "default": "default",
            "type": "string",
            "description": "The configuration zone to which the listener belongs.<br/>Clients connected to this listener will inherit zone-settings created under this zone name.<br/><br/>A zone can override the configs under below root names:<br/>- `mqtt`<br/>- `force_shutdown`<br/>- `force_gc`<br/>- `flapping_detect`<br/>- `durable_sessions`"
          },
          "enable_authn": {
            "default": true,
            "type": "string",
            "enum": [
              true,
              false,
              "quick_deny_anonymous"
            ],
            "description": "Set <code>true</code> (default) to enable client authentication on this listener, the authentication<br/>process goes through the configured authentication chain.<br/>When set to <code>false</code>, any client (with or without username/password) is allowed to connect.<br/>When set to <code>quick_deny_anonymous</code>, it behaves like when set to <code>true</code>, but clients will be<br/>denied immediately without going through any authenticators if <code>username</code> is not provided. This is useful to fence off<br/>anonymous clients early."
          },
          "max_conn_rate": {
            "default": "infinity",
            "type": "string",
            "description": "Used to limit the rate at which the current listener accepts connections.<br/><br/>Once the limit is reached, EMQX will pause fetching connections from the Accept queue, thereby delaying or rejecting new connections.<br/><br/>For example:<br/><br/>- `1000/s`: Only accepts 1000 connections per second.<br/>- `1000/10s`: Only accepts 1000 connections every 10 seconds.",
            "example": "1000/s"
          },
          "messages_rate": {
            "type": "string",
            "description": "Used to limit the number of messages a single client can send to EMQX per second.<br/><br/>Once the limit is reached, EMQX will pause reading data from the receive-buffer, thus slowing down or even temporarily hanging the sender.<br/><br/>For example:<br/><br/>- `500/s`: Only 500 messages will be received per second, and the remaining messages will be delayed.<br/>- `500/10s`: Only 500 messages will be received every 10 seconds and the remaining messages will be delayed.",
            "example": "1000/s"
          },
          "bytes_rate": {
            "type": "string",
            "description": "Used to limit the number of bytes a single client can send to EMQX per second.<br/><br/>Once the limit is reached, EMQX will pause reading data from the receive-buffer, thus slowing down or even temporarily hanging the sender.<br/><br/>The unit of the bytes could be: B, KB, MB, GB.<br/><br/>For example:<br/><br/>- `500KB/s`: Only 500 kilobytes per second will be received, and the remaining bytes will be delayed.<br/>- `500MB/10s`: Only 500 megabytes will be received every 10 seconds, and the remaining bytes will be delayed.",
            "example": "100MB/s"
          },
          "access_rules": {
            "default": [
              "allow all"
            ],
            "type": "array",
            "description": "An access rule list consisting of string rules to restrict or allow access from some addresses. The rules that appear earlier in the list are matched first.<br/>The format is `allow | deny <address> | <CIDR> | all`.<br/><br/>For example:<br/><br/>`[\\\"deny 192.168.1.1\\\", \\\"allow 192.168.1.0/24\\\", \\\"deny, all\\\"]`",
            "items": {
              "type": "string"
            }
          },
          "proxy_protocol": {
            "default": false,
            "type": "boolean",
            "description": "Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.<br/><br/>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "type": "string",
            "description": "If a reverse proxy is deployed for EMQX, and the PROXY protocol is enabled at the proxy to pass the client's real IP, this option needs to be turned on so that EMQX can extract the client's real IP from the PROXY protocol header.<br/><br/>EMQX will automatically detect the version of the PROXY protocol and support V1 and V2.<br/><br/>For a detailed description of the PROXY protocol, please refer to: https://www.haproxy.com/blog/haproxy/proxy-protocol/",
            "example": "12m"
          },
          "tcp_options": {
            "$ref": "#/components/schemas/emqx.tcp_opts"
          }
        },
        "type": "object"
      },
      "emqx_authz_schema.node_metrics": {
        "properties": {
          "node": {
            "type": "string",
            "description": "Node name.",
            "example": "emqx@127.0.0.1"
          },
          "metrics": {
            "description": "The metrics of the resource.",
            "$ref": "#/components/schemas/emqx_authz_schema.metrics"
          }
        },
        "type": "object"
      },
      "prometheus.collectors": {
        "required": [
          "mnesia",
          "vm_dist",
          "vm_memory",
          "vm_msacc",
          "vm_statistics",
          "vm_system_info"
        ],
        "properties": {
          "vm_dist": {
            "default": "disabled",
            "type": "string",
            "enum": [
              "disabled",
              "enabled"
            ],
            "description": "Enable or disable VM distribution collector,<br/>collects information about the sockets and processes involved in the Erlang distribution mechanism."
          },
          "mnesia": {
            "default": "disabled",
            "type": "string",
            "enum": [
              "enabled",
              "disabled"
            ],
            "description": "Collects Mnesia metrics mainly using <code> mnesia:system_info/1 </code>"
          },
          "vm_statistics": {
            "default": "disabled",
            "type": "string",
            "enum": [
              "enabled",
              "disabled"
            ],
            "description": "Enable or disable VM statistics collector."
          },
          "vm_system_info": {
            "default": "disabled",
            "type": "string",
            "enum": [
              "enabled",
              "disabled"
            ],
            "description": "Enable or disable VM system info collector."
          },
          "vm_memory": {
            "default": "disabled",
            "type": "string",
            "enum": [
              "enabled",
              "disabled"
            ],
            "description": "Collects information about memory dynamically allocated by the Erlang emulator using<br/><code> erlang:memory/0 </code>."
          },
          "vm_msacc": {
            "default": "disabled",
            "type": "string",
            "enum": [
              "enabled",
              "disabled"
            ],
            "description": "Enable or disable VM microstate accounting metrics collector."
          }
        },
        "type": "object"
      },
      "public.meta": {
        "required": [
          "hasnext"
        ],
        "properties": {
          "page": {
            "default": 1,
            "type": "integer",
            "description": "Page number of the results to fetch.",
            "minimum": 1,
            "example": 1
          },
          "limit": {
            "default": 100,
            "maximum": 10000,
            "type": "integer",
            "description": "Results per page(max 10000)",
            "minimum": 1,
            "example": 50
          },
          "count": {
            "type": "integer",
            "description": "Total number of records matching the query.<br/>Note: this field is present only if the query can be optimized and does not require a full table scan.",
            "minimum": 0
          },
          "hasnext": {
            "type": "boolean",
            "description": "Flag indicating whether there are more results available on next pages."
          }
        },
        "type": "object"
      },
      "connector_mqtt.ingress": {
        "properties": {
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the pool of MQTT clients that will ingest messages from the remote broker.<br/><br/>This value will be respected only if 'remote.topic' is a shared subscription topic or topic-filter<br/>(for example `$share/name1/topic1` or `$share/name2/topic2/#`), otherwise only a single MQTT client will be used.<br/>Each MQTT client will be assigned 'clientid' of the form '${clientid_prefix}:${bridge_name}:ingress:${node}:${n}'<br/>where 'n' is the number of a client inside the pool.<br/>NOTE: Non-shared subscription will not work well when EMQX is clustered.",
            "minimum": 1
          },
          "remote": {
            "description": "The configs about subscribing to the remote broker.",
            "$ref": "#/components/schemas/connector_mqtt.ingress_remote"
          },
          "local": {
            "description": "The configs about sending message to the local broker.",
            "$ref": "#/components/schemas/connector_mqtt.ingress_local"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api_clients.extra_sub_props": {
        "properties": {
          "subid": {
            "type": "string",
            "description": "Only stomp protocol, a unique identity for the subscription. range: 1-65535."
          }
        },
        "type": "object"
      },
      "emqx_telemetry_api.status": {
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable telemetry",
            "example": false
          }
        },
        "type": "object"
      },
      "bridge_http.get_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "http"
            ],
            "description": "The action type."
          },
          "name": {
            "type": "string",
            "description": "Action name, used as a human-readable identifier."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "parameters": {
            "description": "The parameters for HTTP action.",
            "$ref": "#/components/schemas/bridge_http.parameters_opts"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_http.action_resource_opts"
          }
        },
        "type": "object"
      },
      "emqx.force_shutdown": {
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable `force_shutdown` feature."
          },
          "max_mailbox_size": {
            "default": 1000,
            "type": "integer",
            "description": "EMQX creates at least one lightweight process for each client connection.<br/><br/>Each process has its own message queue (aka mailbox) to hold messages from other processes (e.g. MQTT messages) so that the process can read messages from the message queue (mailbox) at any time.<br/><br/>If the system is busy or the process hangs due to a busy socket (see `high_watermark`), the message queue can accumulate many messages.<br/><br/>To avoid excessive memory usage, EMQX will force a process to shut down when the length of its message queue exceeds `max_mailbox_size`.",
            "minimum": 0
          },
          "max_heap_size": {
            "default": "32MB",
            "type": "string",
            "description": "The maximum heap size of the process. If the `force_shutdown` is enabled, processes that exceed this limit will automatically exit or be forcibly killed. Messages in the process message queue (mailbox) are also part of the heap. The shutdown of a process can be divided into the following two situations:<br/><br/>- The process actively checks the current heap size during its own operation, and actively exits after finding that it exceeds the limit.<br/>- The underlying scheduling system checks the current heap size after performing garbage collection for the process, and forcibly kills the process after finding that it exceeds the limit.<br/><br/>Note: The Error logs generated by the above two will be different. The log generated by the former is similar to `...errorContext: connection_shutdown, reason: #{max => 2097152, reason => proc_heap_too_large, value => 2787348}..`,<br/>and the log generated by the latter is similar to `...Context: maximum heap size reached...`.",
            "example": "1024KB"
          }
        },
        "type": "object"
      },
      "emqx.broker": {
        "properties": {
          "enable_session_registry": {
            "default": true,
            "type": "boolean",
            "description": "The Global Session Registry is a cluster-wide mechanism designed to maintain the uniqueness of client IDs within the cluster.<br/>Recommendations for Use<br/><br/>- Default Setting: It is generally advisable to enable. This feature is crucial for session takeover to work properly. For example if a client reconnected to another node in the cluster, the new connection will need to find the old session and take it over.<br/>- Disabling the Feature: Disabling is an option for scenarios when all sessions expire immediately after client is disconnected (i.e. session expiry interval is zero). This can be relevant in certain specialized use cases.<br/><br/>Advantages of Disabling<br/><br/>- Reduced Memory Usage: Turning off the session registry can lower the overall memory footprint of the system.<br/>- Improved Performance: Without the overhead of maintaining a global registry, the node can process client connections faster."
          },
          "session_history_retain": {
            "default": "0s",
            "type": "string",
            "description": "The duration to retain the session registration history. Setting this to a value greater than `0s` will increase memory usage and impact peformance.<br/>This retained history can be used to monitor how many sessions were registered in the past configured duration.<br/>Note: This config has no effect if `enable_session_registry` is set to `false`.<br/><br/>Note: If the clients are using random client IDs, it's not recommended to enable this feature, at least not for a long retention period.<br/><br/>Note: When clustered, the lowest (but greater than `0s`) value among the nodes in the cluster will take effect.",
            "example": "1h"
          }
        },
        "type": "object"
      },
      "gateway.dtls_opts": {
        "properties": {
          "cacertfile": {
            "default": "${EMQX_ETC_DIR}/certs/cacert.pem",
            "type": "string",
            "description": "Trusted PEM format CA certificates bundle file.<br/><br/>The certificates in this file are used to verify the TLS peer's certificates.<br/>Append new certificates to the file if new CAs are to be trusted.<br/>There is no need to restart EMQX to have the updated file loaded, because<br/>the system regularly checks if file has been updated (and reload).<br/><br/>NOTE: invalidating (deleting) a certificate from the file will not affect<br/>already established connections."
          },
          "cacerts": {
            "default": false,
            "type": "boolean",
            "deprecated": true
          },
          "certfile": {
            "default": "${EMQX_ETC_DIR}/certs/cert.pem",
            "type": "string",
            "description": "PEM format certificates chain file.<br/><br/>The certificates in this file should be in reversed order of the certificate<br/>issue chain. That is, the host's certificate should be placed in the beginning<br/>of the file, followed by the immediate issuer certificate and so on.<br/>Although the root CA certificate is optional, it should be placed at the end of<br/>the file if it is to be added."
          },
          "keyfile": {
            "default": "${EMQX_ETC_DIR}/certs/key.pem",
            "type": "string",
            "description": "PEM format private key file."
          },
          "verify": {
            "default": "verify_none",
            "type": "string",
            "enum": [
              "verify_peer",
              "verify_none"
            ],
            "description": "Enable or disable peer verification."
          },
          "reuse_sessions": {
            "default": true,
            "type": "boolean",
            "description": "Enable TLS session reuse.<br/><br/>Has no effect when TLS version is configured (or negotiated) to 1.3"
          },
          "depth": {
            "default": 10,
            "type": "integer",
            "description": "Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path.<br/>So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly;<br/><br/>if 1 the path can be PEER, Intermediate-CA, ROOT-CA;<br/><br/>if 2 the path can be PEER, Intermediate-CA1, Intermediate-CA2, ROOT-CA.",
            "minimum": 0
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "String containing the user's password. Only used if the private key file is password-protected.",
            "example": ""
          },
          "versions": {
            "default": [
              "dtlsv1.2"
            ],
            "type": "array",
            "description": "All TLS/DTLS versions to be supported.<br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.<br/><br/>In case PSK cipher suites are intended, make sure to configure<br/><code>['tlsv1.2', 'tlsv1.1']</code> here.",
            "items": {
              "type": "string"
            }
          },
          "ciphers": {
            "default": [],
            "type": "array",
            "description": "This config holds TLS cipher suite names separated by comma,<br/>or as an array of strings. e.g.<br/><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or<br/><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.<br/><br/><br/>Ciphers (and their ordering) define the way in which the<br/>client and server encrypts information over the network connection.<br/>Selecting a good cipher suite is critical for the<br/>application's data security, confidentiality and performance.<br/><br/>The names should be in OpenSSL string format (not RFC format).<br/>All default values and examples provided by EMQX config<br/>documentation are all in OpenSSL format.<br/><br/><br/>NOTE: Certain cipher suites are only compatible with<br/>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')<br/>incompatible cipher suites will be silently dropped.<br/>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,<br/>configuring cipher suites for other versions will have no effect.<br/><br/><br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br/><br/>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.<br/><br/>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,<br/>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,<br/>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,<br/>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code>",
            "items": {
              "type": "string"
            }
          },
          "secure_renegotiate": {
            "default": true,
            "type": "boolean",
            "description": "Whether to reject TLS renegotiation attempts that are not compliant with [RFC 5746](http://www.ietf.org/rfc/rfc5746.txt).<br/><br/>By default, `secure_renegotiate` is set to `true`, which forces secure renegotiation.<br/>If set to `false`, secure renegotiation will still be used, but will fall back to insecure renegotiation if the peer does not support [RFC 5746](http://www.ietf.org/rfc/rfc5746.txt), which increases the risk of a MitM attack.<br/><br/>Has no effect when TLS version is configured (or negotiated) to 1.3."
          },
          "log_level": {
            "default": "notice",
            "type": "string",
            "enum": [
              "emergency",
              "alert",
              "critical",
              "error",
              "warning",
              "notice",
              "info",
              "debug",
              "none",
              "all"
            ],
            "description": "The minimum level of logging allowed for SSL output.<br/><br/>The default is `notice`, set to a lower `debug` level for more detailed logging that can be used to investigate SSL handshake issues."
          },
          "hibernate_after": {
            "default": "5s",
            "type": "string",
            "description": "Specifies the amount of time that an SSL process will hibernate after being idle, thus reducing its memory footprint.<br/><br/>The hibernating process will be woken up when a new message arrives.<br/>Hibernating and waking up too often can cause CPU utilization to increase, as they both perform garbage collection on the process.",
            "example": "12m"
          },
          "dhfile": {
            "type": "string",
            "description": "Path to a file containing PEM-encoded Diffie-Hellman parameters<br/>to be used by the server if a cipher suite using Diffie-Hellman<br/>key exchange is negotiated. If not specified, default parameters<br/>are used.<br/><br/>NOTE: The <code>dhfile</code> option is not supported by TLS 1.3."
          },
          "fail_if_no_peer_cert": {
            "default": false,
            "type": "boolean",
            "description": "This option is only effective if `verify` is set to `verify_peer`.<br/><br/>If set to `true`, EMQX will reject the connection if the client fails to provide a certificate.<br/><br/>If set to `false`, EMQX will accept clients which don't present a certificate."
          },
          "honor_cipher_order": {
            "default": true,
            "type": "boolean",
            "description": "An important security setting. If this setting is enabled, the server will prioritize the cipher suites it prefers most from the list of cipher suites supported by the client, thus ignoring the client's preferences.<br/><br/>The server's cipher suites are specified by `ciphers`, with preference decreasing from left to right.<br/><br/>It is often better to use the server's preferences, as it is more likely that the server will be configured correctly."
          },
          "client_renegotiation": {
            "default": true,
            "type": "boolean",
            "description": "In protocols that support client-initiated renegotiation,<br/>the cost of resources of such an operation is higher for the server than the client.<br/>This can act as a vector for denial of service attacks.<br/>The SSL application already takes measures to counter-act such attempts,<br/>but client-initiated renegotiation can be strictly disabled by setting this option to false.<br/>The default value is true. Note that disabling renegotiation can result in<br/>long-lived connections becoming unusable due to limits on<br/>the number of messages the underlying cipher suite can encipher.<br/><br/>Has no effect when TLS version is configured (or negotiated) to 1.3"
          },
          "handshake_timeout": {
            "default": "15s",
            "type": "string",
            "description": "Maximum time duration allowed for the handshake to complete",
            "example": "12m"
          },
          "gc_after_handshake": {
            "default": false,
            "type": "boolean",
            "description": "Memory usage tuning. If enabled, will immediately perform a garbage collection after the TLS/SSL handshake."
          },
          "ocsp": {
            "$ref": "#/components/schemas/emqx.ocsp"
          },
          "enable_crl_check": {
            "default": false,
            "type": "boolean",
            "description": "Whether to enable CRL verification for this listener."
          }
        },
        "type": "object"
      },
      "rule_engine.ctx_connected": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "type": "string",
            "enum": [
              "client_connected"
            ],
            "description": "Event Type"
          },
          "clientid": {
            "type": "string",
            "description": "The Client ID"
          },
          "username": {
            "type": "string",
            "description": "Username"
          },
          "mountpoint": {
            "type": "string",
            "description": "The Mountpoint"
          },
          "peername": {
            "type": "string",
            "description": "The IP Address and Port of the Peer Client"
          },
          "sockname": {
            "type": "string",
            "description": "The IP Address and Port of the Local Listener"
          },
          "proto_name": {
            "type": "string",
            "description": "Protocol Name"
          },
          "proto_ver": {
            "type": "string",
            "description": "Protocol Version"
          },
          "keepalive": {
            "type": "integer",
            "description": "KeepAlive"
          },
          "clean_start": {
            "default": true,
            "type": "boolean",
            "description": "Clean Start"
          },
          "expiry_interval": {
            "type": "integer",
            "description": "Expiry Interval"
          },
          "is_bridge": {
            "default": false,
            "type": "boolean",
            "description": "Is Bridge"
          },
          "connected_at": {
            "type": "integer",
            "description": "The Time that this Client is Connected"
          }
        },
        "type": "object"
      },
      "cluster.replicant_info": {
        "properties": {
          "node": {
            "type": "string",
            "description": "Replicant node name",
            "example": "emqx-replicant@127.0.0.2"
          },
          "streams": {
            "type": "integer",
            "description": "The number of RLOG (replicated log) streams",
            "minimum": 0,
            "example": "10"
          }
        },
        "type": "object"
      },
      "bridge_http.put": {
        "required": [
          "url"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this action."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "connect_timeout": {
            "default": "15s",
            "type": "string",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s"
          },
          "retry_interval": {
            "type": "string",
            "deprecated": true,
            "example": "12m"
          },
          "pool_type": {
            "default": "random",
            "type": "string",
            "enum": [
              "random",
              "hash"
            ],
            "description": "The type of the pool. Can be one of `random`, `hash`."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "The pool size.",
            "minimum": 1
          },
          "enable_pipelining": {
            "default": 100,
            "type": "integer",
            "description": "The maximum number of HTTP requests that can be sent before an HTTP response is received.<br/><br/>Setting this to 1 is equivalent to turning off HTTP pipelining, and the EMQX must receive a response to the previous HTTP request before sending the next HTTP request.",
            "minimum": 1
          },
          "request": {
            "type": "object",
            "deprecated": true,
            "description": "This field is never used, so we deprecated it since 5.3.2.",
            "example": {}
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "url": {
            "type": "string",
            "description": "The URL of the HTTP action.<br/><br/>Template with variables is allowed in the path, but variables cannot be used in the scheme, host,<br/>or port part.<br/><br/>For example, <code> http://localhost:9901/${topic} </code> is allowed, but<br/><code> http://${host}:9901/message </code> or <code> http://localhost:${port}/message </code><br/>is not allowed."
          },
          "direction": {
            "type": "string",
            "enum": [
              "egress"
            ],
            "deprecated": true
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to the HTTP server. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: If this action is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "method": {
            "default": "post",
            "type": "string",
            "enum": [
              "post",
              "put",
              "get",
              "delete"
            ],
            "description": "The method of the HTTP request. All the available methods are: post, put, get, delete.<br/><br/>Template with variables is allowed."
          },
          "headers": {
            "default": {
              "accept": "application/json",
              "cache-control": "no-cache",
              "connection": "keep-alive",
              "content-type": "application/json",
              "keep-alive": "timeout=5"
            },
            "type": "object",
            "description": "The headers of the HTTP request.<br/><br/>Template with variables is allowed.",
            "example": {},
            "is_template": true
          },
          "body": {
            "type": "string",
            "description": "The body of the HTTP request.<br/><br/>If not provided, the body will be a JSON object of all the available fields.<br/><br/>There, 'all the available fields' means the context of a MQTT message when<br/>this webhook is triggered by receiving a MQTT message (the `local_topic` is set),<br/>or the context of the event when this webhook is triggered by a rule (i.e. this<br/>webhook is used as an action of a rule).<br/><br/>Template with variables is allowed."
          },
          "max_retries": {
            "default": 2,
            "type": "integer",
            "description": "HTTP request max retry times if failed.",
            "minimum": 0
          },
          "request_timeout": {
            "default": "15s",
            "type": "string",
            "deprecated": true,
            "description": "HTTP request timeout.",
            "example": "32s"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_http.v1_resource_opts"
          }
        },
        "type": "object"
      },
      "emqx_authz_schema.metrics": {
        "properties": {
          "total": {
            "type": "integer",
            "description": "The total number of times the authorization rule was triggered."
          },
          "ignore": {
            "type": "integer",
            "description": "Count of query ignored.  This counter is increased whenever the authorization source attempts to authorize a request, but either it's not applicable, or an error was encountered and the result is undecidable"
          },
          "allow": {
            "type": "integer",
            "description": "The number of times the authentication was successful."
          },
          "deny": {
            "type": "integer",
            "description": "The number of authentication failures."
          },
          "nomatch": {
            "type": "number",
            "description": "The number of times that no authorization rules were matched."
          },
          "rate": {
            "type": "number",
            "description": "The rate of matched, times/second."
          },
          "rate_max": {
            "type": "number",
            "description": "The max rate of matched, times/second."
          },
          "rate_last5m": {
            "type": "number",
            "description": "The average rate of matched in the last 5 minutes, times/second."
          }
        },
        "type": "object"
      },
      "cluster.node_invitation_succeed": {
        "properties": {
          "node": {
            "type": "string",
            "description": "Node name",
            "example": "emqx2@127.0.0.1"
          },
          "started_at": {
            "type": "string",
            "description": "The time of the async invitation is started",
            "example": "2024-01-30T15:24:39.355+08:00"
          },
          "finished_at": {
            "type": "string",
            "description": "The time of the async invitation result is received",
            "example": "2024-01-30T15:24:39.355+08:00"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api_clients.stomp_client": {
        "properties": {
          "node": {
            "type": "string",
            "description": "Name of the node to which the client is connected"
          },
          "clientid": {
            "type": "string",
            "description": "Client ID"
          },
          "username": {
            "type": "string",
            "description": "Username of client when connecting"
          },
          "mountpoint": {
            "type": "string",
            "description": "Topic mountpoint"
          },
          "proto_name": {
            "type": "string",
            "description": "Client protocol name"
          },
          "proto_ver": {
            "type": "string",
            "description": "Protocol version used by the client"
          },
          "ip_address": {
            "type": "string",
            "description": "Client's IP address"
          },
          "port": {
            "type": "integer",
            "description": "Client's port"
          },
          "is_bridge": {
            "type": "boolean",
            "description": "Indicates whether the client is connected via bridge"
          },
          "connected_at": {
            "description": "Client connection time",
            "oneOf": [
              {
                "type": "integer",
                "description": "epoch-millisecond",
                "example": 1640995200000
              },
              {
                "type": "string",
                "format": "date-time",
                "example": "2022-01-01T00:00:00.000Z"
              }
            ]
          },
          "disconnected_at": {
            "description": "Client offline time, This field is only valid and returned when connected is false",
            "oneOf": [
              {
                "type": "integer",
                "description": "epoch-millisecond",
                "example": 1640995200000
              },
              {
                "type": "string",
                "format": "date-time",
                "example": "2022-01-01T00:00:00.000Z"
              }
            ]
          },
          "connected": {
            "type": "boolean",
            "description": "Whether the client is connected"
          },
          "keepalive": {
            "type": "integer",
            "description": "Keepalive time, with the unit of second"
          },
          "clean_start": {
            "type": "boolean",
            "description": "Indicate whether the client is using a brand new session"
          },
          "expiry_interval": {
            "type": "integer",
            "description": "Session expiration interval, with the unit of second"
          },
          "created_at": {
            "description": "Session creation time",
            "oneOf": [
              {
                "type": "integer",
                "description": "epoch-millisecond",
                "example": 1640995200000
              },
              {
                "type": "string",
                "format": "date-time",
                "example": "2022-01-01T00:00:00.000Z"
              }
            ]
          },
          "subscriptions_cnt": {
            "type": "integer",
            "description": "Number of subscriptions established by this client"
          },
          "subscriptions_max": {
            "type": "integer",
            "description": "Maximum number of subscriptions allowed by this client"
          },
          "inflight_cnt": {
            "type": "integer",
            "description": "Current length of inflight"
          },
          "inflight_max": {
            "type": "integer",
            "description": "Maximum length of inflight"
          },
          "mqueue_len": {
            "type": "integer",
            "description": "Current length of message queue"
          },
          "mqueue_max": {
            "type": "integer",
            "description": "Maximum length of message queue"
          },
          "mqueue_dropped": {
            "type": "integer",
            "description": "Number of messages dropped by the message queue due to exceeding the length"
          },
          "awaiting_rel_cnt": {
            "type": "integer",
            "description": "Number of awaiting acknowledge packet"
          },
          "awaiting_rel_max": {
            "type": "integer",
            "description": "Maximum allowed number of awaiting PUBREC packet"
          },
          "recv_oct": {
            "type": "integer",
            "description": "Number of bytes received"
          },
          "recv_cnt": {
            "type": "integer",
            "description": "Number of socket packets received"
          },
          "recv_pkt": {
            "type": "integer",
            "description": "Number of protocol packets received"
          },
          "recv_msg": {
            "type": "integer",
            "description": "Number of message packets received"
          },
          "send_oct": {
            "type": "integer",
            "description": "Number of bytes sent"
          },
          "send_cnt": {
            "type": "integer",
            "description": "Number of socket packets sent"
          },
          "send_pkt": {
            "type": "integer",
            "description": "Number of protocol packets sent"
          },
          "send_msg": {
            "type": "integer",
            "description": "Number of message packets sent"
          },
          "mailbox_len": {
            "type": "integer",
            "description": "Process mailbox size"
          },
          "heap_size": {
            "type": "integer",
            "description": "Process heap size with the unit of byte"
          },
          "reductions": {
            "type": "integer",
            "description": "Erlang reduction"
          }
        },
        "type": "object"
      },
      "authn.redis_sentinel": {
        "required": [
          "backend",
          "cmd",
          "mechanism",
          "sentinel",
          "servers"
        ],
        "properties": {
          "mechanism": {
            "type": "string",
            "enum": [
              "password_based"
            ],
            "description": "Authentication mechanism."
          },
          "backend": {
            "type": "string",
            "enum": [
              "redis"
            ],
            "description": "Backend type."
          },
          "cmd": {
            "type": "string",
            "description": "The Redis Command used to query data for authentication such as password hash, currently only supports <code>HGET</code> and <code>HMGET</code>."
          },
          "password_hash_algorithm": {
            "default": {
              "name": "sha256",
              "salt_position": "prefix"
            },
            "description": "Options for password hash verification.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn_hash.simple"
              },
              {
                "$ref": "#/components/schemas/authn_hash.pbkdf2"
              },
              {
                "$ref": "#/components/schemas/authn_hash.bcrypt"
              }
            ]
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider."
          },
          "servers": {
            "type": "string",
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The Redis default port 6379 is used if `[:Port]` is not specified."
          },
          "redis_type": {
            "default": "sentinel",
            "type": "string",
            "enum": [
              "sentinel"
            ],
            "description": "Sentinel mode. Must be set to 'sentinel' when Redis server is running in sentinel mode."
          },
          "sentinel": {
            "type": "string",
            "description": "The cluster name in Redis sentinel mode."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "database": {
            "default": 0,
            "type": "integer",
            "description": "Redis database ID.",
            "minimum": 0
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_mnesia.clientid_response_data": {
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/emqx_authz_api_mnesia.rules_for_clientid"
            }
          },
          "meta": {
            "$ref": "#/components/schemas/public.meta"
          }
        },
        "type": "object"
      },
      "authn_hash.pbkdf2": {
        "required": [
          "iterations",
          "mac_fun",
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "enum": [
              "pbkdf2"
            ],
            "description": "PBKDF2 password hashing."
          },
          "mac_fun": {
            "type": "string",
            "enum": [
              "md4",
              "md5",
              "ripemd160",
              "sha",
              "sha224",
              "sha256",
              "sha384",
              "sha512"
            ],
            "description": "Specifies mac_fun for PBKDF2 hashing algorithm."
          },
          "iterations": {
            "type": "integer",
            "description": "Iteration count for PBKDF2 hashing algorithm.",
            "minimum": 1
          },
          "dk_length": {
            "type": "integer",
            "description": "Derived length for PBKDF2 hashing algorithm. If not specified, calculated automatically based on `mac_fun`.",
            "minimum": 1
          }
        },
        "type": "object"
      },
      "opentelemetry.otel_logs": {
        "properties": {
          "level": {
            "default": "warning",
            "type": "string",
            "enum": [
              "debug",
              "info",
              "notice",
              "warning",
              "error",
              "critical",
              "alert",
              "emergency",
              "all"
            ],
            "description": "The log level of the Open Telemetry log handler."
          },
          "enable": {
            "default": false,
            "type": "boolean",
            "description": "Enable or disable Open Telemetry signal."
          },
          "scheduled_delay": {
            "default": "1s",
            "type": "string",
            "description": "The delay interval between two consecutive exports of Open Telemetry signals.",
            "example": "32s"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_clients.mqueue_messages": {
        "properties": {
          "data": {
            "type": "array",
            "description": "Client's mqueue messages list.<br/>Messages are ordered according to their priority and queue (FIFO) order: from higher priority to lower priority.<br/>By default, all messages in Mqueue have the same priority of 0.",
            "items": {
              "$ref": "#/components/schemas/emqx_mgmt_api_clients.mqueue_message"
            }
          },
          "meta": {
            "$ref": "#/components/schemas/public.continuation_meta"
          }
        },
        "type": "object"
      },
      "connector_mqtt.egress_local": {
        "properties": {
          "topic": {
            "type": "string",
            "description": "The local topic to be forwarded to the remote broker"
          }
        },
        "type": "object"
      },
      "authn.hash_method": {
        "properties": {
          "type": {
            "default": "hash",
            "type": "string",
            "enum": [
              "hash"
            ],
            "description": "Authentication method type."
          },
          "password_attribute": {
            "default": "userPassword",
            "type": "string",
            "description": "Indicates which attribute is used to represent the user's password."
          },
          "is_superuser_attribute": {
            "default": "isSuperuser",
            "type": "string",
            "description": "Indicates which attribute is used to represent whether the user is a superuser."
          }
        },
        "type": "object"
      },
      "authn.metrics": {
        "properties": {
          "nomatch": {
            "type": "integer",
            "description": "The number of times the instance was ignored when the required authentication information was not found in the current instance."
          },
          "total": {
            "type": "integer",
            "description": "The total number of times the current instance was triggered."
          },
          "success": {
            "type": "integer",
            "description": "The required authentication information is found in the current instance, and the instance returns authentication success."
          },
          "failed": {
            "type": "integer",
            "description": "The required authentication information is found in the current instance, and the instance returns authentication failure."
          },
          "rate": {
            "type": "number",
            "description": "The total rate at which instances are triggered, times/second."
          },
          "rate_max": {
            "type": "number",
            "description": "The highest trigger rate the instance has ever reached, times/second."
          },
          "rate_last5m": {
            "type": "number",
            "description": "The average trigger rate of the instance within 5 minutes, times/second."
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_nodes.node_info": {
        "properties": {
          "node": {
            "type": "string",
            "description": "Node name",
            "example": "emqx@127.0.0.1"
          },
          "connections": {
            "type": "integer",
            "description": "Number of clients session in this node",
            "minimum": 0,
            "example": 0
          },
          "live_connections": {
            "type": "integer",
            "description": "Number of clients currently connected to this node",
            "minimum": 0,
            "example": 0
          },
          "cluster_sessions": {
            "type": "integer",
            "description": "By default, it includes only those sessions that have not expired. If the `broker.session_history_retain` config is set to a duration greater than `0s`, this count will also include sessions that expired within the specified retain time",
            "minimum": 0,
            "example": 0
          },
          "load1": {
            "type": "number",
            "description": "CPU average load in 1 minute",
            "example": 2.66
          },
          "load5": {
            "type": "number",
            "description": "CPU average load in 5 minute",
            "example": 2.66
          },
          "load15": {
            "type": "number",
            "description": "CPU average load in 15 minute",
            "example": 2.66
          },
          "max_fds": {
            "type": "integer",
            "description": "File descriptors limit",
            "minimum": 0,
            "example": 1024
          },
          "memory_total": {
            "type": "string",
            "description": "Allocated memory",
            "example": "512.00M"
          },
          "memory_used": {
            "type": "string",
            "description": "Used memory",
            "example": "256.00M"
          },
          "node_status": {
            "type": "string",
            "enum": [
              "running",
              "stopped"
            ],
            "description": "Node status",
            "example": "running"
          },
          "otp_release": {
            "type": "string",
            "description": "Erlang/OTP version",
            "example": "24.2/12.2"
          },
          "process_available": {
            "type": "integer",
            "description": "Erlang processes limit",
            "minimum": 0,
            "example": 2097152
          },
          "process_used": {
            "type": "integer",
            "description": "Running Erlang processes",
            "minimum": 0,
            "example": 1024
          },
          "uptime": {
            "type": "integer",
            "description": "System uptime, milliseconds",
            "minimum": 0,
            "example": 5120000
          },
          "version": {
            "type": "string",
            "description": "Release version",
            "example": "5.0.0"
          },
          "edition": {
            "type": "string",
            "enum": [
              "Opensource",
              "Enterprise"
            ],
            "description": "Release edition",
            "example": "Opensource"
          },
          "sys_path": {
            "type": "string",
            "description": "Path to system files",
            "example": "path/to/emqx"
          },
          "log_path": {
            "type": "string",
            "description": "Path to log files",
            "example": "path/to/log | The log path is not yet set"
          },
          "role": {
            "type": "string",
            "enum": [
              "core",
              "replicant"
            ],
            "description": "Node role",
            "example": "core"
          }
        },
        "type": "object"
      },
      "emqx_delayed_api.message_without_payload": {
        "properties": {
          "msgid": {
            "type": "integer",
            "description": "Delayed Message ID"
          },
          "node": {
            "type": "string",
            "description": "The node where message from"
          },
          "publish_at": {
            "type": "string",
            "description": "Clinet publish message time, in RFC 3339 format"
          },
          "delayed_interval": {
            "type": "integer",
            "description": "Delayed interval(second)",
            "minimum": 1
          },
          "delayed_remaining": {
            "type": "integer",
            "description": "Delayed remaining(second)",
            "minimum": 0
          },
          "expected_at": {
            "type": "string",
            "description": "Expect publish time, in RFC 3339 format"
          },
          "topic": {
            "type": "string",
            "description": "Topic",
            "example": "/sys/#"
          },
          "qos": {
            "maximum": 2,
            "type": "integer",
            "description": "QoS",
            "minimum": 0,
            "example": 0
          },
          "from_clientid": {
            "type": "string",
            "description": "From ClientID"
          },
          "from_username": {
            "type": "string",
            "description": "From Username"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_mnesia.rules": {
        "properties": {
          "rules": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/emqx_authz_api_mnesia.rule_item"
            }
          }
        },
        "type": "object"
      },
      "slow_subscribers_statistics.record": {
        "properties": {
          "clientid": {
            "type": "string",
            "description": "Message clientid"
          },
          "node": {
            "type": "string",
            "description": "Message node name"
          },
          "topic": {
            "type": "string",
            "description": "Message topic"
          },
          "timespan": {
            "type": "integer",
            "description": "Timespan for message transmission"
          },
          "last_update_time": {
            "type": "integer",
            "description": "The timestamp of last update"
          }
        },
        "type": "object"
      },
      "authn_hash.simple": {
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "enum": [
              "plain",
              "md5",
              "sha",
              "sha256",
              "sha512"
            ],
            "description": "Simple password hashing algorithm."
          },
          "salt_position": {
            "default": "prefix",
            "type": "string",
            "enum": [
              "disable",
              "prefix",
              "suffix"
            ],
            "description": "Salt position for PLAIN, MD5, SHA, SHA256 and SHA512 algorithms."
          }
        },
        "type": "object"
      },
      "emqx_gateway_api_clients.mqttsn_client": {
        "properties": {
          "node": {
            "type": "string",
            "description": "Name of the node to which the client is connected"
          },
          "clientid": {
            "type": "string",
            "description": "Client ID"
          },
          "username": {
            "type": "string",
            "description": "Username of client when connecting"
          },
          "mountpoint": {
            "type": "string",
            "description": "Topic mountpoint"
          },
          "proto_name": {
            "type": "string",
            "description": "Client protocol name"
          },
          "proto_ver": {
            "type": "string",
            "description": "Protocol version used by the client"
          },
          "ip_address": {
            "type": "string",
            "description": "Client's IP address"
          },
          "port": {
            "type": "integer",
            "description": "Client's port"
          },
          "is_bridge": {
            "type": "boolean",
            "description": "Indicates whether the client is connected via bridge"
          },
          "connected_at": {
            "description": "Client connection time",
            "oneOf": [
              {
                "type": "integer",
                "description": "epoch-millisecond",
                "example": 1640995200000
              },
              {
                "type": "string",
                "format": "date-time",
                "example": "2022-01-01T00:00:00.000Z"
              }
            ]
          },
          "disconnected_at": {
            "description": "Client offline time, This field is only valid and returned when connected is false",
            "oneOf": [
              {
                "type": "integer",
                "description": "epoch-millisecond",
                "example": 1640995200000
              },
              {
                "type": "string",
                "format": "date-time",
                "example": "2022-01-01T00:00:00.000Z"
              }
            ]
          },
          "connected": {
            "type": "boolean",
            "description": "Whether the client is connected"
          },
          "keepalive": {
            "type": "integer",
            "description": "Keepalive time, with the unit of second"
          },
          "clean_start": {
            "type": "boolean",
            "description": "Indicate whether the client is using a brand new session"
          },
          "expiry_interval": {
            "type": "integer",
            "description": "Session expiration interval, with the unit of second"
          },
          "created_at": {
            "description": "Session creation time",
            "oneOf": [
              {
                "type": "integer",
                "description": "epoch-millisecond",
                "example": 1640995200000
              },
              {
                "type": "string",
                "format": "date-time",
                "example": "2022-01-01T00:00:00.000Z"
              }
            ]
          },
          "subscriptions_cnt": {
            "type": "integer",
            "description": "Number of subscriptions established by this client"
          },
          "subscriptions_max": {
            "type": "integer",
            "description": "Maximum number of subscriptions allowed by this client"
          },
          "inflight_cnt": {
            "type": "integer",
            "description": "Current length of inflight"
          },
          "inflight_max": {
            "type": "integer",
            "description": "Maximum length of inflight"
          },
          "mqueue_len": {
            "type": "integer",
            "description": "Current length of message queue"
          },
          "mqueue_max": {
            "type": "integer",
            "description": "Maximum length of message queue"
          },
          "mqueue_dropped": {
            "type": "integer",
            "description": "Number of messages dropped by the message queue due to exceeding the length"
          },
          "awaiting_rel_cnt": {
            "type": "integer",
            "description": "Number of awaiting acknowledge packet"
          },
          "awaiting_rel_max": {
            "type": "integer",
            "description": "Maximum allowed number of awaiting PUBREC packet"
          },
          "recv_oct": {
            "type": "integer",
            "description": "Number of bytes received"
          },
          "recv_cnt": {
            "type": "integer",
            "description": "Number of socket packets received"
          },
          "recv_pkt": {
            "type": "integer",
            "description": "Number of protocol packets received"
          },
          "recv_msg": {
            "type": "integer",
            "description": "Number of message packets received"
          },
          "send_oct": {
            "type": "integer",
            "description": "Number of bytes sent"
          },
          "send_cnt": {
            "type": "integer",
            "description": "Number of socket packets sent"
          },
          "send_pkt": {
            "type": "integer",
            "description": "Number of protocol packets sent"
          },
          "send_msg": {
            "type": "integer",
            "description": "Number of message packets sent"
          },
          "mailbox_len": {
            "type": "integer",
            "description": "Process mailbox size"
          },
          "heap_size": {
            "type": "integer",
            "description": "Process heap size with the unit of byte"
          },
          "reductions": {
            "type": "integer",
            "description": "Erlang reduction"
          }
        },
        "type": "object"
      },
      "emqx_topic_metrics_api.metrics": {
        "properties": {
          "message.dropped.count": {
            "type": "integer",
            "description": "Dropped messages count",
            "example": 0
          },
          "message.in.count": {
            "type": "integer",
            "description": "In messages count",
            "example": 0
          },
          "message.out.count": {
            "type": "integer",
            "description": "Out messages count",
            "example": 0
          },
          "message.qos0.in.count": {
            "type": "integer",
            "description": "QoS0 in messages count",
            "example": 0
          },
          "message.qos0.out.count": {
            "type": "integer",
            "description": "QoS0 out messages count",
            "example": 0
          },
          "message.qos1.in.count": {
            "type": "integer",
            "description": "QoS1 in messages count",
            "example": 0
          },
          "message.qos1.out.count": {
            "type": "integer",
            "description": "QoS1 out messages count",
            "example": 0
          },
          "message.qos2.in.count": {
            "type": "integer",
            "description": "QoS2 in messages count",
            "example": 0
          },
          "message.qos2.out.count": {
            "type": "integer",
            "description": "QoS2 out messages count",
            "example": 0
          },
          "message.dropped.rate": {
            "type": "number",
            "description": "Dropped messages rate",
            "example": 0
          },
          "message.in.rate": {
            "type": "number",
            "description": "In messages rate",
            "example": 0
          },
          "message.out.rate": {
            "type": "number",
            "description": "Out messages rate",
            "example": 0
          },
          "message.qos0.in.rate": {
            "type": "number",
            "description": "QoS0 in messages rate",
            "example": 0
          },
          "message.qos0.out.rate": {
            "type": "number",
            "description": "QoS0 out messages rate",
            "example": 0
          },
          "message.qos1.in.rate": {
            "type": "number",
            "description": "QoS1 in messages rate",
            "example": 0
          },
          "message.qos1.out.rate": {
            "type": "number",
            "description": "QoS1 out messages rate",
            "example": 0
          },
          "message.qos2.in.rate": {
            "type": "number",
            "description": "QoS2 in messages rate",
            "example": 0
          },
          "message.qos2.out.rate": {
            "type": "number",
            "description": "QoS2 out messages rate",
            "example": 0
          }
        },
        "type": "object"
      },
      "listeners.ssl_not_required_bind": {
        "required": [
          "id",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "ssl"
            ],
            "description": "Listener type"
          },
          "running": {
            "type": "boolean",
            "description": "Listener status"
          },
          "id": {
            "type": "string",
            "description": "Listener id"
          },
          "current_connections": {
            "type": "integer",
            "description": "Current connections",
            "minimum": 0
          },
          "bind": {
            "default": 8883,
            "type": "string",
            "description": "IP address and port for the listening socket.",
            "example": "127.0.0.1:80"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable listener."
          },
          "acceptors": {
            "default": 16,
            "type": "integer",
            "description": "The size of the listener's receiving pool.",
            "minimum": 1
          },
          "max_connections": {
            "default": "infinity",
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "type": "string",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message<br/>is delivered to the subscriber. The mountpoint is a way that users can use<br/>to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`<br/>set to `some_tenant`, then the client actually subscribes to the topic<br/>`some_tenant/t`. Similarly, if another client B (connected to the same listener<br/>as the client A) sends a message to topic `t`, the message is routed<br/>to all the clients subscribed `some_tenant/t`, so client A will receive the<br/>message, with topic name `t`.<br/><br/>Set to `\"\"` to disable the feature.<br/><br/><br/>Variables in mountpoint string:<br/>  - <code>${clientid}</code>: clientid<br/>  - <code>${username}</code>: username"
          },
          "zone": {
            "default": "default",
            "type": "string",
            "description": "The configuration zone to which the listener belongs.<br/>Clients connected to this listener will inherit zone-settings created under this zone name.<br/><br/>A zone can override the configs under below root names:<br/>- `mqtt`<br/>- `force_shutdown`<br/>- `force_gc`<br/>- `flapping_detect`<br/>- `durable_sessions`"
          },
          "enable_authn": {
            "default": true,
            "type": "string",
            "enum": [
              true,
              false,
              "quick_deny_anonymous"
            ],
            "description": "Set <code>true</code> (default) to enable client authentication on this listener, the authentication<br/>process goes through the configured authentication chain.<br/>When set to <code>false</code>, any client (with or without username/password) is allowed to connect.<br/>When set to <code>quick_deny_anonymous</code>, it behaves like when set to <code>true</code>, but clients will be<br/>denied immediately without going through any authenticators if <code>username</code> is not provided. This is useful to fence off<br/>anonymous clients early."
          },
          "max_conn_rate": {
            "default": "infinity",
            "type": "string",
            "description": "Used to limit the rate at which the current listener accepts connections.<br/><br/>Once the limit is reached, EMQX will pause fetching connections from the Accept queue, thereby delaying or rejecting new connections.<br/><br/>For example:<br/><br/>- `1000/s`: Only accepts 1000 connections per second.<br/>- `1000/10s`: Only accepts 1000 connections every 10 seconds.",
            "example": "1000/s"
          },
          "messages_rate": {
            "type": "string",
            "description": "Used to limit the number of messages a single client can send to EMQX per second.<br/><br/>Once the limit is reached, EMQX will pause reading data from the receive-buffer, thus slowing down or even temporarily hanging the sender.<br/><br/>For example:<br/><br/>- `500/s`: Only 500 messages will be received per second, and the remaining messages will be delayed.<br/>- `500/10s`: Only 500 messages will be received every 10 seconds and the remaining messages will be delayed.",
            "example": "1000/s"
          },
          "bytes_rate": {
            "type": "string",
            "description": "Used to limit the number of bytes a single client can send to EMQX per second.<br/><br/>Once the limit is reached, EMQX will pause reading data from the receive-buffer, thus slowing down or even temporarily hanging the sender.<br/><br/>The unit of the bytes could be: B, KB, MB, GB.<br/><br/>For example:<br/><br/>- `500KB/s`: Only 500 kilobytes per second will be received, and the remaining bytes will be delayed.<br/>- `500MB/10s`: Only 500 megabytes will be received every 10 seconds, and the remaining bytes will be delayed.",
            "example": "100MB/s"
          },
          "access_rules": {
            "default": [
              "allow all"
            ],
            "type": "array",
            "description": "An access rule list consisting of string rules to restrict or allow access from some addresses. The rules that appear earlier in the list are matched first.<br/>The format is `allow | deny <address> | <CIDR> | all`.<br/><br/>For example:<br/><br/>`[\\\"deny 192.168.1.1\\\", \\\"allow 192.168.1.0/24\\\", \\\"deny, all\\\"]`",
            "items": {
              "type": "string"
            }
          },
          "proxy_protocol": {
            "default": false,
            "type": "boolean",
            "description": "Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.<br/><br/>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "type": "string",
            "description": "If a reverse proxy is deployed for EMQX, and the PROXY protocol is enabled at the proxy to pass the client's real IP, this option needs to be turned on so that EMQX can extract the client's real IP from the PROXY protocol header.<br/><br/>EMQX will automatically detect the version of the PROXY protocol and support V1 and V2.<br/><br/>For a detailed description of the PROXY protocol, please refer to: https://www.haproxy.com/blog/haproxy/proxy-protocol/",
            "example": "12m"
          },
          "tcp_options": {
            "$ref": "#/components/schemas/emqx.tcp_opts"
          },
          "ssl_options": {
            "$ref": "#/components/schemas/emqx.listener_ssl_opts"
          }
        },
        "type": "object"
      },
      "cluster.node_invitation_in_progress": {
        "properties": {
          "node": {
            "type": "string",
            "description": "Node name",
            "example": "emqx2@127.0.0.1"
          },
          "started_at": {
            "type": "string",
            "description": "The time of the async invitation is started",
            "example": "2024-01-30T15:24:39.355+08:00"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.update_lwm2m": {
        "required": [
          "translators",
          "xml_dir"
        ],
        "properties": {
          "xml_dir": {
            "type": "string",
            "description": "The Directory for LwM2M Resource definition.",
            "example": "/etc/emqx/lwm2m_xml"
          },
          "lifetime_min": {
            "default": "15s",
            "type": "string",
            "description": "Minimum value of lifetime allowed to be set by the LwM2M client.",
            "example": "12m"
          },
          "lifetime_max": {
            "default": "86400s",
            "type": "string",
            "description": "Maximum value of lifetime allowed to be set by the LwM2M client.",
            "example": "12m"
          },
          "qmode_time_window": {
            "default": "22s",
            "type": "string",
            "description": "The value of the time window during which the network link is considered valid by the LwM2M Gateway in QMode mode.<br/>For example, after receiving an update message from a client, any messages within this time window are sent directly to the LwM2M client, and all messages beyond this time window are temporarily stored in memory.",
            "example": "1h"
          },
          "auto_observe": {
            "default": false,
            "type": "boolean",
            "description": "Automatically observe the object list of REGISTER packet."
          },
          "update_msg_publish_condition": {
            "default": "contains_object_list",
            "type": "string",
            "enum": [
              "always",
              "contains_object_list"
            ],
            "description": "Policy for publishing UPDATE event message.<br/><br/>  - always: send update events as long as the UPDATE request is received.<br/><br/>  - contains_object_list: send update events only if the UPDATE request carries any Object List"
          },
          "translators": {
            "description": "Topic configuration for LwM2M's gateway publishing and subscription.",
            "$ref": "#/components/schemas/gateway.lwm2m_translators"
          },
          "mountpoint": {
            "default": "lwm2m/${endpoint_name}/",
            "type": "string",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message is delivered to the subscriber.<br/>The mountpoint is a way that users can use to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,<br/>then the client actually subscribes to the topic `some_tenant/t`.<br/>Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,<br/>the message is routed to all the clients subscribed `some_tenant/t`,<br/>so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.<br/>Supported placeholders in mountpoint string:<br/><br/>  - <code>${clientid}</code>: clientid<br/><br/>  - <code>${username}</code>: username<br/><br/>  - <code>${endpoint_name}</code>: endpoint name"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Whether to enable this gateway"
          },
          "enable_stats": {
            "default": true,
            "type": "boolean",
            "description": "Whether to enable client process statistic"
          },
          "idle_timeout": {
            "default": "30s",
            "type": "string",
            "description": "The idle time of the client connection process. It has two purposes:<br/>  1. A newly created client process that does not receive any client requests after that time will be closed directly.<br/>  2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.",
            "example": "12m"
          },
          "clientinfo_override": {
            "description": "ClientInfo override.",
            "$ref": "#/components/schemas/gateway.clientinfo_override"
          }
        },
        "type": "object"
      },
      "opentelemetry.trace_filter": {
        "properties": {
          "trace_all": {
            "default": false,
            "type": "boolean",
            "description": "If enabled, all published messages are traced, a new trace ID is generated if it can't be extracted from the message.<br/>Otherwise, only messages published with trace context are traced. Disabled by default."
          }
        },
        "type": "object"
      },
      "authz.postgresql": {
        "required": [
          "database",
          "query",
          "server",
          "type",
          "username"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "postgresql"
            ],
            "description": "Backend type."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Set to <code>true</code> or <code>false</code> to disable this ACL provider"
          },
          "server": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The PostgreSQL default port 5432 is used if `[:Port]` is not specified."
          },
          "disable_prepared_statements": {
            "default": false,
            "type": "boolean",
            "description": "Disables the usage of prepared statements in the connections.<br/>Some endpoints, like PGBouncer or Supabase in Transaction mode, do not<br/>support session features such as prepared statements.  For such connections,<br/>this option should be enabled."
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "prepare_statement": {
            "type": "object",
            "description": "Key-value list of SQL prepared statements.",
            "example": {}
          },
          "query": {
            "type": "string",
            "description": "Database query used to retrieve authorization data."
          }
        },
        "type": "object"
      },
      "bridge_http.post_connector": {
        "required": [
          "name",
          "type",
          "url"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "http"
            ],
            "description": "The action type."
          },
          "name": {
            "type": "string",
            "description": "Action name, used as a human-readable identifier."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this connector."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "url": {
            "type": "string",
            "description": "The URL of the HTTP action.<br/><br/>Template with variables is allowed in the path, but variables cannot be used in the scheme, host,<br/>or port part.<br/><br/>For example, <code> http://localhost:9901/${topic} </code> is allowed, but<br/><code> http://${host}:9901/message </code> or <code> http://localhost:${port}/message </code><br/>is not allowed."
          },
          "headers": {
            "default": {
              "accept": "application/json",
              "cache-control": "no-cache",
              "connection": "keep-alive",
              "content-type": "application/json",
              "keep-alive": "timeout=5"
            },
            "type": "object",
            "description": "The headers of the HTTP request.<br/><br/>Template with variables is allowed.",
            "example": {},
            "is_template": true
          },
          "connect_timeout": {
            "default": "15s",
            "type": "string",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s"
          },
          "retry_interval": {
            "type": "string",
            "deprecated": true,
            "example": "12m"
          },
          "pool_type": {
            "default": "random",
            "type": "string",
            "enum": [
              "random",
              "hash"
            ],
            "description": "The type of the pool. Can be one of `random`, `hash`."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "The pool size.",
            "minimum": 1
          },
          "enable_pipelining": {
            "default": 100,
            "type": "integer",
            "description": "The maximum number of HTTP requests that can be sent before an HTTP response is received.<br/><br/>Setting this to 1 is equivalent to turning off HTTP pipelining, and the EMQX must receive a response to the previous HTTP request before sending the next HTTP request.",
            "minimum": 1
          },
          "request": {
            "type": "object",
            "deprecated": true,
            "description": "This field is never used, so we deprecated it since 5.3.2.",
            "example": {}
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_http.connector_resource_opts"
          }
        },
        "type": "object"
      },
      "rule_engine.rule_metrics": {
        "required": [
          "id"
        ],
        "properties": {
          "id": {
            "type": "string",
            "description": "The ID of the rule",
            "example": "293fb66f"
          },
          "metrics": {
            "description": "The metrics of the rule",
            "$ref": "#/components/schemas/rule_engine.metrics"
          },
          "node_metrics": {
            "type": "array",
            "description": "The metrics of the rule for each node",
            "items": {
              "$ref": "#/components/schemas/rule_engine.node_metrics"
            }
          }
        },
        "type": "object"
      },
      "rule_engine.ctx_sub": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "type": "string",
            "enum": [
              "session_subscribed"
            ],
            "description": "Event Type"
          },
          "clientid": {
            "type": "string",
            "description": "The Client ID"
          },
          "username": {
            "type": "string",
            "description": "Username"
          },
          "payload": {
            "type": "string",
            "description": "The Message Payload"
          },
          "peerhost": {
            "type": "string",
            "description": "The IP Address of the Peer Client"
          },
          "topic": {
            "type": "string",
            "description": "Message Topic"
          },
          "publish_received_at": {
            "type": "integer",
            "description": "The Time that this Message is Received"
          },
          "qos": {
            "maximum": 2,
            "type": "integer",
            "description": "The Message QoS",
            "minimum": 0,
            "example": 0
          }
        },
        "type": "object"
      },
      "modules.delayed": {
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable this feature"
          },
          "max_delayed_messages": {
            "default": 0,
            "type": "integer",
            "description": "Maximum number of delayed messages (0 is no limit)."
          }
        },
        "type": "object"
      },
      "plugins.builder": {
        "properties": {
          "contact": {
            "type": "string",
            "example": "emqx-support@emqx.io"
          },
          "name": {
            "type": "string",
            "example": "EMQX Team"
          },
          "website": {
            "type": "string",
            "example": "www.emqx.com"
          }
        },
        "type": "object"
      },
      "exhook.hook_info": {
        "properties": {
          "name": {
            "type": "string",
            "description": "The hook's name"
          },
          "params": {
            "description": "The parameters used when the hook is registered",
            "properties": {
              "$name": {
                "type": "string"
              }
            },
            "type": "object"
          }
        },
        "type": "object"
      },
      "bridge_mqtt_publisher.action_parameters": {
        "required": [
          "topic"
        ],
        "properties": {
          "topic": {
            "type": "string",
            "description": "Forward to which topic of the remote broker.<br/><br/>Template with variables is allowed."
          },
          "qos": {
            "default": 1,
            "description": "The QoS of the MQTT message to be sent.<br/><br/>Template with variables is allowed.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "maximum": 2,
                "type": "integer",
                "minimum": 0,
                "example": 0
              }
            ]
          },
          "retain": {
            "default": false,
            "description": "The 'retain' flag of the MQTT message to be sent.<br/><br/>Template with variables is allowed.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "boolean"
              }
            ]
          },
          "payload": {
            "type": "string",
            "description": "The payload of the MQTT message to be sent.<br/><br/>Template with variables is allowed."
          }
        },
        "type": "object"
      },
      "retainer.retainer": {
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable retainer feature"
          },
          "msg_expiry_interval": {
            "default": "0s",
            "type": "string",
            "description": "Expired retained messages will not be delivered again, and a setting of 0 means that retained messages will never expire.<br/><br/>However, if the `Message-Expiry-Interval` property is specified in the MQTT message, the value of that property prevails.",
            "example": "32s"
          },
          "msg_clear_interval": {
            "default": "0s",
            "type": "string",
            "description": "The time interval for checking and clearing expired retained messages. This can prevent expired retained messages from being stored for a long time.<br/><br/>If `msg_clear_interval` is set to 0, that is, expired retained messages are not actively checked regularly, EMQX will only check and delete expired retained messages when preparing for delivery.",
            "example": "32s"
          },
          "max_payload_size": {
            "default": "1MB",
            "type": "string",
            "description": "The maximum size of retained messages allowed to be stored. EMQX will refuse to store retained messages larger than this size and output an Error log with the keyword 'retain_failed_for_payload_size_exceeded_limit'.<br/><br/>0 means unlimited retained message size.",
            "example": "32MB"
          },
          "stop_publish_clear_msg": {
            "default": false,
            "type": "boolean",
            "description": "When the retained flag of the `PUBLISH` message is set and Payload is empty,<br/>whether to continue to publish the message.<br/>See:<br/>http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038"
          },
          "delivery_rate": {
            "default": "1000/s",
            "type": "string",
            "description": "The maximum rate of delivering retained messages",
            "example": "1000/s"
          },
          "backend": {
            "description": "Settings for the database storing the retained messages.",
            "$ref": "#/components/schemas/retainer.mnesia_config"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_data_backup.backup_file_info": {
        "required": [
          "created_at",
          "filename",
          "node"
        ],
        "properties": {
          "node": {
            "type": "string",
            "description": "Node name"
          },
          "filename": {
            "type": "string",
            "description": "Data backup file name"
          },
          "created_at": {
            "type": "string",
            "description": "Data backup file creation date and time"
          }
        },
        "type": "object"
      },
      "emqx.sysmon": {
        "properties": {
          "vm": {
            "$ref": "#/components/schemas/emqx.sysmon_vm"
          },
          "os": {
            "$ref": "#/components/schemas/emqx.sysmon_os"
          }
        },
        "type": "object"
      },
      "bridge_http.connector_resource_opts": {
        "properties": {
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "start_after_created": {
            "default": true,
            "type": "boolean",
            "description": "Whether start the resource right after created."
          },
          "start_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "example": "32s"
          }
        },
        "type": "object"
      },
      "authn.postgresql": {
        "required": [
          "backend",
          "database",
          "mechanism",
          "query",
          "server",
          "username"
        ],
        "properties": {
          "mechanism": {
            "type": "string",
            "enum": [
              "password_based"
            ],
            "description": "Authentication mechanism."
          },
          "backend": {
            "type": "string",
            "enum": [
              "postgresql"
            ],
            "description": "Backend type."
          },
          "password_hash_algorithm": {
            "default": {
              "name": "sha256",
              "salt_position": "prefix"
            },
            "description": "Options for password hash verification.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn_hash.simple"
              },
              {
                "$ref": "#/components/schemas/authn_hash.pbkdf2"
              },
              {
                "$ref": "#/components/schemas/authn_hash.bcrypt"
              }
            ]
          },
          "query": {
            "type": "string",
            "description": "SQL used to query data for authentication, such as password hash."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider."
          },
          "server": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The PostgreSQL default port 5432 is used if `[:Port]` is not specified."
          },
          "disable_prepared_statements": {
            "default": false,
            "type": "boolean",
            "description": "Disables the usage of prepared statements in the connections.<br/>Some endpoints, like PGBouncer or Supabase in Transaction mode, do not<br/>support session features such as prepared statements.  For such connections,<br/>this option should be enabled."
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "connector_mqtt.egress": {
        "required": [
          "remote"
        ],
        "properties": {
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the pool of MQTT clients that will publish messages to the remote broker.<br/><br/>Each MQTT client will be assigned 'clientid' of the form '${clientid_prefix}:${bridge_name}:egress:${node}:${n}'<br/>where 'n' is the number of a client inside the pool.",
            "minimum": 1
          },
          "local": {
            "description": "The configs about receiving messages from local broker.",
            "$ref": "#/components/schemas/connector_mqtt.egress_local"
          },
          "remote": {
            "description": "The configs about sending message to the remote broker.",
            "$ref": "#/components/schemas/connector_mqtt.egress_remote"
          }
        },
        "type": "object"
      },
      "exhook.node_metrics": {
        "properties": {
          "node": {
            "type": "string",
            "description": "Node name"
          },
          "metrics": {
            "description": "Metrics information",
            "$ref": "#/components/schemas/exhook.metrics"
          }
        },
        "type": "object"
      },
      "exhook.move_req": {
        "required": [
          "position"
        ],
        "properties": {
          "position": {
            "type": "string",
            "description": "The target position to be moved",
            "example": "front"
          }
        },
        "type": "object"
      },
      "emqx_authz_schema.resource_metrics": {
        "properties": {
          "matched": {
            "type": "integer",
            "description": "Count of this resource is queried."
          },
          "success": {
            "type": "integer",
            "description": "Count of query success."
          },
          "failed": {
            "type": "integer",
            "description": "Count of query failed."
          },
          "rate": {
            "type": "number",
            "description": "The rate of matched, times/second."
          },
          "rate_max": {
            "type": "number",
            "description": "The max rate of matched, times/second."
          },
          "rate_last5m": {
            "type": "number",
            "description": "The average rate of matched in the last 5 minutes, times/second."
          }
        },
        "type": "object"
      },
      "emqx_authz_schema.node_error": {
        "properties": {
          "node": {
            "type": "string",
            "description": "Node name.",
            "example": "emqx@127.0.0.1"
          },
          "error": {
            "type": "string",
            "description": "The error of node."
          }
        },
        "type": "object"
      },
      "exhook.node_status": {
        "properties": {
          "node": {
            "type": "string",
            "description": "Node name"
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "connecting",
              "disconnected",
              "disabled",
              "error"
            ],
            "description": "The status of Exhook server.<br/><br/>connected: connection succeeded<br/><br/>connecting: connection failed, reconnecting<br/><br/>disconnected: failed to connect and didn't reconnect<br/><br/>disabled: this server is disabled<br/><br/>error: failed to view the status of this server"
          }
        },
        "type": "object"
      },
      "listeners.ws_required_bind": {
        "required": [
          "bind",
          "id",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "ws"
            ],
            "description": "Listener type"
          },
          "running": {
            "type": "boolean",
            "description": "Listener status"
          },
          "id": {
            "type": "string",
            "description": "Listener id"
          },
          "current_connections": {
            "type": "integer",
            "description": "Current connections",
            "minimum": 0
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable listener."
          },
          "bind": {
            "default": 8083,
            "type": "string",
            "description": "IP address and port for the listening socket.",
            "example": "127.0.0.1:80"
          },
          "acceptors": {
            "default": 16,
            "type": "integer",
            "description": "The size of the listener's receiving pool.",
            "minimum": 1
          },
          "max_connections": {
            "default": "infinity",
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "type": "string",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message<br/>is delivered to the subscriber. The mountpoint is a way that users can use<br/>to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`<br/>set to `some_tenant`, then the client actually subscribes to the topic<br/>`some_tenant/t`. Similarly, if another client B (connected to the same listener<br/>as the client A) sends a message to topic `t`, the message is routed<br/>to all the clients subscribed `some_tenant/t`, so client A will receive the<br/>message, with topic name `t`.<br/><br/>Set to `\"\"` to disable the feature.<br/><br/><br/>Variables in mountpoint string:<br/>  - <code>${clientid}</code>: clientid<br/>  - <code>${username}</code>: username"
          },
          "zone": {
            "default": "default",
            "type": "string",
            "description": "The configuration zone to which the listener belongs.<br/>Clients connected to this listener will inherit zone-settings created under this zone name.<br/><br/>A zone can override the configs under below root names:<br/>- `mqtt`<br/>- `force_shutdown`<br/>- `force_gc`<br/>- `flapping_detect`<br/>- `durable_sessions`"
          },
          "enable_authn": {
            "default": true,
            "type": "string",
            "enum": [
              true,
              false,
              "quick_deny_anonymous"
            ],
            "description": "Set <code>true</code> (default) to enable client authentication on this listener, the authentication<br/>process goes through the configured authentication chain.<br/>When set to <code>false</code>, any client (with or without username/password) is allowed to connect.<br/>When set to <code>quick_deny_anonymous</code>, it behaves like when set to <code>true</code>, but clients will be<br/>denied immediately without going through any authenticators if <code>username</code> is not provided. This is useful to fence off<br/>anonymous clients early."
          },
          "max_conn_rate": {
            "default": "infinity",
            "type": "string",
            "description": "Used to limit the rate at which the current listener accepts connections.<br/><br/>Once the limit is reached, EMQX will pause fetching connections from the Accept queue, thereby delaying or rejecting new connections.<br/><br/>For example:<br/><br/>- `1000/s`: Only accepts 1000 connections per second.<br/>- `1000/10s`: Only accepts 1000 connections every 10 seconds.",
            "example": "1000/s"
          },
          "messages_rate": {
            "type": "string",
            "description": "Used to limit the number of messages a single client can send to EMQX per second.<br/><br/>Once the limit is reached, EMQX will pause reading data from the receive-buffer, thus slowing down or even temporarily hanging the sender.<br/><br/>For example:<br/><br/>- `500/s`: Only 500 messages will be received per second, and the remaining messages will be delayed.<br/>- `500/10s`: Only 500 messages will be received every 10 seconds and the remaining messages will be delayed.",
            "example": "1000/s"
          },
          "bytes_rate": {
            "type": "string",
            "description": "Used to limit the number of bytes a single client can send to EMQX per second.<br/><br/>Once the limit is reached, EMQX will pause reading data from the receive-buffer, thus slowing down or even temporarily hanging the sender.<br/><br/>The unit of the bytes could be: B, KB, MB, GB.<br/><br/>For example:<br/><br/>- `500KB/s`: Only 500 kilobytes per second will be received, and the remaining bytes will be delayed.<br/>- `500MB/10s`: Only 500 megabytes will be received every 10 seconds, and the remaining bytes will be delayed.",
            "example": "100MB/s"
          },
          "access_rules": {
            "default": [
              "allow all"
            ],
            "type": "array",
            "description": "An access rule list consisting of string rules to restrict or allow access from some addresses. The rules that appear earlier in the list are matched first.<br/>The format is `allow | deny <address> | <CIDR> | all`.<br/><br/>For example:<br/><br/>`[\\\"deny 192.168.1.1\\\", \\\"allow 192.168.1.0/24\\\", \\\"deny, all\\\"]`",
            "items": {
              "type": "string"
            }
          },
          "proxy_protocol": {
            "default": false,
            "type": "boolean",
            "description": "Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.<br/><br/>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "type": "string",
            "description": "If a reverse proxy is deployed for EMQX, and the PROXY protocol is enabled at the proxy to pass the client's real IP, this option needs to be turned on so that EMQX can extract the client's real IP from the PROXY protocol header.<br/><br/>EMQX will automatically detect the version of the PROXY protocol and support V1 and V2.<br/><br/>For a detailed description of the PROXY protocol, please refer to: https://www.haproxy.com/blog/haproxy/proxy-protocol/",
            "example": "12m"
          },
          "tcp_options": {
            "$ref": "#/components/schemas/emqx.tcp_opts"
          },
          "websocket": {
            "$ref": "#/components/schemas/emqx.ws_opts"
          }
        },
        "type": "object"
      },
      "authn.redis_single": {
        "required": [
          "backend",
          "cmd",
          "mechanism",
          "server"
        ],
        "properties": {
          "mechanism": {
            "type": "string",
            "enum": [
              "password_based"
            ],
            "description": "Authentication mechanism."
          },
          "backend": {
            "type": "string",
            "enum": [
              "redis"
            ],
            "description": "Backend type."
          },
          "cmd": {
            "type": "string",
            "description": "The Redis Command used to query data for authentication such as password hash, currently only supports <code>HGET</code> and <code>HMGET</code>."
          },
          "password_hash_algorithm": {
            "default": {
              "name": "sha256",
              "salt_position": "prefix"
            },
            "description": "Options for password hash verification.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn_hash.simple"
              },
              {
                "$ref": "#/components/schemas/authn_hash.pbkdf2"
              },
              {
                "$ref": "#/components/schemas/authn_hash.bcrypt"
              }
            ]
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider."
          },
          "server": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The Redis default port 6379 is used if `[:Port]` is not specified."
          },
          "redis_type": {
            "default": "single",
            "type": "string",
            "enum": [
              "single"
            ],
            "description": "Single mode. Must be set to 'single' when Redis server is running in single mode."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "database": {
            "default": 0,
            "type": "integer",
            "description": "Redis database ID.",
            "minimum": 0
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "listeners.listener_type_status": {
        "required": [
          "enable",
          "ids",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "tcp",
              "ssl",
              "ws",
              "wss",
              "quic"
            ],
            "description": "Listener type"
          },
          "enable": {
            "type": "boolean",
            "description": "Listener enable"
          },
          "ids": {
            "type": "array",
            "description": "Listener Ids",
            "items": {
              "type": "string"
            }
          },
          "status": {
            "$ref": "#/components/schemas/listeners.status"
          },
          "node_status": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/listeners.node_status"
            }
          }
        },
        "type": "object"
      },
      "gateway.translator": {
        "required": [
          "topic"
        ],
        "properties": {
          "topic": {
            "type": "string",
            "description": "Topic Name"
          },
          "qos": {
            "default": 0,
            "maximum": 2,
            "type": "integer",
            "description": "QoS Level",
            "minimum": 0,
            "example": 0
          }
        },
        "type": "object"
      },
      "rule_engine.ctx_check_authz_complete": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "type": "string",
            "enum": [
              "client_check_authz_complete"
            ],
            "description": "Event Type"
          },
          "clientid": {
            "type": "string",
            "description": "The Client ID"
          },
          "username": {
            "type": "string",
            "description": "Username"
          },
          "peerhost": {
            "type": "string",
            "description": "The IP Address of the Peer Client"
          },
          "topic": {
            "type": "string",
            "description": "Message Topic"
          },
          "action": {
            "type": "string",
            "description": "Publish or Subscribe"
          },
          "authz_source": {
            "type": "string",
            "description": "Cache, Plugs or Default"
          },
          "result": {
            "type": "string",
            "description": "Allow or Deny"
          }
        },
        "type": "object"
      },
      "gateway.ssl_server_opts": {
        "properties": {
          "cacertfile": {
            "default": "${EMQX_ETC_DIR}/certs/cacert.pem",
            "type": "string",
            "description": "Trusted PEM format CA certificates bundle file.<br/><br/>The certificates in this file are used to verify the TLS peer's certificates.<br/>Append new certificates to the file if new CAs are to be trusted.<br/>There is no need to restart EMQX to have the updated file loaded, because<br/>the system regularly checks if file has been updated (and reload).<br/><br/>NOTE: invalidating (deleting) a certificate from the file will not affect<br/>already established connections."
          },
          "cacerts": {
            "default": false,
            "type": "boolean",
            "deprecated": true
          },
          "certfile": {
            "default": "${EMQX_ETC_DIR}/certs/cert.pem",
            "type": "string",
            "description": "PEM format certificates chain file.<br/><br/>The certificates in this file should be in reversed order of the certificate<br/>issue chain. That is, the host's certificate should be placed in the beginning<br/>of the file, followed by the immediate issuer certificate and so on.<br/>Although the root CA certificate is optional, it should be placed at the end of<br/>the file if it is to be added."
          },
          "keyfile": {
            "default": "${EMQX_ETC_DIR}/certs/key.pem",
            "type": "string",
            "description": "PEM format private key file."
          },
          "verify": {
            "default": "verify_none",
            "type": "string",
            "enum": [
              "verify_peer",
              "verify_none"
            ],
            "description": "Enable or disable peer verification."
          },
          "reuse_sessions": {
            "default": true,
            "type": "boolean",
            "description": "Enable TLS session reuse.<br/><br/>Has no effect when TLS version is configured (or negotiated) to 1.3"
          },
          "depth": {
            "default": 10,
            "type": "integer",
            "description": "Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path.<br/>So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly;<br/><br/>if 1 the path can be PEER, Intermediate-CA, ROOT-CA;<br/><br/>if 2 the path can be PEER, Intermediate-CA1, Intermediate-CA2, ROOT-CA.",
            "minimum": 0
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "String containing the user's password. Only used if the private key file is password-protected.",
            "example": ""
          },
          "versions": {
            "default": [
              "tlsv1.3",
              "tlsv1.2"
            ],
            "type": "array",
            "description": "All TLS/DTLS versions to be supported.<br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.<br/><br/>In case PSK cipher suites are intended, make sure to configure<br/><code>['tlsv1.2', 'tlsv1.1']</code> here.",
            "items": {
              "type": "string"
            }
          },
          "ciphers": {
            "default": [],
            "type": "array",
            "description": "This config holds TLS cipher suite names separated by comma,<br/>or as an array of strings. e.g.<br/><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or<br/><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.<br/><br/><br/>Ciphers (and their ordering) define the way in which the<br/>client and server encrypts information over the network connection.<br/>Selecting a good cipher suite is critical for the<br/>application's data security, confidentiality and performance.<br/><br/>The names should be in OpenSSL string format (not RFC format).<br/>All default values and examples provided by EMQX config<br/>documentation are all in OpenSSL format.<br/><br/><br/>NOTE: Certain cipher suites are only compatible with<br/>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')<br/>incompatible cipher suites will be silently dropped.<br/>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,<br/>configuring cipher suites for other versions will have no effect.<br/><br/><br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br/><br/>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.<br/><br/>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,<br/>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,<br/>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,<br/>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code>",
            "items": {
              "type": "string"
            }
          },
          "secure_renegotiate": {
            "default": true,
            "type": "boolean",
            "description": "Whether to reject TLS renegotiation attempts that are not compliant with [RFC 5746](http://www.ietf.org/rfc/rfc5746.txt).<br/><br/>By default, `secure_renegotiate` is set to `true`, which forces secure renegotiation.<br/>If set to `false`, secure renegotiation will still be used, but will fall back to insecure renegotiation if the peer does not support [RFC 5746](http://www.ietf.org/rfc/rfc5746.txt), which increases the risk of a MitM attack.<br/><br/>Has no effect when TLS version is configured (or negotiated) to 1.3."
          },
          "log_level": {
            "default": "notice",
            "type": "string",
            "enum": [
              "emergency",
              "alert",
              "critical",
              "error",
              "warning",
              "notice",
              "info",
              "debug",
              "none",
              "all"
            ],
            "description": "The minimum level of logging allowed for SSL output.<br/><br/>The default is `notice`, set to a lower `debug` level for more detailed logging that can be used to investigate SSL handshake issues."
          },
          "hibernate_after": {
            "default": "5s",
            "type": "string",
            "description": "Specifies the amount of time that an SSL process will hibernate after being idle, thus reducing its memory footprint.<br/><br/>The hibernating process will be woken up when a new message arrives.<br/>Hibernating and waking up too often can cause CPU utilization to increase, as they both perform garbage collection on the process.",
            "example": "12m"
          },
          "dhfile": {
            "type": "string",
            "description": "Path to a file containing PEM-encoded Diffie-Hellman parameters<br/>to be used by the server if a cipher suite using Diffie-Hellman<br/>key exchange is negotiated. If not specified, default parameters<br/>are used.<br/><br/>NOTE: The <code>dhfile</code> option is not supported by TLS 1.3."
          },
          "fail_if_no_peer_cert": {
            "default": false,
            "type": "boolean",
            "description": "This option is only effective if `verify` is set to `verify_peer`.<br/><br/>If set to `true`, EMQX will reject the connection if the client fails to provide a certificate.<br/><br/>If set to `false`, EMQX will accept clients which don't present a certificate."
          },
          "honor_cipher_order": {
            "default": true,
            "type": "boolean",
            "description": "An important security setting. If this setting is enabled, the server will prioritize the cipher suites it prefers most from the list of cipher suites supported by the client, thus ignoring the client's preferences.<br/><br/>The server's cipher suites are specified by `ciphers`, with preference decreasing from left to right.<br/><br/>It is often better to use the server's preferences, as it is more likely that the server will be configured correctly."
          },
          "client_renegotiation": {
            "default": true,
            "type": "boolean",
            "description": "In protocols that support client-initiated renegotiation,<br/>the cost of resources of such an operation is higher for the server than the client.<br/>This can act as a vector for denial of service attacks.<br/>The SSL application already takes measures to counter-act such attempts,<br/>but client-initiated renegotiation can be strictly disabled by setting this option to false.<br/>The default value is true. Note that disabling renegotiation can result in<br/>long-lived connections becoming unusable due to limits on<br/>the number of messages the underlying cipher suite can encipher.<br/><br/>Has no effect when TLS version is configured (or negotiated) to 1.3"
          },
          "handshake_timeout": {
            "default": "15s",
            "type": "string",
            "description": "Maximum time duration allowed for the handshake to complete",
            "example": "12m"
          }
        },
        "type": "object"
      },
      "rule_engine.ctx_unsub": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "type": "string",
            "enum": [
              "session_unsubscribed"
            ],
            "description": "Event Type"
          },
          "clientid": {
            "type": "string",
            "description": "The Client ID"
          },
          "username": {
            "type": "string",
            "description": "Username"
          },
          "payload": {
            "type": "string",
            "description": "The Message Payload"
          },
          "peerhost": {
            "type": "string",
            "description": "The IP Address of the Peer Client"
          },
          "topic": {
            "type": "string",
            "description": "Message Topic"
          },
          "publish_received_at": {
            "type": "integer",
            "description": "The Time that this Message is Received"
          },
          "qos": {
            "maximum": 2,
            "type": "integer",
            "description": "The Message QoS",
            "minimum": 0,
            "example": 0
          }
        },
        "type": "object"
      },
      "authz.redis_single": {
        "required": [
          "cmd",
          "server",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "redis"
            ],
            "description": "Backend type."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Set to <code>true</code> or <code>false</code> to disable this ACL provider"
          },
          "server": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The Redis default port 6379 is used if `[:Port]` is not specified."
          },
          "redis_type": {
            "default": "single",
            "type": "string",
            "enum": [
              "single"
            ],
            "description": "Single mode. Must be set to 'single' when Redis server is running in single mode."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "database": {
            "default": 0,
            "type": "integer",
            "description": "Redis database ID.",
            "minimum": 0
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "cmd": {
            "type": "string",
            "description": "Database query used to retrieve authorization data.",
            "example": "HGETALL mqtt_authz"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_sources.sources": {
        "properties": {
          "sources": {
            "type": "array",
            "description": "Authorization data sources.<br/><br/>An array of authorization (ACL) data providers.<br/>It is designed as an array, not a hash-map, so the sources can be<br/>ordered to form a chain of access controls.<br/><br/><br/>When authorizing a 'publish' or 'subscribe' action, the configured<br/>sources are checked in order. When checking an ACL source,<br/>in case the client (identified by username or client ID) is not found,<br/>it moves on to the next source. And it stops immediately<br/>once an 'allow' or 'deny' decision is returned.<br/><br/><br/>If the client is not found in any of the sources,<br/>the default action configured in 'authorization.no_match' is applied.<br/><br/><br/>NOTE:<br/>The source elements are identified by their 'type'.<br/>It is NOT allowed to configure two or more sources of the same type.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/authz.ldap"
                },
                {
                  "$ref": "#/components/schemas/authz.mongo_sharded"
                },
                {
                  "$ref": "#/components/schemas/authz.mongo_rs"
                },
                {
                  "$ref": "#/components/schemas/authz.mongo_single"
                },
                {
                  "$ref": "#/components/schemas/authz.postgresql"
                },
                {
                  "$ref": "#/components/schemas/authz.mysql"
                },
                {
                  "$ref": "#/components/schemas/authz.redis_cluster"
                },
                {
                  "$ref": "#/components/schemas/authz.redis_sentinel"
                },
                {
                  "$ref": "#/components/schemas/authz.redis_single"
                },
                {
                  "$ref": "#/components/schemas/authz.http_post"
                },
                {
                  "$ref": "#/components/schemas/authz.http_get"
                },
                {
                  "$ref": "#/components/schemas/authz.builtin_db"
                },
                {
                  "$ref": "#/components/schemas/authz.api_file"
                }
              ]
            }
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_alarms.alarm": {
        "properties": {
          "node": {
            "type": "string",
            "description": "The name of the node that triggered this alarm.",
            "example": "emqx@127.0.0.1"
          },
          "name": {
            "type": "string",
            "description": "The name of the node that triggered this alarm.",
            "example": "high_system_memory_usage"
          },
          "message": {
            "type": "string",
            "description": "Alarm message, which describes the alarm content in a human-readable format.",
            "example": "System memory usage is higher than 70%"
          },
          "details": {
            "type": "object",
            "description": "Alarm details, provides more alarm information, mainly for program processing.",
            "example": {
              "high_watermark": 70
            }
          },
          "duration": {
            "type": "integer",
            "description": "Indicates how long the alarm has been active in milliseconds.",
            "example": 297056
          },
          "activate_at": {
            "type": "string",
            "description": "Alarm start time, using rfc3339 standard time format.",
            "example": "2021-10-25T11:52:52.548+08:00"
          },
          "deactivate_at": {
            "type": "string",
            "description": "Alarm end time, using rfc3339 standard time format.",
            "example": "2021-10-31T10:52:52.548+08:00"
          }
        },
        "type": "object"
      },
      "bridge_http.action_resource_opts": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "maximum": 1024,
            "type": "integer",
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 1
          },
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "query_mode": {
            "default": "async",
            "type": "string",
            "enum": [
              "sync",
              "async"
            ],
            "description": "Query mode. Optional 'sync/async', default 'async'."
          },
          "request_ttl": {
            "default": "45s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "string",
                "example": "32s"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "type": "integer",
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "type": "string",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB"
          }
        },
        "type": "object"
      },
      "connector.node_status": {
        "properties": {
          "node": {
            "type": "string",
            "description": "The node name.",
            "example": "emqx@127.0.0.1"
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ]
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a connector is failing to connect.",
            "example": "Connection refused"
          }
        },
        "type": "object"
      },
      "authn.ldap_deprecated": {
        "required": [
          "backend",
          "base_dn",
          "mechanism",
          "server",
          "username"
        ],
        "properties": {
          "mechanism": {
            "type": "string",
            "enum": [
              "password_based"
            ],
            "description": "Authentication mechanism."
          },
          "backend": {
            "type": "string",
            "enum": [
              "ldap"
            ],
            "description": "Backend type."
          },
          "query_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Timeout for the LDAP query.",
            "example": "32s"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider."
          },
          "server": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The LDAP default port 389 is used if `[:Port]` is not specified."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "base_dn": {
            "type": "string",
            "description": "The name of the base object entry (or possibly the root) relative to<br/>which the Search is to be performed.",
            "example": "uid=${username},ou=testdevice,dc=emqx,dc=io"
          },
          "filter": {
            "default": "(objectClass=mqttUser)",
            "type": "string",
            "description": "The filter that defines the conditions that must be fulfilled in order<br/>for the Search to match a given entry.<br><br/>The syntax of the filter follows RFC 4515 and also supports placeholders.",
            "example": "(& (objectClass=mqttUser) (uid=${username}))"
          },
          "request_timeout": {
            "default": "10s",
            "type": "string",
            "description": "Sets the maximum time in milliseconds that is used for each individual request.",
            "example": "32s"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/ldap.ssl"
          },
          "password_attribute": {
            "default": "userPassword",
            "type": "string",
            "description": "Indicates which attribute is used to represent the user's password."
          },
          "is_superuser_attribute": {
            "default": "isSuperuser",
            "type": "string",
            "description": "Indicates which attribute is used to represent whether the user is a superuser."
          }
        },
        "type": "object"
      },
      "emqx_dashboard_monitor_api.sampler_current_node": {
        "properties": {
          "dropped_msg_rate": {
            "type": "integer",
            "description": "Dropped messages per 10 seconds"
          },
          "sent_msg_rate": {
            "type": "integer",
            "description": "Sent messages per 10 seconds"
          },
          "persisted_rate": {
            "type": "integer",
            "description": "Messages saved to the durable storage per 10 seconds"
          },
          "received_msg_rate": {
            "type": "integer",
            "description": "Dropped messages per 10 seconds"
          },
          "transformation_failed_rate": {
            "type": "integer",
            "description": "Message transformations failed per 10 seconds"
          },
          "transformation_succeeded_rate": {
            "type": "integer",
            "description": "Message transformations succeeded per 10 seconds"
          },
          "validation_failed_rate": {
            "type": "integer",
            "description": "Schema validations failed per 10 seconds"
          },
          "validation_succeeded_rate": {
            "type": "integer",
            "description": "Schema validations succeeded per 10 seconds"
          },
          "disconnected_durable_sessions": {
            "type": "integer",
            "description": "Disconnected durable sessions at the time of sampling. Can only represent an approximate state."
          },
          "subscriptions_durable": {
            "type": "integer",
            "description": "Subscriptions from durable sessions at the time of sampling. Can only represent an approximate state."
          },
          "subscriptions": {
            "type": "integer",
            "description": "Subscriptions at the time of sampling. Can only represent an approximate state."
          },
          "topics": {
            "type": "integer",
            "description": "Count topics at the time of sampling. Can only represent an approximate state."
          },
          "connections": {
            "type": "integer",
            "description": "Sessions at the time of sampling. Can only represent an approximate state."
          },
          "live_connections": {
            "type": "integer",
            "description": "Connections at the time of sampling. Can only represent an approximate state."
          },
          "node_uptime": {
            "type": "integer",
            "description": "Node up time in seconds. Only presented in endpoint: `/monitor_current/nodes/:node`."
          },
          "retained_msg_count": {
            "type": "integer",
            "description": "Retained messages count at the time of sampling. Can only represent an approximate state."
          },
          "shared_subscriptions": {
            "type": "integer",
            "description": "Shared subscriptions count at the time of sampling. Can only represent an approximate state."
          }
        },
        "type": "object"
      },
      "authn.mongo_single": {
        "required": [
          "backend",
          "collection",
          "database",
          "mechanism",
          "mongo_type",
          "server"
        ],
        "properties": {
          "mechanism": {
            "type": "string",
            "enum": [
              "password_based"
            ],
            "description": "Authentication mechanism."
          },
          "backend": {
            "type": "string",
            "enum": [
              "mongodb"
            ],
            "description": "Backend type."
          },
          "collection": {
            "type": "string",
            "description": "Collection used to store authentication data."
          },
          "filter": {
            "default": {},
            "type": "object",
            "description": "Conditional expression that defines the filter condition in the query.<br/>Filter supports the following placeholders:<br/>- <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting<br/>- <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting",
            "example": {}
          },
          "password_hash_field": {
            "default": "password_hash",
            "type": "string",
            "description": "Document field that contains password hash."
          },
          "salt_field": {
            "default": "salt",
            "type": "string",
            "description": "Document field that contains the password salt."
          },
          "is_superuser_field": {
            "default": "is_superuser",
            "type": "string",
            "description": "Document field that defines if the user has superuser privileges."
          },
          "password_hash_algorithm": {
            "default": {
              "name": "sha256",
              "salt_position": "prefix"
            },
            "description": "Options for password hash verification.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn_hash.simple"
              },
              {
                "$ref": "#/components/schemas/authn_hash.pbkdf2"
              },
              {
                "$ref": "#/components/schemas/authn_hash.bcrypt"
              }
            ]
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider."
          },
          "mongo_type": {
            "default": "single",
            "type": "string",
            "enum": [
              "single"
            ],
            "description": "Standalone instance. Must be set to 'single' when MongoDB server is running in standalone mode."
          },
          "server": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The MongoDB default port 27017 is used if `[:Port]` is not specified."
          },
          "w_mode": {
            "default": "unsafe",
            "type": "string",
            "enum": [
              "unsafe",
              "safe"
            ],
            "description": "Write mode."
          },
          "srv_record": {
            "default": false,
            "type": "boolean",
            "description": "Use DNS SRV record."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "use_legacy_protocol": {
            "default": "auto",
            "type": "string",
            "enum": [
              "auto",
              true,
              false
            ],
            "description": "Whether to use MongoDB's legacy protocol for communicating with the database.  The default is to attempt to automatically determine if the newer protocol is supported."
          },
          "auth_source": {
            "type": "string",
            "description": "Database name associated with the user's credentials."
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "topology": {
            "$ref": "#/components/schemas/mongo.topology"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "bridge_mqtt_publisher.put_source": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "parameters": {
            "$ref": "#/components/schemas/bridge_mqtt_publisher.ingress_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_mqtt_publisher.source_resource_opts"
          }
        },
        "type": "object"
      },
      "mongo.topology": {
        "properties": {
          "max_overflow": {
            "default": 0,
            "type": "integer",
            "description": "The maximum number of additional workers that can be created when all workers in the pool are busy. This helps to manage temporary spikes in workload by allowing more concurrent connections to the MongoDB server.",
            "minimum": 0
          },
          "overflow_ttl": {
            "type": "string",
            "description": "Period of time before workers that exceed the configured pool size (\"overflow\") to be terminated.",
            "example": "32s"
          },
          "overflow_check_period": {
            "type": "string",
            "description": "Period for checking if there are more workers than configured (\"overflow\").",
            "example": "32s"
          },
          "local_threshold_ms": {
            "type": "string",
            "description": "The size of the latency window for selecting among multiple suitable MongoDB instances.",
            "example": "32s"
          },
          "connect_timeout_ms": {
            "type": "string",
            "description": "The duration to attempt a connection before timing out.",
            "example": "32s"
          },
          "socket_timeout_ms": {
            "type": "string",
            "description": "The duration to attempt to send or to receive on a socket before the attempt times out.",
            "example": "32s"
          },
          "server_selection_timeout_ms": {
            "type": "string",
            "description": "Specifies how long to block for server selection before throwing an exception.",
            "example": "32s"
          },
          "wait_queue_timeout_ms": {
            "type": "string",
            "description": "The maximum duration that a worker can wait for a connection to become available.",
            "example": "32s"
          },
          "heartbeat_frequency_ms": {
            "default": "200s",
            "type": "string",
            "description": "Controls when the driver checks the state of the MongoDB deployment. Specify the interval between checks, counted from the end of the previous check until the beginning of the next one. If the number of connections is increased (which will happen, for example, if you increase the pool size), you may need to increase this period as well to avoid creating too many log entries in the MongoDB log file.",
            "example": "32s"
          },
          "min_heartbeat_frequency_ms": {
            "type": "string",
            "description": "Controls the minimum amount of time to wait between heartbeats.",
            "example": "32s"
          }
        },
        "type": "object"
      },
      "emqx.log_throttling": {
        "properties": {
          "time_window": {
            "default": "1m",
            "type": "string",
            "description": "This configuration setting controls the logging behavior for throttled messages,<br/>including, but not limited to messages like 'authorization_permission_denied'.<br/>Within each defined time window, only one instance of a throttled message will be logged to prevent log flooding.<br/>At the conclusion of each time window, a summary log will be generated, detailing the occurrence of any throttled messages during that period.<br/>It's important to note that the shortest effective time window for this setting is 1 second (`1s`).<br/>Should a value lower than `1s` be specified, it will automatically be adjusted to `1s`.",
            "example": "1h"
          }
        },
        "type": "object"
      },
      "authz.mysql": {
        "required": [
          "database",
          "query",
          "server",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "mysql"
            ],
            "description": "Backend type."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Set to <code>true</code> or <code>false</code> to disable this ACL provider"
          },
          "server": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The MySQL default port 3306 is used if `[:Port]` is not specified."
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "default": "root",
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "prepare_statement": {
            "type": "object",
            "description": "Key-value list of SQL prepared statements.",
            "example": {}
          },
          "query": {
            "type": "string",
            "description": "Database query used to retrieve authorization data."
          }
        },
        "type": "object"
      },
      "bridge_http.get": {
        "required": [
          "name",
          "type",
          "url"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "webhook",
              "http"
            ],
            "description": "The action type."
          },
          "name": {
            "type": "string",
            "description": "Action name, used as a human-readable identifier."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this action."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "connect_timeout": {
            "default": "15s",
            "type": "string",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s"
          },
          "retry_interval": {
            "type": "string",
            "deprecated": true,
            "example": "12m"
          },
          "pool_type": {
            "default": "random",
            "type": "string",
            "enum": [
              "random",
              "hash"
            ],
            "description": "The type of the pool. Can be one of `random`, `hash`."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "The pool size.",
            "minimum": 1
          },
          "enable_pipelining": {
            "default": 100,
            "type": "integer",
            "description": "The maximum number of HTTP requests that can be sent before an HTTP response is received.<br/><br/>Setting this to 1 is equivalent to turning off HTTP pipelining, and the EMQX must receive a response to the previous HTTP request before sending the next HTTP request.",
            "minimum": 1
          },
          "request": {
            "type": "object",
            "deprecated": true,
            "description": "This field is never used, so we deprecated it since 5.3.2.",
            "example": {}
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "url": {
            "type": "string",
            "description": "The URL of the HTTP action.<br/><br/>Template with variables is allowed in the path, but variables cannot be used in the scheme, host,<br/>or port part.<br/><br/>For example, <code> http://localhost:9901/${topic} </code> is allowed, but<br/><code> http://${host}:9901/message </code> or <code> http://localhost:${port}/message </code><br/>is not allowed."
          },
          "direction": {
            "type": "string",
            "enum": [
              "egress"
            ],
            "deprecated": true
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to the HTTP server. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: If this action is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "method": {
            "default": "post",
            "type": "string",
            "enum": [
              "post",
              "put",
              "get",
              "delete"
            ],
            "description": "The method of the HTTP request. All the available methods are: post, put, get, delete.<br/><br/>Template with variables is allowed."
          },
          "headers": {
            "default": {
              "accept": "application/json",
              "cache-control": "no-cache",
              "connection": "keep-alive",
              "content-type": "application/json",
              "keep-alive": "timeout=5"
            },
            "type": "object",
            "description": "The headers of the HTTP request.<br/><br/>Template with variables is allowed.",
            "example": {},
            "is_template": true
          },
          "body": {
            "type": "string",
            "description": "The body of the HTTP request.<br/><br/>If not provided, the body will be a JSON object of all the available fields.<br/><br/>There, 'all the available fields' means the context of a MQTT message when<br/>this webhook is triggered by receiving a MQTT message (the `local_topic` is set),<br/>or the context of the event when this webhook is triggered by a rule (i.e. this<br/>webhook is used as an action of a rule).<br/><br/>Template with variables is allowed."
          },
          "max_retries": {
            "default": 2,
            "type": "integer",
            "description": "HTTP request max retry times if failed.",
            "minimum": 0
          },
          "request_timeout": {
            "default": "15s",
            "type": "string",
            "deprecated": true,
            "description": "HTTP request timeout.",
            "example": "32s"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_http.v1_resource_opts"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_sources.position": {
        "required": [
          "position"
        ],
        "properties": {
          "position": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "exhook.detail_server_info": {
        "required": [
          "name",
          "url"
        ],
        "properties": {
          "metrics": {
            "description": "Metrics information of this server in the current node",
            "$ref": "#/components/schemas/exhook.metrics"
          },
          "node_metrics": {
            "type": "array",
            "description": "Metrics information of this server in all nodes",
            "items": {
              "$ref": "#/components/schemas/exhook.node_metrics"
            }
          },
          "node_status": {
            "type": "array",
            "description": "status of this server in all nodes",
            "items": {
              "$ref": "#/components/schemas/exhook.node_status"
            }
          },
          "hooks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/exhook.hook_info"
            }
          },
          "name": {
            "type": "string",
            "description": "Name of the exhook server",
            "example": "default"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable this Exhook server"
          },
          "url": {
            "type": "string",
            "description": "URL of the gRPC server",
            "example": "http://127.0.0.1:9000"
          },
          "request_timeout": {
            "default": "5s",
            "type": "string",
            "description": "The timeout of request gRPC server",
            "example": "12m"
          },
          "failed_action": {
            "default": "deny",
            "type": "string",
            "enum": [
              "deny",
              "ignore"
            ],
            "description": "The value that is returned when the request to the gRPC server fails for any reason"
          },
          "ssl": {
            "$ref": "#/components/schemas/exhook.ssl_conf"
          },
          "socket_options": {
            "default": {
              "keepalive": true,
              "nodelay": true
            },
            "$ref": "#/components/schemas/exhook.socket_options"
          },
          "auto_reconnect": {
            "default": "60s",
            "description": "Whether to automatically reconnect (initialize) the gRPC server.<br/>When gRPC is not available, Exhook tries to request the gRPC service at that interval and reinitialize the list of mounted hooks.",
            "oneOf": [
              {
                "type": "string",
                "example": "12m"
              },
              {
                "type": "string",
                "enum": [
                  false
                ]
              }
            ]
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "The process pool size for gRPC client",
            "minimum": 1
          }
        },
        "type": "object"
      },
      "authn.bind_method": {
        "properties": {
          "type": {
            "default": "bind",
            "type": "string",
            "enum": [
              "bind"
            ],
            "description": "Authentication method type."
          },
          "bind_password": {
            "default": "${password}",
            "type": "string",
            "description": "The template for password to bind.",
            "example": "${password}"
          }
        },
        "type": "object"
      },
      "emqx_dashboard_monitor_api.sampler": {
        "properties": {
          "time_stamp": {
            "type": "integer",
            "description": "Timestamp",
            "minimum": 0
          },
          "disconnected_durable_sessions": {
            "type": "integer",
            "description": "Disconnected durable sessions at the time of sampling. Can only represent an approximate state."
          },
          "subscriptions_durable": {
            "type": "integer",
            "description": "Subscriptions from durable sessions at the time of sampling. Can only represent an approximate state."
          },
          "subscriptions": {
            "type": "integer",
            "description": "Subscriptions at the time of sampling. Can only represent an approximate state."
          },
          "topics": {
            "type": "integer",
            "description": "Count topics at the time of sampling. Can only represent an approximate state."
          },
          "connections": {
            "type": "integer",
            "description": "Sessions at the time of sampling. Can only represent an approximate state."
          },
          "live_connections": {
            "type": "integer",
            "description": "Connections at the time of sampling. Can only represent an approximate state."
          },
          "received": {
            "type": "integer",
            "description": "Received messages last 10 seconds"
          },
          "sent": {
            "type": "integer",
            "description": "Sent messages last 10 seconds"
          },
          "validation_succeeded": {
            "type": "integer",
            "description": "Schema validations succeeded last 10 seconds"
          },
          "validation_failed": {
            "type": "integer",
            "description": "Schema validations failed last 10 seconds"
          },
          "transformation_succeeded": {
            "type": "integer",
            "description": "Message transformations succeeded last 10 seconds"
          },
          "transformation_failed": {
            "type": "integer",
            "description": "Message transformations failed last 10 seconds"
          },
          "dropped": {
            "type": "integer",
            "description": "Dropped messages last 10 seconds"
          },
          "persisted": {
            "type": "integer",
            "description": "Messages saved to the durable storage last 10 seconds"
          }
        },
        "type": "object"
      },
      "rule_engine.ctx_delivery_dropped": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "type": "string",
            "enum": [
              "delivery_dropped"
            ],
            "description": "Event Type"
          },
          "id": {
            "type": "string",
            "description": "Message ID"
          },
          "reason": {
            "type": "string",
            "description": "The Reason for Dropping"
          },
          "from_clientid": {
            "type": "string",
            "description": "The Client ID"
          },
          "from_username": {
            "type": "string",
            "description": "The User Name"
          },
          "clientid": {
            "type": "string",
            "description": "The Client ID"
          },
          "username": {
            "type": "string",
            "description": "Username"
          },
          "payload": {
            "type": "string",
            "description": "The Message Payload"
          },
          "peerhost": {
            "type": "string",
            "description": "The IP Address of the Peer Client"
          },
          "topic": {
            "type": "string",
            "description": "Message Topic"
          },
          "publish_received_at": {
            "type": "integer",
            "description": "The Time that this Message is Received"
          },
          "qos": {
            "maximum": 2,
            "type": "integer",
            "description": "The Message QoS",
            "minimum": 0,
            "example": 0
          }
        },
        "type": "object"
      },
      "authn.jwt_public_key": {
        "required": [
          "algorithm",
          "mechanism",
          "public_key"
        ],
        "properties": {
          "algorithm": {
            "type": "string",
            "enum": [
              "public-key"
            ],
            "description": "JWT signing algorithm, Supports HMAC (configured as <code>hmac-based</code>) and RSA, ECDSA (configured as <code>public-key</code>)."
          },
          "public_key": {
            "type": "string",
            "description": "The public key used to verify the JWT."
          },
          "mechanism": {
            "type": "string",
            "enum": [
              "jwt"
            ],
            "description": "Authentication mechanism."
          },
          "acl_claim_name": {
            "default": "acl",
            "type": "string",
            "description": "The JWT claim designated for accessing ACL (Access Control List) rules can be specified,<br/>such as using the `acl` claim. A typical decoded JWT with this claim might appear as:<br/>`{\"username\": \"user1\", \"acl\": ...}`.<br/><br/>Supported ACL Rule Formats:<br/><br/>- Object Format:<br/>  Utilizes action types pub (publish), sub (subscribe), or all (both publish and subscribe).<br/>  The value is a list of topic filters.<br/>  Example: `{\"pub\": [\"topic1\"], \"sub\": [], \"all\": [\"${username}/#\"]}`.<br/>  This example signifies that the token owner can publish to topic1 and perform both publish and subscribe<br/>  actions on topics starting with their username.<br/>  Note: In this format, if no topic matches, the action is denied, and the authorization process terminates.<br/><br/>- Array Format (resembles File-Based ACL Rules):<br/>  Example: `[{\"permission\": \"allow\", \"action\": \"all\", \"topic\": \"${username}/#\"}]`.<br/>  Additionally, the `pub` or `publish` action rules can be extended with `qos` and `retain` field,<br/>  and `sub` or `subscribe` action rules can be extended with a `qos` field.<br/>  Note: Here, if no rule matches, the action is not immediately denied.<br/>  The process continues to other configured authorization sources,<br/>  and ultimately falls back to the default permission in config `authorization.no_match`.<br/><br/>The ACL claim utilizes MQTT topic wildcard matching rules for publishing or subscribing.<br/>A special syntax for the 'subscribe' action allows the use of `eq` for an exact match.<br/>For instance, `eq t/#` permits or denies subscription to `t/#`, but not to `t/1`."
          },
          "verify_claims": {
            "default": {},
            "type": "object",
            "description": "A list of custom claims to validate. The allowed formats are the following:<br/>A map where claim names are map keys and expected values are map values:<br/> <code>{ claim_name = \"${username}\", ...}</code>.<br/><br/>A list of maps with <code>name</code> (claim name) and <code>value</code> (expected claim value) keys:<br/> <code>[{name = \"claim_name\", value = \"${username}\"}, ...]</code>.<br/><br/>Values can use the following placeholders:<br/>- <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting<br/>- <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting<br/><br/>Authentication will verify that the value of claims in the JWT (taken from the Password field) matches what is required in <code>verify_claims</code>.",
            "example": {}
          },
          "disconnect_after_expire": {
            "default": true,
            "type": "boolean",
            "description": "Disconnect the client after the token expires."
          },
          "from": {
            "default": "password",
            "type": "string",
            "enum": [
              "username",
              "password"
            ],
            "description": "Field to take JWT from."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider."
          }
        },
        "type": "object"
      },
      "emqx_authn_api.response_user": {
        "required": [
          "user_id"
        ],
        "properties": {
          "user_id": {
            "type": "string"
          },
          "is_superuser": {
            "default": false,
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "rule_engine.rule_test": {
        "required": [
          "sql"
        ],
        "properties": {
          "context": {
            "default": {},
            "description": "The context of the event for testing",
            "oneOf": [
              {
                "$ref": "#/components/schemas/rule_engine.ctx_message_transformation_failed"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_schema_validation_failed"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_delivery_dropped"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_bridge_mqtt"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_check_authn_complete"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_check_authz_complete"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_connack"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_disconnected"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_connected"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_dropped"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_acked"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_delivered"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_unsub"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_sub"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_pub"
              }
            ]
          },
          "sql": {
            "type": "string",
            "description": "The SQL of the rule for testing"
          }
        },
        "type": "object"
      },
      "authn_hash.bcrypt_rw": {
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "enum": [
              "bcrypt"
            ],
            "description": "BCRYPT password hashing."
          },
          "salt_rounds": {
            "default": 10,
            "maximum": 10,
            "type": "integer",
            "description": "Work factor for BCRYPT password generation.",
            "minimum": 5,
            "example": 10
          }
        },
        "type": "object"
      },
      "exhook.metrics": {
        "properties": {
          "succeed": {
            "type": "integer",
            "description": "The number of times the hooks execution successful"
          },
          "failed": {
            "type": "integer",
            "description": "The number of times the hook execution failed"
          },
          "rate": {
            "type": "integer",
            "description": "The call rate of hooks"
          },
          "max_rate": {
            "type": "integer",
            "description": "Maximum call rate of hooks"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_clients.clients": {
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/emqx_mgmt_api_clients.client"
            }
          },
          "meta": {
            "$ref": "#/components/schemas/public.meta"
          }
        },
        "type": "object"
      },
      "emqx_authn_api.request_authn_order": {
        "required": [
          "id"
        ],
        "properties": {
          "id": {
            "type": "string",
            "description": "Authenticator ID.",
            "example": "password_based:built_in_database"
          }
        },
        "type": "object"
      },
      "dashboard.listeners": {
        "properties": {
          "http": {
            "description": "TCP listeners",
            "$ref": "#/components/schemas/dashboard.http"
          },
          "https": {
            "description": "SSL listeners",
            "$ref": "#/components/schemas/dashboard.https"
          }
        },
        "type": "object"
      },
      "listeners.tcp_required_bind": {
        "required": [
          "bind",
          "id",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "tcp"
            ],
            "description": "Listener type"
          },
          "running": {
            "type": "boolean",
            "description": "Listener status"
          },
          "id": {
            "type": "string",
            "description": "Listener id"
          },
          "current_connections": {
            "type": "integer",
            "description": "Current connections",
            "minimum": 0
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable listener."
          },
          "bind": {
            "default": 1883,
            "type": "string",
            "description": "IP address and port for the listening socket.",
            "example": "127.0.0.1:80"
          },
          "acceptors": {
            "default": 16,
            "type": "integer",
            "description": "The size of the listener's receiving pool.",
            "minimum": 1
          },
          "max_connections": {
            "default": "infinity",
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "type": "string",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message<br/>is delivered to the subscriber. The mountpoint is a way that users can use<br/>to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`<br/>set to `some_tenant`, then the client actually subscribes to the topic<br/>`some_tenant/t`. Similarly, if another client B (connected to the same listener<br/>as the client A) sends a message to topic `t`, the message is routed<br/>to all the clients subscribed `some_tenant/t`, so client A will receive the<br/>message, with topic name `t`.<br/><br/>Set to `\"\"` to disable the feature.<br/><br/><br/>Variables in mountpoint string:<br/>  - <code>${clientid}</code>: clientid<br/>  - <code>${username}</code>: username"
          },
          "zone": {
            "default": "default",
            "type": "string",
            "description": "The configuration zone to which the listener belongs.<br/>Clients connected to this listener will inherit zone-settings created under this zone name.<br/><br/>A zone can override the configs under below root names:<br/>- `mqtt`<br/>- `force_shutdown`<br/>- `force_gc`<br/>- `flapping_detect`<br/>- `durable_sessions`"
          },
          "enable_authn": {
            "default": true,
            "type": "string",
            "enum": [
              true,
              false,
              "quick_deny_anonymous"
            ],
            "description": "Set <code>true</code> (default) to enable client authentication on this listener, the authentication<br/>process goes through the configured authentication chain.<br/>When set to <code>false</code>, any client (with or without username/password) is allowed to connect.<br/>When set to <code>quick_deny_anonymous</code>, it behaves like when set to <code>true</code>, but clients will be<br/>denied immediately without going through any authenticators if <code>username</code> is not provided. This is useful to fence off<br/>anonymous clients early."
          },
          "max_conn_rate": {
            "default": "infinity",
            "type": "string",
            "description": "Used to limit the rate at which the current listener accepts connections.<br/><br/>Once the limit is reached, EMQX will pause fetching connections from the Accept queue, thereby delaying or rejecting new connections.<br/><br/>For example:<br/><br/>- `1000/s`: Only accepts 1000 connections per second.<br/>- `1000/10s`: Only accepts 1000 connections every 10 seconds.",
            "example": "1000/s"
          },
          "messages_rate": {
            "type": "string",
            "description": "Used to limit the number of messages a single client can send to EMQX per second.<br/><br/>Once the limit is reached, EMQX will pause reading data from the receive-buffer, thus slowing down or even temporarily hanging the sender.<br/><br/>For example:<br/><br/>- `500/s`: Only 500 messages will be received per second, and the remaining messages will be delayed.<br/>- `500/10s`: Only 500 messages will be received every 10 seconds and the remaining messages will be delayed.",
            "example": "1000/s"
          },
          "bytes_rate": {
            "type": "string",
            "description": "Used to limit the number of bytes a single client can send to EMQX per second.<br/><br/>Once the limit is reached, EMQX will pause reading data from the receive-buffer, thus slowing down or even temporarily hanging the sender.<br/><br/>The unit of the bytes could be: B, KB, MB, GB.<br/><br/>For example:<br/><br/>- `500KB/s`: Only 500 kilobytes per second will be received, and the remaining bytes will be delayed.<br/>- `500MB/10s`: Only 500 megabytes will be received every 10 seconds, and the remaining bytes will be delayed.",
            "example": "100MB/s"
          },
          "access_rules": {
            "default": [
              "allow all"
            ],
            "type": "array",
            "description": "An access rule list consisting of string rules to restrict or allow access from some addresses. The rules that appear earlier in the list are matched first.<br/>The format is `allow | deny <address> | <CIDR> | all`.<br/><br/>For example:<br/><br/>`[\\\"deny 192.168.1.1\\\", \\\"allow 192.168.1.0/24\\\", \\\"deny, all\\\"]`",
            "items": {
              "type": "string"
            }
          },
          "proxy_protocol": {
            "default": false,
            "type": "boolean",
            "description": "Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.<br/><br/>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "type": "string",
            "description": "If a reverse proxy is deployed for EMQX, and the PROXY protocol is enabled at the proxy to pass the client's real IP, this option needs to be turned on so that EMQX can extract the client's real IP from the PROXY protocol header.<br/><br/>EMQX will automatically detect the version of the PROXY protocol and support V1 and V2.<br/><br/>For a detailed description of the PROXY protocol, please refer to: https://www.haproxy.com/blog/haproxy/proxy-protocol/",
            "example": "12m"
          },
          "tcp_options": {
            "$ref": "#/components/schemas/emqx.tcp_opts"
          }
        },
        "type": "object"
      },
      "gateway.exproto_grpc_handler": {
        "required": [
          "address",
          "service_name"
        ],
        "properties": {
          "address": {
            "type": "string",
            "description": "gRPC server address."
          },
          "service_name": {
            "default": "ConnectionUnaryHandler",
            "description": "The service name to handle the connection events.<br/>In the initial version, we expected to use streams to improve the efficiency<br/>of requests in `ConnectionHandler`. But unfortunately, events between different<br/>streams are out of order. It causes the `OnSocketCreated` event to may arrive<br/>later than `OnReceivedBytes`.<br/>So we added the `ConnectionUnaryHandler` service since v5.0.25 and forced<br/>the use of Unary in it to avoid ordering problems.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "ConnectionUnaryHandler"
                ]
              },
              {
                "type": "string",
                "enum": [
                  "ConnectionHandler"
                ]
              }
            ]
          },
          "ssl_options": {
            "description": "SSL configuration for the gRPC client.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "rule_engine.rule_apply_test": {
        "properties": {
          "context": {
            "default": {},
            "description": "The context of the event for testing",
            "oneOf": [
              {
                "$ref": "#/components/schemas/rule_engine.ctx_message_transformation_failed"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_schema_validation_failed"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_delivery_dropped"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_bridge_mqtt"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_check_authn_complete"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_check_authz_complete"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_connack"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_disconnected"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_connected"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_dropped"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_acked"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_delivered"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_unsub"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_sub"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_pub"
              }
            ]
          },
          "stop_action_after_template_rendering": {
            "default": true,
            "type": "boolean",
            "description": "Set this to true if the action should be stopped after its template has been rendered (default is true)."
          }
        },
        "type": "object"
      },
      "emqx.event_names": {
        "properties": {
          "client_connected": {
            "default": true,
            "type": "boolean",
            "description": "Enable to publish client connected event messages"
          },
          "client_disconnected": {
            "default": true,
            "type": "boolean",
            "description": "Enable to publish client disconnected event messages."
          },
          "client_subscribed": {
            "default": false,
            "type": "boolean",
            "description": "Enable to publish event message that client subscribed a topic successfully."
          },
          "client_unsubscribed": {
            "default": false,
            "type": "boolean",
            "description": "Enable to publish event message that client unsubscribed a topic successfully."
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_publish.bad_request": {
        "properties": {
          "code": {
            "type": "string",
            "description": "BAD_REQUEST",
            "example": 144
          },
          "message": {
            "type": "string",
            "description": "Describes the failure reason in detail.",
            "example": "topic_name_invalid"
          }
        },
        "type": "object"
      },
      "emqx.tcp_opts": {
        "properties": {
          "active_n": {
            "default": 100,
            "type": "integer",
            "description": "Specify the {active, N} option for this Socket.<br/><br/>See: https://erlang.org/doc/man/inet.html#setopts-2",
            "minimum": 0
          },
          "backlog": {
            "default": 1024,
            "type": "integer",
            "description": "TCP backlog defines the maximum length that the queue of<br/>pending connections can grow to.",
            "minimum": 1
          },
          "send_timeout": {
            "default": "15s",
            "type": "string",
            "description": "The maximum time a process is suspended for sending data to a busy socket. After the timeout, the TCP connection and the process will be closed.<br/><br/>The process is unsuspended only when the socket is unbusy, that is, the data accumulated in the Erlang internal buffer drops from the high watermark (specified by `high_watermark`) to the low watermark (default 4 KB).<br/><br/>Therefore, `(high_watermark - 4 KB) / send_timeout` must be a suitable message outflow speed, otherwise the suspended process will never be able to recover before the timeout.",
            "example": "12m"
          },
          "send_timeout_close": {
            "default": true,
            "type": "boolean",
            "description": "Close the connection if send timeout."
          },
          "recbuf": {
            "type": "string",
            "description": "The TCP receive buffer (OS kernel) for the connections.",
            "example": "2KB"
          },
          "sndbuf": {
            "type": "string",
            "description": "The TCP send buffer (OS kernel) for the connections.",
            "example": "4KB"
          },
          "buffer": {
            "default": "4KB",
            "type": "string",
            "description": "The size of the user-space buffer used by the driver.",
            "example": "4KB"
          },
          "high_watermark": {
            "default": "1MB",
            "type": "string",
            "description": "When EMQX tries to send more data than the OS has allocated for the socket's send buffer, the remaining data will be temporarily stored in Erlang's internal buffer and then sent in the background.<br/><br/>If the amount of data queued in the internal buffer exceeds `high_watermark`, the corresponding socket will be marked as busy.<br/><br/>The process sending data to this busy socket will be suspended until the socket is no longer busy, or the suspension time exceeds `send_timeout`.<br/><br/>The socket will only be unbusy when the data in the internal buffer is below the low watermark.<br/><br/>While the process is suspended, the message queue of the process may accumulate, see `max_mailbox_len` for details.",
            "example": "32MB"
          },
          "nodelay": {
            "default": true,
            "type": "boolean",
            "description": "The TCP_NODELAY flag for the connections."
          },
          "reuseaddr": {
            "default": true,
            "type": "boolean",
            "description": "The SO_REUSEADDR flag for the connections."
          },
          "keepalive": {
            "default": "none",
            "type": "string",
            "description": "Enable TCP keepalive for MQTT connections over TCP or SSL.<br/>The value is three comma separated numbers in the format of 'Idle,Interval,Probes'<br/> - Idle: The number of seconds a connection needs to be idle before the server begins to send out keep-alive probes (Linux default 7200).<br/> - Interval: The number of seconds between TCP keep-alive probes (Linux default 75).<br/> - Probes: The maximum number of TCP keep-alive probes to send before giving up and killing the connection if no response is obtained from the other end (Linux default 9).<br/>For example \"240,30,5\" means: EMQX should start sending TCP keepalive probes after the connection is in idle for 240 seconds, and the probes are sent every 30 seconds until a response is received from the MQTT client, if it misses 5 consecutive responses, EMQX should close the connection.<br/>Default: 'none'"
          }
        },
        "type": "object"
      },
      "listeners.with_name_quic_required_bind": {
        "required": [
          "bind",
          "name",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "quic"
            ],
            "description": "Listener type"
          },
          "running": {
            "type": "boolean",
            "description": "Listener status"
          },
          "name": {
            "type": "string",
            "description": "Listener name"
          },
          "current_connections": {
            "type": "integer",
            "description": "Current connections",
            "minimum": 0
          },
          "ciphers": {
            "default": [
              "TLS_AES_256_GCM_SHA384",
              "TLS_AES_128_GCM_SHA256",
              "TLS_CHACHA20_POLY1305_SHA256"
            ],
            "type": "array",
            "description": "This config holds TLS cipher suite names separated by comma,<br/>or as an array of strings. e.g.<br/><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or<br/><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.<br/><br/><br/>Ciphers (and their ordering) define the way in which the<br/>client and server encrypts information over the network connection.<br/>Selecting a good cipher suite is critical for the<br/>application's data security, confidentiality and performance.<br/><br/>The names should be in OpenSSL string format (not RFC format).<br/>All default values and examples provided by EMQX config<br/>documentation are all in OpenSSL format.<br/><br/><br/>NOTE: Certain cipher suites are only compatible with<br/>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')<br/>incompatible cipher suites will be silently dropped.<br/>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,<br/>configuring cipher suites for other versions will have no effect.<br/><br/><br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br/><br/>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.<br/><br/>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,<br/>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,<br/>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,<br/>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code><br/><br/><br/>NOTE: QUIC listener supports only 'tlsv1.3' ciphers",
            "items": {
              "type": "string"
            }
          },
          "ssl_options": {
            "description": "TLS options for QUIC transport",
            "$ref": "#/components/schemas/emqx.listener_quic_ssl_opts"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable listener."
          },
          "bind": {
            "default": 14567,
            "type": "string",
            "description": "IP address and port for the listening socket.",
            "example": "127.0.0.1:80"
          },
          "acceptors": {
            "default": 16,
            "type": "integer",
            "description": "The size of the listener's receiving pool.",
            "minimum": 1
          },
          "max_connections": {
            "default": "infinity",
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "type": "string",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message<br/>is delivered to the subscriber. The mountpoint is a way that users can use<br/>to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`<br/>set to `some_tenant`, then the client actually subscribes to the topic<br/>`some_tenant/t`. Similarly, if another client B (connected to the same listener<br/>as the client A) sends a message to topic `t`, the message is routed<br/>to all the clients subscribed `some_tenant/t`, so client A will receive the<br/>message, with topic name `t`.<br/><br/>Set to `\"\"` to disable the feature.<br/><br/><br/>Variables in mountpoint string:<br/>  - <code>${clientid}</code>: clientid<br/>  - <code>${username}</code>: username"
          },
          "zone": {
            "default": "default",
            "type": "string",
            "description": "The configuration zone to which the listener belongs.<br/>Clients connected to this listener will inherit zone-settings created under this zone name.<br/><br/>A zone can override the configs under below root names:<br/>- `mqtt`<br/>- `force_shutdown`<br/>- `force_gc`<br/>- `flapping_detect`<br/>- `durable_sessions`"
          },
          "enable_authn": {
            "default": true,
            "type": "string",
            "enum": [
              true,
              false,
              "quick_deny_anonymous"
            ],
            "description": "Set <code>true</code> (default) to enable client authentication on this listener, the authentication<br/>process goes through the configured authentication chain.<br/>When set to <code>false</code>, any client (with or without username/password) is allowed to connect.<br/>When set to <code>quick_deny_anonymous</code>, it behaves like when set to <code>true</code>, but clients will be<br/>denied immediately without going through any authenticators if <code>username</code> is not provided. This is useful to fence off<br/>anonymous clients early."
          },
          "max_conn_rate": {
            "default": "infinity",
            "type": "string",
            "description": "Used to limit the rate at which the current listener accepts connections.<br/><br/>Once the limit is reached, EMQX will pause fetching connections from the Accept queue, thereby delaying or rejecting new connections.<br/><br/>For example:<br/><br/>- `1000/s`: Only accepts 1000 connections per second.<br/>- `1000/10s`: Only accepts 1000 connections every 10 seconds.",
            "example": "1000/s"
          },
          "messages_rate": {
            "type": "string",
            "description": "Used to limit the number of messages a single client can send to EMQX per second.<br/><br/>Once the limit is reached, EMQX will pause reading data from the receive-buffer, thus slowing down or even temporarily hanging the sender.<br/><br/>For example:<br/><br/>- `500/s`: Only 500 messages will be received per second, and the remaining messages will be delayed.<br/>- `500/10s`: Only 500 messages will be received every 10 seconds and the remaining messages will be delayed.",
            "example": "1000/s"
          },
          "bytes_rate": {
            "type": "string",
            "description": "Used to limit the number of bytes a single client can send to EMQX per second.<br/><br/>Once the limit is reached, EMQX will pause reading data from the receive-buffer, thus slowing down or even temporarily hanging the sender.<br/><br/>The unit of the bytes could be: B, KB, MB, GB.<br/><br/>For example:<br/><br/>- `500KB/s`: Only 500 kilobytes per second will be received, and the remaining bytes will be delayed.<br/>- `500MB/10s`: Only 500 megabytes will be received every 10 seconds, and the remaining bytes will be delayed.",
            "example": "100MB/s"
          }
        },
        "type": "object"
      },
      "authz.mongo_sharded": {
        "required": [
          "collection",
          "database",
          "mongo_type",
          "servers",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "mongodb"
            ],
            "description": "Backend type."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Set to <code>true</code> or <code>false</code> to disable this ACL provider"
          },
          "collection": {
            "type": "string",
            "description": "`MongoDB` collection containing the authorization data."
          },
          "filter": {
            "default": {},
            "type": "object",
            "description": "Conditional expression that defines the filter condition in the query.<br/>Filter supports the following placeholders<br/><br/> - <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting<br/><br/> - <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting",
            "example": {}
          },
          "mongo_type": {
            "default": "sharded",
            "type": "string",
            "enum": [
              "sharded"
            ],
            "description": "Sharded cluster. Must be set to 'sharded' when MongoDB server is running in 'sharded' mode."
          },
          "servers": {
            "type": "string",
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The MongoDB default port 27017 is used if `[:Port]` is not specified."
          },
          "w_mode": {
            "default": "unsafe",
            "type": "string",
            "enum": [
              "unsafe",
              "safe"
            ],
            "description": "Write mode."
          },
          "srv_record": {
            "default": false,
            "type": "boolean",
            "description": "Use DNS SRV record."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "use_legacy_protocol": {
            "default": "auto",
            "type": "string",
            "enum": [
              "auto",
              true,
              false
            ],
            "description": "Whether to use MongoDB's legacy protocol for communicating with the database.  The default is to attempt to automatically determine if the newer protocol is supported."
          },
          "auth_source": {
            "type": "string",
            "description": "Database name associated with the user's credentials."
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "topology": {
            "$ref": "#/components/schemas/mongo.topology"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "exhook.list_hook_info": {
        "properties": {
          "name": {
            "type": "string",
            "description": "The hook's name"
          },
          "params": {
            "description": "The parameters used when the hook is registered",
            "properties": {
              "$name": {
                "type": "string"
              }
            },
            "type": "object"
          },
          "metrics": {
            "description": "Metrics information of this hook in the current node",
            "$ref": "#/components/schemas/exhook.metrics"
          },
          "node_metrics": {
            "type": "array",
            "description": "Metrics information of this hook in all nodes",
            "items": {
              "$ref": "#/components/schemas/exhook.node_metrics"
            }
          }
        },
        "type": "object"
      },
      "emqx_gateway_api_listeners.udp_listener": {
        "properties": {
          "id": {
            "type": "string",
            "description": "Listener ID"
          },
          "type": {
            "type": "string",
            "enum": [
              "udp"
            ],
            "description": "Listener Type"
          },
          "name": {
            "type": "string",
            "description": "Listener Name"
          },
          "running": {
            "type": "boolean",
            "description": "Listener Running status"
          },
          "health_check": {
            "description": "Some Cloud platform use a `request-reply` mechanism to check whether a UDP port is healthy, here can configure this pair.",
            "$ref": "#/components/schemas/gateway.udp_health_check"
          },
          "udp_options": {
            "$ref": "#/components/schemas/gateway.udp_opts"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable the listener."
          },
          "bind": {
            "type": "string",
            "description": "The IP address and port that the listener will bind.",
            "example": "127.0.0.1:80"
          },
          "max_connections": {
            "default": 1024,
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "integer",
                "minimum": 1
              }
            ]
          },
          "max_conn_rate": {
            "default": 1000,
            "type": "integer",
            "description": "Maximum connections per second."
          },
          "enable_authn": {
            "default": true,
            "type": "boolean",
            "description": "Set <code>true</code> (default) to enable client authentication on this listener.<br/>When set to <code>false</code> clients will be allowed to connect without authentication."
          },
          "mountpoint": {
            "type": "string",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message is delivered to the subscriber.<br/>The mountpoint is a way that users can use to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,<br/>then the client actually subscribes to the topic `some_tenant/t`.<br/>Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,<br/>the message is routed to all the clients subscribed `some_tenant/t`,<br/>so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.<br/>Supported placeholders in mountpoint string:<br/><br/>  - <code>${clientid}</code>: clientid<br/><br/>  - <code>${username}</code>: username<br/><br/>  - <code>${endpoint_name}</code>: endpoint name"
          },
          "access_rules": {
            "default": [],
            "type": "array",
            "description": "An access rule list consisting of string rules to restrict or allow access from some addresses.<br/>The rules that appear earlier in the list are matched first.<br/>The format is `allow | deny <address> | <CIDR> | all`.<br/><br/>For example:<br/><br/>`[\\\"deny 192.168.1.1\\\", \\\"allow 192.168.1.0/24\\\", \\\"deny, all\\\"]`",
            "items": {
              "type": "string"
            }
          },
          "status": {
            "description": "listener status",
            "$ref": "#/components/schemas/listeners.status"
          },
          "node_status": {
            "type": "array",
            "description": "listener status of each node in the cluster",
            "items": {
              "$ref": "#/components/schemas/listeners.node_status"
            }
          }
        },
        "type": "object"
      },
      "emqx_authz_api_mnesia.rule_item": {
        "required": [
          "action",
          "permission",
          "topic"
        ],
        "properties": {
          "topic": {
            "type": "string",
            "description": "Rule on specific topic",
            "example": "test/topic/1"
          },
          "permission": {
            "type": "string",
            "enum": [
              "allow",
              "deny"
            ],
            "description": "Permission",
            "example": "allow"
          },
          "action": {
            "type": "string",
            "enum": [
              "publish",
              "subscribe",
              "all"
            ],
            "description": "Authorized action (publish/subscribe/all)",
            "example": "publish"
          },
          "qos": {
            "default": [
              0,
              1,
              2
            ],
            "type": "array",
            "description": "QoS of authorized action",
            "items": {
              "maximum": 2,
              "type": "integer",
              "minimum": 0,
              "example": 0
            }
          },
          "retain": {
            "default": "all",
            "description": "Retain flag of authorized action",
            "oneOf": [
              {
                "type": "boolean"
              },
              {
                "type": "string",
                "enum": [
                  "all"
                ]
              }
            ]
          }
        },
        "type": "object"
      },
      "prometheus.push_gateway": {
        "required": [
          "enable"
        ],
        "properties": {
          "enable": {
            "default": false,
            "type": "boolean",
            "description": "Enable or disable Pushgateway"
          },
          "url": {
            "default": "http://127.0.0.1:9091",
            "type": "string",
            "description": "URL of Pushgateway server. Pushgateway is optional, should not be configured if prometheus is to scrape EMQX."
          },
          "interval": {
            "default": "15s",
            "type": "string",
            "description": "Data reporting interval",
            "example": "32s"
          },
          "headers": {
            "default": {},
            "type": "object",
            "description": "An HTTP Headers when pushing to Push Gateway.<br/><br/>For example, <code> { Authorization = \"some-authz-tokens\"}</code>",
            "example": {}
          },
          "job_name": {
            "default": "${name}/instance/${name}~${host}",
            "type": "string",
            "description": "Job Name that is pushed to the Push Gateway. Available variables:<br/><br/>- ${name}: Name of EMQX node.<br/><br/>- ${host}: Host name of EMQX node.<br/><br/>For example, when the EMQX node name is <code>emqx@127.0.0.1</code> then the <code>name</code><br/>variable takes value <code>emqx</code> and the <code>host</code> variable takes value <code>127.0.0.1</code>.<br/>Default value is: <code>${name}/instance/${name}~${host}</code>"
          }
        },
        "type": "object"
      },
      "trace.trace": {
        "required": [
          "name",
          "type"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "Unique name of the trace. Only ASCII letters in a-z, A-Z, 0-9 and underscore '_' are allowed.",
            "example": "EMQX-TRACE-1"
          },
          "type": {
            "type": "string",
            "enum": [
              "clientid",
              "topic",
              "ip_address",
              "ruleid"
            ],
            "description": "Filter type",
            "example": "clientid"
          },
          "topic": {
            "type": "string",
            "description": "Specify the topic or topic filter if the trace 'type' is 'topic'.",
            "example": "/dev/#"
          },
          "clientid": {
            "type": "string",
            "description": "Specify the MQTT clientid if the trace 'type' is 'clientid'.",
            "example": "dev-001"
          },
          "ip_address": {
            "type": "string",
            "description": "Specify the client's IP address if the trace type is 'ip_address'.",
            "example": "127.0.0.1"
          },
          "ruleid": {
            "type": "string",
            "example": "my_rule"
          },
          "status": {
            "type": "string",
            "enum": [
              "running",
              "stopped",
              "waiting"
            ],
            "description": "trace status",
            "example": "running"
          },
          "payload_encode": {
            "default": "text",
            "type": "string",
            "enum": [
              "hex",
              "text",
              "hidden"
            ],
            "description": "Determine the format of the payload format in the trace file.<br/><br/>`text`: Text-based protocol or plain text protocol.<br/> It is recommended when payload is JSON encoded.<br/><br/>`hex`: Binary hexadecimal encode.It is recommended when payload is a custom binary protocol.<br/><br/>`hidden`: payload is obfuscated as `******`"
          },
          "start_at": {
            "description": "rfc3339 timestamp or epoch second",
            "example": "2021-11-04T18:17:38+08:00",
            "oneOf": [
              {
                "type": "integer",
                "description": "epoch-second",
                "example": 1640995200
              },
              {
                "type": "string",
                "format": "date-time",
                "example": "2022-01-01T00:00:00.000Z"
              }
            ]
          },
          "end_at": {
            "description": "rfc3339 timestamp or epoch second",
            "example": "2021-11-05T18:17:38+08:00",
            "oneOf": [
              {
                "type": "integer",
                "description": "epoch-second",
                "example": 1640995200
              },
              {
                "type": "string",
                "format": "date-time",
                "example": "2022-01-01T00:00:00.000Z"
              }
            ]
          },
          "log_size": {
            "type": "array",
            "description": "trace log size",
            "items": {
              "type": "object",
              "example": {}
            },
            "example": [
              {
                "node": "emqx@127.0.0.1",
                "size": 1024
              }
            ]
          },
          "formatter": {
            "description": "The formatter that will be used to format the trace log entries. Set this to text to format the log entries as plain text (default). Set it to json to format each log entry as a JSON object.",
            "example": "text",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "json"
                ]
              },
              {
                "type": "string",
                "enum": [
                  "text"
                ]
              }
            ]
          }
        },
        "type": "object"
      },
      "rule_engine.rule_info": {
        "required": [
          "id",
          "sql"
        ],
        "properties": {
          "id": {
            "type": "string",
            "description": "The ID of the rule",
            "example": "293fb66f"
          },
          "from": {
            "type": "array",
            "description": "The topics of the rule",
            "items": {
              "type": "string"
            },
            "example": "t/#"
          },
          "created_at": {
            "type": "string",
            "description": "The created time of the rule",
            "example": "2021-12-01T15:00:43.153+08:00"
          },
          "name": {
            "default": "",
            "type": "string",
            "description": "The name of the rule",
            "example": "foo"
          },
          "sql": {
            "type": "string",
            "description": "SQL query to transform the messages.<br/>Example: <code>SELECT * FROM \"test/topic\" WHERE payload.x = 1</code>",
            "example": "SELECT * FROM \"test/topic\" WHERE payload.x = 1"
          },
          "actions": {
            "default": [],
            "type": "array",
            "description": "A list of actions of the rule.<br/>An action can be a string that refers to the channel ID of an EMQX bridge, or an object<br/>that refers to a function.<br/>There a some built-in functions like \"republish\" and \"console\", and we also support user<br/>provided functions in the format: \"{module}:{function}\".<br/>The actions in the list are executed sequentially.<br/>This means that if one of the action is executing slowly, all the following actions will not<br/>be executed until it returns.<br/>If one of the action crashed, all other actions come after it will still be executed, in the<br/>original order.<br/>If there's any error when running an action, there will be an error message, and the 'failure'<br/>counter of the function action or the bridge channel will increase.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/rule_engine.user_provided_function"
                },
                {
                  "$ref": "#/components/schemas/rule_engine.builtin_action_console"
                },
                {
                  "$ref": "#/components/schemas/rule_engine.builtin_action_republish"
                },
                {
                  "type": "string"
                }
              ]
            },
            "example": [
              "webhook:my_webhook",
              {
                "args": {
                  "payload": "${payload}",
                  "topic": "t/1"
                },
                "function": "republish"
              },
              {
                "function": "console"
              }
            ]
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable the rule"
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "The description of the rule",
            "example": "Some description"
          },
          "metadata": {
            "type": "object",
            "description": "Rule metadata, do not change manually",
            "example": {}
          }
        },
        "type": "object"
      },
      "gateway.udp_opts": {
        "properties": {
          "active_n": {
            "default": 100,
            "type": "integer",
            "description": "Specify the {active, N} option for the socket.<br/>See: https://erlang.org/doc/man/inet.html#setopts-2"
          },
          "recbuf": {
            "type": "string",
            "description": "Size of the kernel-space receive buffer for the socket.",
            "example": "32MB"
          },
          "sndbuf": {
            "type": "string",
            "description": "Size of the kernel-space send buffer for the socket.",
            "example": "32MB"
          },
          "buffer": {
            "type": "string",
            "description": "Size of the user-space buffer for the socket.",
            "example": "32MB"
          },
          "reuseaddr": {
            "default": true,
            "type": "boolean",
            "description": "Allow local reuse of port numbers."
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.coap": {
        "properties": {
          "name": {
            "type": "string",
            "enum": [
              "coap"
            ],
            "description": "Gateway Name"
          },
          "heartbeat": {
            "default": "30s",
            "type": "string",
            "description": "The gateway server required minimum heartbeat interval.<br/>When connection mode is enabled, this parameter is used to set the minimum heartbeat interval for the connection to be alive",
            "example": "1h"
          },
          "connection_required": {
            "default": false,
            "type": "boolean",
            "description": "Enable or disable connection mode.<br/>Connection mode is a feature of non-standard protocols. When connection mode is enabled, it is necessary to maintain the creation, authentication and alive of connection resources"
          },
          "notify_type": {
            "default": "qos",
            "type": "string",
            "enum": [
              "non",
              "con",
              "qos"
            ],
            "description": "The Notification Message will be delivered to the CoAP client if a new message received on an observed topic.<br/>The type of delivered coap message can be set to:<br/><br/>  - non: Non-confirmable;<br/><br/>  - con: Confirmable;<br/><br/>  - qos: Mapping from QoS type of received message, QoS0 -> non, QoS1,2 -> con"
          },
          "subscribe_qos": {
            "default": "coap",
            "type": "string",
            "enum": [
              "qos0",
              "qos1",
              "qos2",
              "coap"
            ],
            "description": "The Default QoS Level indicator for subscribe request.<br/>This option specifies the QoS level for the CoAP Client when establishing a subscription membership, if the subscribe request is not carried `qos` option. The indicator can be set to:<br/><br/>  - qos0, qos1, qos2: Fixed default QoS level<br/><br/>  - coap: Dynamic QoS level by the message type of subscribe request<br/><br/>    * qos0: If the subscribe request is non-confirmable<br/><br/>    * qos1: If the subscribe request is confirmable"
          },
          "publish_qos": {
            "default": "coap",
            "type": "string",
            "enum": [
              "qos0",
              "qos1",
              "qos2",
              "coap"
            ],
            "description": "The Default QoS Level indicator for publish request.<br/>This option specifies the QoS level for the CoAP Client when publishing a message to EMQX PUB/SUB system, if the publish request is not carried `qos` option. The indicator can be set to:<br/><br/>  - qos0, qos1, qos2: Fixed default QoS level<br/><br/>  - coap: Dynamic QoS level by the message type of publish request<br/><br/>    * qos0: If the publish request is non-confirmable<br/><br/>    * qos1: If the publish request is confirmable"
          },
          "mountpoint": {
            "default": "",
            "type": "string",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message is delivered to the subscriber.<br/>The mountpoint is a way that users can use to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,<br/>then the client actually subscribes to the topic `some_tenant/t`.<br/>Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,<br/>the message is routed to all the clients subscribed `some_tenant/t`,<br/>so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.<br/>Supported placeholders in mountpoint string:<br/><br/>  - <code>${clientid}</code>: clientid<br/><br/>  - <code>${username}</code>: username<br/><br/>  - <code>${endpoint_name}</code>: endpoint name"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Whether to enable this gateway"
          },
          "enable_stats": {
            "default": true,
            "type": "boolean",
            "description": "Whether to enable client process statistic"
          },
          "idle_timeout": {
            "default": "30s",
            "type": "string",
            "description": "The idle time of the client connection process. It has two purposes:<br/>  1. A newly created client process that does not receive any client requests after that time will be closed directly.<br/>  2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.",
            "example": "12m"
          },
          "clientinfo_override": {
            "description": "ClientInfo override.",
            "$ref": "#/components/schemas/gateway.clientinfo_override"
          },
          "listeners": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/emqx_gateway_api.dtls_listener"
                },
                {
                  "$ref": "#/components/schemas/emqx_gateway_api.udp_listener"
                }
              ]
            }
          }
        },
        "type": "object"
      },
      "rule_engine.ctx_acked": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "type": "string",
            "enum": [
              "message_acked"
            ],
            "description": "Event Type"
          },
          "id": {
            "type": "string",
            "description": "Message ID"
          },
          "from_clientid": {
            "type": "string",
            "description": "The Client ID"
          },
          "from_username": {
            "type": "string",
            "description": "The User Name"
          },
          "clientid": {
            "type": "string",
            "description": "The Client ID"
          },
          "username": {
            "type": "string",
            "description": "Username"
          },
          "payload": {
            "type": "string",
            "description": "The Message Payload"
          },
          "peerhost": {
            "type": "string",
            "description": "The IP Address of the Peer Client"
          },
          "topic": {
            "type": "string",
            "description": "Message Topic"
          },
          "publish_received_at": {
            "type": "integer",
            "description": "The Time that this Message is Received"
          },
          "qos": {
            "maximum": 2,
            "type": "integer",
            "description": "The Message QoS",
            "minimum": 0,
            "example": 0
          }
        },
        "type": "object"
      },
      "emqx_gateway_api_listeners.dtls_listener": {
        "properties": {
          "id": {
            "type": "string",
            "description": "Listener ID"
          },
          "type": {
            "type": "string",
            "enum": [
              "dtls"
            ],
            "description": "Listener Type"
          },
          "name": {
            "type": "string",
            "description": "Listener Name"
          },
          "running": {
            "type": "boolean",
            "description": "Listener Running status"
          },
          "acceptors": {
            "default": 16,
            "type": "integer",
            "description": "Size of the acceptor pool."
          },
          "health_check": {
            "description": "Some Cloud platform use a `request-reply` mechanism to check whether a UDP port is healthy, here can configure this pair.",
            "$ref": "#/components/schemas/gateway.udp_health_check"
          },
          "udp_options": {
            "$ref": "#/components/schemas/gateway.udp_opts"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable the listener."
          },
          "bind": {
            "type": "string",
            "description": "The IP address and port that the listener will bind.",
            "example": "127.0.0.1:80"
          },
          "max_connections": {
            "default": 1024,
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "integer",
                "minimum": 1
              }
            ]
          },
          "max_conn_rate": {
            "default": 1000,
            "type": "integer",
            "description": "Maximum connections per second."
          },
          "enable_authn": {
            "default": true,
            "type": "boolean",
            "description": "Set <code>true</code> (default) to enable client authentication on this listener.<br/>When set to <code>false</code> clients will be allowed to connect without authentication."
          },
          "mountpoint": {
            "type": "string",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message is delivered to the subscriber.<br/>The mountpoint is a way that users can use to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,<br/>then the client actually subscribes to the topic `some_tenant/t`.<br/>Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,<br/>the message is routed to all the clients subscribed `some_tenant/t`,<br/>so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.<br/>Supported placeholders in mountpoint string:<br/><br/>  - <code>${clientid}</code>: clientid<br/><br/>  - <code>${username}</code>: username<br/><br/>  - <code>${endpoint_name}</code>: endpoint name"
          },
          "access_rules": {
            "default": [],
            "type": "array",
            "description": "An access rule list consisting of string rules to restrict or allow access from some addresses.<br/>The rules that appear earlier in the list are matched first.<br/>The format is `allow | deny <address> | <CIDR> | all`.<br/><br/>For example:<br/><br/>`[\\\"deny 192.168.1.1\\\", \\\"allow 192.168.1.0/24\\\", \\\"deny, all\\\"]`",
            "items": {
              "type": "string"
            }
          },
          "dtls_options": {
            "description": "DTLS socket options",
            "$ref": "#/components/schemas/gateway.dtls_opts"
          },
          "status": {
            "description": "listener status",
            "$ref": "#/components/schemas/listeners.status"
          },
          "node_status": {
            "type": "array",
            "description": "listener status of each node in the cluster",
            "items": {
              "$ref": "#/components/schemas/listeners.node_status"
            }
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.mqttsn": {
        "required": [
          "gateway_id"
        ],
        "properties": {
          "name": {
            "type": "string",
            "enum": [
              "mqttsn"
            ],
            "description": "Gateway Name"
          },
          "gateway_id": {
            "default": 1,
            "type": "integer",
            "description": "MQTT-SN Gateway ID.<br/>When the <code>broadcast</code> option is enabled, the gateway will broadcast ADVERTISE message with this value"
          },
          "broadcast": {
            "default": false,
            "type": "boolean",
            "description": "Whether to periodically broadcast ADVERTISE messages"
          },
          "enable_qos3": {
            "default": true,
            "type": "boolean",
            "description": "Allows connectionless clients to publish messages with a Qos of -1.<br/>This feature is defined for very simple client implementations which do not support any other features except this one. There is no connection setup nor tear down, no registration nor subscription. The client just sends its 'PUBLISH' messages to a GW"
          },
          "subs_resume": {
            "default": false,
            "type": "boolean",
            "description": "Whether to initiate all subscribed topic name registration messages to the client after the Session has been taken over by a new channel"
          },
          "predefined": {
            "default": [],
            "type": "array",
            "description": "The pre-defined topic IDs and topic names.<br/>A 'pre-defined' topic ID is a topic ID whose mapping to a topic name is known in advance by both the client's application and the gateway",
            "items": {
              "$ref": "#/components/schemas/gateway.mqttsn_predefined"
            }
          },
          "mountpoint": {
            "default": "",
            "type": "string",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message is delivered to the subscriber.<br/>The mountpoint is a way that users can use to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,<br/>then the client actually subscribes to the topic `some_tenant/t`.<br/>Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,<br/>the message is routed to all the clients subscribed `some_tenant/t`,<br/>so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.<br/>Supported placeholders in mountpoint string:<br/><br/>  - <code>${clientid}</code>: clientid<br/><br/>  - <code>${username}</code>: username<br/><br/>  - <code>${endpoint_name}</code>: endpoint name"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Whether to enable this gateway"
          },
          "enable_stats": {
            "default": true,
            "type": "boolean",
            "description": "Whether to enable client process statistic"
          },
          "idle_timeout": {
            "default": "30s",
            "type": "string",
            "description": "The idle time of the client connection process. It has two purposes:<br/>  1. A newly created client process that does not receive any client requests after that time will be closed directly.<br/>  2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.",
            "example": "12m"
          },
          "clientinfo_override": {
            "description": "ClientInfo override.",
            "$ref": "#/components/schemas/gateway.clientinfo_override"
          },
          "listeners": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/emqx_gateway_api.dtls_listener"
                },
                {
                  "$ref": "#/components/schemas/emqx_gateway_api.udp_listener"
                }
              ]
            }
          }
        },
        "type": "object"
      },
      "rule_engine.builtin_action_console": {
        "properties": {
          "function": {
            "type": "string",
            "enum": [
              "console"
            ],
            "description": "Print the actions to the console"
          }
        },
        "type": "object"
      },
      "bridge_mqtt.put": {
        "required": [
          "server"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_mqtt.creation_opts"
          },
          "mode": {
            "default": "cluster_shareload",
            "type": "string",
            "enum": [
              "cluster_shareload"
            ],
            "deprecated": true,
            "description": "The mode of the MQTT Bridge.<br/><br/>- cluster_shareload: create an MQTT connection on each node in the emqx cluster.<br/><br/>In 'cluster_shareload' mode, the incoming load from the remote broker is shared by<br/>using shared subscription.<br/><br/>Note that the 'clientid' is suffixed by the node name, this is to avoid<br/>clientid conflicts between different nodes. And we can only use shared subscription<br/>topic filters for <code>remote.topic</code> of ingress connections."
          },
          "server": {
            "type": "string",
            "description": "The host and port of the remote MQTT broker"
          },
          "clientid_prefix": {
            "type": "string",
            "description": "Optional prefix to prepend to the clientid used by egress bridges."
          },
          "reconnect_interval": {
            "type": "string",
            "deprecated": true
          },
          "proto_ver": {
            "default": "v4",
            "type": "string",
            "enum": [
              "v3",
              "v4",
              "v5"
            ],
            "description": "The MQTT protocol version"
          },
          "bridge_mode": {
            "default": false,
            "type": "boolean",
            "description": "If enable bridge mode.<br/>NOTE: This setting is only for MQTT protocol version older than 5.0, and the remote MQTT<br/>broker MUST support this feature.<br/>If bridge_mode is set to true, the bridge will indicate to the remote broker that it is a bridge not an ordinary client.<br/>This means that loop detection will be more effective and that retained messages will be propagated correctly."
          },
          "username": {
            "type": "string",
            "description": "The username of the MQTT protocol"
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password of the MQTT protocol",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "clean_start": {
            "default": true,
            "type": "boolean",
            "description": "Whether to start a clean session when reconnecting a remote broker for ingress bridge"
          },
          "keepalive": {
            "default": "300s",
            "type": "string",
            "description": "MQTT Keepalive. Time interval is a string that contains a number followed by time unit:<br/>- `ms` for milliseconds,<br/>- `s` for seconds,<br/>- `m` for minutes,<br/>- `h` for hours;<br/><br/>or combination of whereof: `1h5m0s`"
          },
          "retry_interval": {
            "default": "15s",
            "type": "string",
            "description": "Message retry interval. Delay for the MQTT bridge to retry sending the QoS1/QoS2 messages in case of ACK not received. Time interval is a string that contains a number followed by time unit:<br/>- `ms` for milliseconds,<br/>- `s` for seconds,<br/>- `m` for minutes,<br/>- `h` for hours;<br/><br/>or combination of whereof: `1h5m0s`"
          },
          "max_inflight": {
            "default": 32,
            "type": "integer",
            "description": "Max inflight (sent, but un-acked) messages of the MQTT protocol",
            "minimum": 0
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "ingress": {
            "description": "The ingress config defines how this bridge receive messages from the remote MQTT broker, and then<br/>        send them to the local broker.<br/><br/>        Template with variables is allowed in 'remote.qos', 'local.topic', 'local.qos', 'local.retain', 'local.payload'.<br/><br/>        NOTE: if this bridge is used as the input of a rule, and also 'local.topic' is<br/>        configured, then messages got from the remote broker will be sent to both the 'local.topic' and<br/>        the rule.",
            "$ref": "#/components/schemas/connector_mqtt.ingress"
          },
          "egress": {
            "description": "The egress config defines how this bridge forwards messages from the local broker to the remote broker.<br/><br/>Template with variables is allowed in 'remote.topic', 'local.qos', 'local.retain', 'local.payload'.<br/><br/>NOTE: if this bridge is used as the action of a rule, and also 'local.topic'<br/>is configured, then both the data got from the rule and the MQTT messages that matches<br/>'local.topic' will be forwarded.",
            "$ref": "#/components/schemas/connector_mqtt.egress"
          }
        },
        "type": "object"
      },
      "exhook.ssl_conf": {
        "properties": {
          "cacertfile": {
            "type": "string",
            "description": "Trusted PEM format CA certificates bundle file.<br/><br/>The certificates in this file are used to verify the TLS peer's certificates.<br/>Append new certificates to the file if new CAs are to be trusted.<br/>There is no need to restart EMQX to have the updated file loaded, because<br/>the system regularly checks if file has been updated (and reload).<br/><br/>NOTE: invalidating (deleting) a certificate from the file will not affect<br/>already established connections."
          },
          "cacerts": {
            "default": false,
            "type": "boolean",
            "deprecated": true
          },
          "certfile": {
            "type": "string",
            "description": "PEM format certificates chain file.<br/><br/>The certificates in this file should be in reversed order of the certificate<br/>issue chain. That is, the host's certificate should be placed in the beginning<br/>of the file, followed by the immediate issuer certificate and so on.<br/>Although the root CA certificate is optional, it should be placed at the end of<br/>the file if it is to be added."
          },
          "keyfile": {
            "type": "string",
            "description": "PEM format private key file."
          },
          "verify": {
            "default": "verify_none",
            "type": "string",
            "enum": [
              "verify_peer",
              "verify_none"
            ],
            "description": "Enable or disable peer verification."
          },
          "reuse_sessions": {
            "default": true,
            "type": "boolean",
            "description": "Enable TLS session reuse.<br/><br/>Has no effect when TLS version is configured (or negotiated) to 1.3"
          },
          "depth": {
            "default": 10,
            "type": "integer",
            "description": "Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path.<br/>So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly;<br/><br/>if 1 the path can be PEER, Intermediate-CA, ROOT-CA;<br/><br/>if 2 the path can be PEER, Intermediate-CA1, Intermediate-CA2, ROOT-CA.",
            "minimum": 0
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "String containing the user's password. Only used if the private key file is password-protected.",
            "example": ""
          },
          "versions": {
            "default": [
              "tlsv1.3",
              "tlsv1.2"
            ],
            "type": "array",
            "description": "All TLS/DTLS versions to be supported.<br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.<br/><br/>In case PSK cipher suites are intended, make sure to configure<br/><code>['tlsv1.2', 'tlsv1.1']</code> here.",
            "items": {
              "type": "string"
            }
          },
          "ciphers": {
            "default": [],
            "type": "array",
            "description": "This config holds TLS cipher suite names separated by comma,<br/>or as an array of strings. e.g.<br/><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or<br/><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.<br/><br/><br/>Ciphers (and their ordering) define the way in which the<br/>client and server encrypts information over the network connection.<br/>Selecting a good cipher suite is critical for the<br/>application's data security, confidentiality and performance.<br/><br/>The names should be in OpenSSL string format (not RFC format).<br/>All default values and examples provided by EMQX config<br/>documentation are all in OpenSSL format.<br/><br/><br/>NOTE: Certain cipher suites are only compatible with<br/>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')<br/>incompatible cipher suites will be silently dropped.<br/>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,<br/>configuring cipher suites for other versions will have no effect.<br/><br/><br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br/><br/>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.<br/><br/>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,<br/>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,<br/>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,<br/>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code>",
            "items": {
              "type": "string"
            }
          },
          "secure_renegotiate": {
            "default": true,
            "type": "boolean",
            "description": "Whether to reject TLS renegotiation attempts that are not compliant with [RFC 5746](http://www.ietf.org/rfc/rfc5746.txt).<br/><br/>By default, `secure_renegotiate` is set to `true`, which forces secure renegotiation.<br/>If set to `false`, secure renegotiation will still be used, but will fall back to insecure renegotiation if the peer does not support [RFC 5746](http://www.ietf.org/rfc/rfc5746.txt), which increases the risk of a MitM attack.<br/><br/>Has no effect when TLS version is configured (or negotiated) to 1.3."
          },
          "log_level": {
            "default": "notice",
            "type": "string",
            "enum": [
              "emergency",
              "alert",
              "critical",
              "error",
              "warning",
              "notice",
              "info",
              "debug",
              "none",
              "all"
            ],
            "description": "The minimum level of logging allowed for SSL output.<br/><br/>The default is `notice`, set to a lower `debug` level for more detailed logging that can be used to investigate SSL handshake issues."
          },
          "hibernate_after": {
            "default": "5s",
            "type": "string",
            "description": "Specifies the amount of time that an SSL process will hibernate after being idle, thus reducing its memory footprint.<br/><br/>The hibernating process will be woken up when a new message arrives.<br/>Hibernating and waking up too often can cause CPU utilization to increase, as they both perform garbage collection on the process.",
            "example": "12m"
          },
          "enable": {
            "default": false,
            "type": "boolean",
            "description": "Enable TLS."
          },
          "server_name_indication": {
            "description": "Specify the host name to be used in TLS Server Name Indication extension.<br/><br/>For instance, when connecting to \"server.example.net\", the genuine server<br/>which accepts the connection and performs TLS handshake may differ from the<br/>host the TLS client initially connects to, e.g. when connecting to an IP address<br/>or when the host has multiple resolvable DNS records <br/><br/>If not specified, it will default to the host name string which is used<br/>to establish the connection, unless it is IP address used.<br/><br/>The host name is then also used in the host name verification of the peer<br/>certificate.<br/> The special value 'disable' prevents the Server Name<br/>Indication extension from being sent and disables the hostname<br/>verification check.",
            "example": "disable",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "string",
                "enum": [
                  "disable"
                ]
              }
            ]
          }
        },
        "type": "object"
      },
      "authn.node_status": {
        "properties": {
          "node": {
            "type": "string",
            "description": "Node name.",
            "example": "emqx@127.0.0.1"
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting"
            ],
            "description": "The status of the resource for each node."
          }
        },
        "type": "object"
      },
      "lwm2m.resource": {
        "properties": {
          "operations": {
            "type": "string",
            "description": "Resource Operations",
            "example": "E"
          },
          "dataType": {
            "type": "string",
            "enum": [
              "Integer",
              "Float",
              "Time",
              "String",
              "Boolean",
              "Opaque",
              "Objlnk"
            ],
            "description": "Data Type",
            "example": "Integer"
          },
          "path": {
            "type": "string",
            "description": "Resource Path",
            "example": "urn:oma:lwm2m:oma:2"
          },
          "name": {
            "type": "string",
            "description": "Resource Name",
            "example": "lwm2m-test"
          }
        },
        "type": "object"
      },
      "cluster.node_invitation_failed": {
        "properties": {
          "node": {
            "type": "string",
            "description": "Node name",
            "example": "emqx2@127.0.0.1"
          },
          "started_at": {
            "type": "string",
            "description": "The time of the async invitation is started",
            "example": "2024-01-30T15:24:39.355+08:00"
          },
          "finished_at": {
            "type": "string",
            "description": "The time of the async invitation result is received",
            "example": "2024-01-30T15:24:39.355+08:00"
          },
          "reason": {
            "type": "string",
            "description": "Failure reason",
            "example": "Bad RPC to target node"
          }
        },
        "type": "object"
      },
      "gateway.udp_health_check": {
        "properties": {
          "request": {
            "type": "string",
            "description": "The content of the request."
          },
          "reply": {
            "type": "string",
            "description": "The content to reply."
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_data_backup.import_request_body": {
        "required": [
          "filename"
        ],
        "properties": {
          "node": {
            "type": "string",
            "description": "Node name"
          },
          "filename": {
            "type": "string",
            "description": "Data backup file name"
          }
        },
        "type": "object"
      },
      "emqx.authz_cache": {
        "required": [
          "enable"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable the authorization cache."
          },
          "max_size": {
            "default": 32,
            "maximum": 1048576,
            "type": "integer",
            "description": "Maximum number of cached items.",
            "minimum": 1
          },
          "ttl": {
            "default": "1m",
            "type": "string",
            "description": "Time to live for the cached data.",
            "example": "12m"
          },
          "excludes": {
            "default": [],
            "type": "array",
            "description": "Exclude caching ACL check results for topics matching the given patterns.",
            "items": {
              "type": "string"
            }
          }
        },
        "type": "object"
      },
      "gateway.lwm2m_translators": {
        "required": [
          "command",
          "notify",
          "register",
          "response",
          "update"
        ],
        "properties": {
          "command": {
            "description": "The topic for receiving downstream commands.<br/>For each new LwM2M client that succeeds in going online, the gateway creates a subscription relationship to receive downstream commands and send it to the LwM2M client",
            "$ref": "#/components/schemas/gateway.translator"
          },
          "response": {
            "description": "The topic for gateway to publish the acknowledge events from LwM2M client",
            "$ref": "#/components/schemas/gateway.translator"
          },
          "notify": {
            "description": "The topic for gateway to publish the notify events from LwM2M client.<br/>After succeed observe a resource of LwM2M client, Gateway will send the notify events via this topic, if the client reports any resource changes",
            "$ref": "#/components/schemas/gateway.translator"
          },
          "register": {
            "description": "The topic for gateway to publish the register events from LwM2M client.",
            "$ref": "#/components/schemas/gateway.translator"
          },
          "update": {
            "description": "The topic for gateway to publish the update events from LwM2M client",
            "$ref": "#/components/schemas/gateway.translator"
          }
        },
        "type": "object"
      },
      "listeners.ssl_required_bind": {
        "required": [
          "bind",
          "id",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "ssl"
            ],
            "description": "Listener type"
          },
          "running": {
            "type": "boolean",
            "description": "Listener status"
          },
          "id": {
            "type": "string",
            "description": "Listener id"
          },
          "current_connections": {
            "type": "integer",
            "description": "Current connections",
            "minimum": 0
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable listener."
          },
          "bind": {
            "default": 8883,
            "type": "string",
            "description": "IP address and port for the listening socket.",
            "example": "127.0.0.1:80"
          },
          "acceptors": {
            "default": 16,
            "type": "integer",
            "description": "The size of the listener's receiving pool.",
            "minimum": 1
          },
          "max_connections": {
            "default": "infinity",
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "type": "string",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message<br/>is delivered to the subscriber. The mountpoint is a way that users can use<br/>to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`<br/>set to `some_tenant`, then the client actually subscribes to the topic<br/>`some_tenant/t`. Similarly, if another client B (connected to the same listener<br/>as the client A) sends a message to topic `t`, the message is routed<br/>to all the clients subscribed `some_tenant/t`, so client A will receive the<br/>message, with topic name `t`.<br/><br/>Set to `\"\"` to disable the feature.<br/><br/><br/>Variables in mountpoint string:<br/>  - <code>${clientid}</code>: clientid<br/>  - <code>${username}</code>: username"
          },
          "zone": {
            "default": "default",
            "type": "string",
            "description": "The configuration zone to which the listener belongs.<br/>Clients connected to this listener will inherit zone-settings created under this zone name.<br/><br/>A zone can override the configs under below root names:<br/>- `mqtt`<br/>- `force_shutdown`<br/>- `force_gc`<br/>- `flapping_detect`<br/>- `durable_sessions`"
          },
          "enable_authn": {
            "default": true,
            "type": "string",
            "enum": [
              true,
              false,
              "quick_deny_anonymous"
            ],
            "description": "Set <code>true</code> (default) to enable client authentication on this listener, the authentication<br/>process goes through the configured authentication chain.<br/>When set to <code>false</code>, any client (with or without username/password) is allowed to connect.<br/>When set to <code>quick_deny_anonymous</code>, it behaves like when set to <code>true</code>, but clients will be<br/>denied immediately without going through any authenticators if <code>username</code> is not provided. This is useful to fence off<br/>anonymous clients early."
          },
          "max_conn_rate": {
            "default": "infinity",
            "type": "string",
            "description": "Used to limit the rate at which the current listener accepts connections.<br/><br/>Once the limit is reached, EMQX will pause fetching connections from the Accept queue, thereby delaying or rejecting new connections.<br/><br/>For example:<br/><br/>- `1000/s`: Only accepts 1000 connections per second.<br/>- `1000/10s`: Only accepts 1000 connections every 10 seconds.",
            "example": "1000/s"
          },
          "messages_rate": {
            "type": "string",
            "description": "Used to limit the number of messages a single client can send to EMQX per second.<br/><br/>Once the limit is reached, EMQX will pause reading data from the receive-buffer, thus slowing down or even temporarily hanging the sender.<br/><br/>For example:<br/><br/>- `500/s`: Only 500 messages will be received per second, and the remaining messages will be delayed.<br/>- `500/10s`: Only 500 messages will be received every 10 seconds and the remaining messages will be delayed.",
            "example": "1000/s"
          },
          "bytes_rate": {
            "type": "string",
            "description": "Used to limit the number of bytes a single client can send to EMQX per second.<br/><br/>Once the limit is reached, EMQX will pause reading data from the receive-buffer, thus slowing down or even temporarily hanging the sender.<br/><br/>The unit of the bytes could be: B, KB, MB, GB.<br/><br/>For example:<br/><br/>- `500KB/s`: Only 500 kilobytes per second will be received, and the remaining bytes will be delayed.<br/>- `500MB/10s`: Only 500 megabytes will be received every 10 seconds, and the remaining bytes will be delayed.",
            "example": "100MB/s"
          },
          "access_rules": {
            "default": [
              "allow all"
            ],
            "type": "array",
            "description": "An access rule list consisting of string rules to restrict or allow access from some addresses. The rules that appear earlier in the list are matched first.<br/>The format is `allow | deny <address> | <CIDR> | all`.<br/><br/>For example:<br/><br/>`[\\\"deny 192.168.1.1\\\", \\\"allow 192.168.1.0/24\\\", \\\"deny, all\\\"]`",
            "items": {
              "type": "string"
            }
          },
          "proxy_protocol": {
            "default": false,
            "type": "boolean",
            "description": "Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.<br/><br/>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "type": "string",
            "description": "If a reverse proxy is deployed for EMQX, and the PROXY protocol is enabled at the proxy to pass the client's real IP, this option needs to be turned on so that EMQX can extract the client's real IP from the PROXY protocol header.<br/><br/>EMQX will automatically detect the version of the PROXY protocol and support V1 and V2.<br/><br/>For a detailed description of the PROXY protocol, please refer to: https://www.haproxy.com/blog/haproxy/proxy-protocol/",
            "example": "12m"
          },
          "tcp_options": {
            "$ref": "#/components/schemas/emqx.tcp_opts"
          },
          "ssl_options": {
            "$ref": "#/components/schemas/emqx.listener_ssl_opts"
          }
        },
        "type": "object"
      },
      "gateway.stomp_frame": {
        "properties": {
          "max_headers": {
            "default": 10,
            "type": "integer",
            "description": "The maximum number of Header",
            "minimum": 0
          },
          "max_headers_length": {
            "default": 1024,
            "type": "integer",
            "description": "The maximum string length of the Header Value",
            "minimum": 0
          },
          "max_body_length": {
            "default": 65536,
            "type": "integer",
            "description": "Maximum number of bytes of Body allowed per Stomp packet"
          }
        },
        "type": "object"
      },
      "retainer.message_summary": {
        "properties": {
          "msgid": {
            "type": "string",
            "description": "Message ID."
          },
          "topic": {
            "type": "string",
            "description": "Topic."
          },
          "qos": {
            "maximum": 2,
            "type": "integer",
            "description": "QoS.",
            "minimum": 0,
            "example": 0
          },
          "publish_at": {
            "type": "string",
            "description": "Message publish time, RFC 3339 format."
          },
          "from_clientid": {
            "type": "string",
            "description": "The clientid of publisher."
          },
          "from_username": {
            "type": "string",
            "description": "The username of publisher."
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_topics.topic": {
        "required": [
          "node",
          "topic"
        ],
        "properties": {
          "topic": {
            "type": "string",
            "description": "Topic Name"
          },
          "node": {
            "type": "string",
            "description": "Node"
          },
          "session": {
            "type": "string",
            "description": "Session ID"
          }
        },
        "type": "object"
      },
      "emqx.log": {
        "properties": {
          "console": {
            "$ref": "#/components/schemas/emqx.console_handler"
          },
          "file": {
            "default": {
              "level": "warning"
            },
            "description": "File-based log handlers.",
            "oneOf": [
              {
                "properties": {
                  "$handler_name": {
                    "$ref": "#/components/schemas/emqx.log_file_handler"
                  }
                },
                "type": "object"
              },
              {
                "$ref": "#/components/schemas/emqx.log_file_handler"
              }
            ]
          },
          "throttling": {
            "$ref": "#/components/schemas/emqx.log_throttling"
          }
        },
        "type": "object"
      },
      "opentelemetry.otel_exporter": {
        "properties": {
          "endpoint": {
            "default": "http://localhost:4317",
            "type": "string",
            "description": "The target URL to which the exporter is going to send Open Telemetry signal data.",
            "example": "http://127.0.0.1"
          },
          "ssl_options": {
            "default": {
              "enable": false
            },
            "description": "SSL configuration for the Open Telemetry exporter",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "listeners.listener_id_status": {
        "required": [
          "bind",
          "enable",
          "id",
          "name",
          "type"
        ],
        "properties": {
          "id": {
            "type": "string",
            "description": "Listener id",
            "example": "tcp:demo"
          },
          "type": {
            "type": "string",
            "enum": [
              "tcp",
              "ssl",
              "ws",
              "wss",
              "quic"
            ],
            "description": "Listener type"
          },
          "name": {
            "type": "string",
            "description": "Listener name"
          },
          "enable": {
            "type": "boolean",
            "description": "Listener enable"
          },
          "number": {
            "type": "integer",
            "description": "ListenerId counter",
            "minimum": 1
          },
          "bind": {
            "type": "string",
            "description": "Listener bind addr",
            "example": "127.0.0.1:80"
          },
          "acceptors": {
            "type": "integer",
            "description": "ListenerId acceptors",
            "minimum": 1
          },
          "status": {
            "$ref": "#/components/schemas/listeners.status"
          },
          "node_status": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/listeners.node_status"
            }
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_stats.aggregated_data": {
        "properties": {
          "channels.count": {
            "type": "integer",
            "description": "sessions.count",
            "minimum": 0,
            "example": 0
          },
          "channels.max": {
            "type": "integer",
            "description": "session.max",
            "minimum": 0,
            "example": 0
          },
          "connections.count": {
            "type": "integer",
            "description": "Number of current connections",
            "minimum": 0,
            "example": 0
          },
          "connections.max": {
            "type": "integer",
            "description": "Historical maximum number of connections",
            "minimum": 0,
            "example": 0
          },
          "delayed.count": {
            "type": "integer",
            "description": "Number of delayed messages",
            "minimum": 0,
            "example": 0
          },
          "delayed.max": {
            "type": "integer",
            "description": "Historical maximum number of delayed messages",
            "minimum": 0,
            "example": 0
          },
          "live_connections.count": {
            "type": "integer",
            "description": "Number of current live connections",
            "minimum": 0,
            "example": 0
          },
          "live_connections.max": {
            "type": "integer",
            "description": "Historical maximum number of live connections",
            "minimum": 0,
            "example": 0
          },
          "cluster_sessions.count": {
            "type": "integer",
            "description": "Number of sessions in the cluster",
            "minimum": 0,
            "example": 0
          },
          "cluster_sessions.max": {
            "type": "integer",
            "description": "Historical maximum number of sessions in the cluster",
            "minimum": 0,
            "example": 0
          },
          "retained.count": {
            "type": "integer",
            "description": "Number of currently retained messages",
            "minimum": 0,
            "example": 0
          },
          "retained.max": {
            "type": "integer",
            "description": "Historical maximum number of retained messages",
            "minimum": 0,
            "example": 0
          },
          "sessions.count": {
            "type": "integer",
            "description": "Number of current sessions",
            "minimum": 0,
            "example": 0
          },
          "sessions.max": {
            "type": "integer",
            "description": "Historical maximum number of sessions",
            "minimum": 0,
            "example": 0
          },
          "suboptions.count": {
            "type": "integer",
            "description": "subscriptions.count",
            "minimum": 0,
            "example": 0
          },
          "suboptions.max": {
            "type": "integer",
            "description": "subscriptions.max",
            "minimum": 0,
            "example": 0
          },
          "subscribers.count": {
            "type": "integer",
            "description": "Number of current subscribers",
            "minimum": 0,
            "example": 0
          },
          "subscribers.max": {
            "type": "integer",
            "description": "Historical maximum number of subscribers",
            "minimum": 0,
            "example": 0
          },
          "subscriptions.count": {
            "type": "integer",
            "description": "Number of current subscriptions, including shared subscriptions, but not subscriptions from durable sessions",
            "minimum": 0,
            "example": 0
          },
          "subscriptions.max": {
            "type": "integer",
            "description": "Historical maximum number of subscriptions",
            "minimum": 0,
            "example": 0
          },
          "subscriptions.shared.count": {
            "type": "integer",
            "description": "Number of current shared subscriptions",
            "minimum": 0,
            "example": 0
          },
          "subscriptions.shared.max": {
            "type": "integer",
            "description": "Historical maximum number of shared subscriptions",
            "minimum": 0,
            "example": 0
          },
          "topics.count": {
            "type": "integer",
            "description": "Number of current topics",
            "minimum": 0,
            "example": 0
          },
          "topics.max": {
            "type": "integer",
            "description": "Historical maximum number of topics",
            "minimum": 0,
            "example": 0
          }
        },
        "type": "object"
      },
      "emqx_dashboard_monitor_api.sampler_current": {
        "properties": {
          "dropped_msg_rate": {
            "type": "integer",
            "description": "Dropped messages per 10 seconds"
          },
          "sent_msg_rate": {
            "type": "integer",
            "description": "Sent messages per 10 seconds"
          },
          "persisted_rate": {
            "type": "integer",
            "description": "Messages saved to the durable storage per 10 seconds"
          },
          "received_msg_rate": {
            "type": "integer",
            "description": "Dropped messages per 10 seconds"
          },
          "transformation_failed_rate": {
            "type": "integer",
            "description": "Message transformations failed per 10 seconds"
          },
          "transformation_succeeded_rate": {
            "type": "integer",
            "description": "Message transformations succeeded per 10 seconds"
          },
          "validation_failed_rate": {
            "type": "integer",
            "description": "Schema validations failed per 10 seconds"
          },
          "validation_succeeded_rate": {
            "type": "integer",
            "description": "Schema validations succeeded per 10 seconds"
          },
          "disconnected_durable_sessions": {
            "type": "integer",
            "description": "Disconnected durable sessions at the time of sampling. Can only represent an approximate state."
          },
          "subscriptions_durable": {
            "type": "integer",
            "description": "Subscriptions from durable sessions at the time of sampling. Can only represent an approximate state."
          },
          "subscriptions": {
            "type": "integer",
            "description": "Subscriptions at the time of sampling. Can only represent an approximate state."
          },
          "topics": {
            "type": "integer",
            "description": "Count topics at the time of sampling. Can only represent an approximate state."
          },
          "connections": {
            "type": "integer",
            "description": "Sessions at the time of sampling. Can only represent an approximate state."
          },
          "live_connections": {
            "type": "integer",
            "description": "Connections at the time of sampling. Can only represent an approximate state."
          },
          "retained_msg_count": {
            "type": "integer",
            "description": "Retained messages count at the time of sampling. Can only represent an approximate state."
          },
          "shared_subscriptions": {
            "type": "integer",
            "description": "Shared subscriptions count at the time of sampling. Can only represent an approximate state."
          }
        },
        "type": "object"
      },
      "authz.http_post": {
        "required": [
          "method",
          "type",
          "url"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "http"
            ],
            "description": "Backend type."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Set to <code>true</code> or <code>false</code> to disable this ACL provider"
          },
          "url": {
            "type": "string",
            "description": "URL of the auth server."
          },
          "request_timeout": {
            "default": "30s",
            "type": "string",
            "description": "HTTP request timeout."
          },
          "body": {
            "description": "HTTP request body.",
            "properties": {
              "$name": {
                "type": "string"
              }
            },
            "type": "object"
          },
          "connect_timeout": {
            "default": "15s",
            "type": "string",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s"
          },
          "max_retries": {
            "type": "integer",
            "deprecated": true,
            "minimum": 0
          },
          "retry_interval": {
            "type": "string",
            "deprecated": true,
            "example": "12m"
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "The pool size.",
            "minimum": 1
          },
          "enable_pipelining": {
            "default": 100,
            "type": "integer",
            "description": "The maximum number of HTTP requests that can be sent before an HTTP response is received.<br/><br/>Setting this to 1 is equivalent to turning off HTTP pipelining, and the EMQX must receive a response to the previous HTTP request before sending the next HTTP request.",
            "minimum": 1
          },
          "request": {
            "description": "Configure HTTP request parameters.",
            "$ref": "#/components/schemas/connector_http.request"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "method": {
            "type": "string",
            "enum": [
              "post"
            ],
            "description": "HTTP method."
          },
          "headers": {
            "default": {
              "accept": "application/json",
              "cache-control": "no-cache",
              "connection": "keep-alive",
              "content-type": "application/json",
              "keep-alive": "timeout=30, max=1000"
            },
            "type": "object",
            "description": "List of HTTP Headers.",
            "example": {}
          }
        },
        "type": "object"
      },
      "rule_engine.republish_mqtt_properties": {
        "properties": {
          "Payload-Format-Indicator": {
            "type": "string"
          },
          "Message-Expiry-Interval": {
            "type": "string"
          },
          "Content-Type": {
            "type": "string"
          },
          "Response-Topic": {
            "type": "string"
          },
          "Correlation-Data": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "rule_engine.ctx_disconnected": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "type": "string",
            "enum": [
              "client_disconnected"
            ],
            "description": "Event Type"
          },
          "clientid": {
            "type": "string",
            "description": "The Client ID"
          },
          "username": {
            "type": "string",
            "description": "Username"
          },
          "reason": {
            "type": "string",
            "description": "The Reason for Disconnect"
          },
          "peername": {
            "type": "string",
            "description": "The IP Address and Port of the Peer Client"
          },
          "sockname": {
            "type": "string",
            "description": "The IP Address and Port of the Local Listener"
          },
          "disconnected_at": {
            "type": "integer",
            "description": "The Time that this Client is Disconnected"
          }
        },
        "type": "object"
      },
      "connector_mqtt.get_connector": {
        "required": [
          "name",
          "server",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "mqtt"
            ],
            "description": "The type of the connector."
          },
          "name": {
            "type": "string",
            "description": "The name of the connector."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this connector."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the connector<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the connector passes the health probes.<br/><br/>- <code>disconnected</code>: when the connector can not pass health probes.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a connector is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/connector.node_status"
            }
          },
          "actions": {
            "type": "array",
            "description": "List of actions added to this connector.",
            "items": {
              "type": "string"
            },
            "example": [
              "my_action"
            ]
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the pool of MQTT clients that will publish messages to the remote broker.<br/><br/>Each MQTT client will be assigned 'clientid' of the form '${clientid_prefix}:${bridge_name}:egress:${node}:${n}'<br/>where 'n' is the number of a client inside the pool.",
            "minimum": 1
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/connector_mqtt.resource_opts"
          },
          "mode": {
            "default": "cluster_shareload",
            "type": "string",
            "enum": [
              "cluster_shareload"
            ],
            "deprecated": true,
            "description": "The mode of the MQTT Bridge.<br/><br/>- cluster_shareload: create an MQTT connection on each node in the emqx cluster.<br/><br/>In 'cluster_shareload' mode, the incoming load from the remote broker is shared by<br/>using shared subscription.<br/><br/>Note that the 'clientid' is suffixed by the node name, this is to avoid<br/>clientid conflicts between different nodes. And we can only use shared subscription<br/>topic filters for <code>remote.topic</code> of ingress connections."
          },
          "server": {
            "type": "string",
            "description": "The host and port of the remote MQTT broker"
          },
          "clientid_prefix": {
            "type": "string",
            "description": "Optional prefix to prepend to the clientid used by egress bridges."
          },
          "reconnect_interval": {
            "type": "string",
            "deprecated": true
          },
          "proto_ver": {
            "default": "v4",
            "type": "string",
            "enum": [
              "v3",
              "v4",
              "v5"
            ],
            "description": "The MQTT protocol version"
          },
          "bridge_mode": {
            "default": false,
            "type": "boolean",
            "description": "If enable bridge mode.<br/>NOTE: This setting is only for MQTT protocol version older than 5.0, and the remote MQTT<br/>broker MUST support this feature.<br/>If bridge_mode is set to true, the bridge will indicate to the remote broker that it is a bridge not an ordinary client.<br/>This means that loop detection will be more effective and that retained messages will be propagated correctly."
          },
          "username": {
            "type": "string",
            "description": "The username of the MQTT protocol"
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password of the MQTT protocol",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "clean_start": {
            "default": true,
            "type": "boolean",
            "description": "Whether to start a clean session when reconnecting a remote broker for ingress bridge"
          },
          "keepalive": {
            "default": "300s",
            "type": "string",
            "description": "MQTT Keepalive. Time interval is a string that contains a number followed by time unit:<br/>- `ms` for milliseconds,<br/>- `s` for seconds,<br/>- `m` for minutes,<br/>- `h` for hours;<br/><br/>or combination of whereof: `1h5m0s`"
          },
          "retry_interval": {
            "default": "15s",
            "type": "string",
            "description": "Message retry interval. Delay for the MQTT bridge to retry sending the QoS1/QoS2 messages in case of ACK not received. Time interval is a string that contains a number followed by time unit:<br/>- `ms` for milliseconds,<br/>- `s` for seconds,<br/>- `m` for minutes,<br/>- `h` for hours;<br/><br/>or combination of whereof: `1h5m0s`"
          },
          "max_inflight": {
            "default": 32,
            "type": "integer",
            "description": "Max inflight (sent, but un-acked) messages of the MQTT protocol",
            "minimum": 0
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "authn.http_get": {
        "required": [
          "backend",
          "mechanism",
          "method",
          "url"
        ],
        "properties": {
          "method": {
            "type": "string",
            "enum": [
              "get"
            ],
            "description": "HTTP request method."
          },
          "headers": {
            "default": {
              "accept": "application/json",
              "cache-control": "no-cache",
              "connection": "keep-alive",
              "keep-alive": "timeout=30, max=1000"
            },
            "type": "object",
            "description": "List of HTTP headers (without <code>content-type</code>).",
            "example": {}
          },
          "mechanism": {
            "type": "string",
            "enum": [
              "password_based"
            ],
            "description": "Authentication mechanism."
          },
          "backend": {
            "type": "string",
            "enum": [
              "http"
            ],
            "description": "Backend type."
          },
          "url": {
            "type": "string",
            "description": "URL of the HTTP server."
          },
          "body": {
            "type": "object",
            "description": "HTTP request body.",
            "example": {}
          },
          "request_timeout": {
            "default": "5s",
            "type": "string",
            "description": "HTTP request timeout.",
            "example": "32s"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider."
          },
          "request": {
            "description": "Configure HTTP request parameters.",
            "$ref": "#/components/schemas/connector_http.request"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "connect_timeout": {
            "default": "15s",
            "type": "string",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s"
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "The pool size.",
            "minimum": 1
          },
          "max_retries": {
            "type": "integer",
            "deprecated": true,
            "minimum": 0
          },
          "retry_interval": {
            "type": "string",
            "deprecated": true,
            "example": "12m"
          },
          "enable_pipelining": {
            "default": 100,
            "type": "integer",
            "description": "The maximum number of HTTP requests that can be sent before an HTTP response is received.<br/><br/>Setting this to 1 is equivalent to turning off HTTP pipelining, and the EMQX must receive a response to the previous HTTP request before sending the next HTTP request.",
            "minimum": 1
          }
        },
        "type": "object"
      },
      "opentelemetry.otel_traces": {
        "properties": {
          "enable": {
            "default": false,
            "type": "boolean",
            "description": "Enable or disable Open Telemetry signal."
          },
          "scheduled_delay": {
            "default": "5s",
            "type": "string",
            "description": "The delay interval between two consecutive exports of Open Telemetry signals.",
            "example": "32s"
          },
          "filter": {
            "description": "Open Telemetry Trace Filter configuration",
            "$ref": "#/components/schemas/opentelemetry.trace_filter"
          }
        },
        "type": "object"
      },
      "rule_engine.rule_creation": {
        "required": [
          "sql"
        ],
        "properties": {
          "name": {
            "default": "",
            "type": "string",
            "description": "The name of the rule",
            "example": "foo"
          },
          "sql": {
            "type": "string",
            "description": "SQL query to transform the messages.<br/>Example: <code>SELECT * FROM \"test/topic\" WHERE payload.x = 1</code>",
            "example": "SELECT * FROM \"test/topic\" WHERE payload.x = 1"
          },
          "actions": {
            "default": [],
            "type": "array",
            "description": "A list of actions of the rule.<br/>An action can be a string that refers to the channel ID of an EMQX bridge, or an object<br/>that refers to a function.<br/>There a some built-in functions like \"republish\" and \"console\", and we also support user<br/>provided functions in the format: \"{module}:{function}\".<br/>The actions in the list are executed sequentially.<br/>This means that if one of the action is executing slowly, all the following actions will not<br/>be executed until it returns.<br/>If one of the action crashed, all other actions come after it will still be executed, in the<br/>original order.<br/>If there's any error when running an action, there will be an error message, and the 'failure'<br/>counter of the function action or the bridge channel will increase.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/rule_engine.user_provided_function"
                },
                {
                  "$ref": "#/components/schemas/rule_engine.builtin_action_console"
                },
                {
                  "$ref": "#/components/schemas/rule_engine.builtin_action_republish"
                },
                {
                  "type": "string"
                }
              ]
            },
            "example": [
              "webhook:my_webhook",
              {
                "args": {
                  "payload": "${payload}",
                  "topic": "t/1"
                },
                "function": "republish"
              },
              {
                "function": "console"
              }
            ]
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable the rule"
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "The description of the rule",
            "example": "Some description"
          },
          "metadata": {
            "type": "object",
            "description": "Rule metadata, do not change manually",
            "example": {}
          }
        },
        "type": "object"
      },
      "dashboard.ssl_options": {
        "properties": {
          "cacertfile": {
            "default": "${EMQX_ETC_DIR}/certs/cacert.pem",
            "type": "string",
            "description": "Trusted PEM format CA certificates bundle file.<br/><br/>The certificates in this file are used to verify the TLS peer's certificates.<br/>Append new certificates to the file if new CAs are to be trusted.<br/>There is no need to restart EMQX to have the updated file loaded, because<br/>the system regularly checks if file has been updated (and reload).<br/><br/>NOTE: invalidating (deleting) a certificate from the file will not affect<br/>already established connections."
          },
          "cacerts": {
            "default": false,
            "type": "boolean",
            "deprecated": true
          },
          "certfile": {
            "default": "${EMQX_ETC_DIR}/certs/cert.pem",
            "type": "string",
            "description": "PEM format certificates chain file.<br/><br/>The certificates in this file should be in reversed order of the certificate<br/>issue chain. That is, the host's certificate should be placed in the beginning<br/>of the file, followed by the immediate issuer certificate and so on.<br/>Although the root CA certificate is optional, it should be placed at the end of<br/>the file if it is to be added."
          },
          "keyfile": {
            "default": "${EMQX_ETC_DIR}/certs/key.pem",
            "type": "string",
            "description": "PEM format private key file."
          },
          "verify": {
            "default": "verify_none",
            "type": "string",
            "enum": [
              "verify_peer",
              "verify_none"
            ],
            "description": "Enable or disable peer verification."
          },
          "reuse_sessions": {
            "default": true,
            "type": "boolean",
            "description": "Enable TLS session reuse.<br/><br/>Has no effect when TLS version is configured (or negotiated) to 1.3"
          },
          "depth": {
            "default": 10,
            "type": "integer",
            "description": "Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path.<br/>So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly;<br/><br/>if 1 the path can be PEER, Intermediate-CA, ROOT-CA;<br/><br/>if 2 the path can be PEER, Intermediate-CA1, Intermediate-CA2, ROOT-CA.",
            "minimum": 0
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "String containing the user's password. Only used if the private key file is password-protected.",
            "example": ""
          },
          "versions": {
            "default": [
              "tlsv1.3",
              "tlsv1.2"
            ],
            "type": "array",
            "description": "All TLS/DTLS versions to be supported.<br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.<br/><br/>In case PSK cipher suites are intended, make sure to configure<br/><code>['tlsv1.2', 'tlsv1.1']</code> here.",
            "items": {
              "type": "string"
            }
          },
          "ciphers": {
            "default": [],
            "type": "array",
            "description": "This config holds TLS cipher suite names separated by comma,<br/>or as an array of strings. e.g.<br/><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or<br/><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.<br/><br/><br/>Ciphers (and their ordering) define the way in which the<br/>client and server encrypts information over the network connection.<br/>Selecting a good cipher suite is critical for the<br/>application's data security, confidentiality and performance.<br/><br/>The names should be in OpenSSL string format (not RFC format).<br/>All default values and examples provided by EMQX config<br/>documentation are all in OpenSSL format.<br/><br/><br/>NOTE: Certain cipher suites are only compatible with<br/>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')<br/>incompatible cipher suites will be silently dropped.<br/>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,<br/>configuring cipher suites for other versions will have no effect.<br/><br/><br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br/><br/>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.<br/><br/>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,<br/>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,<br/>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,<br/>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code>",
            "items": {
              "type": "string"
            }
          },
          "secure_renegotiate": {
            "default": true,
            "type": "boolean",
            "description": "Whether to reject TLS renegotiation attempts that are not compliant with [RFC 5746](http://www.ietf.org/rfc/rfc5746.txt).<br/><br/>By default, `secure_renegotiate` is set to `true`, which forces secure renegotiation.<br/>If set to `false`, secure renegotiation will still be used, but will fall back to insecure renegotiation if the peer does not support [RFC 5746](http://www.ietf.org/rfc/rfc5746.txt), which increases the risk of a MitM attack.<br/><br/>Has no effect when TLS version is configured (or negotiated) to 1.3."
          },
          "log_level": {
            "default": "notice",
            "type": "string",
            "enum": [
              "emergency",
              "alert",
              "critical",
              "error",
              "warning",
              "notice",
              "info",
              "debug",
              "none",
              "all"
            ],
            "description": "The minimum level of logging allowed for SSL output.<br/><br/>The default is `notice`, set to a lower `debug` level for more detailed logging that can be used to investigate SSL handshake issues."
          },
          "hibernate_after": {
            "default": "5s",
            "type": "string",
            "description": "Specifies the amount of time that an SSL process will hibernate after being idle, thus reducing its memory footprint.<br/><br/>The hibernating process will be woken up when a new message arrives.<br/>Hibernating and waking up too often can cause CPU utilization to increase, as they both perform garbage collection on the process.",
            "example": "12m"
          },
          "dhfile": {
            "type": "string",
            "description": "Path to a file containing PEM-encoded Diffie-Hellman parameters<br/>to be used by the server if a cipher suite using Diffie-Hellman<br/>key exchange is negotiated. If not specified, default parameters<br/>are used.<br/><br/>NOTE: The <code>dhfile</code> option is not supported by TLS 1.3."
          },
          "fail_if_no_peer_cert": {
            "default": false,
            "type": "boolean",
            "description": "This option is only effective if `verify` is set to `verify_peer`.<br/><br/>If set to `true`, EMQX will reject the connection if the client fails to provide a certificate.<br/><br/>If set to `false`, EMQX will accept clients which don't present a certificate."
          },
          "honor_cipher_order": {
            "default": true,
            "type": "boolean",
            "description": "An important security setting. If this setting is enabled, the server will prioritize the cipher suites it prefers most from the list of cipher suites supported by the client, thus ignoring the client's preferences.<br/><br/>The server's cipher suites are specified by `ciphers`, with preference decreasing from left to right.<br/><br/>It is often better to use the server's preferences, as it is more likely that the server will be configured correctly."
          },
          "client_renegotiation": {
            "default": true,
            "type": "boolean",
            "description": "In protocols that support client-initiated renegotiation,<br/>the cost of resources of such an operation is higher for the server than the client.<br/>This can act as a vector for denial of service attacks.<br/>The SSL application already takes measures to counter-act such attempts,<br/>but client-initiated renegotiation can be strictly disabled by setting this option to false.<br/>The default value is true. Note that disabling renegotiation can result in<br/>long-lived connections becoming unusable due to limits on<br/>the number of messages the underlying cipher suite can encipher.<br/><br/>Has no effect when TLS version is configured (or negotiated) to 1.3"
          },
          "handshake_timeout": {
            "default": "15s",
            "type": "string",
            "description": "Maximum time duration allowed for the handshake to complete",
            "example": "12m"
          }
        },
        "type": "object"
      },
      "emqx_telemetry_api.telemetry": {
        "properties": {
          "emqx_version": {
            "type": "string",
            "description": "Get emqx version",
            "example": "5.0.0-beta.3-32d1547c"
          },
          "license": {
            "type": "object",
            "description": "Get license information",
            "example": {
              "edition": "opensource"
            }
          },
          "os_name": {
            "type": "string",
            "description": "Get OS name",
            "example": "Linux"
          },
          "os_version": {
            "type": "string",
            "description": "Get OS version",
            "example": "20.04"
          },
          "otp_version": {
            "type": "string",
            "description": "Get Erlang OTP version",
            "example": "24"
          },
          "up_time": {
            "type": "integer",
            "description": "Get uptime",
            "example": 20220113
          },
          "uuid": {
            "type": "string",
            "description": "Get UUID",
            "example": "AAAAAAAA-BBBB-CCCC-2022-DDDDEEEEFFF"
          },
          "nodes_uuid": {
            "type": "array",
            "description": "Get nodes UUID",
            "items": {
              "type": "string"
            },
            "example": [
              "AAAAAAAA-BBBB-CCCC-2022-DDDDEEEEFFF",
              "ZZZZZZZZ-CCCC-BBBB-2022-DDDDEEEEFFF"
            ]
          },
          "active_plugins": {
            "type": "array",
            "description": "Get active plugins",
            "items": {
              "type": "string"
            },
            "example": [
              "Plugin A",
              "Plugin B"
            ]
          },
          "active_modules": {
            "type": "array",
            "description": "Get active modules",
            "items": {
              "type": "string"
            },
            "example": [
              "Module A",
              "Module B"
            ]
          },
          "num_clients": {
            "type": "integer",
            "description": "Get number of clients",
            "example": 20220113
          },
          "messages_received": {
            "type": "integer",
            "description": "Get number of messages received",
            "example": 2022
          },
          "messages_sent": {
            "type": "integer",
            "description": "Get number of messages sent",
            "example": 2022
          }
        },
        "type": "object"
      },
      "listeners.node_status": {
        "properties": {
          "node": {
            "type": "string",
            "description": "Node name",
            "example": "emqx@127.0.0.1"
          },
          "status": {
            "$ref": "#/components/schemas/listeners.status"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_clients.client": {
        "properties": {
          "awaiting_rel_cnt": {
            "type": "integer",
            "description": "v4 api name [awaiting_rel] Number of awaiting PUBREC packet"
          },
          "awaiting_rel_max": {
            "type": "integer",
            "description": "v4 api name [max_awaiting_rel]. Maximum allowed number of awaiting PUBREC packet"
          },
          "clean_start": {
            "type": "boolean",
            "description": "Indicate whether the client is using a brand new session"
          },
          "clientid": {
            "type": "string",
            "description": "Client identifier"
          },
          "connected": {
            "type": "boolean",
            "description": "Whether the client is connected"
          },
          "connected_at": {
            "description": "Client connection time, rfc3339 or timestamp(millisecond)",
            "oneOf": [
              {
                "type": "integer",
                "description": "epoch-millisecond",
                "example": 1640995200000
              },
              {
                "type": "string",
                "format": "date-time",
                "example": "2022-01-01T00:00:00.000Z"
              }
            ]
          },
          "created_at": {
            "description": "Session creation time, rfc3339 or timestamp(millisecond)",
            "oneOf": [
              {
                "type": "integer",
                "description": "epoch-millisecond",
                "example": 1640995200000
              },
              {
                "type": "string",
                "format": "date-time",
                "example": "2022-01-01T00:00:00.000Z"
              }
            ]
          },
          "disconnected_at": {
            "description": "Client offline time. It's Only valid and returned when connected is false, rfc3339 or timestamp(millisecond)",
            "oneOf": [
              {
                "type": "integer",
                "description": "epoch-millisecond",
                "example": 1640995200000
              },
              {
                "type": "string",
                "format": "date-time",
                "example": "2022-01-01T00:00:00.000Z"
              }
            ]
          },
          "expiry_interval": {
            "type": "integer",
            "description": "Session expiration interval, with the unit of second"
          },
          "heap_size": {
            "type": "integer",
            "description": "Process heap size with the unit of byte"
          },
          "inflight_cnt": {
            "type": "integer",
            "description": "Current length of inflight"
          },
          "inflight_max": {
            "type": "integer",
            "description": "v4 api name [max_inflight]. Maximum length of inflight"
          },
          "ip_address": {
            "type": "string",
            "description": "Client's IP address"
          },
          "is_bridge": {
            "type": "boolean",
            "description": "Indicates whether the client is connected via bridge"
          },
          "is_expired": {
            "type": "boolean",
            "description": "Indicates whether the client session is expired"
          },
          "keepalive": {
            "type": "integer",
            "description": "keepalive time, with the unit of second"
          },
          "mailbox_len": {
            "type": "integer",
            "description": "Process mailbox size"
          },
          "mqueue_dropped": {
            "type": "integer",
            "description": "Number of messages dropped by the message queue due to exceeding the length"
          },
          "mqueue_len": {
            "type": "integer",
            "description": "Current length of message queue"
          },
          "mqueue_max": {
            "type": "integer",
            "description": "v4 api name [max_mqueue]. Maximum length of message queue"
          },
          "node": {
            "type": "string",
            "description": "Name of the node to which the client is connected"
          },
          "port": {
            "type": "integer",
            "description": "Client's port"
          },
          "proto_name": {
            "type": "string",
            "description": "Client protocol name"
          },
          "proto_ver": {
            "type": "integer",
            "description": "Protocol version used by the client"
          },
          "recv_cnt": {
            "type": "integer",
            "description": "Number of TCP packets received"
          },
          "recv_msg": {
            "type": "integer",
            "description": "Number of PUBLISH packets received"
          },
          "recv_msg.dropped": {
            "type": "integer",
            "description": "Number of dropped PUBLISH packets"
          },
          "recv_msg.dropped.await_pubrel_timeout": {
            "type": "integer",
            "description": "Number of dropped PUBLISH packets due to expired"
          },
          "recv_msg.qos0": {
            "type": "integer",
            "description": "Number of PUBLISH QoS0 packets received"
          },
          "recv_msg.qos1": {
            "type": "integer",
            "description": "Number of PUBLISH QoS1 packets received"
          },
          "recv_msg.qos2": {
            "type": "integer",
            "description": "Number of PUBLISH QoS2 packets received"
          },
          "recv_oct": {
            "type": "integer",
            "description": "Number of bytes received"
          },
          "recv_pkt": {
            "type": "integer",
            "description": "Number of MQTT packets received"
          },
          "reductions": {
            "type": "integer",
            "description": "Erlang reduction"
          },
          "send_cnt": {
            "type": "integer",
            "description": "Number of TCP packets sent"
          },
          "send_msg": {
            "type": "integer",
            "description": "Number of PUBLISH packets sent"
          },
          "send_msg.dropped": {
            "type": "integer",
            "description": "Number of dropped PUBLISH packets"
          },
          "send_msg.dropped.expired": {
            "type": "integer",
            "description": "Number of dropped PUBLISH packets due to expired"
          },
          "send_msg.dropped.queue_full": {
            "type": "integer",
            "description": "Number of dropped PUBLISH packets due to queue full"
          },
          "send_msg.dropped.too_large": {
            "type": "integer",
            "description": "Number of dropped PUBLISH packets due to packet length too large"
          },
          "send_msg.qos0": {
            "type": "integer",
            "description": "Number of PUBLISH QoS0 packets sent"
          },
          "send_msg.qos1": {
            "type": "integer",
            "description": "Number of PUBLISH QoS1 packets sent"
          },
          "send_msg.qos2": {
            "type": "integer",
            "description": "Number of PUBLISH QoS2 packets sent"
          },
          "send_oct": {
            "type": "integer",
            "description": "Number of bytes sent"
          },
          "send_pkt": {
            "type": "integer",
            "description": "Number of MQTT packets sent"
          },
          "subscriptions_cnt": {
            "type": "integer",
            "description": "Number of subscriptions established by this client."
          },
          "subscriptions_max": {
            "type": "integer",
            "description": "v4 api name [max_subscriptions] Maximum number of subscriptions allowed by this client"
          },
          "username": {
            "type": "string",
            "description": "User name of client when connecting"
          },
          "mountpoint": {
            "type": "string",
            "description": "Topic mountpoint"
          },
          "durable": {
            "type": "boolean",
            "description": "Session is durable"
          },
          "n_streams": {
            "type": "integer",
            "description": "Number of streams used by the durable session",
            "minimum": 0
          },
          "seqno_q1_comm": {
            "type": "integer",
            "description": "Sequence number of the last PUBACK received from the client (Durable sessions only)",
            "minimum": 0
          },
          "seqno_q1_dup": {
            "type": "integer",
            "description": "Sequence number of the last QoS1 message sent to the client, that hasn't been acked (Durable sessions only)",
            "minimum": 0
          },
          "seqno_q1_next": {
            "type": "integer",
            "description": "Sequence number of next QoS1 message to be added to the batch (Durable sessions only)",
            "minimum": 0
          },
          "seqno_q2_comm": {
            "type": "integer",
            "description": "Sequence number of the last PUBCOMP received from the client (Durable sessions only)",
            "minimum": 0
          },
          "seqno_q2_dup": {
            "type": "integer",
            "description": "Sequence number of last unacked QoS2 PUBLISH message sent to the client (Durable sessions only)",
            "minimum": 0
          },
          "seqno_q2_rec": {
            "type": "integer",
            "description": "Sequence number of last PUBREC received from the client (Durable sessions only)",
            "minimum": 0
          },
          "seqno_q2_next": {
            "type": "integer",
            "description": "Sequence number of next QoS2 message to be added to the batch (Durable sessions only)",
            "minimum": 0
          }
        },
        "type": "object"
      },
      "opentelemetry.otel_metrics": {
        "required": [
          "enable"
        ],
        "properties": {
          "enable": {
            "default": false,
            "type": "boolean",
            "description": "Enable or disable Open Telemetry signal."
          },
          "interval": {
            "default": "10s",
            "type": "string",
            "description": "The delay interval between two consecutive exports of Open Telemetry signals.",
            "example": "32s"
          }
        },
        "type": "object"
      },
      "bridge_mqtt.get": {
        "required": [
          "server"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_mqtt.creation_opts"
          },
          "mode": {
            "default": "cluster_shareload",
            "type": "string",
            "enum": [
              "cluster_shareload"
            ],
            "deprecated": true,
            "description": "The mode of the MQTT Bridge.<br/><br/>- cluster_shareload: create an MQTT connection on each node in the emqx cluster.<br/><br/>In 'cluster_shareload' mode, the incoming load from the remote broker is shared by<br/>using shared subscription.<br/><br/>Note that the 'clientid' is suffixed by the node name, this is to avoid<br/>clientid conflicts between different nodes. And we can only use shared subscription<br/>topic filters for <code>remote.topic</code> of ingress connections."
          },
          "server": {
            "type": "string",
            "description": "The host and port of the remote MQTT broker"
          },
          "clientid_prefix": {
            "type": "string",
            "description": "Optional prefix to prepend to the clientid used by egress bridges."
          },
          "reconnect_interval": {
            "type": "string",
            "deprecated": true
          },
          "proto_ver": {
            "default": "v4",
            "type": "string",
            "enum": [
              "v3",
              "v4",
              "v5"
            ],
            "description": "The MQTT protocol version"
          },
          "bridge_mode": {
            "default": false,
            "type": "boolean",
            "description": "If enable bridge mode.<br/>NOTE: This setting is only for MQTT protocol version older than 5.0, and the remote MQTT<br/>broker MUST support this feature.<br/>If bridge_mode is set to true, the bridge will indicate to the remote broker that it is a bridge not an ordinary client.<br/>This means that loop detection will be more effective and that retained messages will be propagated correctly."
          },
          "username": {
            "type": "string",
            "description": "The username of the MQTT protocol"
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password of the MQTT protocol",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "clean_start": {
            "default": true,
            "type": "boolean",
            "description": "Whether to start a clean session when reconnecting a remote broker for ingress bridge"
          },
          "keepalive": {
            "default": "300s",
            "type": "string",
            "description": "MQTT Keepalive. Time interval is a string that contains a number followed by time unit:<br/>- `ms` for milliseconds,<br/>- `s` for seconds,<br/>- `m` for minutes,<br/>- `h` for hours;<br/><br/>or combination of whereof: `1h5m0s`"
          },
          "retry_interval": {
            "default": "15s",
            "type": "string",
            "description": "Message retry interval. Delay for the MQTT bridge to retry sending the QoS1/QoS2 messages in case of ACK not received. Time interval is a string that contains a number followed by time unit:<br/>- `ms` for milliseconds,<br/>- `s` for seconds,<br/>- `m` for minutes,<br/>- `h` for hours;<br/><br/>or combination of whereof: `1h5m0s`"
          },
          "max_inflight": {
            "default": 32,
            "type": "integer",
            "description": "Max inflight (sent, but un-acked) messages of the MQTT protocol",
            "minimum": 0
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "ingress": {
            "description": "The ingress config defines how this bridge receive messages from the remote MQTT broker, and then<br/>        send them to the local broker.<br/><br/>        Template with variables is allowed in 'remote.qos', 'local.topic', 'local.qos', 'local.retain', 'local.payload'.<br/><br/>        NOTE: if this bridge is used as the input of a rule, and also 'local.topic' is<br/>        configured, then messages got from the remote broker will be sent to both the 'local.topic' and<br/>        the rule.",
            "$ref": "#/components/schemas/connector_mqtt.ingress"
          },
          "egress": {
            "description": "The egress config defines how this bridge forwards messages from the local broker to the remote broker.<br/><br/>Template with variables is allowed in 'remote.topic', 'local.qos', 'local.retain', 'local.payload'.<br/><br/>NOTE: if this bridge is used as the action of a rule, and also 'local.topic'<br/>is configured, then both the data got from the rule and the MQTT messages that matches<br/>'local.topic' will be forwarded.",
            "$ref": "#/components/schemas/connector_mqtt.egress"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_subscriptions.subscription": {
        "properties": {
          "node": {
            "type": "string",
            "description": "Access type",
            "example": "emqx@127.0.0.1"
          },
          "topic": {
            "type": "string",
            "description": "Topic name",
            "example": "testtopic/1"
          },
          "clientid": {
            "type": "string",
            "description": "Client identifier",
            "example": "emqx_clientid_xx128cdhfc"
          },
          "qos": {
            "maximum": 2,
            "type": "integer",
            "description": "QoS",
            "minimum": 0,
            "example": 0
          },
          "nl": {
            "type": "integer",
            "description": "No Local",
            "example": 0
          },
          "rap": {
            "type": "integer",
            "description": "Retain as Published",
            "example": 0
          },
          "rh": {
            "type": "integer",
            "description": "Retain Handling",
            "example": 0
          },
          "durable": {
            "type": "boolean",
            "description": "Durable subscription",
            "example": false
          }
        },
        "type": "object"
      },
      "emqx_gateway_api_listeners.ssl_listener": {
        "properties": {
          "id": {
            "type": "string",
            "description": "Listener ID"
          },
          "type": {
            "type": "string",
            "enum": [
              "ssl"
            ],
            "description": "Listener Type"
          },
          "name": {
            "type": "string",
            "description": "Listener Name"
          },
          "running": {
            "type": "boolean",
            "description": "Listener Running status"
          },
          "acceptors": {
            "default": 16,
            "type": "integer",
            "description": "Size of the acceptor pool."
          },
          "tcp_options": {
            "description": "Setting the TCP socket options.",
            "$ref": "#/components/schemas/emqx.tcp_opts"
          },
          "proxy_protocol": {
            "default": false,
            "type": "boolean",
            "description": "If a reverse proxy is deployed for EMQX, and the PROXY protocol is enabled at the proxy to pass the client's real IP,<br/>this option needs to be turned on so that EMQX can extract the client's real IP from the PROXY protocol header.<br/>EMQX will automatically detect the version of the PROXY protocol and support V1 and V2.<br/><br/>For a detailed description of the PROXY protocol, please refer to: https://www.haproxy.com/blog/haproxy/proxy-protocol/"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "type": "string",
            "description": "Timeout for proxy protocol.<br/>EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.",
            "example": "12m"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable the listener."
          },
          "bind": {
            "type": "string",
            "description": "The IP address and port that the listener will bind.",
            "example": "127.0.0.1:80"
          },
          "max_connections": {
            "default": 1024,
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "integer",
                "minimum": 1
              }
            ]
          },
          "max_conn_rate": {
            "default": 1000,
            "type": "integer",
            "description": "Maximum connections per second."
          },
          "enable_authn": {
            "default": true,
            "type": "boolean",
            "description": "Set <code>true</code> (default) to enable client authentication on this listener.<br/>When set to <code>false</code> clients will be allowed to connect without authentication."
          },
          "mountpoint": {
            "type": "string",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message is delivered to the subscriber.<br/>The mountpoint is a way that users can use to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,<br/>then the client actually subscribes to the topic `some_tenant/t`.<br/>Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,<br/>the message is routed to all the clients subscribed `some_tenant/t`,<br/>so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.<br/>Supported placeholders in mountpoint string:<br/><br/>  - <code>${clientid}</code>: clientid<br/><br/>  - <code>${username}</code>: username<br/><br/>  - <code>${endpoint_name}</code>: endpoint name"
          },
          "access_rules": {
            "default": [],
            "type": "array",
            "description": "An access rule list consisting of string rules to restrict or allow access from some addresses.<br/>The rules that appear earlier in the list are matched first.<br/>The format is `allow | deny <address> | <CIDR> | all`.<br/><br/>For example:<br/><br/>`[\\\"deny 192.168.1.1\\\", \\\"allow 192.168.1.0/24\\\", \\\"deny, all\\\"]`",
            "items": {
              "type": "string"
            }
          },
          "ssl_options": {
            "description": "SSL Socket options.",
            "$ref": "#/components/schemas/emqx.listener_ssl_opts"
          },
          "status": {
            "description": "listener status",
            "$ref": "#/components/schemas/listeners.status"
          },
          "node_status": {
            "type": "array",
            "description": "listener status of each node in the cluster",
            "items": {
              "$ref": "#/components/schemas/listeners.node_status"
            }
          }
        },
        "type": "object"
      },
      "emqx_topic_metrics_api.topic_metrics": {
        "required": [
          "create_time",
          "metrics",
          "topic"
        ],
        "properties": {
          "topic": {
            "type": "string",
            "description": "Topic",
            "example": "testtopic/1"
          },
          "create_time": {
            "description": "Create time",
            "example": "2022-01-14T21:48:47+08:00",
            "oneOf": [
              {
                "type": "integer",
                "description": "epoch-second",
                "example": 1640995200
              },
              {
                "type": "string",
                "format": "date-time",
                "example": "2022-01-01T00:00:00.000Z"
              }
            ]
          },
          "reset_time": {
            "description": "Reset time. In rfc3339. Nullable if never reset",
            "example": "2022-01-14T21:48:47+08:00",
            "oneOf": [
              {
                "type": "integer",
                "description": "epoch-second",
                "example": 1640995200
              },
              {
                "type": "string",
                "format": "date-time",
                "example": "2022-01-01T00:00:00.000Z"
              }
            ]
          },
          "metrics": {
            "description": "Metrics",
            "$ref": "#/components/schemas/emqx_topic_metrics_api.metrics"
          }
        },
        "type": "object"
      },
      "listeners.quic_required_bind": {
        "required": [
          "bind",
          "id",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "quic"
            ],
            "description": "Listener type"
          },
          "running": {
            "type": "boolean",
            "description": "Listener status"
          },
          "id": {
            "type": "string",
            "description": "Listener id"
          },
          "current_connections": {
            "type": "integer",
            "description": "Current connections",
            "minimum": 0
          },
          "ciphers": {
            "default": [
              "TLS_AES_256_GCM_SHA384",
              "TLS_AES_128_GCM_SHA256",
              "TLS_CHACHA20_POLY1305_SHA256"
            ],
            "type": "array",
            "description": "This config holds TLS cipher suite names separated by comma,<br/>or as an array of strings. e.g.<br/><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or<br/><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.<br/><br/><br/>Ciphers (and their ordering) define the way in which the<br/>client and server encrypts information over the network connection.<br/>Selecting a good cipher suite is critical for the<br/>application's data security, confidentiality and performance.<br/><br/>The names should be in OpenSSL string format (not RFC format).<br/>All default values and examples provided by EMQX config<br/>documentation are all in OpenSSL format.<br/><br/><br/>NOTE: Certain cipher suites are only compatible with<br/>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')<br/>incompatible cipher suites will be silently dropped.<br/>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,<br/>configuring cipher suites for other versions will have no effect.<br/><br/><br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br/><br/>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.<br/><br/>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,<br/>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,<br/>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,<br/>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code><br/><br/><br/>NOTE: QUIC listener supports only 'tlsv1.3' ciphers",
            "items": {
              "type": "string"
            }
          },
          "ssl_options": {
            "description": "TLS options for QUIC transport",
            "$ref": "#/components/schemas/emqx.listener_quic_ssl_opts"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable listener."
          },
          "bind": {
            "default": 14567,
            "type": "string",
            "description": "IP address and port for the listening socket.",
            "example": "127.0.0.1:80"
          },
          "acceptors": {
            "default": 16,
            "type": "integer",
            "description": "The size of the listener's receiving pool.",
            "minimum": 1
          },
          "max_connections": {
            "default": "infinity",
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "type": "string",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message<br/>is delivered to the subscriber. The mountpoint is a way that users can use<br/>to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`<br/>set to `some_tenant`, then the client actually subscribes to the topic<br/>`some_tenant/t`. Similarly, if another client B (connected to the same listener<br/>as the client A) sends a message to topic `t`, the message is routed<br/>to all the clients subscribed `some_tenant/t`, so client A will receive the<br/>message, with topic name `t`.<br/><br/>Set to `\"\"` to disable the feature.<br/><br/><br/>Variables in mountpoint string:<br/>  - <code>${clientid}</code>: clientid<br/>  - <code>${username}</code>: username"
          },
          "zone": {
            "default": "default",
            "type": "string",
            "description": "The configuration zone to which the listener belongs.<br/>Clients connected to this listener will inherit zone-settings created under this zone name.<br/><br/>A zone can override the configs under below root names:<br/>- `mqtt`<br/>- `force_shutdown`<br/>- `force_gc`<br/>- `flapping_detect`<br/>- `durable_sessions`"
          },
          "enable_authn": {
            "default": true,
            "type": "string",
            "enum": [
              true,
              false,
              "quick_deny_anonymous"
            ],
            "description": "Set <code>true</code> (default) to enable client authentication on this listener, the authentication<br/>process goes through the configured authentication chain.<br/>When set to <code>false</code>, any client (with or without username/password) is allowed to connect.<br/>When set to <code>quick_deny_anonymous</code>, it behaves like when set to <code>true</code>, but clients will be<br/>denied immediately without going through any authenticators if <code>username</code> is not provided. This is useful to fence off<br/>anonymous clients early."
          },
          "max_conn_rate": {
            "default": "infinity",
            "type": "string",
            "description": "Used to limit the rate at which the current listener accepts connections.<br/><br/>Once the limit is reached, EMQX will pause fetching connections from the Accept queue, thereby delaying or rejecting new connections.<br/><br/>For example:<br/><br/>- `1000/s`: Only accepts 1000 connections per second.<br/>- `1000/10s`: Only accepts 1000 connections every 10 seconds.",
            "example": "1000/s"
          },
          "messages_rate": {
            "type": "string",
            "description": "Used to limit the number of messages a single client can send to EMQX per second.<br/><br/>Once the limit is reached, EMQX will pause reading data from the receive-buffer, thus slowing down or even temporarily hanging the sender.<br/><br/>For example:<br/><br/>- `500/s`: Only 500 messages will be received per second, and the remaining messages will be delayed.<br/>- `500/10s`: Only 500 messages will be received every 10 seconds and the remaining messages will be delayed.",
            "example": "1000/s"
          },
          "bytes_rate": {
            "type": "string",
            "description": "Used to limit the number of bytes a single client can send to EMQX per second.<br/><br/>Once the limit is reached, EMQX will pause reading data from the receive-buffer, thus slowing down or even temporarily hanging the sender.<br/><br/>The unit of the bytes could be: B, KB, MB, GB.<br/><br/>For example:<br/><br/>- `500KB/s`: Only 500 kilobytes per second will be received, and the remaining bytes will be delayed.<br/>- `500MB/10s`: Only 500 megabytes will be received every 10 seconds, and the remaining bytes will be delayed.",
            "example": "100MB/s"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_mnesia.username_response_data": {
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/emqx_authz_api_mnesia.rules_for_username"
            }
          },
          "meta": {
            "$ref": "#/components/schemas/public.meta"
          }
        },
        "type": "object"
      },
      "authn.http_post": {
        "required": [
          "backend",
          "mechanism",
          "method",
          "url"
        ],
        "properties": {
          "method": {
            "type": "string",
            "enum": [
              "post"
            ],
            "description": "HTTP request method."
          },
          "headers": {
            "default": {
              "accept": "application/json",
              "cache-control": "no-cache",
              "connection": "keep-alive",
              "content-type": "application/json",
              "keep-alive": "timeout=30, max=1000"
            },
            "type": "object",
            "description": "List of HTTP Headers.",
            "example": {}
          },
          "mechanism": {
            "type": "string",
            "enum": [
              "password_based"
            ],
            "description": "Authentication mechanism."
          },
          "backend": {
            "type": "string",
            "enum": [
              "http"
            ],
            "description": "Backend type."
          },
          "url": {
            "type": "string",
            "description": "URL of the HTTP server."
          },
          "body": {
            "type": "object",
            "description": "HTTP request body.",
            "example": {}
          },
          "request_timeout": {
            "default": "5s",
            "type": "string",
            "description": "HTTP request timeout.",
            "example": "32s"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider."
          },
          "request": {
            "description": "Configure HTTP request parameters.",
            "$ref": "#/components/schemas/connector_http.request"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "connect_timeout": {
            "default": "15s",
            "type": "string",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s"
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "The pool size.",
            "minimum": 1
          },
          "max_retries": {
            "type": "integer",
            "deprecated": true,
            "minimum": 0
          },
          "retry_interval": {
            "type": "string",
            "deprecated": true,
            "example": "12m"
          },
          "enable_pipelining": {
            "default": 100,
            "type": "integer",
            "description": "The maximum number of HTTP requests that can be sent before an HTTP response is received.<br/><br/>Setting this to 1 is equivalent to turning off HTTP pipelining, and the EMQX must receive a response to the previous HTTP request before sending the next HTTP request.",
            "minimum": 1
          }
        },
        "type": "object"
      },
      "bridge_mqtt.post": {
        "required": [
          "name",
          "server",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "mqtt"
            ],
            "description": "The bridge type."
          },
          "name": {
            "type": "string",
            "description": "Bridge name, used as a human-readable identifier."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_mqtt.creation_opts"
          },
          "mode": {
            "default": "cluster_shareload",
            "type": "string",
            "enum": [
              "cluster_shareload"
            ],
            "deprecated": true,
            "description": "The mode of the MQTT Bridge.<br/><br/>- cluster_shareload: create an MQTT connection on each node in the emqx cluster.<br/><br/>In 'cluster_shareload' mode, the incoming load from the remote broker is shared by<br/>using shared subscription.<br/><br/>Note that the 'clientid' is suffixed by the node name, this is to avoid<br/>clientid conflicts between different nodes. And we can only use shared subscription<br/>topic filters for <code>remote.topic</code> of ingress connections."
          },
          "server": {
            "type": "string",
            "description": "The host and port of the remote MQTT broker"
          },
          "clientid_prefix": {
            "type": "string",
            "description": "Optional prefix to prepend to the clientid used by egress bridges."
          },
          "reconnect_interval": {
            "type": "string",
            "deprecated": true
          },
          "proto_ver": {
            "default": "v4",
            "type": "string",
            "enum": [
              "v3",
              "v4",
              "v5"
            ],
            "description": "The MQTT protocol version"
          },
          "bridge_mode": {
            "default": false,
            "type": "boolean",
            "description": "If enable bridge mode.<br/>NOTE: This setting is only for MQTT protocol version older than 5.0, and the remote MQTT<br/>broker MUST support this feature.<br/>If bridge_mode is set to true, the bridge will indicate to the remote broker that it is a bridge not an ordinary client.<br/>This means that loop detection will be more effective and that retained messages will be propagated correctly."
          },
          "username": {
            "type": "string",
            "description": "The username of the MQTT protocol"
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password of the MQTT protocol",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "clean_start": {
            "default": true,
            "type": "boolean",
            "description": "Whether to start a clean session when reconnecting a remote broker for ingress bridge"
          },
          "keepalive": {
            "default": "300s",
            "type": "string",
            "description": "MQTT Keepalive. Time interval is a string that contains a number followed by time unit:<br/>- `ms` for milliseconds,<br/>- `s` for seconds,<br/>- `m` for minutes,<br/>- `h` for hours;<br/><br/>or combination of whereof: `1h5m0s`"
          },
          "retry_interval": {
            "default": "15s",
            "type": "string",
            "description": "Message retry interval. Delay for the MQTT bridge to retry sending the QoS1/QoS2 messages in case of ACK not received. Time interval is a string that contains a number followed by time unit:<br/>- `ms` for milliseconds,<br/>- `s` for seconds,<br/>- `m` for minutes,<br/>- `h` for hours;<br/><br/>or combination of whereof: `1h5m0s`"
          },
          "max_inflight": {
            "default": 32,
            "type": "integer",
            "description": "Max inflight (sent, but un-acked) messages of the MQTT protocol",
            "minimum": 0
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "ingress": {
            "description": "The ingress config defines how this bridge receive messages from the remote MQTT broker, and then<br/>        send them to the local broker.<br/><br/>        Template with variables is allowed in 'remote.qos', 'local.topic', 'local.qos', 'local.retain', 'local.payload'.<br/><br/>        NOTE: if this bridge is used as the input of a rule, and also 'local.topic' is<br/>        configured, then messages got from the remote broker will be sent to both the 'local.topic' and<br/>        the rule.",
            "$ref": "#/components/schemas/connector_mqtt.ingress"
          },
          "egress": {
            "description": "The egress config defines how this bridge forwards messages from the local broker to the remote broker.<br/><br/>Template with variables is allowed in 'remote.topic', 'local.qos', 'local.retain', 'local.payload'.<br/><br/>NOTE: if this bridge is used as the action of a rule, and also 'local.topic'<br/>is configured, then both the data got from the rule and the MQTT messages that matches<br/>'local.topic' will be forwarded.",
            "$ref": "#/components/schemas/connector_mqtt.egress"
          }
        },
        "type": "object"
      },
      "rule_engine.metrics": {
        "properties": {
          "matched": {
            "type": "integer",
            "description": "How many times the FROM clause of the SQL is matched.",
            "minimum": 0
          },
          "matched.rate": {
            "type": "number",
            "description": "The rate of matched, times/second"
          },
          "matched.rate.max": {
            "type": "number",
            "description": "The max rate of matched, times/second"
          },
          "matched.rate.last5m": {
            "type": "number",
            "description": "The average rate of matched in last 5 minutes, times/second"
          },
          "passed": {
            "type": "integer",
            "description": "How many times the SQL is passed",
            "minimum": 0
          },
          "failed": {
            "type": "integer",
            "description": "How many times the SQL statement has failed",
            "minimum": 0
          },
          "failed.exception": {
            "type": "integer",
            "description": "How many times the SQL is failed due to exceptions. This may because of a crash when calling a SQL function, or trying to do arithmetic operation on undefined variables",
            "minimum": 0
          },
          "failed.unknown": {
            "type": "integer",
            "description": "How many times the SQL is failed due to an unknown error.",
            "minimum": 0
          },
          "actions.total": {
            "type": "integer",
            "description": "How many times the actions are called by the rule. This value may several times of 'matched', depending on the number of the actions of the rule.",
            "minimum": 0
          },
          "actions.success": {
            "type": "integer",
            "description": "How many times the rule successided to call the actions.",
            "minimum": 0
          },
          "actions.failed": {
            "type": "integer",
            "description": "How many times the rule failed to call the actions.",
            "minimum": 0
          },
          "actions.failed.out_of_service": {
            "type": "integer",
            "description": "How many times the rule has failed to call actions due to the action is out of service. For example, a bridge is disabled or stopped.",
            "minimum": 0
          },
          "actions.failed.unknown": {
            "type": "integer",
            "description": "The number of action failures that have occurred due to unanticipated reasons. For more information on these errors, please refer to the EMQX log file.",
            "minimum": 0
          }
        },
        "type": "object"
      },
      "plugins.plugin": {
        "required": [
          "description",
          "name",
          "rel_apps",
          "rel_vsn",
          "running_status"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "Name-Vsn: without .tar.gz",
            "example": "emqx_plugin_template-5.0-rc.1"
          },
          "author": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "example": [
              "EMQX Team"
            ]
          },
          "builder": {
            "$ref": "#/components/schemas/plugins.builder"
          },
          "built_on_otp_release": {
            "type": "string",
            "example": "24"
          },
          "compatibility": {
            "type": "object",
            "example": {
              "emqx": "~>5.0"
            }
          },
          "git_commit_or_build_date": {
            "type": "string",
            "description": "Last git commit date by `git log -1 --pretty=format:'%cd' --date=format:'%Y-%m-%d`.<br/> If the last commit date is not available, the build date will be presented.",
            "example": "2021-12-25"
          },
          "functionality": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "example": [
              "Demo"
            ]
          },
          "git_ref": {
            "type": "string",
            "example": "ddab50fafeed6b1faea70fc9ffd8c700d7e26ec1"
          },
          "metadata_vsn": {
            "type": "string",
            "example": "0.1.0"
          },
          "rel_vsn": {
            "type": "string",
            "description": "Plugins release version",
            "example": "5.0-rc.1"
          },
          "rel_apps": {
            "type": "array",
            "description": "Aplications in plugin.",
            "items": {
              "type": "string"
            },
            "example": [
              "emqx_plugin_template-5.0.0",
              "map_sets-1.1.0"
            ]
          },
          "repo": {
            "type": "string",
            "example": "https://github.com/emqx/emqx-plugin-template"
          },
          "description": {
            "type": "string",
            "description": "Plugin description.",
            "example": "This is an demo plugin description"
          },
          "running_status": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/plugins.running_status"
            }
          },
          "readme": {
            "type": "string",
            "description": "only return when `GET /plugins/{name}`.",
            "example": "This is an demo plugin."
          }
        },
        "type": "object"
      },
      "emqx_authz_api_mnesia.rules_for_clientid": {
        "required": [
          "clientid"
        ],
        "properties": {
          "rules": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/emqx_authz_api_mnesia.rule_item"
            }
          },
          "clientid": {
            "type": "string",
            "description": "ClientID",
            "example": "client1"
          }
        },
        "type": "object"
      },
      "connector_mqtt.ingress_remote": {
        "required": [
          "topic"
        ],
        "properties": {
          "topic": {
            "type": "string",
            "description": "Receive messages from which topic of the remote broker"
          },
          "qos": {
            "default": 1,
            "maximum": 2,
            "type": "integer",
            "description": "The QoS level to be used when subscribing to the remote broker",
            "minimum": 0,
            "example": 0
          }
        },
        "type": "object"
      },
      "bridge_mqtt_publisher.post_source": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "mqtt"
            ]
          },
          "name": {
            "type": "string"
          },
          "parameters": {
            "$ref": "#/components/schemas/bridge_mqtt_publisher.ingress_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_mqtt_publisher.source_resource_opts"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api_clients.coap_client": {
        "properties": {
          "node": {
            "type": "string",
            "description": "Name of the node to which the client is connected"
          },
          "clientid": {
            "type": "string",
            "description": "Client ID"
          },
          "username": {
            "type": "string",
            "description": "Username of client when connecting"
          },
          "mountpoint": {
            "type": "string",
            "description": "Topic mountpoint"
          },
          "proto_name": {
            "type": "string",
            "description": "Client protocol name"
          },
          "proto_ver": {
            "type": "string",
            "description": "Protocol version used by the client"
          },
          "ip_address": {
            "type": "string",
            "description": "Client's IP address"
          },
          "port": {
            "type": "integer",
            "description": "Client's port"
          },
          "is_bridge": {
            "type": "boolean",
            "description": "Indicates whether the client is connected via bridge"
          },
          "connected_at": {
            "description": "Client connection time",
            "oneOf": [
              {
                "type": "integer",
                "description": "epoch-millisecond",
                "example": 1640995200000
              },
              {
                "type": "string",
                "format": "date-time",
                "example": "2022-01-01T00:00:00.000Z"
              }
            ]
          },
          "disconnected_at": {
            "description": "Client offline time, This field is only valid and returned when connected is false",
            "oneOf": [
              {
                "type": "integer",
                "description": "epoch-millisecond",
                "example": 1640995200000
              },
              {
                "type": "string",
                "format": "date-time",
                "example": "2022-01-01T00:00:00.000Z"
              }
            ]
          },
          "connected": {
            "type": "boolean",
            "description": "Whether the client is connected"
          },
          "keepalive": {
            "type": "integer",
            "description": "Keepalive time, with the unit of second"
          },
          "clean_start": {
            "type": "boolean",
            "description": "Indicate whether the client is using a brand new session"
          },
          "expiry_interval": {
            "type": "integer",
            "description": "Session expiration interval, with the unit of second"
          },
          "created_at": {
            "description": "Session creation time",
            "oneOf": [
              {
                "type": "integer",
                "description": "epoch-millisecond",
                "example": 1640995200000
              },
              {
                "type": "string",
                "format": "date-time",
                "example": "2022-01-01T00:00:00.000Z"
              }
            ]
          },
          "subscriptions_cnt": {
            "type": "integer",
            "description": "Number of subscriptions established by this client"
          },
          "subscriptions_max": {
            "type": "integer",
            "description": "Maximum number of subscriptions allowed by this client"
          },
          "inflight_cnt": {
            "type": "integer",
            "description": "Current length of inflight"
          },
          "inflight_max": {
            "type": "integer",
            "description": "Maximum length of inflight"
          },
          "mqueue_len": {
            "type": "integer",
            "description": "Current length of message queue"
          },
          "mqueue_max": {
            "type": "integer",
            "description": "Maximum length of message queue"
          },
          "mqueue_dropped": {
            "type": "integer",
            "description": "Number of messages dropped by the message queue due to exceeding the length"
          },
          "awaiting_rel_cnt": {
            "type": "integer",
            "description": "Number of awaiting acknowledge packet"
          },
          "awaiting_rel_max": {
            "type": "integer",
            "description": "Maximum allowed number of awaiting PUBREC packet"
          },
          "recv_oct": {
            "type": "integer",
            "description": "Number of bytes received"
          },
          "recv_cnt": {
            "type": "integer",
            "description": "Number of socket packets received"
          },
          "recv_pkt": {
            "type": "integer",
            "description": "Number of protocol packets received"
          },
          "recv_msg": {
            "type": "integer",
            "description": "Number of message packets received"
          },
          "send_oct": {
            "type": "integer",
            "description": "Number of bytes sent"
          },
          "send_cnt": {
            "type": "integer",
            "description": "Number of socket packets sent"
          },
          "send_pkt": {
            "type": "integer",
            "description": "Number of protocol packets sent"
          },
          "send_msg": {
            "type": "integer",
            "description": "Number of message packets sent"
          },
          "mailbox_len": {
            "type": "integer",
            "description": "Process mailbox size"
          },
          "heap_size": {
            "type": "integer",
            "description": "Process heap size with the unit of byte"
          },
          "reductions": {
            "type": "integer",
            "description": "Erlang reduction"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_clients.authz_cache": {
        "properties": {
          "access": {
            "type": "string",
            "description": "Access type",
            "example": "publish"
          },
          "result": {
            "type": "string",
            "enum": [
              "allow",
              "denny"
            ],
            "description": "Allow or deny",
            "example": "allow"
          },
          "topic": {
            "type": "string",
            "description": "Topic name",
            "example": "testtopic/1"
          },
          "updated_time": {
            "type": "integer",
            "description": "Update time",
            "example": 1687850712989
          }
        },
        "type": "object"
      },
      "slow_subs.slow_subs": {
        "properties": {
          "enable": {
            "default": false,
            "type": "boolean",
            "description": "Enable Slow Subscriptions"
          },
          "threshold": {
            "default": "500ms",
            "type": "string",
            "description": "The Client ID and topic of the consumer whose message latency is greater than this threshold will be recorded in the slow subscription list.",
            "example": "32s"
          },
          "expire_interval": {
            "default": "300s",
            "type": "string",
            "description": "The expiration time of the slow subscription record, if the record is not updated within the expiration time, then the record will be deleted.",
            "example": "32s"
          },
          "top_k_num": {
            "default": 10,
            "type": "integer",
            "description": "The maximum number of slow-subscription records, up to a maximum of 1000.",
            "minimum": 1
          },
          "stats_type": {
            "default": "whole",
            "type": "string",
            "enum": [
              "whole",
              "internal",
              "response"
            ],
            "description": "Message latency calculation method:<br/><br/>- `whole`: The time from when the message arrives at the EMQX (the EMQX gets the message from the receive-buffer) until the message completes delivery.<br/>- `internal`: The time from when the message arrives at the EMQX (the EMQX gets the message from the receive-buffer) to when the message begins to be delivered (the EMQX attempts to write the message to the send-buffer).<br/>- `response`: The time from the start of message delivery to the completion.<br/><br/>Note: The completion delivery time refers to the time when QoS 1 and 2 messages complete the MQTT message response process, i.e., the time when QoS 1 message receives the PUBACK packet and QoS 2 message receives the PUBCOMP packet.<br/>Since there is no response packet for QoS 0 message, the completion delivery time of the QoS 0 message will be replaced by the time when the message starts to be delivered. Therefore, when using the `response` method to calculate the latency, the latency of a QoS 0 message will always be equal to 0."
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_clients.message": {
        "properties": {
          "msgid": {
            "type": "string",
            "description": "Message ID."
          },
          "topic": {
            "type": "string",
            "description": "Message topic."
          },
          "qos": {
            "maximum": 2,
            "type": "integer",
            "description": "Message QoS.",
            "minimum": 0,
            "example": 0
          },
          "publish_at": {
            "type": "integer",
            "description": "Message publish time, a millisecond precision Unix epoch timestamp."
          },
          "from_clientid": {
            "type": "string",
            "description": "Message publisher's Client ID"
          },
          "from_username": {
            "type": "string",
            "description": "Message publisher's username."
          },
          "payload": {
            "type": "string"
          },
          "inserted_at": {
            "type": "string",
            "description": "A nanosecond precision Unix epoch timestamp at which a message was inserted to In-flight / Mqueue."
          }
        },
        "type": "object"
      },
      "limiter.limiter": {
        "properties": {},
        "type": "object"
      },
      "dashboard.https": {
        "required": [
          "ssl_options"
        ],
        "properties": {
          "bind": {
            "default": 0,
            "type": "string",
            "description": "Bind the listener to a specified address and port number, for example `127.0.0.1:18083`.<br/>If configured with just the port number (e.g. `18083`) it's equivalent to binding to all addresses `0.0.0.0`.<br/>The listener is disabled if `bind` is `0`.",
            "example": "0.0.0.0:18084"
          },
          "ssl_options": {
            "description": "SSL/TLS options for the dashboard listener.",
            "$ref": "#/components/schemas/dashboard.ssl_options"
          },
          "num_acceptors": {
            "default": 20,
            "type": "integer",
            "description": "Socket acceptor pool size for TCP protocols. Default is the number of schedulers online"
          },
          "max_connections": {
            "default": 512,
            "type": "integer",
            "description": "The maximum number of concurrent connections allowed by the listener."
          },
          "backlog": {
            "default": 1024,
            "type": "integer",
            "description": "Defines the maximum length that the queue of pending connections can grow to."
          },
          "send_timeout": {
            "default": "10s",
            "type": "string",
            "description": "Send timeout for the socket.",
            "example": "12m"
          },
          "inet6": {
            "default": false,
            "type": "boolean",
            "description": "Enable IPv6 support, default is false, which means IPv4 only."
          },
          "ipv6_v6only": {
            "default": false,
            "type": "boolean",
            "description": "Disable IPv4-to-IPv6 mapping for the listener.<br/>The configuration is only valid when the inet6 is true."
          },
          "proxy_header": {
            "default": false,
            "type": "boolean",
            "description": "Enable support for `HAProxy` header. Be aware once enabled regular HTTP requests can't be handled anymore."
          }
        },
        "type": "object"
      },
      "gateway.exproto_grpc_server": {
        "required": [
          "bind"
        ],
        "properties": {
          "bind": {
            "type": "string",
            "description": "Listening address and port for the gRPC server.",
            "example": "127.0.0.1:80"
          },
          "ssl_options": {
            "description": "SSL configuration for the gRPC server.",
            "$ref": "#/components/schemas/gateway.ssl_server_opts"
          }
        },
        "type": "object"
      },
      "trace.log_file_detail": {
        "properties": {
          "node": {
            "type": "string",
            "description": "Node name",
            "example": "emqx@127.0.0.1"
          },
          "size": {
            "type": "integer",
            "description": "file size"
          },
          "mtime": {
            "type": "integer",
            "description": "The last time this file is modified."
          }
        },
        "type": "object"
      },
      "rule_engine.ctx_check_authn_complete": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "type": "string",
            "enum": [
              "client_check_authn_complete"
            ],
            "description": "Event Type"
          },
          "clientid": {
            "type": "string",
            "description": "The Client ID"
          },
          "username": {
            "type": "string",
            "description": "Username"
          },
          "reason_code": {
            "type": "string",
            "description": "The reason code"
          },
          "peername": {
            "type": "string",
            "description": "The IP Address and Port of the Peer Client"
          },
          "is_anonymous": {
            "type": "boolean",
            "description": "True if this user is anonymous."
          },
          "is_superuser": {
            "type": "boolean",
            "description": "True if this is a super user."
          }
        },
        "type": "object"
      },
      "authn.node_metrics": {
        "properties": {
          "node": {
            "type": "string",
            "description": "Node name.",
            "example": "emqx@127.0.0.1"
          },
          "metrics": {
            "description": "The metrics of the resource.",
            "$ref": "#/components/schemas/authn.metrics"
          }
        },
        "type": "object"
      },
      "gateway.websocket": {
        "properties": {
          "path": {
            "default": "",
            "type": "string",
            "description": "WebSocket's MQTT protocol path. So the address of EMQX Broker's WebSocket is:<br/><code>ws://{ip}:{port}/mqtt</code>"
          },
          "piggyback": {
            "default": "single",
            "type": "string",
            "enum": [
              "single",
              "multiple"
            ],
            "description": "Whether a WebSocket message is allowed to contain multiple MQTT packets."
          },
          "compress": {
            "default": false,
            "type": "boolean",
            "description": "If <code>true</code>, compress WebSocket messages using <code>zlib</code>.<br/><br/>The configuration items under <code>deflate_opts</code> belong to the compression-related parameter configuration."
          },
          "idle_timeout": {
            "default": "7200s",
            "type": "string",
            "description": "The timeout for waiting for the WebSocket upgrade request. After the timeout, the connection will be closed.",
            "example": "12m"
          },
          "max_frame_size": {
            "default": "infinity",
            "description": "The maximum length of a single MQTT packet.",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "fail_if_no_subprotocol": {
            "default": true,
            "type": "boolean",
            "description": "If <code>true</code>, the server will return an error when<br/> the client does not carry the <code>Sec-WebSocket-Protocol</code> field.<br/> <br/>Note: WeChat applet needs to disable this verification."
          },
          "supported_subprotocols": {
            "default": "",
            "type": "string",
            "description": "Comma-separated list of supported subprotocols.",
            "example": "item1,item2"
          },
          "check_origin_enable": {
            "default": false,
            "type": "boolean",
            "description": "If <code>true</code>, <code>origin</code> HTTP header will be<br/> validated against the list of allowed origins configured in <code>check_origins</code><br/> parameter."
          },
          "allow_origin_absence": {
            "default": true,
            "type": "boolean",
            "description": "If <code>false</code> and <code>check_origin_enable</code> is<br/> <code>true</code>, the server will reject requests that don't have <code>origin</code><br/> HTTP header."
          },
          "check_origins": {
            "default": "http://localhost:18083, http://127.0.0.1:18083",
            "type": "string",
            "description": "List of allowed origins.<br/>See <code>check_origin_enable</code>.",
            "example": "item1,item2"
          },
          "proxy_address_header": {
            "default": "x-forwarded-for",
            "type": "string",
            "description": "HTTP header used to pass information about the client IP address.<br/>Relevant when the EMQX cluster is deployed behind a load-balancer."
          },
          "proxy_port_header": {
            "default": "x-forwarded-port",
            "type": "string",
            "description": "HTTP header used to pass information about the client port. Relevant when the EMQX cluster is deployed behind a load-balancer."
          },
          "deflate_opts": {
            "$ref": "#/components/schemas/emqx.deflate_opts"
          }
        },
        "type": "object"
      },
      "emqx_authz_schema.node_resource_metrics": {
        "properties": {
          "node": {
            "type": "string",
            "description": "Node name.",
            "example": "emqx@127.0.0.1"
          },
          "metrics": {
            "description": "The metrics of the resource.",
            "$ref": "#/components/schemas/emqx_authz_schema.resource_metrics"
          }
        },
        "type": "object"
      },
      "connector_mqtt.resource_opts": {
        "properties": {
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "start_after_created": {
            "default": true,
            "type": "boolean",
            "description": "Whether start the resource right after created."
          },
          "start_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "example": "32s"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_sources.request_sources_order": {
        "required": [
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "file",
              "built_in_database",
              "http",
              "redis",
              "mysql",
              "postgresql",
              "mongodb",
              "ldap"
            ],
            "description": "Authorization type",
            "example": "file"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_data_backup.files_response": {
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/emqx_mgmt_api_data_backup.backup_file_info"
            }
          },
          "meta": {
            "$ref": "#/components/schemas/public.meta"
          }
        },
        "type": "object"
      },
      "emqx.sysmon_os": {
        "properties": {
          "cpu_check_interval": {
            "default": "60s",
            "type": "string",
            "description": "The time interval for the periodic CPU check. Disabled on Windows platform.",
            "example": "12m"
          },
          "cpu_high_watermark": {
            "default": "80%",
            "type": "string",
            "description": "The threshold, as percentage of system CPU load,<br/> for how much system cpu can be used before the corresponding alarm is raised. Disabled on Windows platform",
            "example": "12%"
          },
          "cpu_low_watermark": {
            "default": "60%",
            "type": "string",
            "description": "The threshold, as percentage of system CPU load,<br/> for how much system cpu can be used before the corresponding alarm is cleared. Disabled on Windows platform",
            "example": "12%"
          },
          "mem_check_interval": {
            "default": "60s",
            "description": "The time interval for the periodic memory check. Disabled on Windows platform.",
            "oneOf": [
              {
                "type": "string",
                "example": "12m"
              },
              {
                "type": "string",
                "enum": [
                  "disabled"
                ]
              }
            ]
          },
          "sysmem_high_watermark": {
            "default": "70%",
            "type": "string",
            "description": "The threshold, as percentage of system memory,<br/> for how much system memory can be allocated before the corresponding alarm is raised. Disabled on Windows platform",
            "example": "12%"
          },
          "procmem_high_watermark": {
            "default": "5%",
            "type": "string",
            "description": "The threshold, as percentage of system memory,<br/> for how much system memory can be allocated by one Erlang process before<br/> the corresponding alarm is raised. Disabled on Windows platform.",
            "example": "12%"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.dtls_listener": {
        "properties": {
          "id": {
            "type": "string",
            "description": "Listener ID"
          },
          "type": {
            "type": "string",
            "enum": [
              "dtls"
            ],
            "description": "Listener Type"
          },
          "name": {
            "type": "string",
            "description": "Listener Name"
          },
          "running": {
            "type": "boolean",
            "description": "Listener Running status"
          },
          "acceptors": {
            "default": 16,
            "type": "integer",
            "description": "Size of the acceptor pool."
          },
          "health_check": {
            "description": "Some Cloud platform use a `request-reply` mechanism to check whether a UDP port is healthy, here can configure this pair.",
            "$ref": "#/components/schemas/gateway.udp_health_check"
          },
          "udp_options": {
            "$ref": "#/components/schemas/gateway.udp_opts"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable the listener."
          },
          "bind": {
            "type": "string",
            "description": "The IP address and port that the listener will bind.",
            "example": "127.0.0.1:80"
          },
          "max_connections": {
            "default": 1024,
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "integer",
                "minimum": 1
              }
            ]
          },
          "max_conn_rate": {
            "default": 1000,
            "type": "integer",
            "description": "Maximum connections per second."
          },
          "enable_authn": {
            "default": true,
            "type": "boolean",
            "description": "Set <code>true</code> (default) to enable client authentication on this listener.<br/>When set to <code>false</code> clients will be allowed to connect without authentication."
          },
          "mountpoint": {
            "type": "string",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message is delivered to the subscriber.<br/>The mountpoint is a way that users can use to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,<br/>then the client actually subscribes to the topic `some_tenant/t`.<br/>Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,<br/>the message is routed to all the clients subscribed `some_tenant/t`,<br/>so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.<br/>Supported placeholders in mountpoint string:<br/><br/>  - <code>${clientid}</code>: clientid<br/><br/>  - <code>${username}</code>: username<br/><br/>  - <code>${endpoint_name}</code>: endpoint name"
          },
          "access_rules": {
            "default": [],
            "type": "array",
            "description": "An access rule list consisting of string rules to restrict or allow access from some addresses.<br/>The rules that appear earlier in the list are matched first.<br/>The format is `allow | deny <address> | <CIDR> | all`.<br/><br/>For example:<br/><br/>`[\\\"deny 192.168.1.1\\\", \\\"allow 192.168.1.0/24\\\", \\\"deny, all\\\"]`",
            "items": {
              "type": "string"
            }
          },
          "dtls_options": {
            "description": "DTLS socket options",
            "$ref": "#/components/schemas/gateway.dtls_opts"
          }
        },
        "type": "object"
      },
      "ldap.ssl": {
        "properties": {
          "cacertfile": {
            "type": "string",
            "description": "Trusted PEM format CA certificates bundle file.<br/><br/>The certificates in this file are used to verify the TLS peer's certificates.<br/>Append new certificates to the file if new CAs are to be trusted.<br/>There is no need to restart EMQX to have the updated file loaded, because<br/>the system regularly checks if file has been updated (and reload).<br/><br/>NOTE: invalidating (deleting) a certificate from the file will not affect<br/>already established connections."
          },
          "cacerts": {
            "default": false,
            "type": "boolean",
            "deprecated": true
          },
          "certfile": {
            "type": "string",
            "description": "PEM format certificates chain file.<br/><br/>The certificates in this file should be in reversed order of the certificate<br/>issue chain. That is, the host's certificate should be placed in the beginning<br/>of the file, followed by the immediate issuer certificate and so on.<br/>Although the root CA certificate is optional, it should be placed at the end of<br/>the file if it is to be added."
          },
          "keyfile": {
            "type": "string",
            "description": "PEM format private key file."
          },
          "verify": {
            "default": "verify_none",
            "type": "string",
            "enum": [
              "verify_peer",
              "verify_none"
            ],
            "description": "Enable or disable peer verification."
          },
          "reuse_sessions": {
            "default": true,
            "type": "boolean",
            "description": "Enable TLS session reuse.<br/><br/>Has no effect when TLS version is configured (or negotiated) to 1.3"
          },
          "depth": {
            "default": 10,
            "type": "integer",
            "description": "Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path.<br/>So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly;<br/><br/>if 1 the path can be PEER, Intermediate-CA, ROOT-CA;<br/><br/>if 2 the path can be PEER, Intermediate-CA1, Intermediate-CA2, ROOT-CA.",
            "minimum": 0
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "String containing the user's password. Only used if the private key file is password-protected.",
            "example": ""
          },
          "versions": {
            "default": [
              "tlsv1.3",
              "tlsv1.2"
            ],
            "type": "array",
            "description": "All TLS/DTLS versions to be supported.<br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.<br/><br/>In case PSK cipher suites are intended, make sure to configure<br/><code>['tlsv1.2', 'tlsv1.1']</code> here.",
            "items": {
              "type": "string"
            }
          },
          "ciphers": {
            "default": [],
            "type": "array",
            "description": "This config holds TLS cipher suite names separated by comma,<br/>or as an array of strings. e.g.<br/><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or<br/><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.<br/><br/><br/>Ciphers (and their ordering) define the way in which the<br/>client and server encrypts information over the network connection.<br/>Selecting a good cipher suite is critical for the<br/>application's data security, confidentiality and performance.<br/><br/>The names should be in OpenSSL string format (not RFC format).<br/>All default values and examples provided by EMQX config<br/>documentation are all in OpenSSL format.<br/><br/><br/>NOTE: Certain cipher suites are only compatible with<br/>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')<br/>incompatible cipher suites will be silently dropped.<br/>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,<br/>configuring cipher suites for other versions will have no effect.<br/><br/><br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br/><br/>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.<br/><br/>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,<br/>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,<br/>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,<br/>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code>",
            "items": {
              "type": "string"
            }
          },
          "secure_renegotiate": {
            "default": true,
            "type": "boolean",
            "description": "Whether to reject TLS renegotiation attempts that are not compliant with [RFC 5746](http://www.ietf.org/rfc/rfc5746.txt).<br/><br/>By default, `secure_renegotiate` is set to `true`, which forces secure renegotiation.<br/>If set to `false`, secure renegotiation will still be used, but will fall back to insecure renegotiation if the peer does not support [RFC 5746](http://www.ietf.org/rfc/rfc5746.txt), which increases the risk of a MitM attack.<br/><br/>Has no effect when TLS version is configured (or negotiated) to 1.3."
          },
          "log_level": {
            "default": "notice",
            "type": "string",
            "enum": [
              "emergency",
              "alert",
              "critical",
              "error",
              "warning",
              "notice",
              "info",
              "debug",
              "none",
              "all"
            ],
            "description": "The minimum level of logging allowed for SSL output.<br/><br/>The default is `notice`, set to a lower `debug` level for more detailed logging that can be used to investigate SSL handshake issues."
          },
          "hibernate_after": {
            "default": "5s",
            "type": "string",
            "description": "Specifies the amount of time that an SSL process will hibernate after being idle, thus reducing its memory footprint.<br/><br/>The hibernating process will be woken up when a new message arrives.<br/>Hibernating and waking up too often can cause CPU utilization to increase, as they both perform garbage collection on the process.",
            "example": "12m"
          },
          "enable": {
            "default": false,
            "type": "boolean",
            "description": "Enable TLS."
          },
          "server_name_indication": {
            "description": "Specify the host name to be used in TLS Server Name Indication extension.<br/><br/>For instance, when connecting to \"server.example.net\", the genuine server<br/>which accepts the connection and performs TLS handshake may differ from the<br/>host the TLS client initially connects to, e.g. when connecting to an IP address<br/>or when the host has multiple resolvable DNS records <br/><br/>If not specified, it will default to the host name string which is used<br/>to establish the connection, unless it is IP address used.<br/><br/>The host name is then also used in the host name verification of the peer<br/>certificate.<br/> The special value 'disable' prevents the Server Name<br/>Indication extension from being sent and disables the hostname<br/>verification check.",
            "example": "disable",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "string",
                "enum": [
                  "disable"
                ]
              }
            ]
          }
        },
        "type": "object"
      },
      "dashboard.user": {
        "properties": {
          "username": {
            "type": "string",
            "description": "Dashboard Username",
            "maxLength": 100,
            "example": "admin"
          },
          "description": {
            "type": "string",
            "description": "Dashboard User Description",
            "example": "administrator"
          },
          "backend": {
            "type": "string",
            "description": "User account source",
            "example": "local"
          }
        },
        "type": "object"
      },
      "emqx.deflate_opts": {
        "properties": {
          "level": {
            "type": "string",
            "enum": [
              "none",
              "default",
              "best_compression",
              "best_speed"
            ],
            "description": "Compression level."
          },
          "mem_level": {
            "default": 8,
            "maximum": 9,
            "type": "integer",
            "description": "Specifies the size of the compression state.<br/><br/>Lower values decrease memory usage per connection.",
            "minimum": 1
          },
          "strategy": {
            "default": "default",
            "type": "string",
            "enum": [
              "default",
              "filtered",
              "huffman_only",
              "rle"
            ],
            "description": "Specifies the compression strategy."
          },
          "server_context_takeover": {
            "default": "takeover",
            "type": "string",
            "enum": [
              "takeover",
              "no_takeover"
            ],
            "description": "Takeover means the compression state is retained between server messages."
          },
          "client_context_takeover": {
            "default": "takeover",
            "type": "string",
            "enum": [
              "takeover",
              "no_takeover"
            ],
            "description": "Takeover means the compression state is retained between client messages."
          },
          "server_max_window_bits": {
            "default": 15,
            "maximum": 15,
            "type": "integer",
            "description": "Specifies the size of the compression context for the server.",
            "minimum": 8
          },
          "client_max_window_bits": {
            "default": 15,
            "maximum": 15,
            "type": "integer",
            "description": "Specifies the size of the compression context for the client.",
            "minimum": 8
          }
        },
        "type": "object"
      },
      "emqx.log_file_handler": {
        "properties": {
          "path": {
            "default": "${EMQX_LOG_DIR}/emqx.log",
            "type": "string",
            "description": "Name the log file."
          },
          "rotation_count": {
            "default": 10,
            "maximum": 128,
            "type": "integer",
            "description": "Maximum number of log files.",
            "minimum": 1
          },
          "rotation_size": {
            "default": "50MB",
            "description": "This parameter controls log file rotation. The value `infinity` means the log file will grow indefinitely, otherwise the log file will be rotated once it reaches `rotation_size` in bytes.",
            "oneOf": [
              {
                "type": "string",
                "example": "32MB"
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "level": {
            "default": "warning",
            "type": "string",
            "enum": [
              "debug",
              "info",
              "notice",
              "warning",
              "error",
              "critical",
              "alert",
              "emergency",
              "all"
            ],
            "description": "The log level for the current log handler.<br/>Defaults to warning."
          },
          "enable": {
            "default": false,
            "type": "boolean",
            "description": "Enable this log handler."
          },
          "formatter": {
            "default": "text",
            "type": "string",
            "enum": [
              "text",
              "json"
            ],
            "description": "Choose log formatter. <code>text</code> for free text, and <code>json</code> for structured logging."
          },
          "timestamp_format": {
            "default": "auto",
            "type": "string",
            "enum": [
              "auto",
              "epoch",
              "rfc3339"
            ],
            "description": "Pick a timestamp format:<br/>- `auto`: automatically choose the best format based on log formatter. `epoch` for JSON and `rfc3339` for text.<br/>- `epoch`: Unix epoch time in microseconds.<br/>- `rfc3339`: RFC3339 format."
          },
          "time_offset": {
            "default": "system",
            "type": "string",
            "description": "The time offset to be used when formatting the timestamp.<br/>Can be one of:<br/>  - <code>system</code>: the time offset used by the local system<br/>  - <code>utc</code>: the UTC time offset<br/>  - <code>+-[hh]:[mm]</code>: user specified time offset, such as \"-02:00\" or \"+00:00\"<br/>Defaults to: <code>system</code>.<br/>This config has no effect for when formatter is <code>json</code> as the timestamp in JSON is milliseconds since epoch."
          },
          "payload_encode": {
            "default": "text",
            "type": "string",
            "enum": [
              "hex",
              "text",
              "hidden"
            ],
            "description": "Determine the format of the payload format in the trace file.<br/><br/>`text`: Text-based protocol or plain text protocol.<br/> It is recommended when payload is JSON encoded.<br/><br/>`hex`: Binary hexadecimal encode. It is recommended when payload is a custom binary protocol.<br/><br/>`hidden`: payload is obfuscated as `******`"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api_clients.lwm2m_client": {
        "properties": {
          "endpoint_name": {
            "type": "string",
            "description": "The LwM2M client endpoint name"
          },
          "lifetime": {
            "type": "integer",
            "description": "LwM2M Life time"
          },
          "node": {
            "type": "string",
            "description": "Name of the node to which the client is connected"
          },
          "clientid": {
            "type": "string",
            "description": "Client ID"
          },
          "username": {
            "type": "string",
            "description": "Username of client when connecting"
          },
          "mountpoint": {
            "type": "string",
            "description": "Topic mountpoint"
          },
          "proto_name": {
            "type": "string",
            "description": "Client protocol name"
          },
          "proto_ver": {
            "type": "string",
            "description": "Protocol version used by the client"
          },
          "ip_address": {
            "type": "string",
            "description": "Client's IP address"
          },
          "port": {
            "type": "integer",
            "description": "Client's port"
          },
          "is_bridge": {
            "type": "boolean",
            "description": "Indicates whether the client is connected via bridge"
          },
          "connected_at": {
            "description": "Client connection time",
            "oneOf": [
              {
                "type": "integer",
                "description": "epoch-millisecond",
                "example": 1640995200000
              },
              {
                "type": "string",
                "format": "date-time",
                "example": "2022-01-01T00:00:00.000Z"
              }
            ]
          },
          "disconnected_at": {
            "description": "Client offline time, This field is only valid and returned when connected is false",
            "oneOf": [
              {
                "type": "integer",
                "description": "epoch-millisecond",
                "example": 1640995200000
              },
              {
                "type": "string",
                "format": "date-time",
                "example": "2022-01-01T00:00:00.000Z"
              }
            ]
          },
          "connected": {
            "type": "boolean",
            "description": "Whether the client is connected"
          },
          "keepalive": {
            "type": "integer",
            "description": "Keepalive time, with the unit of second"
          },
          "clean_start": {
            "type": "boolean",
            "description": "Indicate whether the client is using a brand new session"
          },
          "expiry_interval": {
            "type": "integer",
            "description": "Session expiration interval, with the unit of second"
          },
          "created_at": {
            "description": "Session creation time",
            "oneOf": [
              {
                "type": "integer",
                "description": "epoch-millisecond",
                "example": 1640995200000
              },
              {
                "type": "string",
                "format": "date-time",
                "example": "2022-01-01T00:00:00.000Z"
              }
            ]
          },
          "subscriptions_cnt": {
            "type": "integer",
            "description": "Number of subscriptions established by this client"
          },
          "subscriptions_max": {
            "type": "integer",
            "description": "Maximum number of subscriptions allowed by this client"
          },
          "inflight_cnt": {
            "type": "integer",
            "description": "Current length of inflight"
          },
          "inflight_max": {
            "type": "integer",
            "description": "Maximum length of inflight"
          },
          "mqueue_len": {
            "type": "integer",
            "description": "Current length of message queue"
          },
          "mqueue_max": {
            "type": "integer",
            "description": "Maximum length of message queue"
          },
          "mqueue_dropped": {
            "type": "integer",
            "description": "Number of messages dropped by the message queue due to exceeding the length"
          },
          "awaiting_rel_cnt": {
            "type": "integer",
            "description": "Number of awaiting acknowledge packet"
          },
          "awaiting_rel_max": {
            "type": "integer",
            "description": "Maximum allowed number of awaiting PUBREC packet"
          },
          "recv_oct": {
            "type": "integer",
            "description": "Number of bytes received"
          },
          "recv_cnt": {
            "type": "integer",
            "description": "Number of socket packets received"
          },
          "recv_pkt": {
            "type": "integer",
            "description": "Number of protocol packets received"
          },
          "recv_msg": {
            "type": "integer",
            "description": "Number of message packets received"
          },
          "send_oct": {
            "type": "integer",
            "description": "Number of bytes sent"
          },
          "send_cnt": {
            "type": "integer",
            "description": "Number of socket packets sent"
          },
          "send_pkt": {
            "type": "integer",
            "description": "Number of protocol packets sent"
          },
          "send_msg": {
            "type": "integer",
            "description": "Number of message packets sent"
          },
          "mailbox_len": {
            "type": "integer",
            "description": "Process mailbox size"
          },
          "heap_size": {
            "type": "integer",
            "description": "Process heap size with the unit of byte"
          },
          "reductions": {
            "type": "integer",
            "description": "Erlang reduction"
          }
        },
        "type": "object"
      },
      "bridge_mqtt_publisher.post_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "mqtt"
            ]
          },
          "name": {
            "type": "string"
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Action specific configs.",
            "$ref": "#/components/schemas/bridge_mqtt_publisher.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_mqtt_publisher.action_resource_opts"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.wss_listener": {
        "properties": {
          "id": {
            "type": "string",
            "description": "Listener ID"
          },
          "type": {
            "type": "string",
            "enum": [
              "wss"
            ],
            "description": "Listener Type"
          },
          "name": {
            "type": "string",
            "description": "Listener Name"
          },
          "running": {
            "type": "boolean",
            "description": "Listener Running status"
          },
          "acceptors": {
            "default": 16,
            "type": "integer",
            "description": "Size of the acceptor pool."
          },
          "tcp_options": {
            "description": "Setting the TCP socket options.",
            "$ref": "#/components/schemas/emqx.tcp_opts"
          },
          "proxy_protocol": {
            "default": false,
            "type": "boolean",
            "description": "If a reverse proxy is deployed for EMQX, and the PROXY protocol is enabled at the proxy to pass the client's real IP,<br/>this option needs to be turned on so that EMQX can extract the client's real IP from the PROXY protocol header.<br/>EMQX will automatically detect the version of the PROXY protocol and support V1 and V2.<br/><br/>For a detailed description of the PROXY protocol, please refer to: https://www.haproxy.com/blog/haproxy/proxy-protocol/"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "type": "string",
            "description": "Timeout for proxy protocol.<br/>EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.",
            "example": "12m"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable the listener."
          },
          "bind": {
            "type": "string",
            "description": "The IP address and port that the listener will bind.",
            "example": "127.0.0.1:80"
          },
          "max_connections": {
            "default": 1024,
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "integer",
                "minimum": 1
              }
            ]
          },
          "max_conn_rate": {
            "default": 1000,
            "type": "integer",
            "description": "Maximum connections per second."
          },
          "enable_authn": {
            "default": true,
            "type": "boolean",
            "description": "Set <code>true</code> (default) to enable client authentication on this listener.<br/>When set to <code>false</code> clients will be allowed to connect without authentication."
          },
          "mountpoint": {
            "type": "string",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message is delivered to the subscriber.<br/>The mountpoint is a way that users can use to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,<br/>then the client actually subscribes to the topic `some_tenant/t`.<br/>Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,<br/>the message is routed to all the clients subscribed `some_tenant/t`,<br/>so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.<br/>Supported placeholders in mountpoint string:<br/><br/>  - <code>${clientid}</code>: clientid<br/><br/>  - <code>${username}</code>: username<br/><br/>  - <code>${endpoint_name}</code>: endpoint name"
          },
          "access_rules": {
            "default": [],
            "type": "array",
            "description": "An access rule list consisting of string rules to restrict or allow access from some addresses.<br/>The rules that appear earlier in the list are matched first.<br/>The format is `allow | deny <address> | <CIDR> | all`.<br/><br/>For example:<br/><br/>`[\\\"deny 192.168.1.1\\\", \\\"allow 192.168.1.0/24\\\", \\\"deny, all\\\"]`",
            "items": {
              "type": "string"
            }
          },
          "ssl_options": {
            "description": "SSL Socket options.",
            "$ref": "#/components/schemas/emqx.listener_wss_opts"
          },
          "websocket": {
            "$ref": "#/components/schemas/gateway.websocket"
          }
        },
        "type": "object"
      },
      "emqx.durable_sessions": {
        "properties": {
          "enable": {
            "default": false,
            "type": "boolean",
            "description": "Use durable storage for client sessions persistence.<br/>If enabled, sessions configured to outlive client connections, along with their corresponding messages, will be durably stored and survive broker downtime.<br/><br/>:::warning<br/>This feature is currently experimental. Please don't enable it in the production environments that contain valuable data.<br/>:::"
          },
          "batch_size": {
            "default": 100,
            "type": "integer",
            "description": "This value affects the flow control for the persistent sessions.<br/>Persistent session queries the durable message storage in batches.<br/>This value specifies size of the batch.<br/><br/>Note: larger batches generally improve the throughput and overall performance of the system, but increase RAM usage per client.",
            "minimum": 1
          },
          "idle_poll_interval": {
            "default": "100ms",
            "type": "string",
            "example": "12m"
          },
          "heartbeat_interval": {
            "default": "5000ms",
            "type": "string",
            "example": "12m"
          },
          "session_gc_interval": {
            "default": "10m",
            "type": "string",
            "description": "The interval at which session garbage collection is executed for persistent sessions.",
            "example": "12m"
          },
          "session_gc_batch_size": {
            "default": 100,
            "type": "integer",
            "description": "The size of each batch of expired persistent sessions to be garbage collected per iteration.",
            "minimum": 1
          },
          "message_retention_period": {
            "default": "1d",
            "type": "string",
            "example": "12m"
          }
        },
        "type": "object"
      },
      "emqx_authz_schema.metrics_status_fields": {
        "properties": {
          "resource_metrics": {
            "description": "The metrics of the resource.",
            "$ref": "#/components/schemas/emqx_authz_schema.resource_metrics"
          },
          "node_resource_metrics": {
            "type": "array",
            "description": "The metrics of the resource for each node.",
            "items": {
              "$ref": "#/components/schemas/emqx_authz_schema.node_resource_metrics"
            }
          },
          "metrics": {
            "description": "The metrics of the resource.",
            "$ref": "#/components/schemas/emqx_authz_schema.metrics"
          },
          "node_metrics": {
            "type": "array",
            "description": "The metrics of the resource for each node.",
            "items": {
              "$ref": "#/components/schemas/emqx_authz_schema.node_metrics"
            }
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the resource."
          },
          "node_status": {
            "type": "array",
            "description": "The status of the resource for each node.",
            "items": {
              "$ref": "#/components/schemas/emqx_authz_schema.node_status"
            }
          },
          "node_error": {
            "type": "array",
            "description": "The error of node.",
            "items": {
              "$ref": "#/components/schemas/emqx_authz_schema.node_error"
            }
          }
        },
        "type": "object"
      },
      "auto_subscribe.topic": {
        "required": [
          "topic"
        ],
        "properties": {
          "topic": {
            "type": "string",
            "description": "Topic name, placeholders are supported. For example: client/${clientid}/username/${username}/host/${host}/port/${port}<br/>Required field, and cannot be empty string",
            "example": "/clientid/${clientid}/username/${username}/host/${host}/port/${port}"
          },
          "qos": {
            "default": 0,
            "maximum": 2,
            "type": "integer",
            "description": "Default value 0. Quality of service.<br/>At most once (0)<br/>At least once (1)<br/>Exactly once (2)",
            "minimum": 0,
            "example": 0
          },
          "rh": {
            "default": 0,
            "maximum": 2,
            "type": "integer",
            "description": "Default value 0. This option is used to specify whether the server forwards the retained message to the client when establishing a subscription.<br/>Retain Handling is equal to 0, as long as the client successfully subscribes, the server will send the retained message.<br/>Retain Handling is equal to 1, if the client successfully subscribes and this subscription does not exist previously, the server sends the retained message. After all, sometimes the client re-initiate the subscription just to change the QoS, but it does not mean that it wants to receive the reserved messages again.<br/>Retain Handling is equal to 2, even if the client successfully subscribes, the server does not send the retained message.",
            "minimum": 0
          },
          "rap": {
            "default": 0,
            "maximum": 1,
            "type": "integer",
            "description": "Default value 0. This option is used to specify whether the server retains the RETAIN mark when forwarding messages to the client, and this option does not affect the RETAIN mark in the retained message. Therefore, when the option Retain As Publish is set to 0, the client will directly distinguish whether this is a normal forwarded message or a retained message according to the RETAIN mark in the message, instead of judging whether this message is the first received after subscribing(the forwarded message may be sent before the retained message, which depends on the specific implementation of different brokers).",
            "minimum": 0
          },
          "nl": {
            "default": 0,
            "maximum": 1,
            "type": "integer",
            "description": "Default value 0.<br/>MQTT v3.1.1: if you subscribe to the topic published by yourself, you will receive all messages that you published.<br/>MQTT v5: if you set this option as 1 when subscribing, the server will not forward the message you published to you.",
            "minimum": 0
          }
        },
        "type": "object"
      },
      "rule_engine.ctx_schema_validation_failed": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "type": "string",
            "enum": [
              "schema_validation_failed"
            ],
            "description": "Event Type"
          },
          "validation": {
            "type": "string",
            "description": "Validation"
          },
          "clientid": {
            "type": "string",
            "description": "The Client ID"
          },
          "username": {
            "type": "string",
            "description": "Username"
          },
          "payload": {
            "type": "string",
            "description": "The Message Payload"
          },
          "peerhost": {
            "type": "string",
            "description": "The IP Address of the Peer Client"
          },
          "topic": {
            "type": "string",
            "description": "Message Topic"
          },
          "publish_received_at": {
            "type": "integer",
            "description": "The Time that this Message is Received"
          },
          "qos": {
            "maximum": 2,
            "type": "integer",
            "description": "The Message QoS",
            "minimum": 0,
            "example": 0
          }
        },
        "type": "object"
      },
      "authn.redis_cluster": {
        "required": [
          "backend",
          "cmd",
          "mechanism",
          "servers"
        ],
        "properties": {
          "mechanism": {
            "type": "string",
            "enum": [
              "password_based"
            ],
            "description": "Authentication mechanism."
          },
          "backend": {
            "type": "string",
            "enum": [
              "redis"
            ],
            "description": "Backend type."
          },
          "cmd": {
            "type": "string",
            "description": "The Redis Command used to query data for authentication such as password hash, currently only supports <code>HGET</code> and <code>HMGET</code>."
          },
          "password_hash_algorithm": {
            "default": {
              "name": "sha256",
              "salt_position": "prefix"
            },
            "description": "Options for password hash verification.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn_hash.simple"
              },
              {
                "$ref": "#/components/schemas/authn_hash.pbkdf2"
              },
              {
                "$ref": "#/components/schemas/authn_hash.bcrypt"
              }
            ]
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider."
          },
          "servers": {
            "type": "string",
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The Redis default port 6379 is used if `[:Port]` is not specified."
          },
          "redis_type": {
            "default": "cluster",
            "type": "string",
            "enum": [
              "cluster"
            ],
            "description": "Cluster mode. Must be set to 'cluster' when Redis server is running in clustered mode."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "authz.mongo_rs": {
        "required": [
          "collection",
          "database",
          "mongo_type",
          "replica_set_name",
          "servers",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "mongodb"
            ],
            "description": "Backend type."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Set to <code>true</code> or <code>false</code> to disable this ACL provider"
          },
          "collection": {
            "type": "string",
            "description": "`MongoDB` collection containing the authorization data."
          },
          "filter": {
            "default": {},
            "type": "object",
            "description": "Conditional expression that defines the filter condition in the query.<br/>Filter supports the following placeholders<br/><br/> - <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting<br/><br/> - <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting",
            "example": {}
          },
          "mongo_type": {
            "default": "rs",
            "type": "string",
            "enum": [
              "rs"
            ],
            "description": "Replica set. Must be set to 'rs' when MongoDB server is running in 'replica set' mode."
          },
          "servers": {
            "type": "string",
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The MongoDB default port 27017 is used if `[:Port]` is not specified."
          },
          "w_mode": {
            "default": "unsafe",
            "type": "string",
            "enum": [
              "unsafe",
              "safe"
            ],
            "description": "Write mode."
          },
          "r_mode": {
            "default": "master",
            "type": "string",
            "enum": [
              "master",
              "slave_ok"
            ],
            "description": "Read mode."
          },
          "replica_set_name": {
            "type": "string",
            "description": "Name of the replica set."
          },
          "srv_record": {
            "default": false,
            "type": "boolean",
            "description": "Use DNS SRV record."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "use_legacy_protocol": {
            "default": "auto",
            "type": "string",
            "enum": [
              "auto",
              true,
              false
            ],
            "description": "Whether to use MongoDB's legacy protocol for communicating with the database.  The default is to attempt to automatically determine if the newer protocol is supported."
          },
          "auth_source": {
            "type": "string",
            "description": "Database name associated with the user's credentials."
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "topology": {
            "$ref": "#/components/schemas/mongo.topology"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "authn.node_error": {
        "properties": {
          "node": {
            "type": "string",
            "description": "Node name.",
            "example": "emqx@127.0.0.1"
          },
          "error": {
            "type": "string",
            "description": "The error of node."
          }
        },
        "type": "object"
      },
      "opentelemetry.opentelemetry": {
        "properties": {
          "metrics": {
            "description": "Open Telemetry Metrics configuration.",
            "$ref": "#/components/schemas/opentelemetry.otel_metrics"
          },
          "logs": {
            "description": "Open Telemetry Logs configuration. If enabled, EMQX installs a log handler that formats events according to Open Telemetry log data model and<br/>exports them to the configured Open Telemetry collector or backend.",
            "$ref": "#/components/schemas/opentelemetry.otel_logs"
          },
          "traces": {
            "description": "Open Telemetry Traces configuration.",
            "$ref": "#/components/schemas/opentelemetry.otel_traces"
          },
          "exporter": {
            "description": "Open Telemetry Exporter",
            "$ref": "#/components/schemas/opentelemetry.otel_exporter"
          }
        },
        "type": "object"
      },
      "gateway.mqttsn_predefined": {
        "required": [
          "id",
          "topic"
        ],
        "properties": {
          "id": {
            "maximum": 1024,
            "type": "integer",
            "description": "Topic ID. Range: 1-65535",
            "minimum": 1
          },
          "topic": {
            "type": "string",
            "description": "Topic Name"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.exproto": {
        "required": [
          "handler",
          "server"
        ],
        "properties": {
          "name": {
            "type": "string",
            "enum": [
              "exproto"
            ],
            "description": "Gateway Name"
          },
          "server": {
            "description": "Configurations for starting the <code>ConnectionAdapter</code> service",
            "$ref": "#/components/schemas/gateway.exproto_grpc_server"
          },
          "handler": {
            "description": "Configurations for request to <code>ConnectionHandler</code> service",
            "$ref": "#/components/schemas/gateway.exproto_grpc_handler"
          },
          "mountpoint": {
            "default": "",
            "type": "string",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message is delivered to the subscriber.<br/>The mountpoint is a way that users can use to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,<br/>then the client actually subscribes to the topic `some_tenant/t`.<br/>Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,<br/>the message is routed to all the clients subscribed `some_tenant/t`,<br/>so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.<br/>Supported placeholders in mountpoint string:<br/><br/>  - <code>${clientid}</code>: clientid<br/><br/>  - <code>${username}</code>: username<br/><br/>  - <code>${endpoint_name}</code>: endpoint name"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Whether to enable this gateway"
          },
          "enable_stats": {
            "default": true,
            "type": "boolean",
            "description": "Whether to enable client process statistic"
          },
          "idle_timeout": {
            "default": "30s",
            "type": "string",
            "description": "The idle time of the client connection process. It has two purposes:<br/>  1. A newly created client process that does not receive any client requests after that time will be closed directly.<br/>  2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.",
            "example": "12m"
          },
          "clientinfo_override": {
            "description": "ClientInfo override.",
            "$ref": "#/components/schemas/gateway.clientinfo_override"
          },
          "listeners": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/emqx_gateway_api.dtls_listener"
                },
                {
                  "$ref": "#/components/schemas/emqx_gateway_api.udp_listener"
                },
                {
                  "$ref": "#/components/schemas/emqx_gateway_api.ssl_listener"
                },
                {
                  "$ref": "#/components/schemas/emqx_gateway_api.tcp_listener"
                }
              ]
            }
          }
        },
        "type": "object"
      },
      "rule_engine.user_provided_function": {
        "required": [
          "function"
        ],
        "properties": {
          "function": {
            "type": "string",
            "description": "The user provided function. Should be in the format: '{module}:{function}'.<br/>Where {module} is the Erlang callback module and {function} is the Erlang function.<br/><br/>To write your own function, checkout the function <code>console</code> and<br/><code>republish</code> in the source file:<br/><code>apps/emqx_rule_engine/src/emqx_rule_actions.erl</code> as an example.",
            "example": "module:function"
          },
          "args": {
            "default": {},
            "type": "object",
            "description": "The args will be passed as the 3rd argument to module:function/3,<br/>checkout the function <code>console</code> and <code>republish</code> in the source file:<br/><code>apps/emqx_rule_engine/src/emqx_rule_actions.erl</code> as an example.",
            "example": {}
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.udp_listener": {
        "properties": {
          "id": {
            "type": "string",
            "description": "Listener ID"
          },
          "type": {
            "type": "string",
            "enum": [
              "udp"
            ],
            "description": "Listener Type"
          },
          "name": {
            "type": "string",
            "description": "Listener Name"
          },
          "running": {
            "type": "boolean",
            "description": "Listener Running status"
          },
          "health_check": {
            "description": "Some Cloud platform use a `request-reply` mechanism to check whether a UDP port is healthy, here can configure this pair.",
            "$ref": "#/components/schemas/gateway.udp_health_check"
          },
          "udp_options": {
            "$ref": "#/components/schemas/gateway.udp_opts"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable the listener."
          },
          "bind": {
            "type": "string",
            "description": "The IP address and port that the listener will bind.",
            "example": "127.0.0.1:80"
          },
          "max_connections": {
            "default": 1024,
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "integer",
                "minimum": 1
              }
            ]
          },
          "max_conn_rate": {
            "default": 1000,
            "type": "integer",
            "description": "Maximum connections per second."
          },
          "enable_authn": {
            "default": true,
            "type": "boolean",
            "description": "Set <code>true</code> (default) to enable client authentication on this listener.<br/>When set to <code>false</code> clients will be allowed to connect without authentication."
          },
          "mountpoint": {
            "type": "string",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message is delivered to the subscriber.<br/>The mountpoint is a way that users can use to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,<br/>then the client actually subscribes to the topic `some_tenant/t`.<br/>Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,<br/>the message is routed to all the clients subscribed `some_tenant/t`,<br/>so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.<br/>Supported placeholders in mountpoint string:<br/><br/>  - <code>${clientid}</code>: clientid<br/><br/>  - <code>${username}</code>: username<br/><br/>  - <code>${endpoint_name}</code>: endpoint name"
          },
          "access_rules": {
            "default": [],
            "type": "array",
            "description": "An access rule list consisting of string rules to restrict or allow access from some addresses.<br/>The rules that appear earlier in the list are matched first.<br/>The format is `allow | deny <address> | <CIDR> | all`.<br/><br/>For example:<br/><br/>`[\\\"deny 192.168.1.1\\\", \\\"allow 192.168.1.0/24\\\", \\\"deny, all\\\"]`",
            "items": {
              "type": "string"
            }
          }
        },
        "type": "object"
      },
      "bridge_mqtt_publisher.action_resource_opts": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "maximum": 1024,
            "type": "integer",
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 1
          },
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "query_mode": {
            "default": "async",
            "type": "string",
            "enum": [
              "sync",
              "async"
            ],
            "description": "Query mode. Optional 'sync/async', default 'async'."
          },
          "request_ttl": {
            "default": "45s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "string",
                "example": "32s"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "type": "integer",
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "type": "string",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api_listeners.tcp_listener": {
        "properties": {
          "id": {
            "type": "string",
            "description": "Listener ID"
          },
          "type": {
            "type": "string",
            "enum": [
              "tcp"
            ],
            "description": "Listener Type"
          },
          "name": {
            "type": "string",
            "description": "Listener Name"
          },
          "running": {
            "type": "boolean",
            "description": "Listener Running status"
          },
          "acceptors": {
            "default": 16,
            "type": "integer",
            "description": "Size of the acceptor pool."
          },
          "tcp_options": {
            "description": "Setting the TCP socket options.",
            "$ref": "#/components/schemas/emqx.tcp_opts"
          },
          "proxy_protocol": {
            "default": false,
            "type": "boolean",
            "description": "If a reverse proxy is deployed for EMQX, and the PROXY protocol is enabled at the proxy to pass the client's real IP,<br/>this option needs to be turned on so that EMQX can extract the client's real IP from the PROXY protocol header.<br/>EMQX will automatically detect the version of the PROXY protocol and support V1 and V2.<br/><br/>For a detailed description of the PROXY protocol, please refer to: https://www.haproxy.com/blog/haproxy/proxy-protocol/"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "type": "string",
            "description": "Timeout for proxy protocol.<br/>EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.",
            "example": "12m"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable the listener."
          },
          "bind": {
            "type": "string",
            "description": "The IP address and port that the listener will bind.",
            "example": "127.0.0.1:80"
          },
          "max_connections": {
            "default": 1024,
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "integer",
                "minimum": 1
              }
            ]
          },
          "max_conn_rate": {
            "default": 1000,
            "type": "integer",
            "description": "Maximum connections per second."
          },
          "enable_authn": {
            "default": true,
            "type": "boolean",
            "description": "Set <code>true</code> (default) to enable client authentication on this listener.<br/>When set to <code>false</code> clients will be allowed to connect without authentication."
          },
          "mountpoint": {
            "type": "string",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message is delivered to the subscriber.<br/>The mountpoint is a way that users can use to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,<br/>then the client actually subscribes to the topic `some_tenant/t`.<br/>Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,<br/>the message is routed to all the clients subscribed `some_tenant/t`,<br/>so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.<br/>Supported placeholders in mountpoint string:<br/><br/>  - <code>${clientid}</code>: clientid<br/><br/>  - <code>${username}</code>: username<br/><br/>  - <code>${endpoint_name}</code>: endpoint name"
          },
          "access_rules": {
            "default": [],
            "type": "array",
            "description": "An access rule list consisting of string rules to restrict or allow access from some addresses.<br/>The rules that appear earlier in the list are matched first.<br/>The format is `allow | deny <address> | <CIDR> | all`.<br/><br/>For example:<br/><br/>`[\\\"deny 192.168.1.1\\\", \\\"allow 192.168.1.0/24\\\", \\\"deny, all\\\"]`",
            "items": {
              "type": "string"
            }
          },
          "status": {
            "description": "listener status",
            "$ref": "#/components/schemas/listeners.status"
          },
          "node_status": {
            "type": "array",
            "description": "listener status of each node in the cluster",
            "items": {
              "$ref": "#/components/schemas/listeners.node_status"
            }
          }
        },
        "type": "object"
      },
      "emqx_delayed_api.message": {
        "properties": {
          "msgid": {
            "type": "integer",
            "description": "Delayed Message ID"
          },
          "node": {
            "type": "string",
            "description": "The node where message from"
          },
          "publish_at": {
            "type": "string",
            "description": "Clinet publish message time, in RFC 3339 format"
          },
          "delayed_interval": {
            "type": "integer",
            "description": "Delayed interval(second)",
            "minimum": 1
          },
          "delayed_remaining": {
            "type": "integer",
            "description": "Delayed remaining(second)",
            "minimum": 0
          },
          "expected_at": {
            "type": "string",
            "description": "Expect publish time, in RFC 3339 format"
          },
          "topic": {
            "type": "string",
            "description": "Topic",
            "example": "/sys/#"
          },
          "qos": {
            "maximum": 2,
            "type": "integer",
            "description": "QoS",
            "minimum": 0,
            "example": 0
          },
          "from_clientid": {
            "type": "string",
            "description": "From ClientID"
          },
          "from_username": {
            "type": "string",
            "description": "From Username"
          },
          "payload": {
            "type": "string",
            "description": "Payload, base64 encoded. Payload will be set to 'PAYLOAD_TO_LARGE' if its length is larger than 2048 bytes"
          }
        },
        "type": "object"
      },
      "authz.redis_cluster": {
        "required": [
          "cmd",
          "servers",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "redis"
            ],
            "description": "Backend type."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Set to <code>true</code> or <code>false</code> to disable this ACL provider"
          },
          "servers": {
            "type": "string",
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The Redis default port 6379 is used if `[:Port]` is not specified."
          },
          "redis_type": {
            "default": "cluster",
            "type": "string",
            "enum": [
              "cluster"
            ],
            "description": "Cluster mode. Must be set to 'cluster' when Redis server is running in clustered mode."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "cmd": {
            "type": "string",
            "description": "Database query used to retrieve authorization data.",
            "example": "HGETALL mqtt_authz"
          }
        },
        "type": "object"
      },
      "emqx.force_gc": {
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable forced garbage collection."
          },
          "count": {
            "default": 16000,
            "type": "integer",
            "description": "GC the process after this many received messages.",
            "minimum": 0
          },
          "bytes": {
            "default": "16MB",
            "type": "string",
            "description": "GC the process after specified number of bytes have passed through.",
            "example": "32MB"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_publish.message_properties": {
        "properties": {
          "payload_format_indicator": {
            "maximum": 1,
            "type": "integer",
            "description": "0 (0x00) Byte Indicates that the Payload is unspecified bytes, which is equivalent to not sending a Payload Format Indicator.<br/>1 (0x01) Byte Indicates that the Payload is UTF-8 Encoded Character Data. The UTF-8 data in the Payload MUST be well-formed UTF-8 as defined by the Unicode specification and restated in RFC 3629.",
            "minimum": 0,
            "example": 0
          },
          "message_expiry_interval": {
            "type": "integer",
            "description": "Identifier of the Message Expiry Interval. If the Message Expiry Interval has passed and the Server has not managed to start onward delivery to a matching subscriber, then it MUST delete the copy of the message for that subscriber."
          },
          "response_topic": {
            "type": "string",
            "description": "Identifier of the Response Topic.The Response Topic MUST be a UTF-8 Encoded, It MUST NOT contain wildcard characters.",
            "example": "some_other_topic"
          },
          "correlation_data": {
            "type": "string",
            "description": "Identifier of the Correlation Data. The Server MUST send the Correlation Data unaltered to all subscribers receiving the Application Message."
          },
          "user_properties": {
            "type": "object",
            "description": "The User-Property key-value pairs. Note: in case there are duplicated keys, only the last one will be used.",
            "example": {
              "foo": "bar"
            }
          },
          "content_type": {
            "type": "string",
            "description": "The Content Type MUST be a UTF-8 Encoded String.",
            "example": "text/plain"
          }
        },
        "type": "object"
      },
      "relup.package": {
        "properties": {
          "name": {
            "type": "string",
            "description": "File name of the package",
            "example": "emqx_relup-5.8.2.tar.gz"
          },
          "target_vsn": {
            "type": "string",
            "description": "Target emqx version for this package",
            "example": "5.8.2"
          },
          "built_on_otp_release": {
            "type": "string",
            "example": "24"
          },
          "applicable_vsns": {
            "type": "array",
            "description": "The emqx versions that this package can be applied to.",
            "items": {
              "type": "string"
            },
            "example": [
              "5.8.0",
              "5.8.1"
            ]
          },
          "build_date": {
            "type": "string",
            "description": "The date when the package was built.",
            "example": "2021-12-25"
          },
          "change_logs": {
            "type": "array",
            "description": "Changes that this package brings",
            "items": {
              "type": "string"
            },
            "example": [
              "1. Fix a bug foo in the plugin.2. Add a new bar feature."
            ]
          },
          "md5_sum": {
            "type": "string",
            "example": "d41d8cd98f00b204e9800998ecf8427e"
          }
        },
        "type": "object"
      },
      "public.continuation_meta": {
        "required": [
          "start"
        ],
        "properties": {
          "start": {
            "description": "The position of the current first element of the data collection.",
            "example": "none",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "string",
                "enum": [
                  "none"
                ]
              }
            ]
          },
          "position": {
            "description": "An opaque token that can then be in subsequent requests to get  the next chunk of results: \"?position={prev_response.meta.position}\"<br/>It is used instead of \"page\" parameter to traverse highly volatile data.<br/>Can be omitted or set to \"none\" to get the first chunk of data.",
            "example": "none",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "string",
                "enum": [
                  "end_of_data"
                ]
              },
              {
                "type": "string",
                "enum": [
                  "none"
                ]
              }
            ]
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.gateway_overview": {
        "properties": {
          "name": {
            "type": "string",
            "description": "Gateway Name"
          },
          "status": {
            "type": "string",
            "enum": [
              "running",
              "stopped",
              "unloaded"
            ],
            "description": "Gateway status"
          },
          "created_at": {
            "type": "string",
            "description": "The Gateway created datetime"
          },
          "started_at": {
            "type": "string",
            "description": "The Gateway started datetime"
          },
          "stopped_at": {
            "type": "string",
            "description": "The Gateway stopped datetime"
          },
          "max_connections": {
            "type": "integer",
            "description": "The maximum number of concurrent connections allowed by the gateway.",
            "minimum": 1
          },
          "current_connections": {
            "type": "integer",
            "description": "The Gateway current connected connections/clients",
            "minimum": 0
          },
          "listeners": {
            "type": "array",
            "description": "The Gateway listeners overview",
            "items": {
              "$ref": "#/components/schemas/emqx_gateway_api.gateway_listener_overview"
            }
          },
          "node_status": {
            "type": "array",
            "description": "The status of the gateway on each node in the cluster",
            "items": {
              "$ref": "#/components/schemas/emqx_gateway_api.gateway_node_status"
            }
          }
        },
        "type": "object"
      },
      "rule_engine.rule_events": {
        "required": [
          "event"
        ],
        "properties": {
          "event": {
            "type": "string",
            "enum": [
              "$events/client_connected",
              "$events/client_disconnected",
              "$events/client_connack",
              "$events/client_check_authz_complete",
              "$events/session_subscribed",
              "$events/session_unsubscribed",
              "$events/message_delivered",
              "$events/message_acked",
              "$events/message_dropped",
              "$events/message_transformation_failed",
              "$events/schema_validation_failed",
              "$events/delivery_dropped"
            ],
            "description": "The event topics"
          },
          "title": {
            "type": "string",
            "description": "The title",
            "example": "some title"
          },
          "description": {
            "type": "string",
            "description": "The description",
            "example": "some desc"
          },
          "columns": {
            "type": "object",
            "description": "The columns",
            "example": {}
          },
          "test_columns": {
            "type": "object",
            "description": "The test columns",
            "example": {}
          },
          "sql_example": {
            "type": "string",
            "description": "The sql_example"
          }
        },
        "type": "object"
      },
      "dashboard.dashboard": {
        "required": [
          "default_password"
        ],
        "properties": {
          "listeners": {
            "description": "HTTP(s) listeners are identified by their protocol type and are<br/>used to serve dashboard UI and restful HTTP API.<br/>Listeners must have a unique combination of port number and IP address.<br/>For example, an HTTP listener can listen on all configured IP addresses<br/>on a given port for a machine by specifying the IP address 0.0.0.0.<br/>Alternatively, the HTTP listener can specify a unique IP address for each listener,<br/>but use the same port.",
            "$ref": "#/components/schemas/dashboard.listeners"
          },
          "default_password": {
            "default": "public",
            "type": "string",
            "description": "The password used to initialize a database record for `admin` user.<br/>NOTE: Changing the default password after it has been initialized (boot up for the fist time) has no effect.<br/>Once initialized, the default password `public` must be changed from dashboard or CLI as soon as possible.",
            "readOnly": true
          },
          "token_expired_time": {
            "default": "60m",
            "type": "string",
            "description": "JWT token expiration time. Default is 60 minutes",
            "example": "12m"
          },
          "cors": {
            "default": false,
            "type": "boolean",
            "description": "Support Cross-Origin Resource Sharing (CORS).<br/>Allows a server to indicate any origins (domain, scheme, or port) other than<br/>its own from which a browser should permit loading resources."
          },
          "swagger_support": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable support for swagger API documentation."
          }
        },
        "type": "object"
      },
      "listeners.with_name_wss_required_bind": {
        "required": [
          "bind",
          "name",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "wss"
            ],
            "description": "Listener type"
          },
          "running": {
            "type": "boolean",
            "description": "Listener status"
          },
          "name": {
            "type": "string",
            "description": "Listener name"
          },
          "current_connections": {
            "type": "integer",
            "description": "Current connections",
            "minimum": 0
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable listener."
          },
          "bind": {
            "default": 8084,
            "type": "string",
            "description": "IP address and port for the listening socket.",
            "example": "127.0.0.1:80"
          },
          "acceptors": {
            "default": 16,
            "type": "integer",
            "description": "The size of the listener's receiving pool.",
            "minimum": 1
          },
          "max_connections": {
            "default": "infinity",
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "type": "string",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message<br/>is delivered to the subscriber. The mountpoint is a way that users can use<br/>to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`<br/>set to `some_tenant`, then the client actually subscribes to the topic<br/>`some_tenant/t`. Similarly, if another client B (connected to the same listener<br/>as the client A) sends a message to topic `t`, the message is routed<br/>to all the clients subscribed `some_tenant/t`, so client A will receive the<br/>message, with topic name `t`.<br/><br/>Set to `\"\"` to disable the feature.<br/><br/><br/>Variables in mountpoint string:<br/>  - <code>${clientid}</code>: clientid<br/>  - <code>${username}</code>: username"
          },
          "zone": {
            "default": "default",
            "type": "string",
            "description": "The configuration zone to which the listener belongs.<br/>Clients connected to this listener will inherit zone-settings created under this zone name.<br/><br/>A zone can override the configs under below root names:<br/>- `mqtt`<br/>- `force_shutdown`<br/>- `force_gc`<br/>- `flapping_detect`<br/>- `durable_sessions`"
          },
          "enable_authn": {
            "default": true,
            "type": "string",
            "enum": [
              true,
              false,
              "quick_deny_anonymous"
            ],
            "description": "Set <code>true</code> (default) to enable client authentication on this listener, the authentication<br/>process goes through the configured authentication chain.<br/>When set to <code>false</code>, any client (with or without username/password) is allowed to connect.<br/>When set to <code>quick_deny_anonymous</code>, it behaves like when set to <code>true</code>, but clients will be<br/>denied immediately without going through any authenticators if <code>username</code> is not provided. This is useful to fence off<br/>anonymous clients early."
          },
          "max_conn_rate": {
            "default": "infinity",
            "type": "string",
            "description": "Used to limit the rate at which the current listener accepts connections.<br/><br/>Once the limit is reached, EMQX will pause fetching connections from the Accept queue, thereby delaying or rejecting new connections.<br/><br/>For example:<br/><br/>- `1000/s`: Only accepts 1000 connections per second.<br/>- `1000/10s`: Only accepts 1000 connections every 10 seconds.",
            "example": "1000/s"
          },
          "messages_rate": {
            "type": "string",
            "description": "Used to limit the number of messages a single client can send to EMQX per second.<br/><br/>Once the limit is reached, EMQX will pause reading data from the receive-buffer, thus slowing down or even temporarily hanging the sender.<br/><br/>For example:<br/><br/>- `500/s`: Only 500 messages will be received per second, and the remaining messages will be delayed.<br/>- `500/10s`: Only 500 messages will be received every 10 seconds and the remaining messages will be delayed.",
            "example": "1000/s"
          },
          "bytes_rate": {
            "type": "string",
            "description": "Used to limit the number of bytes a single client can send to EMQX per second.<br/><br/>Once the limit is reached, EMQX will pause reading data from the receive-buffer, thus slowing down or even temporarily hanging the sender.<br/><br/>The unit of the bytes could be: B, KB, MB, GB.<br/><br/>For example:<br/><br/>- `500KB/s`: Only 500 kilobytes per second will be received, and the remaining bytes will be delayed.<br/>- `500MB/10s`: Only 500 megabytes will be received every 10 seconds, and the remaining bytes will be delayed.",
            "example": "100MB/s"
          },
          "access_rules": {
            "default": [
              "allow all"
            ],
            "type": "array",
            "description": "An access rule list consisting of string rules to restrict or allow access from some addresses. The rules that appear earlier in the list are matched first.<br/>The format is `allow | deny <address> | <CIDR> | all`.<br/><br/>For example:<br/><br/>`[\\\"deny 192.168.1.1\\\", \\\"allow 192.168.1.0/24\\\", \\\"deny, all\\\"]`",
            "items": {
              "type": "string"
            }
          },
          "proxy_protocol": {
            "default": false,
            "type": "boolean",
            "description": "Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.<br/><br/>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "type": "string",
            "description": "If a reverse proxy is deployed for EMQX, and the PROXY protocol is enabled at the proxy to pass the client's real IP, this option needs to be turned on so that EMQX can extract the client's real IP from the PROXY protocol header.<br/><br/>EMQX will automatically detect the version of the PROXY protocol and support V1 and V2.<br/><br/>For a detailed description of the PROXY protocol, please refer to: https://www.haproxy.com/blog/haproxy/proxy-protocol/",
            "example": "12m"
          },
          "tcp_options": {
            "$ref": "#/components/schemas/emqx.tcp_opts"
          },
          "ssl_options": {
            "$ref": "#/components/schemas/emqx.listener_wss_opts"
          },
          "websocket": {
            "$ref": "#/components/schemas/emqx.ws_opts"
          }
        },
        "type": "object"
      },
      "bridge_mqtt_publisher.put_bridge_v2": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Action specific configs.",
            "$ref": "#/components/schemas/bridge_mqtt_publisher.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_mqtt_publisher.action_resource_opts"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.gateway_node_status": {
        "properties": {
          "node": {
            "type": "string",
            "enum": [
              "emqx@127.0.0.1"
            ],
            "description": "Node Name"
          },
          "status": {
            "type": "string",
            "enum": [
              "running",
              "stopped",
              "unloaded"
            ],
            "description": "Gateway status"
          },
          "max_connections": {
            "type": "integer",
            "description": "The maximum number of concurrent connections allowed by the gateway.",
            "minimum": 1
          },
          "current_connections": {
            "type": "integer",
            "description": "The Gateway current connected connections/clients",
            "minimum": 0
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.lwm2m": {
        "required": [
          "translators",
          "xml_dir"
        ],
        "properties": {
          "name": {
            "type": "string",
            "enum": [
              "lwm2m"
            ],
            "description": "Gateway Name"
          },
          "xml_dir": {
            "type": "string",
            "description": "The Directory for LwM2M Resource definition.",
            "example": "/etc/emqx/lwm2m_xml"
          },
          "lifetime_min": {
            "default": "15s",
            "type": "string",
            "description": "Minimum value of lifetime allowed to be set by the LwM2M client.",
            "example": "12m"
          },
          "lifetime_max": {
            "default": "86400s",
            "type": "string",
            "description": "Maximum value of lifetime allowed to be set by the LwM2M client.",
            "example": "12m"
          },
          "qmode_time_window": {
            "default": "22s",
            "type": "string",
            "description": "The value of the time window during which the network link is considered valid by the LwM2M Gateway in QMode mode.<br/>For example, after receiving an update message from a client, any messages within this time window are sent directly to the LwM2M client, and all messages beyond this time window are temporarily stored in memory.",
            "example": "1h"
          },
          "auto_observe": {
            "default": false,
            "type": "boolean",
            "description": "Automatically observe the object list of REGISTER packet."
          },
          "update_msg_publish_condition": {
            "default": "contains_object_list",
            "type": "string",
            "enum": [
              "always",
              "contains_object_list"
            ],
            "description": "Policy for publishing UPDATE event message.<br/><br/>  - always: send update events as long as the UPDATE request is received.<br/><br/>  - contains_object_list: send update events only if the UPDATE request carries any Object List"
          },
          "translators": {
            "description": "Topic configuration for LwM2M's gateway publishing and subscription.",
            "$ref": "#/components/schemas/gateway.lwm2m_translators"
          },
          "mountpoint": {
            "default": "lwm2m/${endpoint_name}/",
            "type": "string",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message is delivered to the subscriber.<br/>The mountpoint is a way that users can use to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,<br/>then the client actually subscribes to the topic `some_tenant/t`.<br/>Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,<br/>the message is routed to all the clients subscribed `some_tenant/t`,<br/>so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.<br/>Supported placeholders in mountpoint string:<br/><br/>  - <code>${clientid}</code>: clientid<br/><br/>  - <code>${username}</code>: username<br/><br/>  - <code>${endpoint_name}</code>: endpoint name"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Whether to enable this gateway"
          },
          "enable_stats": {
            "default": true,
            "type": "boolean",
            "description": "Whether to enable client process statistic"
          },
          "idle_timeout": {
            "default": "30s",
            "type": "string",
            "description": "The idle time of the client connection process. It has two purposes:<br/>  1. A newly created client process that does not receive any client requests after that time will be closed directly.<br/>  2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.",
            "example": "12m"
          },
          "clientinfo_override": {
            "description": "ClientInfo override.",
            "$ref": "#/components/schemas/gateway.clientinfo_override"
          },
          "listeners": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/emqx_gateway_api.dtls_listener"
                },
                {
                  "$ref": "#/components/schemas/emqx_gateway_api.udp_listener"
                }
              ]
            }
          }
        },
        "type": "object"
      },
      "bridge_http.parameters_opts": {
        "properties": {
          "path": {
            "type": "string",
            "description": "The URL path for this Action.<br/><br/>This path will be appended to the Connector's <code>url</code> configuration to form the full<br/>URL address.<br/>Template with variables is allowed in this option. For example, <code>/room/{$room_no}</code>"
          },
          "method": {
            "default": "post",
            "type": "string",
            "enum": [
              "post",
              "put",
              "get",
              "delete"
            ],
            "description": "The method of the HTTP request. All the available methods are: post, put, get, delete.<br/><br/>Template with variables is allowed."
          },
          "headers": {
            "default": {
              "accept": "application/json",
              "cache-control": "no-cache",
              "connection": "keep-alive",
              "content-type": "application/json",
              "keep-alive": "timeout=5"
            },
            "type": "object",
            "description": "The headers of the HTTP request.<br/><br/>Template with variables is allowed.",
            "example": {},
            "is_template": true
          },
          "body": {
            "type": "string",
            "description": "The body of the HTTP request.<br/><br/>If not provided, the body will be a JSON object of all the available fields.<br/><br/>There, 'all the available fields' means the context of a MQTT message when<br/>this webhook is triggered by receiving a MQTT message (the `local_topic` is set),<br/>or the context of the event when this webhook is triggered by a rule (i.e. this<br/>webhook is used as an action of a rule).<br/><br/>Template with variables is allowed."
          },
          "max_retries": {
            "default": 2,
            "type": "integer",
            "description": "HTTP request max retry times if failed.",
            "minimum": 0
          },
          "request_timeout": {
            "default": "15s",
            "type": "string",
            "deprecated": true,
            "description": "HTTP request timeout.",
            "example": "32s"
          }
        },
        "type": "object"
      },
      "relup.upgrade_history": {
        "properties": {
          "started_at": {
            "type": "string",
            "description": "The timestamp (in format of RFC3339) when the upgrade started",
            "example": "2024-07-15T13:48:02.648559+08:00"
          },
          "finished_at": {
            "type": "string",
            "description": "The timestamp (in format of RFC3339) when the upgrade finished",
            "example": "2024-07-16T11:00:01.875627+08:00"
          },
          "from_vsn": {
            "type": "string",
            "description": "The version before the upgrade",
            "example": "5.8.0"
          },
          "target_vsn": {
            "type": "string",
            "description": "The target version of the upgrade",
            "example": "5.8.2"
          },
          "upgrade_opts": {
            "type": "object",
            "description": "The options used for the upgrade",
            "example": {
              "deploy_inplace": false
            }
          },
          "status": {
            "type": "string",
            "enum": [
              "in-progress",
              "finished"
            ],
            "description": "The upgrade status of the node",
            "example": "in-progress"
          },
          "result": {
            "description": "The upgrade result",
            "example": "success",
            "oneOf": [
              {
                "$ref": "#/components/schemas/relup.upgrade_error"
              },
              {
                "type": "string",
                "enum": [
                  "success"
                ]
              }
            ]
          }
        },
        "type": "object"
      }
    },
    "securitySchemes": {
      "bearerAuth": {
        "scheme": "bearer",
        "type": "http",
        "description": "Authorize with Bearer Token"
      },
      "basicAuth": {
        "scheme": "basic",
        "type": "http",
        "description": "Authorize with [API Keys](https://www.emqx.io/docs/en/v5.0/admin/api.html#api-keys)"
      }
    }
  },
  "paths": {
    "/plugins/{name}/schema": {
      "get": {
        "description": "Get plugin's config AVRO schema.",
        "tags": [
          "Plugins"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/plugins.name"
          }
        ],
        "summary": "Get installed plugin's AVRO schema",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "FILE_NOT_EXISTED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Plugin Not Found or Plugin not given a schema file"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/authentication/{id}/position/{position}": {
      "put": {
        "description": "Move authenticator in global authentication chain.",
        "tags": [
          "Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Authenticator ID.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "position",
            "description": "Position of authenticator in chain. Possible values are 'front', 'rear', 'before:{other_authenticator}', 'after:{other_authenticator}'.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "before:password_based:built_in_database"
          }
        ],
        "responses": {
          "204": {
            "description": "Authenticator moved"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/actions/{id}/metrics/reset": {
      "put": {
        "description": "Reset a bridge metrics by id.",
        "tags": [
          "Actions"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_action"
          }
        ],
        "summary": "Reset action metrics",
        "responses": {
          "204": {
            "description": "Reset success"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Action not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/metrics": {
      "get": {
        "description": "EMQX metrics",
        "tags": [
          "Metrics"
        ],
        "parameters": [
          {
            "in": "query",
            "name": "aggregate",
            "description": "Whether to aggregate all nodes Metrics",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/emqx_mgmt_api_metrics.node_metrics"
                      }
                    },
                    {
                      "$ref": "#/components/schemas/emqx_mgmt_api_metrics.aggregated_metrics"
                    }
                  ]
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/authentication/{id}/users/{user_id}": {
      "get": {
        "description": "Get user from authenticator in global authentication chain.",
        "tags": [
          "Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Authenticator ID.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "user_id",
            "description": "User ID.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "regular_user": {
                    "value": {
                      "user_id": "user1"
                    },
                    "summary": "Regular user"
                  },
                  "super_user": {
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    },
                    "summary": "Superuser"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update user in authenticator in global authentication chain.",
        "tags": [
          "Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Authenticator ID.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "user_id",
            "description": "User ID.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "regular_user": {
                    "value": {
                      "user_id": "user1"
                    },
                    "summary": "Regular user"
                  },
                  "super_user": {
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    },
                    "summary": "Superuser"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "regular_user": {
                  "value": {
                    "password": "******"
                  },
                  "summary": "Update regular user"
                },
                "super_user": {
                  "value": {
                    "password": "******",
                    "is_superuser": true
                  },
                  "summary": "Update user and promote to superuser"
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authn_api.request_user_update"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete user in authenticator in global authentication chain.",
        "tags": [
          "Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Authenticator ID.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "user_id",
            "description": "User ID.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "User deleted"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/authentication/{id}/import_users": {
      "post": {
        "description": "Import users into authenticator in global authentication chain.",
        "tags": [
          "Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Authenticator ID.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "type",
            "description": "The import file template type, enum with `plain`,`hash`",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "plain",
                "hash"
              ]
            },
            "example": "hash"
          }
        ],
        "responses": {
          "204": {
            "description": "Users imported"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "description": "Import body",
          "content": {
            "multipart/form-data": {
              "schema": {
                "type": "object",
                "properties": {
                  "filename": {
                    "type": "string",
                    "format": "binary"
                  }
                }
              }
            },
            "application/json": {
              "schema": {
                "type": "object",
                "example": [
                  {
                    "is_superuser": true,
                    "password": "password1",
                    "user_id": "user1"
                  },
                  {
                    "is_superuser": false,
                    "password": "password2",
                    "user_id": "user2"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/actions/{id}/{operation}": {
      "post": {
        "description": "Start bridge on all nodes in the cluster.",
        "tags": [
          "Actions"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_action"
          },
          {
            "in": "path",
            "name": "operation",
            "description": "Operation can be one of: 'start'.",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "start"
              ]
            },
            "example": "start"
          }
        ],
        "summary": "Manually start a bridge",
        "responses": {
          "204": {
            "description": "Operation success"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Problem with configuration of external service"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bridge not found or invalid operation"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "501": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_IMPLEMENTED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Implemented"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Service unavailable"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/mqtt/delayed": {
      "get": {
        "description": "Get delayed status",
        "tags": [
          "MQTT"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/modules.delayed"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Enable or disable delayed, set max delayed messages",
        "tags": [
          "MQTT"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Enable or disable delayed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/modules.delayed"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Max limit illegality"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/modules.delayed"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/lwm2m/clients/{clientid}/observe": {
      "post": {
        "description": "Observe or Cancel observe a resource",
        "tags": [
          "LwM2M Gateways"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "urn:oma:lwm2m:oma:2"
          },
          {
            "in": "query",
            "name": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "/3/0/7"
          },
          {
            "in": "query",
            "name": "enable",
            "required": true,
            "schema": {
              "type": "boolean"
            },
            "example": true
          }
        ],
        "summary": "Observe a Resource",
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "CLIENT_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Clientid not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/plugins/{name}": {
      "get": {
        "description": "Describe a plugin according to its `release.json` and `README.md`.",
        "tags": [
          "Plugins"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/plugins.name"
          }
        ],
        "summary": "Get a plugin description",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/plugins.plugin"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Plugin Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Uninstalls a previously uploaded plugin package.",
        "tags": [
          "Plugins"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/plugins.name"
          }
        ],
        "summary": "Delete a plugin",
        "responses": {
          "204": {
            "description": "Uninstall successfully"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "PARAM_ERROR"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad parameter"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Plugin Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/bridges/{id}/metrics/reset": {
      "put": {
        "description": "Reset a bridge metrics by Id",
        "tags": [
          "Bridges"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge Id. Must be of format {type}:{name}",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:http_example"
          }
        ],
        "summary": "Reset bridge metrics",
        "responses": {
          "204": {
            "description": "Reset success"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bridge not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/status": {
      "get": {
        "description": "Serves as a health check for the node.<br/>Returns response to describe the status of the node and the application.<br/><br/>This endpoint requires no authentication.<br/><br/>Returns status code 200 if the EMQX application is up and running, 503 otherwise.<br/>This API was introduced in v5.0.10.<br/>The GET `/status` endpoint (without the `/api/...` prefix) is also an alias to this endpoint and works in the same way.<br/>This alias has been available since v5.0.0.<br/><br/>Starting from v5.0.25 or e5.0.4, you can also use 'format' parameter to get JSON format information.",
        "tags": [
          "Status"
        ],
        "parameters": [
          {
            "in": "query",
            "name": "format",
            "description": "Specify the response format, 'text' (default) to return the HTTP body in free text,<br/>or 'json' to return the HTTP body with a JSON object.",
            "schema": {
              "default": "text",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "If 'format' parameter is 'json', then it returns a JSON like below:<br/><br/>{<br/>  \"rel_vsn\": \"v5.0.23\",<br/>  \"node_name\": \"emqx@127.0.0.1\",<br/>  \"broker_status\": \"started\",<br/>  \"app_status\": \"running\"<br/>}<br/><br/><br/>Otherwise it returns free text strings as below:<br/><br/>Node emqx@127.0.0.1 is started<br/>emqx is running"
          },
          "503": {
            "description": "When EMQX application is temporary not running or being restarted, it may return 'emqx is not_running'.<br/>If the 'format' parameter is provided 'json', then the 'app_status' field in the JSON object will be 'not_running'."
          }
        },
        "security": []
      }
    },
    "/topics/{topic}": {
      "get": {
        "description": "Lookup topic info by name",
        "tags": [
          "Topics"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "topic",
            "description": "Topic Name",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": ""
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/emqx_mgmt_api_topics.topic"
                  }
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "TOPIC_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Topic not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/stats": {
      "get": {
        "description": "EMQX stats",
        "tags": [
          "Metrics"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_mgmt_api_stats.aggregate"
          }
        ],
        "responses": {
          "200": {
            "description": "List stats ok",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/emqx_mgmt_api_stats.aggregated_data"
                    },
                    {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/emqx_mgmt_api_stats.per_node_data"
                      }
                    }
                  ]
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/monitor_current": {
      "get": {
        "description": "Current monitor (statistics) data, e.g. number of connections and connection rate in the whole cluster.",
        "tags": [
          "Metrics"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_dashboard_monitor_api.sampler_current"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/authorization/sources/built_in_database/rules/users": {
      "get": {
        "description": "Show the list of rules for users",
        "tags": [
          "Authorization"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          },
          {
            "in": "query",
            "name": "like_username",
            "description": "Fuzzy search `username` as substring",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "password_based:built_in_database": {
                    "value": {
                      "data": [
                        {
                          "rules": [
                            {
                              "action": "publish",
                              "topic": "test/topic/1",
                              "permission": "allow"
                            },
                            {
                              "action": "subscribe",
                              "topic": "test/topic/2",
                              "permission": "allow"
                            },
                            {
                              "action": "all",
                              "topic": "eq test/#",
                              "permission": "deny"
                            },
                            {
                              "action": "publish",
                              "retain": "true",
                              "topic": "test/topic/3",
                              "qos": [
                                "1"
                              ],
                              "permission": "allow"
                            },
                            {
                              "action": "publish",
                              "retain": "all",
                              "topic": "test/topic/4",
                              "qos": [
                                "0",
                                "1",
                                "2"
                              ],
                              "permission": "allow"
                            }
                          ],
                          "username": "user1"
                        }
                      ],
                      "meta": {
                        "count": 1,
                        "limit": 100,
                        "page": 1
                      }
                    },
                    "summary": "Username"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authz_api_mnesia.username_response_data"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Add new rule for 'username'",
        "tags": [
          "Authorization"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": "Created"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad username or bad rule schema"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "409": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "ALREADY_EXISTS"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "ALREADY_EXISTS"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "password_based:built_in_database": {
                  "value": [
                    {
                      "rules": [
                        {
                          "action": "publish",
                          "topic": "test/topic/1",
                          "permission": "allow"
                        },
                        {
                          "action": "subscribe",
                          "topic": "test/topic/2",
                          "permission": "allow"
                        },
                        {
                          "action": "all",
                          "topic": "eq test/#",
                          "permission": "deny"
                        },
                        {
                          "action": "publish",
                          "retain": "true",
                          "topic": "test/topic/3",
                          "qos": [
                            "1"
                          ],
                          "permission": "allow"
                        },
                        {
                          "action": "publish",
                          "retain": "all",
                          "topic": "test/topic/4",
                          "qos": [
                            "0",
                            "1",
                            "2"
                          ],
                          "permission": "allow"
                        }
                      ],
                      "username": "user1"
                    }
                  ],
                  "summary": "Username"
                }
              },
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/emqx_authz_api_mnesia.rules_for_username"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/nodes/{node}/stats": {
      "get": {
        "description": "Get node run-time stats. Such as the number of topics, connections, etc.",
        "tags": [
          "Nodes"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_mgmt_api_nodes.node_name"
          }
        ],
        "responses": {
          "200": {
            "description": "Get node stats successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_stats.aggregated_data"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Node not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/exhooks/{name}": {
      "get": {
        "description": "Get the detail information of Exhook server",
        "tags": [
          "ExHook"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "The Exhook server name",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "default"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/exhook.detail_server_info"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Server not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update the server",
        "tags": [
          "ExHook"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "The Exhook server name",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "default"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/exhook.detail_server_info"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Server not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "500": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_RPC"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad RPC"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "example": {
                "name": "default",
                "ssl": {
                  "enable": false,
                  "certfile": "/etc/emqx/certs/cert.pem",
                  "keyfile": "/etc/emqx/certs/key.pem",
                  "cacertfile": "/etc/emqx/certs/cacert.pem"
                },
                "pool_size": 8,
                "enable": true,
                "url": "http://127.0.0.1:8081",
                "request_timeout": "5s",
                "auto_reconnect": "60s",
                "failed_action": "deny"
              },
              "schema": {
                "$ref": "#/components/schemas/exhook.server_config"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete the server",
        "tags": [
          "ExHook"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "The Exhook server name",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "default"
          }
        ],
        "responses": {
          "204": {
            "description": ""
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Server not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "500": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_RPC"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad RPC"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/prometheus": {
      "get": {
        "description": "Get Prometheus config info",
        "tags": [
          "Monitor"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "collectors": {
                    "mnesia": "disabled",
                    "vm_msacc": "disabled",
                    "vm_memory": "disabled",
                    "vm_system_info": "disabled",
                    "vm_statistics": "disabled",
                    "vm_dist": "disabled"
                  },
                  "push_gateway": {
                    "interval": "15s",
                    "headers": {
                      "Authorization": "Basic YWRtaW46Y2JraG55eWd5QDE="
                    },
                    "url": "http://127.0.0.1:9091",
                    "job_name": "${name}/instance/${name}~${host}"
                  },
                  "enable_basic_auth": false
                },
                "schema": {
                  "$ref": "#/components/schemas/prometheus.recommend_setting"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update Prometheus config",
        "tags": [
          "Monitor"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "collectors": {
                    "mnesia": "disabled",
                    "vm_msacc": "disabled",
                    "vm_memory": "disabled",
                    "vm_system_info": "disabled",
                    "vm_statistics": "disabled",
                    "vm_dist": "disabled"
                  },
                  "push_gateway": {
                    "interval": "15s",
                    "headers": {
                      "Authorization": "Basic YWRtaW46Y2JraG55eWd5QDE="
                    },
                    "url": "http://127.0.0.1:9091",
                    "job_name": "${name}/instance/${name}~${host}"
                  },
                  "enable_basic_auth": false
                },
                "schema": {
                  "$ref": "#/components/schemas/prometheus.recommend_setting"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "recommend_setting": {
                  "value": {
                    "collectors": {
                      "mnesia": "disabled",
                      "vm_msacc": "disabled",
                      "vm_memory": "disabled",
                      "vm_system_info": "disabled",
                      "vm_statistics": "disabled",
                      "vm_dist": "disabled"
                    },
                    "push_gateway": {
                      "interval": "15s",
                      "headers": {
                        "Authorization": "Basic YWRtaW46Y2JraG55eWd5QDE="
                      },
                      "url": "http://127.0.0.1:9091",
                      "job_name": "${name}/instance/${name}~${host}"
                    },
                    "enable_basic_auth": false
                  },
                  "summary": "recommend_setting"
                },
                "legacy_deprecated_setting": {
                  "value": {
                    "enable": true,
                    "interval": "15s",
                    "headers": {
                      "Authorization": "Basic YWRtaW46Y2JraG55eWd5QDE="
                    },
                    "job_name": "${name}/instance/${name}~${host}",
                    "vm_msacc_collector": "disabled",
                    "vm_memory_collector": "disabled",
                    "vm_system_info_collector": "disabled",
                    "vm_statistics_collector": "disabled",
                    "mnesia_collector": "disabled",
                    "vm_dist_collector": "disabled",
                    "push_gateway_server": "http://127.0.0.1:9091"
                  },
                  "summary": "legacy_deprecated_setting"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/prometheus.legacy_deprecated_setting"
                  },
                  {
                    "$ref": "#/components/schemas/prometheus.recommend_setting"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/mqtt/auto_subscribe": {
      "get": {
        "description": "Get auto subscribe topic list",
        "tags": [
          "Auto Subscribe"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "After the device logs in successfully, the subscription is automatically completed for the device through the pre-defined subscription representation. Supports the use of placeholders.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/auto_subscribe.topic"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update auto subscribe topic list",
        "tags": [
          "Auto Subscribe"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "After the device logs in successfully, the subscription is automatically completed for the device through the pre-defined subscription representation. Supports the use of placeholders.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/auto_subscribe.topic"
                  }
                }
              }
            }
          },
          "409": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "EXCEED_LIMIT"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Auto Subscribe topics max limit"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/auto_subscribe.topic"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/{name}/listeners/{id}/authentication": {
      "get": {
        "description": "Get the listener's authenticator configs.",
        "tags": [
          "Gateway Listeners"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "lwm2m",
                "mqttsn",
                "stomp"
              ]
            },
            "example": "stomp"
          },
          {
            "in": "path",
            "name": "id",
            "description": "Listener ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": ""
          }
        ],
        "summary": "Get the listener's authenticator",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "jwt": {
                    "value": {
                      "mechanism": "jwt",
                      "secret": "mysecret",
                      "algorithm": "hmac-based",
                      "secret_base64_encoded": false,
                      "use_jwks": false,
                      "verify_claims": {
                        "username": "${username}"
                      }
                    },
                    "summary": "JWT authentication"
                  },
                  "password_based:built_in_database": {
                    "value": {
                      "mechanism": "password_based",
                      "backend": "built_in_database",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "user_id_type": "username"
                    },
                    "summary": "Built-in password_based authentication"
                  },
                  "password_based:http": {
                    "value": {
                      "ssl": {
                        "enable": false
                      },
                      "connect_timeout": "5s",
                      "mechanism": "password_based",
                      "pool_size": 8,
                      "body": {
                        "password": "${password}",
                        "username": "${username}"
                      },
                      "headers": {
                        "content-type": "application/json"
                      },
                      "method": "post",
                      "url": "http://127.0.0.1:18083",
                      "backend": "http",
                      "request_timeout": "5s",
                      "enable_pipelining": 100
                    },
                    "summary": "password_based authentication through external HTTP API"
                  },
                  "password_based:mongodb": {
                    "value": {
                      "mechanism": "password_based",
                      "filter": {
                        "username": "${username}"
                      },
                      "server": "127.0.0.1:27017",
                      "database": "example",
                      "backend": "mongodb",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "collection": "users",
                      "is_superuser_field": "is_superuser",
                      "password_hash_field": "password_hash",
                      "salt_field": "salt"
                    },
                    "summary": "password_based authentication with MongoDB backend"
                  },
                  "password_based:redis": {
                    "value": {
                      "mechanism": "password_based",
                      "server": "127.0.0.1:6379",
                      "cmd": "HMGET ${username} password_hash salt",
                      "database": 0,
                      "backend": "redis",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "redis_type": "single"
                    },
                    "summary": "password_based authentication with Redis backend"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authn.ldap_deprecated"
                    },
                    {
                      "$ref": "#/components/schemas/authn.ldap"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_jwks"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_public_key"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_hmac"
                    },
                    {
                      "$ref": "#/components/schemas/authn.http_post"
                    },
                    {
                      "$ref": "#/components/schemas/authn.http_get"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_single"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_sharded"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_rs"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_single"
                    },
                    {
                      "$ref": "#/components/schemas/authn.postgresql"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mysql"
                    },
                    {
                      "$ref": "#/components/schemas/authn.builtin_db"
                    }
                  ]
                }
              }
            }
          },
          "204": {
            "description": "Authentication or listener does not existed"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update authenticator configs for the listener, or disable/enable it.",
        "tags": [
          "Gateway Listeners"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "lwm2m",
                "mqttsn",
                "stomp"
              ]
            },
            "example": "stomp"
          },
          {
            "in": "path",
            "name": "id",
            "description": "Listener ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": ""
          }
        ],
        "summary": "Update config of authenticator for listener",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "jwt": {
                    "value": {
                      "mechanism": "jwt",
                      "secret": "mysecret",
                      "algorithm": "hmac-based",
                      "secret_base64_encoded": false,
                      "use_jwks": false,
                      "verify_claims": {
                        "username": "${username}"
                      }
                    },
                    "summary": "JWT authentication"
                  },
                  "password_based:built_in_database": {
                    "value": {
                      "mechanism": "password_based",
                      "backend": "built_in_database",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "user_id_type": "username"
                    },
                    "summary": "Built-in password_based authentication"
                  },
                  "password_based:http": {
                    "value": {
                      "ssl": {
                        "enable": false
                      },
                      "connect_timeout": "5s",
                      "mechanism": "password_based",
                      "pool_size": 8,
                      "body": {
                        "password": "${password}",
                        "username": "${username}"
                      },
                      "headers": {
                        "content-type": "application/json"
                      },
                      "method": "post",
                      "url": "http://127.0.0.1:18083",
                      "backend": "http",
                      "request_timeout": "5s",
                      "enable_pipelining": 100
                    },
                    "summary": "password_based authentication through external HTTP API"
                  },
                  "password_based:mongodb": {
                    "value": {
                      "mechanism": "password_based",
                      "filter": {
                        "username": "${username}"
                      },
                      "server": "127.0.0.1:27017",
                      "database": "example",
                      "backend": "mongodb",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "collection": "users",
                      "is_superuser_field": "is_superuser",
                      "password_hash_field": "password_hash",
                      "salt_field": "salt"
                    },
                    "summary": "password_based authentication with MongoDB backend"
                  },
                  "password_based:redis": {
                    "value": {
                      "mechanism": "password_based",
                      "server": "127.0.0.1:6379",
                      "cmd": "HMGET ${username} password_hash salt",
                      "database": 0,
                      "backend": "redis",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "redis_type": "single"
                    },
                    "summary": "password_based authentication with Redis backend"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authn.ldap_deprecated"
                    },
                    {
                      "$ref": "#/components/schemas/authn.ldap"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_jwks"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_public_key"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_hmac"
                    },
                    {
                      "$ref": "#/components/schemas/authn.http_post"
                    },
                    {
                      "$ref": "#/components/schemas/authn.http_get"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_single"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_sharded"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_rs"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_single"
                    },
                    {
                      "$ref": "#/components/schemas/authn.postgresql"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mysql"
                    },
                    {
                      "$ref": "#/components/schemas/authn.builtin_db"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "jwt": {
                  "value": {
                    "mechanism": "jwt",
                    "secret": "mysecret",
                    "algorithm": "hmac-based",
                    "secret_base64_encoded": false,
                    "use_jwks": false,
                    "verify_claims": {
                      "username": "${username}"
                    }
                  },
                  "summary": "JWT authentication"
                },
                "password_based:built_in_database": {
                  "value": {
                    "mechanism": "password_based",
                    "backend": "built_in_database",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "user_id_type": "username"
                  },
                  "summary": "Built-in password_based authentication"
                },
                "password_based:http": {
                  "value": {
                    "ssl": {
                      "enable": false
                    },
                    "connect_timeout": "5s",
                    "mechanism": "password_based",
                    "pool_size": 8,
                    "body": {
                      "password": "${password}",
                      "username": "${username}"
                    },
                    "headers": {
                      "content-type": "application/json"
                    },
                    "method": "post",
                    "url": "http://127.0.0.1:18083",
                    "backend": "http",
                    "request_timeout": "5s",
                    "enable_pipelining": 100
                  },
                  "summary": "password_based authentication through external HTTP API"
                },
                "password_based:mongodb": {
                  "value": {
                    "mechanism": "password_based",
                    "filter": {
                      "username": "${username}"
                    },
                    "server": "127.0.0.1:27017",
                    "database": "example",
                    "backend": "mongodb",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "collection": "users",
                    "is_superuser_field": "is_superuser",
                    "password_hash_field": "password_hash",
                    "salt_field": "salt"
                  },
                  "summary": "password_based authentication with MongoDB backend"
                },
                "password_based:redis": {
                  "value": {
                    "mechanism": "password_based",
                    "server": "127.0.0.1:6379",
                    "cmd": "HMGET ${username} password_hash salt",
                    "database": 0,
                    "backend": "redis",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "redis_type": "single"
                  },
                  "summary": "password_based authentication with Redis backend"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/authn.ldap_deprecated"
                  },
                  {
                    "$ref": "#/components/schemas/authn.ldap"
                  },
                  {
                    "$ref": "#/components/schemas/authn.jwt_jwks"
                  },
                  {
                    "$ref": "#/components/schemas/authn.jwt_public_key"
                  },
                  {
                    "$ref": "#/components/schemas/authn.jwt_hmac"
                  },
                  {
                    "$ref": "#/components/schemas/authn.http_post"
                  },
                  {
                    "$ref": "#/components/schemas/authn.http_get"
                  },
                  {
                    "$ref": "#/components/schemas/authn.redis_sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/authn.redis_cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn.redis_single"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mongo_sharded"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mongo_rs"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mongo_single"
                  },
                  {
                    "$ref": "#/components/schemas/authn.postgresql"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mysql"
                  },
                  {
                    "$ref": "#/components/schemas/authn.builtin_db"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Remove authenticator for the listener.",
        "tags": [
          "Gateway Listeners"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "lwm2m",
                "mqttsn",
                "stomp"
              ]
            },
            "example": "stomp"
          },
          {
            "in": "path",
            "name": "id",
            "description": "Listener ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": ""
          }
        ],
        "summary": "Delete the listener's authenticator",
        "responses": {
          "200": {
            "description": "Deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Enable authenticator for specified listener for client authentication.<br/><br/>When authenticator is enabled for a listener, all clients connecting to that listener will use that authenticator for authentication.",
        "tags": [
          "Gateway Listeners"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "lwm2m",
                "mqttsn",
                "stomp"
              ]
            },
            "example": "stomp"
          },
          {
            "in": "path",
            "name": "id",
            "description": "Listener ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": ""
          }
        ],
        "summary": "Create authenticator for listener",
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "jwt": {
                    "value": {
                      "mechanism": "jwt",
                      "secret": "mysecret",
                      "algorithm": "hmac-based",
                      "secret_base64_encoded": false,
                      "use_jwks": false,
                      "verify_claims": {
                        "username": "${username}"
                      }
                    },
                    "summary": "JWT authentication"
                  },
                  "password_based:built_in_database": {
                    "value": {
                      "mechanism": "password_based",
                      "backend": "built_in_database",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "user_id_type": "username"
                    },
                    "summary": "Built-in password_based authentication"
                  },
                  "password_based:http": {
                    "value": {
                      "ssl": {
                        "enable": false
                      },
                      "connect_timeout": "5s",
                      "mechanism": "password_based",
                      "pool_size": 8,
                      "body": {
                        "password": "${password}",
                        "username": "${username}"
                      },
                      "headers": {
                        "content-type": "application/json"
                      },
                      "method": "post",
                      "url": "http://127.0.0.1:18083",
                      "backend": "http",
                      "request_timeout": "5s",
                      "enable_pipelining": 100
                    },
                    "summary": "password_based authentication through external HTTP API"
                  },
                  "password_based:mongodb": {
                    "value": {
                      "mechanism": "password_based",
                      "filter": {
                        "username": "${username}"
                      },
                      "server": "127.0.0.1:27017",
                      "database": "example",
                      "backend": "mongodb",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "collection": "users",
                      "is_superuser_field": "is_superuser",
                      "password_hash_field": "password_hash",
                      "salt_field": "salt"
                    },
                    "summary": "password_based authentication with MongoDB backend"
                  },
                  "password_based:redis": {
                    "value": {
                      "mechanism": "password_based",
                      "server": "127.0.0.1:6379",
                      "cmd": "HMGET ${username} password_hash salt",
                      "database": 0,
                      "backend": "redis",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "redis_type": "single"
                    },
                    "summary": "password_based authentication with Redis backend"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authn.ldap_deprecated"
                    },
                    {
                      "$ref": "#/components/schemas/authn.ldap"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_jwks"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_public_key"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_hmac"
                    },
                    {
                      "$ref": "#/components/schemas/authn.http_post"
                    },
                    {
                      "$ref": "#/components/schemas/authn.http_get"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_single"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_sharded"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_rs"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_single"
                    },
                    {
                      "$ref": "#/components/schemas/authn.postgresql"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mysql"
                    },
                    {
                      "$ref": "#/components/schemas/authn.builtin_db"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "jwt": {
                  "value": {
                    "mechanism": "jwt",
                    "secret": "mysecret",
                    "algorithm": "hmac-based",
                    "secret_base64_encoded": false,
                    "use_jwks": false,
                    "verify_claims": {
                      "username": "${username}"
                    }
                  },
                  "summary": "JWT authentication"
                },
                "password_based:built_in_database": {
                  "value": {
                    "mechanism": "password_based",
                    "backend": "built_in_database",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "user_id_type": "username"
                  },
                  "summary": "Built-in password_based authentication"
                },
                "password_based:http": {
                  "value": {
                    "ssl": {
                      "enable": false
                    },
                    "connect_timeout": "5s",
                    "mechanism": "password_based",
                    "pool_size": 8,
                    "body": {
                      "password": "${password}",
                      "username": "${username}"
                    },
                    "headers": {
                      "content-type": "application/json"
                    },
                    "method": "post",
                    "url": "http://127.0.0.1:18083",
                    "backend": "http",
                    "request_timeout": "5s",
                    "enable_pipelining": 100
                  },
                  "summary": "password_based authentication through external HTTP API"
                },
                "password_based:mongodb": {
                  "value": {
                    "mechanism": "password_based",
                    "filter": {
                      "username": "${username}"
                    },
                    "server": "127.0.0.1:27017",
                    "database": "example",
                    "backend": "mongodb",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "collection": "users",
                    "is_superuser_field": "is_superuser",
                    "password_hash_field": "password_hash",
                    "salt_field": "salt"
                  },
                  "summary": "password_based authentication with MongoDB backend"
                },
                "password_based:redis": {
                  "value": {
                    "mechanism": "password_based",
                    "server": "127.0.0.1:6379",
                    "cmd": "HMGET ${username} password_hash salt",
                    "database": 0,
                    "backend": "redis",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "redis_type": "single"
                  },
                  "summary": "password_based authentication with Redis backend"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/authn.ldap_deprecated"
                  },
                  {
                    "$ref": "#/components/schemas/authn.ldap"
                  },
                  {
                    "$ref": "#/components/schemas/authn.jwt_jwks"
                  },
                  {
                    "$ref": "#/components/schemas/authn.jwt_public_key"
                  },
                  {
                    "$ref": "#/components/schemas/authn.jwt_hmac"
                  },
                  {
                    "$ref": "#/components/schemas/authn.http_post"
                  },
                  {
                    "$ref": "#/components/schemas/authn.http_get"
                  },
                  {
                    "$ref": "#/components/schemas/authn.redis_sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/authn.redis_cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn.redis_single"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mongo_sharded"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mongo_rs"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mongo_single"
                  },
                  {
                    "$ref": "#/components/schemas/authn.postgresql"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mysql"
                  },
                  {
                    "$ref": "#/components/schemas/authn.builtin_db"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/{name}/listeners": {
      "get": {
        "description": "Gets a list of gateway listeners. This interface returns all the configs of the listener (including the authenticator on that listener), as well as the status of that listener running in the cluster.",
        "tags": [
          "Gateway Listeners"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "lwm2m",
                "mqttsn",
                "stomp"
              ]
            },
            "example": "stomp"
          }
        ],
        "summary": "List all listeners",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": [
                  {
                    "name": "udp-def",
                    "status": {
                      "running": true,
                      "max_connections": 1024000,
                      "current_connections": 10
                    },
                    "type": "udp",
                    "bind": "22212",
                    "udp_options": {
                      "buffer": "10KB",
                      "recbuf": "10KB",
                      "reuseaddr": true,
                      "sndbuf": "10KB",
                      "active_n": 100
                    },
                    "node_status": [
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "running": true,
                          "max_connections": 1024000,
                          "current_connections": 10
                        }
                      }
                    ]
                  },
                  {
                    "name": "dtls-def",
                    "status": {
                      "running": true,
                      "max_connections": 1024000,
                      "current_connections": 10
                    },
                    "type": "dtls",
                    "bind": "22213",
                    "udp_options": {
                      "backlog": 1024,
                      "active_n": 100
                    },
                    "node_status": [
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "running": true,
                          "max_connections": 1024000,
                          "current_connections": 10
                        }
                      }
                    ],
                    "acceptors": 16,
                    "dtls_options": {
                      "verify": "verify_none",
                      "versions": [
                        "dtlsv1.2",
                        "dtlsv1"
                      ],
                      "fail_if_no_peer_cert": false,
                      "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                      "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                      "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem"
                    },
                    "max_connections": 1024000,
                    "access_rules": [
                      "allow all"
                    ],
                    "max_conn_rate": 1000
                  },
                  {
                    "name": "ssl-def",
                    "status": {
                      "running": true,
                      "max_connections": 1024000,
                      "current_connections": 10
                    },
                    "type": "ssl",
                    "bind": "22211",
                    "tcp_options": {
                      "backlog": 1024,
                      "active_n": 100
                    },
                    "ssl_options": {
                      "verify": "verify_none",
                      "versions": [
                        "tlsv1.3",
                        "tlsv1.2",
                        "tlsv1.1",
                        "tlsv1"
                      ],
                      "fail_if_no_peer_cert": false,
                      "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                      "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                      "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem"
                    },
                    "node_status": [
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "running": true,
                          "max_connections": 1024000,
                          "current_connections": 10
                        }
                      }
                    ],
                    "acceptors": 16,
                    "max_connections": 1024000,
                    "access_rules": [
                      "allow all"
                    ],
                    "max_conn_rate": 1000
                  },
                  {
                    "name": "tcp-def",
                    "status": {
                      "running": true,
                      "max_connections": 1024000,
                      "current_connections": 10
                    },
                    "type": "tcp",
                    "bind": "22210",
                    "tcp_options": {
                      "buffer": "10KB",
                      "high_watermark": "1MB",
                      "keepalive": "none",
                      "nodelay": false,
                      "recbuf": "10KB",
                      "reuseaddr": true,
                      "send_timeout": "15s",
                      "send_timeout_close": true,
                      "sndbuf": "10KB",
                      "backlog": 1024,
                      "active_n": 100
                    },
                    "node_status": [
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "running": true,
                          "max_connections": 1024000,
                          "current_connections": 10
                        }
                      }
                    ],
                    "acceptors": 16,
                    "max_connections": 1024000,
                    "max_conn_rate": 1000
                  },
                  {
                    "name": "ws-def",
                    "status": {
                      "running": true,
                      "max_connections": 1024000,
                      "current_connections": 10
                    },
                    "type": "ws",
                    "bind": "33043",
                    "tcp_options": {
                      "buffer": "10KB",
                      "high_watermark": "1MB",
                      "keepalive": "none",
                      "nodelay": false,
                      "recbuf": "10KB",
                      "reuseaddr": true,
                      "send_timeout": "15s",
                      "send_timeout_close": true,
                      "sndbuf": "10KB",
                      "backlog": 1024,
                      "active_n": 100
                    },
                    "node_status": [
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "running": true,
                          "max_connections": 1024000,
                          "current_connections": 10
                        }
                      }
                    ],
                    "websocket": {
                      "path": "/ocpp",
                      "compress": false,
                      "fail_if_no_subprotocol": true,
                      "supported_subprotocols": "ocpp1.6",
                      "check_origins": "http://localhost:18083, http://127.0.0.1:18083",
                      "check_origin_enable": false,
                      "piggyback": "single"
                    },
                    "acceptors": 16,
                    "max_connections": 1024000,
                    "max_conn_rate": 1000
                  },
                  {
                    "name": "ws-ssl-def",
                    "status": {
                      "running": true,
                      "max_connections": 1024000,
                      "current_connections": 10
                    },
                    "type": "wss",
                    "bind": "33053",
                    "tcp_options": {
                      "buffer": "10KB",
                      "high_watermark": "1MB",
                      "keepalive": "none",
                      "nodelay": false,
                      "recbuf": "10KB",
                      "reuseaddr": true,
                      "send_timeout": "15s",
                      "send_timeout_close": true,
                      "sndbuf": "10KB",
                      "backlog": 1024,
                      "active_n": 100
                    },
                    "ssl_options": {
                      "verify": "verify_none",
                      "versions": [
                        "tlsv1.3",
                        "tlsv1.2",
                        "tlsv1.1",
                        "tlsv1"
                      ],
                      "fail_if_no_peer_cert": false,
                      "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                      "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                      "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem"
                    },
                    "node_status": [
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "running": true,
                          "max_connections": 1024000,
                          "current_connections": 10
                        }
                      }
                    ],
                    "websocket": {
                      "path": "/ocpp",
                      "compress": false,
                      "fail_if_no_subprotocol": true,
                      "supported_subprotocols": "ocpp1.6",
                      "check_origins": "http://localhost:18083, http://127.0.0.1:18083",
                      "check_origin_enable": false,
                      "piggyback": "single"
                    },
                    "acceptors": 16,
                    "max_connections": 1024000,
                    "max_conn_rate": 1000
                  },
                  {
                    "name": "dtls-psk",
                    "status": {
                      "running": true,
                      "max_connections": 1024000,
                      "current_connections": 10
                    },
                    "type": "dtls",
                    "bind": "22214",
                    "node_status": [
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "running": true,
                          "max_connections": 1024000,
                          "current_connections": 10
                        }
                      }
                    ],
                    "acceptors": 16,
                    "dtls_options": {
                      "verify": "verify_none",
                      "ciphers": "RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA",
                      "versions": [
                        "dtlsv1.2",
                        "dtlsv1"
                      ],
                      "fail_if_no_peer_cert": false,
                      "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                      "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                      "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem",
                      "user_lookup_fun": "emqx_tls_psk:lookup"
                    },
                    "max_connections": 1024000,
                    "max_conn_rate": 1000
                  },
                  {
                    "name": "tcp-with-authn",
                    "status": {
                      "running": true,
                      "max_connections": 1024000,
                      "current_connections": 10
                    },
                    "type": "tcp",
                    "bind": "22215",
                    "authentication": {
                      "mechanism": "password_based",
                      "backend": "built_in_database",
                      "password_hash_algorithm": {
                        "name": "sha256"
                      },
                      "user_id_type": "username"
                    },
                    "node_status": [
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "running": true,
                          "max_connections": 1024000,
                          "current_connections": 10
                        }
                      }
                    ],
                    "acceptors": 16,
                    "max_connections": 1024000,
                    "max_conn_rate": 1000
                  }
                ],
                "schema": {
                  "type": "array",
                  "items": {
                    "oneOf": [
                      {
                        "$ref": "#/components/schemas/emqx_gateway_api_listeners.dtls_listener"
                      },
                      {
                        "$ref": "#/components/schemas/emqx_gateway_api_listeners.udp_listener"
                      },
                      {
                        "$ref": "#/components/schemas/emqx_gateway_api_listeners.ssl_listener"
                      },
                      {
                        "$ref": "#/components/schemas/emqx_gateway_api_listeners.tcp_listener"
                      }
                    ]
                  }
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Create the gateway listener.<br/><br/>Note: For listener types not supported by a gateway, this API returns `400: BAD_REQUEST`.",
        "tags": [
          "Gateway Listeners"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "lwm2m",
                "mqttsn",
                "stomp"
              ]
            },
            "example": "stomp"
          }
        ],
        "summary": "Add listener",
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "udp_listener": {
                    "value": {
                      "name": "udp-def",
                      "type": "udp",
                      "bind": "22212",
                      "udp_options": {
                        "buffer": "10KB",
                        "recbuf": "10KB",
                        "reuseaddr": true,
                        "sndbuf": "10KB",
                        "active_n": 100
                      }
                    },
                    "summary": "A simple UDP listener example"
                  },
                  "dtls_listener": {
                    "value": {
                      "name": "dtls-def",
                      "type": "dtls",
                      "bind": "22213",
                      "udp_options": {
                        "backlog": 1024,
                        "active_n": 100
                      },
                      "acceptors": 16,
                      "dtls_options": {
                        "verify": "verify_none",
                        "versions": [
                          "dtlsv1.2",
                          "dtlsv1"
                        ],
                        "fail_if_no_peer_cert": false,
                        "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                        "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                        "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem"
                      },
                      "max_connections": 1024000,
                      "access_rules": [
                        "allow all"
                      ],
                      "max_conn_rate": 1000
                    },
                    "summary": "A simple DTLS listener example"
                  },
                  "ssl_listener": {
                    "value": {
                      "name": "ssl-def",
                      "type": "ssl",
                      "bind": "22211",
                      "tcp_options": {
                        "backlog": 1024,
                        "active_n": 100
                      },
                      "ssl_options": {
                        "verify": "verify_none",
                        "versions": [
                          "tlsv1.3",
                          "tlsv1.2",
                          "tlsv1.1",
                          "tlsv1"
                        ],
                        "fail_if_no_peer_cert": false,
                        "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                        "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                        "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem"
                      },
                      "acceptors": 16,
                      "max_connections": 1024000,
                      "access_rules": [
                        "allow all"
                      ],
                      "max_conn_rate": 1000
                    },
                    "summary": "A simple SSL listener example"
                  },
                  "tcp_listener": {
                    "value": {
                      "name": "tcp-def",
                      "type": "tcp",
                      "bind": "22210",
                      "tcp_options": {
                        "buffer": "10KB",
                        "high_watermark": "1MB",
                        "keepalive": "none",
                        "nodelay": false,
                        "recbuf": "10KB",
                        "reuseaddr": true,
                        "send_timeout": "15s",
                        "send_timeout_close": true,
                        "sndbuf": "10KB",
                        "backlog": 1024,
                        "active_n": 100
                      },
                      "acceptors": 16,
                      "max_connections": 1024000,
                      "max_conn_rate": 1000
                    },
                    "summary": "A simple TCP listener example"
                  },
                  "ws_listener": {
                    "value": {
                      "name": "ws-def",
                      "type": "ws",
                      "bind": "33043",
                      "tcp_options": {
                        "buffer": "10KB",
                        "high_watermark": "1MB",
                        "keepalive": "none",
                        "nodelay": false,
                        "recbuf": "10KB",
                        "reuseaddr": true,
                        "send_timeout": "15s",
                        "send_timeout_close": true,
                        "sndbuf": "10KB",
                        "backlog": 1024,
                        "active_n": 100
                      },
                      "websocket": {
                        "path": "/ocpp",
                        "compress": false,
                        "fail_if_no_subprotocol": true,
                        "supported_subprotocols": "ocpp1.6",
                        "check_origins": "http://localhost:18083, http://127.0.0.1:18083",
                        "check_origin_enable": false,
                        "piggyback": "single"
                      },
                      "acceptors": 16,
                      "max_connections": 1024000,
                      "max_conn_rate": 1000
                    },
                    "summary": "A simple WebSocket listener example"
                  },
                  "wss_listener": {
                    "value": {
                      "name": "ws-ssl-def",
                      "type": "wss",
                      "bind": "33053",
                      "tcp_options": {
                        "buffer": "10KB",
                        "high_watermark": "1MB",
                        "keepalive": "none",
                        "nodelay": false,
                        "recbuf": "10KB",
                        "reuseaddr": true,
                        "send_timeout": "15s",
                        "send_timeout_close": true,
                        "sndbuf": "10KB",
                        "backlog": 1024,
                        "active_n": 100
                      },
                      "ssl_options": {
                        "verify": "verify_none",
                        "versions": [
                          "tlsv1.3",
                          "tlsv1.2",
                          "tlsv1.1",
                          "tlsv1"
                        ],
                        "fail_if_no_peer_cert": false,
                        "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                        "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                        "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem"
                      },
                      "websocket": {
                        "path": "/ocpp",
                        "compress": false,
                        "fail_if_no_subprotocol": true,
                        "supported_subprotocols": "ocpp1.6",
                        "check_origins": "http://localhost:18083, http://127.0.0.1:18083",
                        "check_origin_enable": false,
                        "piggyback": "single"
                      },
                      "acceptors": 16,
                      "max_connections": 1024000,
                      "max_conn_rate": 1000
                    },
                    "summary": "A simple WebSocket/TLS listener example"
                  },
                  "dtls_listener_with_psk_ciphers": {
                    "value": {
                      "name": "dtls-psk",
                      "type": "dtls",
                      "bind": "22214",
                      "acceptors": 16,
                      "dtls_options": {
                        "verify": "verify_none",
                        "ciphers": "RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA",
                        "versions": [
                          "dtlsv1.2",
                          "dtlsv1"
                        ],
                        "fail_if_no_peer_cert": false,
                        "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                        "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                        "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem",
                        "user_lookup_fun": "emqx_tls_psk:lookup"
                      },
                      "max_connections": 1024000,
                      "max_conn_rate": 1000
                    },
                    "summary": "A DTLS listener with PSK example"
                  },
                  "lisetner_with_authn": {
                    "value": {
                      "name": "tcp-with-authn",
                      "type": "tcp",
                      "bind": "22215",
                      "authentication": {
                        "mechanism": "password_based",
                        "backend": "built_in_database",
                        "password_hash_algorithm": {
                          "name": "sha256"
                        },
                        "user_id_type": "username"
                      },
                      "acceptors": 16,
                      "max_connections": 1024000,
                      "max_conn_rate": 1000
                    },
                    "summary": "A TCP listener with authentication example"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.wss_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.ws_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.dtls_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.udp_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.ssl_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.tcp_listener"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "udp_listener": {
                  "value": {
                    "name": "udp-def",
                    "type": "udp",
                    "bind": "22212",
                    "udp_options": {
                      "buffer": "10KB",
                      "recbuf": "10KB",
                      "reuseaddr": true,
                      "sndbuf": "10KB",
                      "active_n": 100
                    }
                  },
                  "summary": "A simple UDP listener example"
                },
                "dtls_listener": {
                  "value": {
                    "name": "dtls-def",
                    "type": "dtls",
                    "bind": "22213",
                    "udp_options": {
                      "backlog": 1024,
                      "active_n": 100
                    },
                    "acceptors": 16,
                    "dtls_options": {
                      "verify": "verify_none",
                      "versions": [
                        "dtlsv1.2",
                        "dtlsv1"
                      ],
                      "fail_if_no_peer_cert": false,
                      "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                      "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                      "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem"
                    },
                    "max_connections": 1024000,
                    "access_rules": [
                      "allow all"
                    ],
                    "max_conn_rate": 1000
                  },
                  "summary": "A simple DTLS listener example"
                },
                "ssl_listener": {
                  "value": {
                    "name": "ssl-def",
                    "type": "ssl",
                    "bind": "22211",
                    "tcp_options": {
                      "backlog": 1024,
                      "active_n": 100
                    },
                    "ssl_options": {
                      "verify": "verify_none",
                      "versions": [
                        "tlsv1.3",
                        "tlsv1.2",
                        "tlsv1.1",
                        "tlsv1"
                      ],
                      "fail_if_no_peer_cert": false,
                      "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                      "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                      "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem"
                    },
                    "acceptors": 16,
                    "max_connections": 1024000,
                    "access_rules": [
                      "allow all"
                    ],
                    "max_conn_rate": 1000
                  },
                  "summary": "A simple SSL listener example"
                },
                "tcp_listener": {
                  "value": {
                    "name": "tcp-def",
                    "type": "tcp",
                    "bind": "22210",
                    "tcp_options": {
                      "buffer": "10KB",
                      "high_watermark": "1MB",
                      "keepalive": "none",
                      "nodelay": false,
                      "recbuf": "10KB",
                      "reuseaddr": true,
                      "send_timeout": "15s",
                      "send_timeout_close": true,
                      "sndbuf": "10KB",
                      "backlog": 1024,
                      "active_n": 100
                    },
                    "acceptors": 16,
                    "max_connections": 1024000,
                    "max_conn_rate": 1000
                  },
                  "summary": "A simple TCP listener example"
                },
                "ws_listener": {
                  "value": {
                    "name": "ws-def",
                    "type": "ws",
                    "bind": "33043",
                    "tcp_options": {
                      "buffer": "10KB",
                      "high_watermark": "1MB",
                      "keepalive": "none",
                      "nodelay": false,
                      "recbuf": "10KB",
                      "reuseaddr": true,
                      "send_timeout": "15s",
                      "send_timeout_close": true,
                      "sndbuf": "10KB",
                      "backlog": 1024,
                      "active_n": 100
                    },
                    "websocket": {
                      "path": "/ocpp",
                      "compress": false,
                      "fail_if_no_subprotocol": true,
                      "supported_subprotocols": "ocpp1.6",
                      "check_origins": "http://localhost:18083, http://127.0.0.1:18083",
                      "check_origin_enable": false,
                      "piggyback": "single"
                    },
                    "acceptors": 16,
                    "max_connections": 1024000,
                    "max_conn_rate": 1000
                  },
                  "summary": "A simple WebSocket listener example"
                },
                "wss_listener": {
                  "value": {
                    "name": "ws-ssl-def",
                    "type": "wss",
                    "bind": "33053",
                    "tcp_options": {
                      "buffer": "10KB",
                      "high_watermark": "1MB",
                      "keepalive": "none",
                      "nodelay": false,
                      "recbuf": "10KB",
                      "reuseaddr": true,
                      "send_timeout": "15s",
                      "send_timeout_close": true,
                      "sndbuf": "10KB",
                      "backlog": 1024,
                      "active_n": 100
                    },
                    "ssl_options": {
                      "verify": "verify_none",
                      "versions": [
                        "tlsv1.3",
                        "tlsv1.2",
                        "tlsv1.1",
                        "tlsv1"
                      ],
                      "fail_if_no_peer_cert": false,
                      "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                      "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                      "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem"
                    },
                    "websocket": {
                      "path": "/ocpp",
                      "compress": false,
                      "fail_if_no_subprotocol": true,
                      "supported_subprotocols": "ocpp1.6",
                      "check_origins": "http://localhost:18083, http://127.0.0.1:18083",
                      "check_origin_enable": false,
                      "piggyback": "single"
                    },
                    "acceptors": 16,
                    "max_connections": 1024000,
                    "max_conn_rate": 1000
                  },
                  "summary": "A simple WebSocket/TLS listener example"
                },
                "dtls_listener_with_psk_ciphers": {
                  "value": {
                    "name": "dtls-psk",
                    "type": "dtls",
                    "bind": "22214",
                    "acceptors": 16,
                    "dtls_options": {
                      "verify": "verify_none",
                      "ciphers": "RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA",
                      "versions": [
                        "dtlsv1.2",
                        "dtlsv1"
                      ],
                      "fail_if_no_peer_cert": false,
                      "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                      "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                      "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem",
                      "user_lookup_fun": "emqx_tls_psk:lookup"
                    },
                    "max_connections": 1024000,
                    "max_conn_rate": 1000
                  },
                  "summary": "A DTLS listener with PSK example"
                },
                "lisetner_with_authn": {
                  "value": {
                    "name": "tcp-with-authn",
                    "type": "tcp",
                    "bind": "22215",
                    "authentication": {
                      "mechanism": "password_based",
                      "backend": "built_in_database",
                      "password_hash_algorithm": {
                        "name": "sha256"
                      },
                      "user_id_type": "username"
                    },
                    "acceptors": 16,
                    "max_connections": 1024000,
                    "max_conn_rate": 1000
                  },
                  "summary": "A TCP listener with authentication example"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.wss_listener"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.ws_listener"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.dtls_listener"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.udp_listener"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.ssl_listener"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.tcp_listener"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/plugins/{name}/config": {
      "get": {
        "description": "Get plugin config. Config schema is defined by user's schema.avsc file.<br/>",
        "tags": [
          "Plugins"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/plugins.name"
          }
        ],
        "summary": "Get plugin config",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_CONFIG"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Plugin Config Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Plugin Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update plugin config. Config schema defined by user's schema.avsc file.<br/>",
        "tags": [
          "Plugins"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/plugins.name"
          }
        ],
        "summary": "Update plugin config",
        "responses": {
          "204": {
            "description": "Config updated successfully"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_CONFIG",
                        "UNEXPECTED_ERROR"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Update plugin config failed"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Plugin Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/configs/sys_topics": {
      "get": {
        "description": "Get the sub-configurations under *sys_topics*",
        "tags": [
          "Configs"
        ],
        "parameters": [],
        "summary": "Get the sub-configurations under *sys_topics*",
        "responses": {
          "200": {
            "description": "System topics configuration.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx.sys_topics"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "config not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update the sub-configurations under *sys_topics*",
        "tags": [
          "Configs"
        ],
        "parameters": [],
        "summary": "Update the sub-configurations under *sys_topics*",
        "responses": {
          "200": {
            "description": "System topics configuration.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx.sys_topics"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UPDATE_FAILED",
                        "INVALID_CONFIG"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "403": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UPDATE_FAILED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx.sys_topics"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/clients/kickout/bulk": {
      "post": {
        "description": "Kick out a batch of client by client IDs",
        "tags": [
          "Clients"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": "Kick out clients successfully"
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "example": [
                "emqx_clientid_985bb09d",
                "emqx_clientid_211cc01c"
              ],
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/connectors_probe": {
      "post": {
        "description": "Test creating a new connector.",
        "tags": [
          "Connectors"
        ],
        "parameters": [],
        "summary": "Test creating connector",
        "responses": {
          "204": {
            "description": "Test connector OK"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "TEST_FAILED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "connector test failed"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "http": {
                  "value": {
                    "name": "my_http_connector",
                    "type": "http",
                    "connect_timeout": "15s",
                    "pool_size": 1,
                    "enable": true,
                    "headers": {
                      "content-type": "application/json"
                    },
                    "url": "http://localhost:8080/api/v1",
                    "pool_type": "hash",
                    "enable_pipelining": 100
                  },
                  "summary": "HTTP Connector"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/connector_mqtt.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_http.post_connector"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/nodes/{node}/sources/{id}/{operation}": {
      "post": {
        "description": "Start bridge on a specific node.",
        "tags": [
          "Sources"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "node",
            "description": "The node name, e.g. 'emqx@127.0.0.1'.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "emqx@127.0.0.1"
          },
          {
            "in": "path",
            "name": "id",
            "description": "The bridge id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_action"
          },
          {
            "in": "path",
            "name": "operation",
            "description": "Operation can be one of: 'start'.",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "start"
              ]
            },
            "example": "start"
          }
        ],
        "summary": "Manually start a bridge on a given node",
        "responses": {
          "204": {
            "description": "Operation success"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Problem with configuration of external service or bridge not enabled"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bridge or node not found or invalid operation"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "501": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_IMPLEMENTED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Implemented"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Service unavailable"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/authorization/sources/built_in_database/rules/clients": {
      "get": {
        "description": "Show the list of rules for clients",
        "tags": [
          "Authorization"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          },
          {
            "in": "query",
            "name": "like_clientid",
            "description": "Fuzzy search `clientid` as substring",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "password_based:built_in_database": {
                    "value": {
                      "data": [
                        {
                          "rules": [
                            {
                              "action": "publish",
                              "topic": "test/topic/1",
                              "permission": "allow"
                            },
                            {
                              "action": "subscribe",
                              "topic": "test/topic/2",
                              "permission": "allow"
                            },
                            {
                              "action": "all",
                              "topic": "eq test/#",
                              "permission": "deny"
                            },
                            {
                              "action": "publish",
                              "retain": "true",
                              "topic": "test/topic/3",
                              "qos": [
                                "1"
                              ],
                              "permission": "allow"
                            },
                            {
                              "action": "publish",
                              "retain": "all",
                              "topic": "test/topic/4",
                              "qos": [
                                "0",
                                "1",
                                "2"
                              ],
                              "permission": "allow"
                            }
                          ],
                          "clientid": "client1"
                        }
                      ],
                      "meta": {
                        "count": 1,
                        "limit": 100,
                        "page": 1
                      }
                    },
                    "summary": "ClientID"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authz_api_mnesia.clientid_response_data"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Add new rule for 'clientid'",
        "tags": [
          "Authorization"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": "Created"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad clientid or bad rule schema"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "password_based:built_in_database": {
                  "value": [
                    {
                      "rules": [
                        {
                          "action": "publish",
                          "topic": "test/topic/1",
                          "permission": "allow"
                        },
                        {
                          "action": "subscribe",
                          "topic": "test/topic/2",
                          "permission": "allow"
                        },
                        {
                          "action": "all",
                          "topic": "eq test/#",
                          "permission": "deny"
                        },
                        {
                          "action": "publish",
                          "retain": "true",
                          "topic": "test/topic/3",
                          "qos": [
                            "1"
                          ],
                          "permission": "allow"
                        },
                        {
                          "action": "publish",
                          "retain": "all",
                          "topic": "test/topic/4",
                          "qos": [
                            "0",
                            "1",
                            "2"
                          ],
                          "permission": "allow"
                        }
                      ],
                      "clientid": "client1"
                    }
                  ],
                  "summary": "ClientID"
                }
              },
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/emqx_authz_api_mnesia.rules_for_clientid"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/mqtt/delayed/messages/{node}/{msgid}": {
      "get": {
        "description": "View delayed message",
        "tags": [
          "MQTT"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "node",
            "description": "The node where message from",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "msgid",
            "description": "Delayed Message ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_delayed_api.message_without_payload"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "MESSAGE_ID_SCHEMA_ERROR",
                        "INVALID_NODE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Message ID format"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "MESSAGE_ID_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Message ID not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete delayed message",
        "tags": [
          "MQTT"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "node",
            "description": "The node where message from",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "msgid",
            "description": "Delayed Message ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Delete delayed message success"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "MESSAGE_ID_SCHEMA_ERROR",
                        "INVALID_NODE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Message ID format"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "MESSAGE_ID_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Message ID not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/monitor_current/nodes/{node}": {
      "get": {
        "description": "Node monitor (statistics) data, e.g. number of connections and connection rate on the specified node.",
        "tags": [
          "Metrics"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "node",
            "description": "EMQX node name.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "emqx@127.0.0.1"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_dashboard_monitor_api.sampler_current_node"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Node not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/telemetry/status": {
      "get": {
        "description": "Get telemetry status",
        "tags": [
          "Telemetry"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Get telemetry status",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_telemetry_api.status"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Enable or disable telemetry",
        "tags": [
          "Telemetry"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Enable or disable telemetry",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_telemetry_api.status"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx_telemetry_api.status"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/authentication/{id}/users": {
      "get": {
        "description": "List users in authenticator in global authentication chain.",
        "tags": [
          "Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Authenticator ID.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          },
          {
            "in": "query",
            "name": "like_user_id",
            "description": "Fuzzy search user_id (username or clientid).",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "is_superuser",
            "description": "Is superuser",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "data": [
                    {
                      "user_id": "user1"
                    },
                    {
                      "is_superuser": true,
                      "user_id": "user2"
                    }
                  ],
                  "meta": {
                    "count": 300,
                    "limit": 20,
                    "page": 0
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_users"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Create users for authenticator in global authentication chain.",
        "tags": [
          "Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Authenticator ID.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "regular_user": {
                    "value": {
                      "user_id": "user1"
                    },
                    "summary": "Regular user"
                  },
                  "super_user": {
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    },
                    "summary": "Superuser"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "regular_user": {
                  "value": {
                    "password": "******",
                    "user_id": "user1"
                  },
                  "summary": "Regular user"
                },
                "super_user": {
                  "value": {
                    "password": "******",
                    "is_superuser": true,
                    "user_id": "user2"
                  },
                  "summary": "Superuser"
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authn_api.request_user_create"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/sessions_count": {
      "get": {
        "description": "Get the total number of sessions in the cluster.<br/>By default, it includes only those sessions that have not expired.<br/>If the `broker.session_history_retain` config is set to a duration greater than 0s,<br/>this count will also include sessions that expired within the specified retain time.<br/>By specifying the `since` parameter, it can return the number of sessions that have expired within the specified time.",
        "tags": [
          "Clients"
        ],
        "parameters": [
          {
            "in": "query",
            "name": "since",
            "description": "Include sessions expired after this time (UNIX Epoch in seconds precision)",
            "required": false,
            "schema": {
              "default": 0,
              "type": "integer",
              "minimum": 0
            },
            "example": 1705391625
          }
        ],
        "responses": {
          "200": {
            "description": "Number of sessions",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Node {name} cannot handle this request."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/sources": {
      "get": {
        "description": "List all created bridges.",
        "tags": [
          "Sources"
        ],
        "parameters": [],
        "summary": "List sources",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": [
                  {
                    "name": "mqtt_source",
                    "status": "connected",
                    "type": "mqtt",
                    "description": "My example mqtt source",
                    "enable": true,
                    "parameters": {
                      "topic": "remote/topic",
                      "qos": 1
                    },
                    "connector": "mqtt_connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  }
                ],
                "schema": {
                  "type": "array",
                  "items": {
                    "oneOf": [
                      {
                        "$ref": "#/components/schemas/bridge_mqtt_publisher.get_source"
                      }
                    ]
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Create a new bridge by type and name.",
        "tags": [
          "Sources"
        ],
        "parameters": [],
        "summary": "Create source",
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "mqtt": {
                    "value": {
                      "name": "mqtt_source",
                      "status": "connected",
                      "type": "mqtt",
                      "description": "My example mqtt source",
                      "enable": true,
                      "parameters": {
                        "topic": "remote/topic",
                        "qos": 1
                      },
                      "connector": "mqtt_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "MQTT Subscriber Source"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/bridge_mqtt_publisher.get_source"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "ALREADY_EXISTS"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Source already exists"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "mqtt": {
                  "value": {
                    "name": "mqtt_source",
                    "type": "mqtt",
                    "description": "My example mqtt source",
                    "enable": true,
                    "parameters": {
                      "topic": "remote/topic",
                      "qos": 1
                    },
                    "connector": "mqtt_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "MQTT Subscriber Source"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/bridge_mqtt_publisher.post_source"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/actions/{id}/enable/{enable}": {
      "put": {
        "description": "Enable or Disable bridge on all nodes in the cluster.",
        "tags": [
          "Actions"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_action"
          },
          {
            "in": "path",
            "name": "enable",
            "description": "Whether to enable this bridge.",
            "required": true,
            "schema": {
              "type": "boolean"
            },
            "example": true
          }
        ],
        "summary": "Enable or disable bridge",
        "responses": {
          "204": {
            "description": "Success"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bridge not found or invalid operation"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Service unavailable"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/prometheus/data_integration": {
      "get": {
        "description": "Get Prometheus Metrics for Data Integration",
        "tags": [
          "Monitor"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_prometheus_api.mode"
          }
        ],
        "responses": {
          "200": {
            "description": "Get Prometheus Data.",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          }
        },
        "security": []
      }
    },
    "/data/files/{filename}": {
      "get": {
        "description": "Download a data backup file",
        "tags": [
          "Data Backup"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "filename",
            "description": "Data backup file name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "node",
            "description": "Node name",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "enum": [
                    "binary"
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Backup file not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete a data backup file",
        "tags": [
          "Data Backup"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "filename",
            "description": "Data backup file name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "node",
            "description": "Node name",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Backup file not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/cluster": {
      "get": {
        "description": "Get cluster info",
        "tags": [
          "Cluster"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "name": {
                      "type": "string",
                      "description": "Cluster name"
                    },
                    "nodes": {
                      "type": "array",
                      "description": "Node name",
                      "items": {
                        "type": "string"
                      }
                    },
                    "self": {
                      "type": "string",
                      "description": "Self node name"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/plugins/{name}/{action}": {
      "put": {
        "description": "start/stop a installed plugin.<br/>- **start**: start the plugin.<br/>- **stop**: stop the plugin.<br/>",
        "tags": [
          "Plugins"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/plugins.name"
          },
          {
            "in": "path",
            "name": "action",
            "description": "Action",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "start",
                "stop"
              ]
            }
          }
        ],
        "summary": "Trigger action on an installed plugin",
        "responses": {
          "204": {
            "description": "Trigger action successfully"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Plugin Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/sources/{id}": {
      "get": {
        "description": "Get a bridge by id.",
        "tags": [
          "Sources"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_action"
          }
        ],
        "summary": "Get source",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "mqtt": {
                    "value": {
                      "name": "mqtt_source",
                      "status": "connected",
                      "type": "mqtt",
                      "description": "My example mqtt source",
                      "enable": true,
                      "parameters": {
                        "topic": "remote/topic",
                        "qos": 1
                      },
                      "connector": "mqtt_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "MQTT Subscriber Source"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/bridge_mqtt_publisher.get_source"
                    }
                  ]
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Source not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update a bridge by id.",
        "tags": [
          "Sources"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_action"
          }
        ],
        "summary": "Update source",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "mqtt": {
                    "value": {
                      "name": "mqtt_source",
                      "status": "connected",
                      "type": "mqtt",
                      "description": "My example mqtt source",
                      "enable": true,
                      "parameters": {
                        "topic": "remote/topic",
                        "qos": 1
                      },
                      "connector": "mqtt_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "MQTT Subscriber Source"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/bridge_mqtt_publisher.get_source"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Update source failed"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Source not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "mqtt": {
                  "value": {
                    "description": "My example mqtt source",
                    "enable": true,
                    "parameters": {
                      "topic": "remote/topic",
                      "qos": 1
                    },
                    "connector": "mqtt_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "MQTT Subscriber Source"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/bridge_mqtt_publisher.put_source"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete a bridge by id.",
        "tags": [
          "Sources"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_action"
          },
          {
            "in": "query",
            "name": "also_delete_dep_actions",
            "description": "Whether to cascade delete dependent actions.",
            "required": false,
            "schema": {
              "default": false,
              "type": "boolean"
            }
          }
        ],
        "summary": "Delete source",
        "responses": {
          "204": {
            "description": "Source deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "rules": {
                      "type": "array",
                      "description": "Dependent Rule IDs",
                      "items": {
                        "type": "string"
                      }
                    },
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Cannot delete bridge while active rules are defined for this source"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Source not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Service unavailable"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/data/export": {
      "post": {
        "description": "Export a data backup file",
        "tags": [
          "Data Backup"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "node": "emqx@127.0.0.1",
                  "size": 22740,
                  "filename": "emqx-export-2023-11-23-19-13-19.043.tar.gz",
                  "created_at": "2023-11-23T19:13:19+02:00",
                  "created_at_sec": 1700759599
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_data_backup.backup_file_info"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/source_types": {
      "get": {
        "description": "Lists the available source types.",
        "tags": [
          "Sources"
        ],
        "parameters": [],
        "summary": "List available source types",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "types": {
                    "value": [
                      "mqtt"
                    ],
                    "summary": "Source types"
                  }
                },
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "enum": [
                      "mqtt"
                    ]
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/{name}/clients/{clientid}": {
      "get": {
        "description": "Get the gateway client information",
        "tags": [
          "Gateway Clients"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "description": "Client ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "lwm2m",
                "mqttsn",
                "stomp"
              ]
            }
          }
        ],
        "summary": "Get client info",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "lwm2m_client": {
                    "value": {
                      "username": "guest",
                      "recv_oct": 56,
                      "awaiting_rel_max": "infinity",
                      "connected_at": "2021-12-07T10:44:02.721+08:00",
                      "proto_ver": "1.0",
                      "inflight_max": "infinity",
                      "keepalive": 0,
                      "node": "emqx@127.0.0.1",
                      "send_cnt": 1,
                      "subscriptions_max": "infinity",
                      "recv_pkt": 1,
                      "mqueue_dropped": 0,
                      "is_bridge": false,
                      "send_msg": 0,
                      "clientid": "MzAyMzEzNTUwNzk1NDA1MzYyMzIwNzUxNjQwMTY1NzQ0NjE",
                      "created_at": "2021-12-07T10:44:02.721+08:00",
                      "send_oct": 61,
                      "mailbox_len": 0,
                      "endpoint_name": "urn:imei:154928475237123",
                      "heap_size": 4185,
                      "recv_msg": 0,
                      "disconnected_at": null,
                      "subscriptions_cnt": 0,
                      "awaiting_rel_cnt": 0,
                      "port": 50675,
                      "proto_name": "LwM2M",
                      "ip_address": "127.0.0.1",
                      "mqueue_max": "infinity",
                      "clean_start": true,
                      "lifetime": 86400,
                      "inflight_cnt": 0,
                      "send_pkt": 1,
                      "mqueue_len": 0,
                      "connected": true,
                      "reductions": 72022,
                      "expiry_interval": 0,
                      "recv_cnt": 1
                    },
                    "summary": "LwM2M client info"
                  },
                  "general_client": {
                    "value": {
                      "username": "guest",
                      "recv_oct": 56,
                      "awaiting_rel_max": "infinity",
                      "connected_at": "2021-12-07T10:44:02.721+08:00",
                      "proto_ver": "1.0",
                      "inflight_max": "infinity",
                      "keepalive": 0,
                      "node": "emqx@127.0.0.1",
                      "send_cnt": 1,
                      "subscriptions_max": "infinity",
                      "recv_pkt": 1,
                      "mqueue_dropped": 0,
                      "is_bridge": false,
                      "send_msg": 0,
                      "clientid": "MzAyMzEzNTUwNzk1NDA1MzYyMzIwNzUxNjQwMTY1NzQ0NjE",
                      "created_at": "2021-12-07T10:44:02.721+08:00",
                      "send_oct": 61,
                      "mailbox_len": 0,
                      "heap_size": 4185,
                      "recv_msg": 0,
                      "disconnected_at": null,
                      "subscriptions_cnt": 0,
                      "awaiting_rel_cnt": 0,
                      "port": 50675,
                      "proto_name": "STOMP",
                      "ip_address": "127.0.0.1",
                      "mqueue_max": "infinity",
                      "clean_start": true,
                      "inflight_cnt": 0,
                      "send_pkt": 1,
                      "mqueue_len": 0,
                      "connected": true,
                      "reductions": 72022,
                      "expiry_interval": 0,
                      "recv_cnt": 1
                    },
                    "summary": "General client info"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api_clients.exproto_client"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api_clients.lwm2m_client"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api_clients.coap_client"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api_clients.mqttsn_client"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api_clients.stomp_client"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Kick out the gateway client",
        "tags": [
          "Gateway Clients"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "description": "Client ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "lwm2m",
                "mqttsn",
                "stomp"
              ]
            }
          }
        ],
        "summary": "Kick out client",
        "responses": {
          "204": {
            "description": "Kicked"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/publish/bulk": {
      "post": {
        "description": "Possible HTTP response status code are:<br/><br/>200: All messages are delivered to at least one subscriber;<br/><br/>202: At least one message was not delivered to any subscriber;<br/><br/>400: At least one message is invalid. For example bad topic name, or QoS is out of range;<br/><br/>503: Failed to deliver at least one of the messages;<br/><br/><br/>In case there is at lest one invalid message in the batch, the HTTP response body<br/>is the same as for <code>/publish</code> API.<br/><br/>Otherwise the HTTP response body is an array of JSON objects indicating the publish<br/>result of each individual message in the batch.",
        "tags": [
          "Publish"
        ],
        "parameters": [],
        "summary": "Publish a batch of messages",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/emqx_mgmt_api_publish.publish_ok"
                  }
                }
              }
            }
          },
          "202": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/emqx_mgmt_api_publish.publish_error"
                  }
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/emqx_mgmt_api_publish.publish_error"
                      }
                    },
                    {
                      "$ref": "#/components/schemas/emqx_mgmt_api_publish.bad_request"
                    }
                  ]
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/emqx_mgmt_api_publish.publish_error"
                  }
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_publish.publish_message"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/nodes/{node}/bridges/{id}/{operation}": {
      "post": {
        "description": "Stop/Restart bridges on a specific node.",
        "tags": [
          "Bridges"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "node",
            "description": "The node name, e.g. emqx@127.0.0.1",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "emqx@127.0.0.1"
          },
          {
            "in": "path",
            "name": "id",
            "description": "The bridge Id. Must be of format {type}:{name}",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:http_example"
          },
          {
            "in": "path",
            "name": "operation",
            "description": "Operations can be one of: stop, restart",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "start",
                "stop",
                "restart"
              ]
            },
            "example": "start"
          }
        ],
        "summary": "Stop/restart bridge",
        "responses": {
          "204": {
            "description": "Operation success"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Problem with configuration of external service or bridge not enabled"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bridge or node not found or invalid operation"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "501": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_IMPLEMENTED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Implemented"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Service unavailable"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/rule_test": {
      "post": {
        "description": "Test a rule",
        "tags": [
          "Rules"
        ],
        "parameters": [],
        "summary": "Test a rule",
        "responses": {
          "200": {
            "description": "Rule Test Pass"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Invalid Parameters"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "412": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_MATCH"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "SQL Not Match"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/rule_engine.rule_test"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/authorization/sources/built_in_database/rules/clients/{clientid}": {
      "get": {
        "description": "Get rule for 'clientid'",
        "tags": [
          "Authorization"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_authz_api_mnesia.clientid"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "password_based:built_in_database": {
                    "value": {
                      "rules": [
                        {
                          "action": "publish",
                          "topic": "test/topic/1",
                          "permission": "allow"
                        },
                        {
                          "action": "subscribe",
                          "topic": "test/topic/2",
                          "permission": "allow"
                        },
                        {
                          "action": "all",
                          "topic": "eq test/#",
                          "permission": "deny"
                        },
                        {
                          "action": "publish",
                          "retain": "true",
                          "topic": "test/topic/3",
                          "qos": [
                            "1"
                          ],
                          "permission": "allow"
                        },
                        {
                          "action": "publish",
                          "retain": "all",
                          "topic": "test/topic/4",
                          "qos": [
                            "0",
                            "1",
                            "2"
                          ],
                          "permission": "allow"
                        }
                      ],
                      "clientid": "client1"
                    },
                    "summary": "ClientID"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authz_api_mnesia.rules_for_clientid"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Set rule for 'clientid'",
        "tags": [
          "Authorization"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_authz_api_mnesia.clientid"
          }
        ],
        "responses": {
          "204": {
            "description": "Updated"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad clientid or bad rule schema"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "password_based:built_in_database": {
                  "value": {
                    "rules": [
                      {
                        "action": "publish",
                        "topic": "test/topic/1",
                        "permission": "allow"
                      },
                      {
                        "action": "subscribe",
                        "topic": "test/topic/2",
                        "permission": "allow"
                      },
                      {
                        "action": "all",
                        "topic": "eq test/#",
                        "permission": "deny"
                      },
                      {
                        "action": "publish",
                        "retain": "true",
                        "topic": "test/topic/3",
                        "qos": [
                          "1"
                        ],
                        "permission": "allow"
                      },
                      {
                        "action": "publish",
                        "retain": "all",
                        "topic": "test/topic/4",
                        "qos": [
                          "0",
                          "1",
                          "2"
                        ],
                        "permission": "allow"
                      }
                    ],
                    "clientid": "client1"
                  },
                  "summary": "ClientID"
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authz_api_mnesia.rules_for_clientid"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete rule for 'clientid'",
        "tags": [
          "Authorization"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_authz_api_mnesia.clientid"
          }
        ],
        "responses": {
          "204": {
            "description": "Deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad clientid"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "ClientID Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/configs/sysmon": {
      "get": {
        "description": "Get the sub-configurations under *sysmon*",
        "tags": [
          "Configs"
        ],
        "parameters": [],
        "summary": "Get the sub-configurations under *sysmon*",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx.sysmon"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "config not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update the sub-configurations under *sysmon*",
        "tags": [
          "Configs"
        ],
        "parameters": [],
        "summary": "Update the sub-configurations under *sysmon*",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx.sysmon"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UPDATE_FAILED",
                        "INVALID_CONFIG"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "403": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UPDATE_FAILED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx.sysmon"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/connectors/{id}": {
      "get": {
        "description": "Get a connector by id.",
        "tags": [
          "Connectors"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The connector id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_connector"
          }
        ],
        "summary": "Get connector",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "http": {
                    "value": {
                      "name": "my_http_connector",
                      "status": "connected",
                      "type": "http",
                      "connect_timeout": "15s",
                      "pool_size": 1,
                      "enable": true,
                      "headers": {
                        "content-type": "application/json"
                      },
                      "url": "http://localhost:8080/api/v1",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "pool_type": "hash",
                      "enable_pipelining": 100
                    },
                    "summary": "HTTP Connector"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/connector_mqtt.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_http.get_connector"
                    }
                  ]
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Connector not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update a connector by id.",
        "tags": [
          "Connectors"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The connector id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_connector"
          }
        ],
        "summary": "Update connector",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "http": {
                    "value": {
                      "name": "my_http_connector",
                      "status": "connected",
                      "type": "http",
                      "connect_timeout": "15s",
                      "pool_size": 1,
                      "enable": true,
                      "headers": {
                        "content-type": "application/json"
                      },
                      "url": "http://localhost:8080/api/v1",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "pool_type": "hash",
                      "enable_pipelining": 100
                    },
                    "summary": "HTTP Connector"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/connector_mqtt.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_http.get_connector"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Update connector failed"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Connector not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "http": {
                  "value": {
                    "connect_timeout": "15s",
                    "pool_size": 1,
                    "enable": true,
                    "headers": {
                      "content-type": "application/json"
                    },
                    "url": "http://localhost:8080/api/v1",
                    "pool_type": "hash",
                    "enable_pipelining": 100
                  },
                  "summary": "HTTP Connector"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/connector_mqtt.put_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_http.put_connector"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete a connector by id.",
        "tags": [
          "Connectors"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The connector id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_connector"
          }
        ],
        "summary": "Delete connector",
        "responses": {
          "204": {
            "description": "Connector deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Cannot delete connector while active rules are defined for this connector"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Connector not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Service unavailable"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/clients/{clientid}/authorization/cache": {
      "get": {
        "description": "Get client authz cache in the cluster.",
        "tags": [
          "Clients"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_clients.authz_cache"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "CLIENTID_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Client ID not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Clean client authz cache in the cluster.",
        "tags": [
          "Clients"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Clean client authz cache successfully"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "CLIENTID_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Client ID not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/data/import": {
      "post": {
        "description": "Import a data backup file",
        "tags": [
          "Data Backup"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Backup file import failed"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "example": {
                "node": "emqx@127.0.0.1",
                "filename": "emqx-export-2023-11-23-19-13-19.043.tar.gz"
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_mgmt_api_data_backup.import_request_body"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/cluster/{node}/force_leave": {
      "delete": {
        "description": "Force leave node from cluster",
        "tags": [
          "Cluster"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/cluster.node"
          }
        ],
        "responses": {
          "204": {
            "description": "Delete successfully"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/{name}/listeners/{id}": {
      "get": {
        "description": "Get the gateway listener configs",
        "tags": [
          "Gateway Listeners"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "lwm2m",
                "mqttsn",
                "stomp"
              ]
            },
            "example": "stomp"
          },
          {
            "in": "path",
            "name": "id",
            "description": "Listener ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": ""
          }
        ],
        "summary": "Get listener config",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "udp_listener": {
                    "value": {
                      "name": "udp-def",
                      "type": "udp",
                      "bind": "22212",
                      "udp_options": {
                        "buffer": "10KB",
                        "recbuf": "10KB",
                        "reuseaddr": true,
                        "sndbuf": "10KB",
                        "active_n": 100
                      }
                    },
                    "summary": "A simple UDP listener example"
                  },
                  "dtls_listener": {
                    "value": {
                      "name": "dtls-def",
                      "type": "dtls",
                      "bind": "22213",
                      "udp_options": {
                        "backlog": 1024,
                        "active_n": 100
                      },
                      "acceptors": 16,
                      "dtls_options": {
                        "verify": "verify_none",
                        "versions": [
                          "dtlsv1.2",
                          "dtlsv1"
                        ],
                        "fail_if_no_peer_cert": false,
                        "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                        "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                        "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem"
                      },
                      "max_connections": 1024000,
                      "access_rules": [
                        "allow all"
                      ],
                      "max_conn_rate": 1000
                    },
                    "summary": "A simple DTLS listener example"
                  },
                  "ssl_listener": {
                    "value": {
                      "name": "ssl-def",
                      "type": "ssl",
                      "bind": "22211",
                      "tcp_options": {
                        "backlog": 1024,
                        "active_n": 100
                      },
                      "ssl_options": {
                        "verify": "verify_none",
                        "versions": [
                          "tlsv1.3",
                          "tlsv1.2",
                          "tlsv1.1",
                          "tlsv1"
                        ],
                        "fail_if_no_peer_cert": false,
                        "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                        "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                        "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem"
                      },
                      "acceptors": 16,
                      "max_connections": 1024000,
                      "access_rules": [
                        "allow all"
                      ],
                      "max_conn_rate": 1000
                    },
                    "summary": "A simple SSL listener example"
                  },
                  "tcp_listener": {
                    "value": {
                      "name": "tcp-def",
                      "type": "tcp",
                      "bind": "22210",
                      "tcp_options": {
                        "buffer": "10KB",
                        "high_watermark": "1MB",
                        "keepalive": "none",
                        "nodelay": false,
                        "recbuf": "10KB",
                        "reuseaddr": true,
                        "send_timeout": "15s",
                        "send_timeout_close": true,
                        "sndbuf": "10KB",
                        "backlog": 1024,
                        "active_n": 100
                      },
                      "acceptors": 16,
                      "max_connections": 1024000,
                      "max_conn_rate": 1000
                    },
                    "summary": "A simple TCP listener example"
                  },
                  "ws_listener": {
                    "value": {
                      "name": "ws-def",
                      "type": "ws",
                      "bind": "33043",
                      "tcp_options": {
                        "buffer": "10KB",
                        "high_watermark": "1MB",
                        "keepalive": "none",
                        "nodelay": false,
                        "recbuf": "10KB",
                        "reuseaddr": true,
                        "send_timeout": "15s",
                        "send_timeout_close": true,
                        "sndbuf": "10KB",
                        "backlog": 1024,
                        "active_n": 100
                      },
                      "websocket": {
                        "path": "/ocpp",
                        "compress": false,
                        "fail_if_no_subprotocol": true,
                        "supported_subprotocols": "ocpp1.6",
                        "check_origins": "http://localhost:18083, http://127.0.0.1:18083",
                        "check_origin_enable": false,
                        "piggyback": "single"
                      },
                      "acceptors": 16,
                      "max_connections": 1024000,
                      "max_conn_rate": 1000
                    },
                    "summary": "A simple WebSocket listener example"
                  },
                  "wss_listener": {
                    "value": {
                      "name": "ws-ssl-def",
                      "type": "wss",
                      "bind": "33053",
                      "tcp_options": {
                        "buffer": "10KB",
                        "high_watermark": "1MB",
                        "keepalive": "none",
                        "nodelay": false,
                        "recbuf": "10KB",
                        "reuseaddr": true,
                        "send_timeout": "15s",
                        "send_timeout_close": true,
                        "sndbuf": "10KB",
                        "backlog": 1024,
                        "active_n": 100
                      },
                      "ssl_options": {
                        "verify": "verify_none",
                        "versions": [
                          "tlsv1.3",
                          "tlsv1.2",
                          "tlsv1.1",
                          "tlsv1"
                        ],
                        "fail_if_no_peer_cert": false,
                        "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                        "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                        "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem"
                      },
                      "websocket": {
                        "path": "/ocpp",
                        "compress": false,
                        "fail_if_no_subprotocol": true,
                        "supported_subprotocols": "ocpp1.6",
                        "check_origins": "http://localhost:18083, http://127.0.0.1:18083",
                        "check_origin_enable": false,
                        "piggyback": "single"
                      },
                      "acceptors": 16,
                      "max_connections": 1024000,
                      "max_conn_rate": 1000
                    },
                    "summary": "A simple WebSocket/TLS listener example"
                  },
                  "dtls_listener_with_psk_ciphers": {
                    "value": {
                      "name": "dtls-psk",
                      "type": "dtls",
                      "bind": "22214",
                      "acceptors": 16,
                      "dtls_options": {
                        "verify": "verify_none",
                        "ciphers": "RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA",
                        "versions": [
                          "dtlsv1.2",
                          "dtlsv1"
                        ],
                        "fail_if_no_peer_cert": false,
                        "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                        "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                        "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem",
                        "user_lookup_fun": "emqx_tls_psk:lookup"
                      },
                      "max_connections": 1024000,
                      "max_conn_rate": 1000
                    },
                    "summary": "A DTLS listener with PSK example"
                  },
                  "lisetner_with_authn": {
                    "value": {
                      "name": "tcp-with-authn",
                      "type": "tcp",
                      "bind": "22215",
                      "authentication": {
                        "mechanism": "password_based",
                        "backend": "built_in_database",
                        "password_hash_algorithm": {
                          "name": "sha256"
                        },
                        "user_id_type": "username"
                      },
                      "acceptors": 16,
                      "max_connections": 1024000,
                      "max_conn_rate": 1000
                    },
                    "summary": "A TCP listener with authentication example"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.wss_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.ws_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.dtls_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.udp_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.ssl_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.tcp_listener"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update the gateway listener. The listener being updated performs a restart and all clients connected to that listener will be disconnected.",
        "tags": [
          "Gateway Listeners"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "lwm2m",
                "mqttsn",
                "stomp"
              ]
            },
            "example": "stomp"
          },
          {
            "in": "path",
            "name": "id",
            "description": "Listener ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": ""
          }
        ],
        "summary": "Update listener config",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "udp_listener": {
                    "value": {
                      "name": "udp-def",
                      "type": "udp",
                      "bind": "22212",
                      "udp_options": {
                        "buffer": "10KB",
                        "recbuf": "10KB",
                        "reuseaddr": true,
                        "sndbuf": "10KB",
                        "active_n": 100
                      }
                    },
                    "summary": "A simple UDP listener example"
                  },
                  "dtls_listener": {
                    "value": {
                      "name": "dtls-def",
                      "type": "dtls",
                      "bind": "22213",
                      "udp_options": {
                        "backlog": 1024,
                        "active_n": 100
                      },
                      "acceptors": 16,
                      "dtls_options": {
                        "verify": "verify_none",
                        "versions": [
                          "dtlsv1.2",
                          "dtlsv1"
                        ],
                        "fail_if_no_peer_cert": false,
                        "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                        "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                        "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem"
                      },
                      "max_connections": 1024000,
                      "access_rules": [
                        "allow all"
                      ],
                      "max_conn_rate": 1000
                    },
                    "summary": "A simple DTLS listener example"
                  },
                  "ssl_listener": {
                    "value": {
                      "name": "ssl-def",
                      "type": "ssl",
                      "bind": "22211",
                      "tcp_options": {
                        "backlog": 1024,
                        "active_n": 100
                      },
                      "ssl_options": {
                        "verify": "verify_none",
                        "versions": [
                          "tlsv1.3",
                          "tlsv1.2",
                          "tlsv1.1",
                          "tlsv1"
                        ],
                        "fail_if_no_peer_cert": false,
                        "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                        "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                        "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem"
                      },
                      "acceptors": 16,
                      "max_connections": 1024000,
                      "access_rules": [
                        "allow all"
                      ],
                      "max_conn_rate": 1000
                    },
                    "summary": "A simple SSL listener example"
                  },
                  "tcp_listener": {
                    "value": {
                      "name": "tcp-def",
                      "type": "tcp",
                      "bind": "22210",
                      "tcp_options": {
                        "buffer": "10KB",
                        "high_watermark": "1MB",
                        "keepalive": "none",
                        "nodelay": false,
                        "recbuf": "10KB",
                        "reuseaddr": true,
                        "send_timeout": "15s",
                        "send_timeout_close": true,
                        "sndbuf": "10KB",
                        "backlog": 1024,
                        "active_n": 100
                      },
                      "acceptors": 16,
                      "max_connections": 1024000,
                      "max_conn_rate": 1000
                    },
                    "summary": "A simple TCP listener example"
                  },
                  "ws_listener": {
                    "value": {
                      "name": "ws-def",
                      "type": "ws",
                      "bind": "33043",
                      "tcp_options": {
                        "buffer": "10KB",
                        "high_watermark": "1MB",
                        "keepalive": "none",
                        "nodelay": false,
                        "recbuf": "10KB",
                        "reuseaddr": true,
                        "send_timeout": "15s",
                        "send_timeout_close": true,
                        "sndbuf": "10KB",
                        "backlog": 1024,
                        "active_n": 100
                      },
                      "websocket": {
                        "path": "/ocpp",
                        "compress": false,
                        "fail_if_no_subprotocol": true,
                        "supported_subprotocols": "ocpp1.6",
                        "check_origins": "http://localhost:18083, http://127.0.0.1:18083",
                        "check_origin_enable": false,
                        "piggyback": "single"
                      },
                      "acceptors": 16,
                      "max_connections": 1024000,
                      "max_conn_rate": 1000
                    },
                    "summary": "A simple WebSocket listener example"
                  },
                  "wss_listener": {
                    "value": {
                      "name": "ws-ssl-def",
                      "type": "wss",
                      "bind": "33053",
                      "tcp_options": {
                        "buffer": "10KB",
                        "high_watermark": "1MB",
                        "keepalive": "none",
                        "nodelay": false,
                        "recbuf": "10KB",
                        "reuseaddr": true,
                        "send_timeout": "15s",
                        "send_timeout_close": true,
                        "sndbuf": "10KB",
                        "backlog": 1024,
                        "active_n": 100
                      },
                      "ssl_options": {
                        "verify": "verify_none",
                        "versions": [
                          "tlsv1.3",
                          "tlsv1.2",
                          "tlsv1.1",
                          "tlsv1"
                        ],
                        "fail_if_no_peer_cert": false,
                        "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                        "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                        "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem"
                      },
                      "websocket": {
                        "path": "/ocpp",
                        "compress": false,
                        "fail_if_no_subprotocol": true,
                        "supported_subprotocols": "ocpp1.6",
                        "check_origins": "http://localhost:18083, http://127.0.0.1:18083",
                        "check_origin_enable": false,
                        "piggyback": "single"
                      },
                      "acceptors": 16,
                      "max_connections": 1024000,
                      "max_conn_rate": 1000
                    },
                    "summary": "A simple WebSocket/TLS listener example"
                  },
                  "dtls_listener_with_psk_ciphers": {
                    "value": {
                      "name": "dtls-psk",
                      "type": "dtls",
                      "bind": "22214",
                      "acceptors": 16,
                      "dtls_options": {
                        "verify": "verify_none",
                        "ciphers": "RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA",
                        "versions": [
                          "dtlsv1.2",
                          "dtlsv1"
                        ],
                        "fail_if_no_peer_cert": false,
                        "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                        "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                        "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem",
                        "user_lookup_fun": "emqx_tls_psk:lookup"
                      },
                      "max_connections": 1024000,
                      "max_conn_rate": 1000
                    },
                    "summary": "A DTLS listener with PSK example"
                  },
                  "lisetner_with_authn": {
                    "value": {
                      "name": "tcp-with-authn",
                      "type": "tcp",
                      "bind": "22215",
                      "authentication": {
                        "mechanism": "password_based",
                        "backend": "built_in_database",
                        "password_hash_algorithm": {
                          "name": "sha256"
                        },
                        "user_id_type": "username"
                      },
                      "acceptors": 16,
                      "max_connections": 1024000,
                      "max_conn_rate": 1000
                    },
                    "summary": "A TCP listener with authentication example"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.wss_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.ws_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.dtls_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.udp_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.ssl_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.tcp_listener"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "udp_listener": {
                  "value": {
                    "name": "udp-def",
                    "type": "udp",
                    "bind": "22212",
                    "udp_options": {
                      "buffer": "10KB",
                      "recbuf": "10KB",
                      "reuseaddr": true,
                      "sndbuf": "10KB",
                      "active_n": 100
                    }
                  },
                  "summary": "A simple UDP listener example"
                },
                "dtls_listener": {
                  "value": {
                    "name": "dtls-def",
                    "type": "dtls",
                    "bind": "22213",
                    "udp_options": {
                      "backlog": 1024,
                      "active_n": 100
                    },
                    "acceptors": 16,
                    "dtls_options": {
                      "verify": "verify_none",
                      "versions": [
                        "dtlsv1.2",
                        "dtlsv1"
                      ],
                      "fail_if_no_peer_cert": false,
                      "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                      "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                      "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem"
                    },
                    "max_connections": 1024000,
                    "access_rules": [
                      "allow all"
                    ],
                    "max_conn_rate": 1000
                  },
                  "summary": "A simple DTLS listener example"
                },
                "ssl_listener": {
                  "value": {
                    "name": "ssl-def",
                    "type": "ssl",
                    "bind": "22211",
                    "tcp_options": {
                      "backlog": 1024,
                      "active_n": 100
                    },
                    "ssl_options": {
                      "verify": "verify_none",
                      "versions": [
                        "tlsv1.3",
                        "tlsv1.2",
                        "tlsv1.1",
                        "tlsv1"
                      ],
                      "fail_if_no_peer_cert": false,
                      "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                      "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                      "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem"
                    },
                    "acceptors": 16,
                    "max_connections": 1024000,
                    "access_rules": [
                      "allow all"
                    ],
                    "max_conn_rate": 1000
                  },
                  "summary": "A simple SSL listener example"
                },
                "tcp_listener": {
                  "value": {
                    "name": "tcp-def",
                    "type": "tcp",
                    "bind": "22210",
                    "tcp_options": {
                      "buffer": "10KB",
                      "high_watermark": "1MB",
                      "keepalive": "none",
                      "nodelay": false,
                      "recbuf": "10KB",
                      "reuseaddr": true,
                      "send_timeout": "15s",
                      "send_timeout_close": true,
                      "sndbuf": "10KB",
                      "backlog": 1024,
                      "active_n": 100
                    },
                    "acceptors": 16,
                    "max_connections": 1024000,
                    "max_conn_rate": 1000
                  },
                  "summary": "A simple TCP listener example"
                },
                "ws_listener": {
                  "value": {
                    "name": "ws-def",
                    "type": "ws",
                    "bind": "33043",
                    "tcp_options": {
                      "buffer": "10KB",
                      "high_watermark": "1MB",
                      "keepalive": "none",
                      "nodelay": false,
                      "recbuf": "10KB",
                      "reuseaddr": true,
                      "send_timeout": "15s",
                      "send_timeout_close": true,
                      "sndbuf": "10KB",
                      "backlog": 1024,
                      "active_n": 100
                    },
                    "websocket": {
                      "path": "/ocpp",
                      "compress": false,
                      "fail_if_no_subprotocol": true,
                      "supported_subprotocols": "ocpp1.6",
                      "check_origins": "http://localhost:18083, http://127.0.0.1:18083",
                      "check_origin_enable": false,
                      "piggyback": "single"
                    },
                    "acceptors": 16,
                    "max_connections": 1024000,
                    "max_conn_rate": 1000
                  },
                  "summary": "A simple WebSocket listener example"
                },
                "wss_listener": {
                  "value": {
                    "name": "ws-ssl-def",
                    "type": "wss",
                    "bind": "33053",
                    "tcp_options": {
                      "buffer": "10KB",
                      "high_watermark": "1MB",
                      "keepalive": "none",
                      "nodelay": false,
                      "recbuf": "10KB",
                      "reuseaddr": true,
                      "send_timeout": "15s",
                      "send_timeout_close": true,
                      "sndbuf": "10KB",
                      "backlog": 1024,
                      "active_n": 100
                    },
                    "ssl_options": {
                      "verify": "verify_none",
                      "versions": [
                        "tlsv1.3",
                        "tlsv1.2",
                        "tlsv1.1",
                        "tlsv1"
                      ],
                      "fail_if_no_peer_cert": false,
                      "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                      "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                      "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem"
                    },
                    "websocket": {
                      "path": "/ocpp",
                      "compress": false,
                      "fail_if_no_subprotocol": true,
                      "supported_subprotocols": "ocpp1.6",
                      "check_origins": "http://localhost:18083, http://127.0.0.1:18083",
                      "check_origin_enable": false,
                      "piggyback": "single"
                    },
                    "acceptors": 16,
                    "max_connections": 1024000,
                    "max_conn_rate": 1000
                  },
                  "summary": "A simple WebSocket/TLS listener example"
                },
                "dtls_listener_with_psk_ciphers": {
                  "value": {
                    "name": "dtls-psk",
                    "type": "dtls",
                    "bind": "22214",
                    "acceptors": 16,
                    "dtls_options": {
                      "verify": "verify_none",
                      "ciphers": "RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA",
                      "versions": [
                        "dtlsv1.2",
                        "dtlsv1"
                      ],
                      "fail_if_no_peer_cert": false,
                      "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                      "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                      "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem",
                      "user_lookup_fun": "emqx_tls_psk:lookup"
                    },
                    "max_connections": 1024000,
                    "max_conn_rate": 1000
                  },
                  "summary": "A DTLS listener with PSK example"
                },
                "lisetner_with_authn": {
                  "value": {
                    "name": "tcp-with-authn",
                    "type": "tcp",
                    "bind": "22215",
                    "authentication": {
                      "mechanism": "password_based",
                      "backend": "built_in_database",
                      "password_hash_algorithm": {
                        "name": "sha256"
                      },
                      "user_id_type": "username"
                    },
                    "acceptors": 16,
                    "max_connections": 1024000,
                    "max_conn_rate": 1000
                  },
                  "summary": "A TCP listener with authentication example"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.wss_listener"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.ws_listener"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.dtls_listener"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.udp_listener"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.ssl_listener"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.tcp_listener"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete the gateway listener. All connected clients under the deleted listener will be disconnected.",
        "tags": [
          "Gateway Listeners"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "lwm2m",
                "mqttsn",
                "stomp"
              ]
            },
            "example": "stomp"
          },
          {
            "in": "path",
            "name": "id",
            "description": "Listener ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": ""
          }
        ],
        "summary": "Delete listener",
        "responses": {
          "204": {
            "description": "Deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/relup/upgrade/{node}": {
      "post": {
        "description": "Upgrade a specified node to the target version with the installed package.",
        "tags": [
          "Relup"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/relup.node_name"
          }
        ],
        "summary": "Upgrade a specified node",
        "responses": {
          "204": {
            "description": "Upgrade is started successfully"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UNEXPECTED_ERROR"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Upgrade failed because of invalid input or environment"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Node not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "500": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "INTERNAL_ERROR"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Upgrade failed because of internal errors"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/sources/{id}/metrics/reset": {
      "put": {
        "description": "Reset a bridge metrics by id.",
        "tags": [
          "Sources"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_action"
          }
        ],
        "summary": "Reset source metrics",
        "responses": {
          "204": {
            "description": "Reset success"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Source not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/rules/{id}/test": {
      "post": {
        "description": "Apply a rule with the given message and environment",
        "tags": [
          "Rules"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "my_rule_id"
          }
        ],
        "summary": "Apply a rule for testing",
        "responses": {
          "200": {
            "description": "Rule Applied"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Invalid Parameters"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "RULE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "The rule could not be found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "412": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_MATCH"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "SQL Not Match"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/rule_engine.rule_apply_test"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/relup/upgrade": {
      "post": {
        "description": "Upgrade all nodes to the target version with the installed package.",
        "tags": [
          "Relup"
        ],
        "parameters": [],
        "summary": "Upgrade all nodes",
        "responses": {
          "204": {
            "description": "Upgrade is started successfully"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UNEXPECTED_ERROR"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Upgrade failed because of invalid input or environment"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "500": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "INTERNAL_ERROR"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Upgrade failed because of internal errors"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/{name}/enable/{enable}": {
      "put": {
        "description": "Update the gateway basic configurations and running status.<br/><br/>Note: The Authentication and Listener configurations should be updated by other special APIs.",
        "tags": [
          "Gateways"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "lwm2m",
                "mqttsn",
                "stomp"
              ]
            },
            "example": "stomp"
          },
          {
            "in": "path",
            "name": "enable",
            "description": "Whether to enable this gateway",
            "required": true,
            "schema": {
              "type": "boolean"
            },
            "example": true
          }
        ],
        "summary": "Enable or disable gateway",
        "responses": {
          "204": {
            "description": "Gateway configuration updated"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/relup/package/upload": {
      "post": {
        "description": "Upload a hot upgrade package (emqx_relup-vsn.tar.gz).<br/>Note that only one package is alllowed to be installed at a time.",
        "tags": [
          "Relup"
        ],
        "parameters": [],
        "summary": "Upload a hot upgrade package",
        "responses": {
          "204": {
            "description": "Package is uploaded successfully"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UNEXPECTED_ERROR",
                        "ALREADY_INSTALLED",
                        "BAD_PLUGIN_INFO"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "multipart/form-data": {
              "encoding": {
                "plugin": {
                  "contentType": "application/gzip"
                }
              },
              "schema": {
                "type": "object",
                "properties": {
                  "plugin": {
                    "type": "string",
                    "format": "binary"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/rules": {
      "get": {
        "description": "List all rules",
        "tags": [
          "Rules"
        ],
        "parameters": [
          {
            "in": "query",
            "name": "enable",
            "description": "Filter enable/disable rules",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "in": "query",
            "name": "from",
            "description": "Filter rules by from(topic), exact match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "like_id",
            "description": "Filter rules by id, Substring matching",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "like_from",
            "description": "Filter rules by from(topic), Substring matching",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "like_description",
            "description": "Filter rules by description, Substring matching",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "match_from",
            "description": "Filter rules by from(topic), Mqtt topic matching",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "action",
            "description": "Filters rules that contain any of the given action id(s).  When used in conjunction with source id filtering, the rules must contain sources *and* actions that match some of the criteria.",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "in": "query",
            "name": "source",
            "description": "Filters rules that contain any of the given source id(s).  When used in conjunction with action id filtering, the rules must contain sources *and* actions that match some of the criteria.",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          }
        ],
        "summary": "List rules",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "data": {
                      "type": "array",
                      "description": "List of rules",
                      "items": {
                        "$ref": "#/components/schemas/rule_engine.rule_info"
                      }
                    },
                    "meta": {
                      "$ref": "#/components/schemas/public.meta"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Invalid Parameters"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Create a new rule using given Id",
        "tags": [
          "Rules"
        ],
        "parameters": [],
        "summary": "Create a rule",
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/rule_engine.rule_info"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Invalid Parameters"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/rule_engine.rule_creation"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/authentication/{id}/status": {
      "get": {
        "description": "Get authenticator status from global authentication chain.",
        "tags": [
          "Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Authenticator ID.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "status_metrics": {
                    "value": {
                      "status": "connected",
                      "node_status": [
                        {
                          "node": "emqx@127.0.0.1",
                          "status": "connected"
                        }
                      ],
                      "metrics": {
                        "nomatch": 0,
                        "total": 0,
                        "success": 0,
                        "failed": 0,
                        "rate": 0,
                        "rate_last5m": 0,
                        "rate_max": 0
                      },
                      "resource_metrics": {
                        "matched": 0,
                        "success": 0,
                        "failed": 0,
                        "rate": 0,
                        "rate_last5m": 0,
                        "rate_max": 0
                      },
                      "node_error": [],
                      "node_metrics": [
                        {
                          "node": "emqx@127.0.0.1",
                          "metrics": {
                            "nomatch": 0,
                            "total": 0,
                            "matched": 0,
                            "failed": 0,
                            "rate": 0,
                            "rate_last5m": 0,
                            "rate_max": 0
                          }
                        }
                      ],
                      "node_resource_metrics": [
                        {
                          "node": "emqx@127.0.0.1",
                          "metrics": {
                            "matched": 0,
                            "success": 0,
                            "failed": 0,
                            "rate": 0,
                            "rate_last5m": 0,
                            "rate_max": 0
                          }
                        }
                      ]
                    },
                    "summary": "Authn status metrics"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/authn.metrics_status_fields"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "500": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "INTERNAL_ERROR"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Internal Service Error"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/mqtt/topic_rewrite": {
      "get": {
        "description": "List all rewrite rules",
        "tags": [
          "MQTT"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "List all rewrite rules",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/modules.rewrite"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update all rewrite rules",
        "tags": [
          "MQTT"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Update all rewrite rules",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/modules.rewrite"
                  }
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "413": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "EXCEED_LIMIT"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Rules count exceed max limit"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/modules.rewrite"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways": {
      "get": {
        "description": "This API returns an overview info for the specified or all gateways.<br/>including current running status, number of connections, listener status, etc.",
        "tags": [
          "Gateways"
        ],
        "parameters": [
          {
            "in": "query",
            "name": "status",
            "description": "Filter gateways by status.<br/><br/>It is enum with `running`, `stopped`, `unloaded`",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "running",
                "stopped",
                "unloaded"
              ]
            },
            "example": "running"
          }
        ],
        "summary": "List all gateways",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": [
                  {
                    "name": "coap",
                    "status": "unloaded"
                  },
                  {
                    "name": "exproto",
                    "status": "unloaded"
                  },
                  {
                    "name": "lwm2m",
                    "status": "running",
                    "started_at": "2021-12-08T14:41:26.202+08:00",
                    "node_status": [
                      {
                        "node": "node@127.0.0.1",
                        "status": "running",
                        "max_connections": 1024000,
                        "current_connections": 0
                      }
                    ],
                    "max_connections": 1024000,
                    "listeners": [
                      {
                        "id": "lwm2m:udp:default",
                        "name": "default",
                        "running": true,
                        "type": "udp"
                      }
                    ],
                    "created_at": "2021-12-08T14:41:26.171+08:00",
                    "current_connections": 0
                  },
                  {
                    "name": "mqttsn",
                    "status": "stopped",
                    "node_status": [
                      {
                        "node": "node@127.0.0.1",
                        "status": "running",
                        "max_connections": 1024000,
                        "current_connections": 0
                      }
                    ],
                    "max_connections": 1024000,
                    "listeners": [
                      {
                        "id": "mqttsn:udp:default",
                        "name": "default",
                        "running": false,
                        "type": "udp"
                      }
                    ],
                    "created_at": "2021-12-08T14:41:45.071+08:00",
                    "current_connections": 0,
                    "stopped_at": "2021-12-08T14:56:35.576+08:00"
                  },
                  {
                    "name": "stomp",
                    "status": "running",
                    "started_at": "2021-12-08T14:42:15.274+08:00",
                    "node_status": [
                      {
                        "node": "node@127.0.0.1",
                        "status": "running",
                        "max_connections": 1024000,
                        "current_connections": 0
                      }
                    ],
                    "max_connections": 1024000,
                    "listeners": [
                      {
                        "id": "stomp:tcp:default",
                        "name": "default",
                        "running": true,
                        "type": "tcp"
                      }
                    ],
                    "created_at": "2021-12-08T14:42:15.272+08:00",
                    "current_connections": 0
                  }
                ],
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/emqx_gateway_api.gateway_overview"
                  }
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/mqtt/topic_metrics/{topic}": {
      "get": {
        "description": "Get topic metrics",
        "tags": [
          "MQTT"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "topic",
            "description": "Topic string. Notice: Topic string in url path must be encoded",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "testtopic/1"
          }
        ],
        "responses": {
          "200": {
            "description": "Topic",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_topic_metrics_api.topic_metrics"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "TOPIC_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found. Topic metrics not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete topic metrics",
        "tags": [
          "MQTT"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "topic",
            "description": "Topic string. Notice: Topic string in url path must be encoded",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "testtopic/1"
          }
        ],
        "responses": {
          "204": {
            "description": "Delete topic metrics"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "TOPIC_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found. Topic metrics not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/bridges_probe": {
      "post": {
        "description": "Test creating a new bridge by given ID <br/><br/>The ID must be of format '{type}:{name}'",
        "tags": [
          "Bridges"
        ],
        "parameters": [],
        "summary": "Test creating bridge",
        "responses": {
          "204": {
            "description": "Test bridge OK"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "TEST_FAILED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "bridge test failed"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "http_example": {
                  "value": {
                    "name": "http_example",
                    "type": "http",
                    "ssl": {
                      "enable": false
                    },
                    "connect_timeout": "15s",
                    "pool_size": 4,
                    "enable": true,
                    "body": "${payload}",
                    "method": "post",
                    "url": "http://localhost:9901/messages/${topic}",
                    "max_retries": 3,
                    "request_timeout": "15s",
                    "pool_type": "random",
                    "resource_opts": {
                      "worker_pool_size": 1,
                      "query_mode": "async",
                      "max_buffer_bytes": 104857600,
                      "inflight_window": 100,
                      "health_check_interval": 15000
                    },
                    "enable_pipelining": 100,
                    "local_topic": "emqx_http/#"
                  },
                  "summary": "HTTP"
                },
                "mqtt_example": {
                  "value": {
                    "name": "mqtt_example",
                    "type": "mqtt",
                    "keepalive": "300s",
                    "ssl": {
                      "enable": false
                    },
                    "server": "127.0.0.1:1883",
                    "enable": true,
                    "password": "******",
                    "username": "foo",
                    "proto_ver": "v4",
                    "clean_start": true,
                    "retry_interval": "15s",
                    "max_inflight": 100,
                    "resource_opts": {
                      "query_mode": "sync",
                      "max_buffer_bytes": 104857600,
                      "health_check_interval": "15s"
                    },
                    "ingress": {
                      "local": {
                        "retain": "${retain}",
                        "payload": "${payload}",
                        "topic": "from_aws/${topic}",
                        "qos": "${qos}"
                      },
                      "remote": {
                        "topic": "aws/#",
                        "qos": 1
                      }
                    },
                    "egress": {
                      "local": {
                        "topic": "emqx/#"
                      },
                      "remote": {
                        "retain": false,
                        "payload": "${payload}",
                        "topic": "from_emqx/${topic}",
                        "qos": "${qos}"
                      }
                    }
                  },
                  "summary": "MQTT Bridge"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/bridge_http.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mqtt.post"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/monitor/nodes/{node}": {
      "get": {
        "description": "List the monitor (statistics) data on the specified node.",
        "tags": [
          "Metrics"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "node",
            "description": "EMQX node name.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "emqx@127.0.0.1"
          },
          {
            "in": "query",
            "name": "latest",
            "description": "The latest N seconds data. Like 300 for 5 min.",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 1
            },
            "example": 300
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/emqx_dashboard_monitor_api.sampler"
                  }
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Node not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/prometheus/stats": {
      "get": {
        "description": "Get Prometheus Metrics",
        "tags": [
          "Monitor"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_prometheus_api.mode"
          }
        ],
        "responses": {
          "200": {
            "description": "Get Prometheus Data.",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          }
        },
        "security": []
      }
    },
    "/trace/{name}/log_detail": {
      "get": {
        "description": "get trace log file's metadata, such as size, last update time",
        "tags": [
          "Trace"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/trace.name"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/trace.log_file_detail"
                  }
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Trace Name Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/authentication/{id}": {
      "get": {
        "description": "Get authenticator from global authentication chain.",
        "tags": [
          "Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Authenticator ID.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "jwt": {
                    "value": {
                      "mechanism": "jwt",
                      "secret": "mysecret",
                      "algorithm": "hmac-based",
                      "secret_base64_encoded": false,
                      "use_jwks": false,
                      "verify_claims": {
                        "username": "${username}"
                      }
                    },
                    "summary": "JWT authentication"
                  },
                  "password_based:built_in_database": {
                    "value": {
                      "mechanism": "password_based",
                      "backend": "built_in_database",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "user_id_type": "username"
                    },
                    "summary": "Built-in password_based authentication"
                  },
                  "password_based:http": {
                    "value": {
                      "ssl": {
                        "enable": false
                      },
                      "connect_timeout": "5s",
                      "mechanism": "password_based",
                      "pool_size": 8,
                      "body": {
                        "password": "${password}",
                        "username": "${username}"
                      },
                      "headers": {
                        "content-type": "application/json"
                      },
                      "method": "post",
                      "url": "http://127.0.0.1:18083",
                      "backend": "http",
                      "request_timeout": "5s",
                      "enable_pipelining": 100
                    },
                    "summary": "password_based authentication through external HTTP API"
                  },
                  "password_based:mongodb": {
                    "value": {
                      "mechanism": "password_based",
                      "filter": {
                        "username": "${username}"
                      },
                      "server": "127.0.0.1:27017",
                      "database": "example",
                      "backend": "mongodb",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "collection": "users",
                      "is_superuser_field": "is_superuser",
                      "password_hash_field": "password_hash",
                      "salt_field": "salt"
                    },
                    "summary": "password_based authentication with MongoDB backend"
                  },
                  "password_based:redis": {
                    "value": {
                      "mechanism": "password_based",
                      "server": "127.0.0.1:6379",
                      "cmd": "HMGET ${username} password_hash salt",
                      "database": 0,
                      "backend": "redis",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "redis_type": "single"
                    },
                    "summary": "password_based authentication with Redis backend"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authn.ldap_deprecated"
                    },
                    {
                      "$ref": "#/components/schemas/authn.ldap"
                    },
                    {
                      "$ref": "#/components/schemas/authn.scram"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_jwks"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_public_key"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_hmac"
                    },
                    {
                      "$ref": "#/components/schemas/authn.http_post"
                    },
                    {
                      "$ref": "#/components/schemas/authn.http_get"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_single"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_sharded"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_rs"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_single"
                    },
                    {
                      "$ref": "#/components/schemas/authn.postgresql"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mysql"
                    },
                    {
                      "$ref": "#/components/schemas/authn.builtin_db"
                    }
                  ]
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update authenticator from global authentication chain.",
        "tags": [
          "Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Authenticator ID.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Authenticator updated"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "409": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "ALREADY_EXISTS"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "ALREADY_EXISTS"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "jwt": {
                  "value": {
                    "mechanism": "jwt",
                    "secret": "mysecret",
                    "algorithm": "hmac-based",
                    "secret_base64_encoded": false,
                    "use_jwks": false,
                    "verify_claims": {
                      "username": "${username}"
                    }
                  },
                  "summary": "JWT authentication"
                },
                "password_based:built_in_database": {
                  "value": {
                    "mechanism": "password_based",
                    "backend": "built_in_database",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "user_id_type": "username"
                  },
                  "summary": "Built-in password_based authentication"
                },
                "password_based:http": {
                  "value": {
                    "ssl": {
                      "enable": false
                    },
                    "connect_timeout": "5s",
                    "mechanism": "password_based",
                    "pool_size": 8,
                    "body": {
                      "password": "${password}",
                      "username": "${username}"
                    },
                    "headers": {
                      "content-type": "application/json"
                    },
                    "method": "post",
                    "url": "http://127.0.0.1:18083",
                    "backend": "http",
                    "request_timeout": "5s",
                    "enable_pipelining": 100
                  },
                  "summary": "password_based authentication through external HTTP API"
                },
                "password_based:mongodb": {
                  "value": {
                    "mechanism": "password_based",
                    "filter": {
                      "username": "${username}"
                    },
                    "server": "127.0.0.1:27017",
                    "database": "example",
                    "backend": "mongodb",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "collection": "users",
                    "is_superuser_field": "is_superuser",
                    "password_hash_field": "password_hash",
                    "salt_field": "salt"
                  },
                  "summary": "password_based authentication with MongoDB backend"
                },
                "password_based:redis": {
                  "value": {
                    "mechanism": "password_based",
                    "server": "127.0.0.1:6379",
                    "cmd": "HMGET ${username} password_hash salt",
                    "database": 0,
                    "backend": "redis",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "redis_type": "single"
                  },
                  "summary": "password_based authentication with Redis backend"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/authn.ldap_deprecated"
                  },
                  {
                    "$ref": "#/components/schemas/authn.ldap"
                  },
                  {
                    "$ref": "#/components/schemas/authn.scram"
                  },
                  {
                    "$ref": "#/components/schemas/authn.jwt_jwks"
                  },
                  {
                    "$ref": "#/components/schemas/authn.jwt_public_key"
                  },
                  {
                    "$ref": "#/components/schemas/authn.jwt_hmac"
                  },
                  {
                    "$ref": "#/components/schemas/authn.http_post"
                  },
                  {
                    "$ref": "#/components/schemas/authn.http_get"
                  },
                  {
                    "$ref": "#/components/schemas/authn.redis_sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/authn.redis_cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn.redis_single"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mongo_sharded"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mongo_rs"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mongo_single"
                  },
                  {
                    "$ref": "#/components/schemas/authn.postgresql"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mysql"
                  },
                  {
                    "$ref": "#/components/schemas/authn.builtin_db_api"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete authenticator from global authentication chain.",
        "tags": [
          "Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Authenticator ID.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Authenticator deleted"
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/publish": {
      "post": {
        "description": "Possible HTTP status response codes are:<br/><br/><code>200</code>: The message is delivered to at least one subscriber;<br/><br/><code>202</code>: No matched subscribers;<br/><br/><code>400</code>: Message is invalid. for example bad topic name, or QoS is out of range;<br/><br/><code>503</code>: Failed to deliver the message to subscriber(s)",
        "tags": [
          "Publish"
        ],
        "parameters": [],
        "summary": "Publish a message",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_publish.publish_ok"
                }
              }
            }
          },
          "202": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_publish.publish_error"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_publish.bad_request"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_publish.publish_error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx_mgmt_api_publish.publish_message"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/nodes/{node}/metrics": {
      "get": {
        "description": "Get node run-time counter metrics. Such as received or sent bytes or messages, the number of succeeded or failed authentications or authorizations, etc.",
        "tags": [
          "Nodes"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_mgmt_api_nodes.node_name"
          }
        ],
        "responses": {
          "200": {
            "description": "Get node metrics successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_metrics.node_metrics"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Node not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/configs/global_zone": {
      "get": {
        "description": "Get the MQTT-related configuration",
        "tags": [
          "Configs"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "mqtt": {
                      "$ref": "#/components/schemas/emqx.mqtt"
                    },
                    "flapping_detect": {
                      "$ref": "#/components/schemas/emqx.flapping_detect"
                    },
                    "force_shutdown": {
                      "$ref": "#/components/schemas/emqx.force_shutdown"
                    },
                    "force_gc": {
                      "$ref": "#/components/schemas/emqx.force_gc"
                    },
                    "durable_sessions": {
                      "$ref": "#/components/schemas/emqx.durable_sessions"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update MQTT-related configuration",
        "tags": [
          "Configs"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "mqtt": {
                      "$ref": "#/components/schemas/emqx.mqtt"
                    },
                    "flapping_detect": {
                      "$ref": "#/components/schemas/emqx.flapping_detect"
                    },
                    "force_shutdown": {
                      "$ref": "#/components/schemas/emqx.force_shutdown"
                    },
                    "force_gc": {
                      "$ref": "#/components/schemas/emqx.force_gc"
                    },
                    "durable_sessions": {
                      "$ref": "#/components/schemas/emqx.durable_sessions"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UPDATE_FAILED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "403": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UPDATE_FAILED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "mqtt": {
                    "$ref": "#/components/schemas/emqx.mqtt"
                  },
                  "flapping_detect": {
                    "$ref": "#/components/schemas/emqx.flapping_detect"
                  },
                  "force_shutdown": {
                    "$ref": "#/components/schemas/emqx.force_shutdown"
                  },
                  "force_gc": {
                    "$ref": "#/components/schemas/emqx.force_gc"
                  },
                  "durable_sessions": {
                    "$ref": "#/components/schemas/emqx.durable_sessions"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/sources/{id}/enable/{enable}": {
      "put": {
        "description": "Enable or Disable bridge on all nodes in the cluster.",
        "tags": [
          "Sources"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_action"
          },
          {
            "in": "path",
            "name": "enable",
            "description": "Whether to enable this bridge.",
            "required": true,
            "schema": {
              "type": "boolean"
            },
            "example": true
          }
        ],
        "summary": "Enable or disable bridge",
        "responses": {
          "204": {
            "description": "Success"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bridge not found or invalid operation"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Service unavailable"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/data/files": {
      "get": {
        "description": "List backup files",
        "tags": [
          "Data Backup"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "data": [
                    {
                      "node": "emqx@127.0.0.1",
                      "size": 22740,
                      "filename": "emqx-export-2023-09-02-11-11-33.012.tar.gz",
                      "created_at": "2023-09-02T11:11:33+02:00",
                      "created_at_sec": 1693645893
                    },
                    {
                      "node": "emqx@127.0.0.1",
                      "size": 22740,
                      "filename": "emqx-export-2023-11-23-19-13-19.043.tar.gz",
                      "created_at": "2023-11-23T19:13:19+02:00",
                      "created_at_sec": 1700759599
                    }
                  ],
                  "meta": {
                    "count": 300,
                    "limit": 20,
                    "page": 0
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_data_backup.files_response"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Upload a data backup file",
        "tags": [
          "Data Backup"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad backup file"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "multipart/form-data": {
              "schema": {
                "type": "object",
                "properties": {
                  "filename": {
                    "type": "string",
                    "format": "binary"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/bridges/{id}/enable/{enable}": {
      "put": {
        "description": "Enable or Disable bridges on all nodes in the cluster.",
        "tags": [
          "Bridges"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge Id. Must be of format {type}:{name}",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:http_example"
          },
          {
            "in": "path",
            "name": "enable",
            "description": "Whether to enable this bridge",
            "required": true,
            "schema": {
              "type": "boolean"
            },
            "example": true
          }
        ],
        "summary": "Enable or disable bridge",
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "bridge already exists as non Bridge V1 compatible action"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bridge not found or invalid operation"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Service unavailable"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/bridges/{id}/metrics": {
      "get": {
        "description": "Get bridge metrics by Id",
        "tags": [
          "Bridges"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge Id. Must be of format {type}:{name}",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:http_example"
          }
        ],
        "summary": "Get bridge metrics",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "metrics": {
                      "description": "Bridge metrics.",
                      "$ref": "#/components/schemas/bridge.metrics"
                    },
                    "node_metrics": {
                      "type": "array",
                      "description": "Node metrics.",
                      "items": {
                        "$ref": "#/components/schemas/bridge.node_metrics"
                      }
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bridge not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/users": {
      "get": {
        "description": "Dashboard list users",
        "tags": [
          "Dashboard"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Dashboard list users",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/dashboard.user"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Create dashboard user",
        "tags": [
          "Dashboard"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "username": {
                      "type": "string",
                      "description": "Dashboard Username",
                      "maxLength": 100,
                      "example": "admin"
                    },
                    "description": {
                      "type": "string",
                      "description": "Dashboard User Description",
                      "example": "administrator"
                    },
                    "backend": {
                      "type": "string",
                      "description": "User account source",
                      "example": "local"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "username": {
                    "type": "string",
                    "description": "Dashboard Username",
                    "maxLength": 100,
                    "example": "admin"
                  },
                  "password": {
                    "type": "string",
                    "description": "Dashboard Password",
                    "maxLength": 100,
                    "example": "public"
                  },
                  "description": {
                    "type": "string",
                    "description": "Dashboard User Description",
                    "example": "administrator"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/authorization/sources/{type}/status": {
      "get": {
        "description": "Get a authorization source",
        "tags": [
          "Authorization"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "type",
            "description": "Authorization type",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "file",
                "built_in_database",
                "http",
                "redis",
                "mysql",
                "postgresql",
                "mongodb",
                "ldap"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "metrics_example": {
                    "value": {
                      "status": "connected",
                      "node_status": [
                        {
                          "node": "emqx@127.0.0.1",
                          "status": "connected"
                        }
                      ],
                      "metrics": {
                        "nomatch": 0,
                        "total": 0,
                        "allow": 0,
                        "deny": 0,
                        "rate": 0,
                        "rate_last5m": 0,
                        "rate_max": 0
                      },
                      "resource_metrics": {
                        "matched": 0,
                        "success": 0,
                        "failed": 0,
                        "rate": 0,
                        "rate_last5m": 0,
                        "rate_max": 0
                      },
                      "node_metrics": [
                        {
                          "node": "emqx@127.0.0.1",
                          "metrics": {
                            "nomatch": 0,
                            "total": 0,
                            "allow": 0,
                            "deny": 0,
                            "rate": 0,
                            "rate_last5m": 0,
                            "rate_max": 0
                          }
                        }
                      ],
                      "node_resource_metrics": [
                        {
                          "node": "emqx@127.0.0.1",
                          "metrics": {
                            "matched": 0,
                            "success": 0,
                            "failed": 0,
                            "rate": 0,
                            "rate_last5m": 0,
                            "rate_max": 0
                          }
                        }
                      ]
                    },
                    "summary": "Showing a typical metrics example"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authz_schema.metrics_status_fields"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/sources_probe": {
      "post": {
        "description": "Test creating a new bridge.",
        "tags": [
          "Sources"
        ],
        "parameters": [],
        "summary": "Test creating bridge",
        "responses": {
          "204": {
            "description": "Test bridge OK"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "TEST_FAILED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "bridge test failed"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "mqtt": {
                  "value": {
                    "name": "mqtt_source",
                    "type": "mqtt",
                    "description": "My example mqtt source",
                    "enable": true,
                    "parameters": {
                      "topic": "remote/topic",
                      "qos": 1
                    },
                    "connector": "mqtt_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "MQTT Subscriber Source"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/bridge_mqtt_publisher.post_source"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/listeners": {
      "get": {
        "description": "List all running node's listeners for the specified type.",
        "tags": [
          "Listeners"
        ],
        "parameters": [
          {
            "in": "query",
            "name": "type",
            "description": "Listener type",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "tcp",
                "ssl",
                "ws",
                "wss",
                "quic"
              ]
            },
            "example": "tcp"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": [
                  {
                    "id": "tcp:demo",
                    "name": "demo",
                    "status": {
                      "running": true,
                      "max_connections": 2048000,
                      "current_connections": 201
                    },
                    "type": "tcp",
                    "bind": "0.0.0.0:1884",
                    "number": 2,
                    "enable": true,
                    "node_status": [
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "running": true,
                          "max_connections": 1024000,
                          "current_connections": 100
                        }
                      },
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "running": true,
                          "max_connections": 1024000,
                          "current_connections": 101
                        }
                      }
                    ],
                    "acceptors": 16
                  },
                  {
                    "id": "tcp:default",
                    "name": "default",
                    "status": {
                      "running": true,
                      "max_connections": "infinity",
                      "current_connections": 501
                    },
                    "type": "tcp",
                    "bind": "0.0.0.0:1883",
                    "number": 2,
                    "enable": true,
                    "node_status": [
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "running": true,
                          "max_connections": "infinity",
                          "current_connections": 200
                        }
                      },
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "running": true,
                          "max_connections": "infinity",
                          "current_connections": 301
                        }
                      }
                    ],
                    "acceptors": 32
                  }
                ],
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/listeners.listener_id_status"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Create the specified listener on all nodes.",
        "tags": [
          "Listeners"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "id": "tcp:demo",
                  "running": true,
                  "type": "tcp",
                  "bind": "0.0.0.0:1884",
                  "tcp_options": {
                    "buffer": "4KB",
                    "high_watermark": "1MB",
                    "nodelay": false,
                    "reuseaddr": true,
                    "send_timeout": "15s",
                    "send_timeout_close": true,
                    "backlog": 1024,
                    "active_n": 100
                  },
                  "acceptors": 16,
                  "proxy_protocol": false,
                  "max_connections": 204800,
                  "access_rules": [
                    "allow all"
                  ],
                  "proxy_protocol_timeout": "3s",
                  "zone": "default",
                  "mountpoint": "/",
                  "current_connections": 10240
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/listeners.wss_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.ws_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.tcp_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.ssl_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.quic_required_bind"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_LISTENER_ID",
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "example": {
                "name": "demo",
                "running": true,
                "type": "tcp",
                "bind": "0.0.0.0:1884",
                "tcp_options": {
                  "buffer": "4KB",
                  "high_watermark": "1MB",
                  "nodelay": false,
                  "reuseaddr": true,
                  "send_timeout": "15s",
                  "send_timeout_close": true,
                  "backlog": 1024,
                  "active_n": 100
                },
                "acceptors": 16,
                "proxy_protocol": false,
                "max_connections": 204800,
                "access_rules": [
                  "allow all"
                ],
                "proxy_protocol_timeout": "3s",
                "zone": "default",
                "mountpoint": "/",
                "current_connections": 10240
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/listeners.with_name_quic_required_bind"
                  },
                  {
                    "$ref": "#/components/schemas/listeners.with_name_wss_required_bind"
                  },
                  {
                    "$ref": "#/components/schemas/listeners.with_name_ws_required_bind"
                  },
                  {
                    "$ref": "#/components/schemas/listeners.with_name_ssl_required_bind"
                  },
                  {
                    "$ref": "#/components/schemas/listeners.with_name_tcp_required_bind"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/trace/{name}/download": {
      "get": {
        "description": "Download trace log by name",
        "tags": [
          "Trace"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/trace.name"
          },
          {
            "$ref": "#/components/parameters/trace.node"
          }
        ],
        "responses": {
          "200": {
            "description": "A trace zip file",
            "content": {
              "application/octet-stream": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "NODE_ERROR"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Trace Name or Node Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/clients/{clientid}": {
      "get": {
        "description": "Get clients info by client ID",
        "tags": [
          "Clients"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "heap_size": 610,
                  "send_msg.dropped.expired": 0,
                  "send_oct": 31,
                  "recv_msg.qos1": 0,
                  "is_persistent": false,
                  "send_pkt": 4,
                  "clean_start": true,
                  "inflight_cnt": 0,
                  "node": "emqx@127.0.0.1",
                  "send_msg.dropped.queue_full": 0,
                  "awaiting_rel_cnt": 0,
                  "inflight_max": 32,
                  "created_at": "2024-01-01T12:34:56.789+08:00",
                  "subscriptions_cnt": 1,
                  "mailbox_len": 0,
                  "send_cnt": 4,
                  "connected": true,
                  "ip_address": "127.0.0.1",
                  "awaiting_rel_max": 100,
                  "recv_msg.qos2": 0,
                  "proto_ver": 5,
                  "mountpoint": "null",
                  "proto_name": "MQTT",
                  "durable": false,
                  "port": 52571,
                  "connected_at": "2024-01-01T12:34:56.789+08:00",
                  "enable_authn": true,
                  "expiry_interval": 0,
                  "username": null,
                  "recv_msg": 0,
                  "recv_oct": 49,
                  "send_msg.dropped.too_large": 0,
                  "keepalive": 60,
                  "send_msg.qos1": 0,
                  "send_msg.qos2": 0,
                  "recv_msg.qos0": 0,
                  "send_msg.qos0": 0,
                  "subscriptions_max": "infinity",
                  "mqueue_max": 1000,
                  "mqueue_dropped": 0,
                  "clientid": "01",
                  "is_bridge": false,
                  "peerport": 52571,
                  "send_msg": 0,
                  "listener": "tcp:default",
                  "recv_cnt": 4,
                  "recv_pkt": 4,
                  "recv_msg.dropped": 0,
                  "send_msg.dropped": 0,
                  "recv_msg.dropped.await_pubrel_timeout": 0,
                  "reductions": 6836,
                  "mqueue_len": 0
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_clients.client"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "CLIENTID_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Client ID not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Kick out client by client ID",
        "tags": [
          "Clients"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Kick out client successfully"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "CLIENTID_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Client ID not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/sources/{id}/metrics": {
      "get": {
        "description": "Get bridge metrics by id.",
        "tags": [
          "Sources"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_action"
          }
        ],
        "summary": "Get source metrics",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "metrics": {
                      "description": "Bridge metrics.",
                      "$ref": "#/components/schemas/bridge.metrics"
                    },
                    "node_metrics": {
                      "type": "array",
                      "description": "Node metrics.",
                      "items": {
                        "$ref": "#/components/schemas/bridge.node_metrics"
                      }
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Source not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/{name}/authentication": {
      "get": {
        "description": "Gets the configuration of the specified gateway authenticator.<br/><br/>Returns 404 when gateway or authentication is not enabled.",
        "tags": [
          "Gateway Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "lwm2m",
                "mqttsn",
                "stomp"
              ]
            },
            "example": "stomp"
          }
        ],
        "summary": "Get authenticator configuration",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "jwt": {
                    "value": {
                      "mechanism": "jwt",
                      "secret": "mysecret",
                      "algorithm": "hmac-based",
                      "secret_base64_encoded": false,
                      "use_jwks": false,
                      "verify_claims": {
                        "username": "${username}"
                      }
                    },
                    "summary": "JWT authentication"
                  },
                  "password_based:built_in_database": {
                    "value": {
                      "mechanism": "password_based",
                      "backend": "built_in_database",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "user_id_type": "username"
                    },
                    "summary": "Built-in password_based authentication"
                  },
                  "password_based:http": {
                    "value": {
                      "ssl": {
                        "enable": false
                      },
                      "connect_timeout": "5s",
                      "mechanism": "password_based",
                      "pool_size": 8,
                      "body": {
                        "password": "${password}",
                        "username": "${username}"
                      },
                      "headers": {
                        "content-type": "application/json"
                      },
                      "method": "post",
                      "url": "http://127.0.0.1:18083",
                      "backend": "http",
                      "request_timeout": "5s",
                      "enable_pipelining": 100
                    },
                    "summary": "password_based authentication through external HTTP API"
                  },
                  "password_based:mongodb": {
                    "value": {
                      "mechanism": "password_based",
                      "filter": {
                        "username": "${username}"
                      },
                      "server": "127.0.0.1:27017",
                      "database": "example",
                      "backend": "mongodb",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "collection": "users",
                      "is_superuser_field": "is_superuser",
                      "password_hash_field": "password_hash",
                      "salt_field": "salt"
                    },
                    "summary": "password_based authentication with MongoDB backend"
                  },
                  "password_based:redis": {
                    "value": {
                      "mechanism": "password_based",
                      "server": "127.0.0.1:6379",
                      "cmd": "HMGET ${username} password_hash salt",
                      "database": 0,
                      "backend": "redis",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "redis_type": "single"
                    },
                    "summary": "password_based authentication with Redis backend"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authn.ldap_deprecated"
                    },
                    {
                      "$ref": "#/components/schemas/authn.ldap"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_jwks"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_public_key"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_hmac"
                    },
                    {
                      "$ref": "#/components/schemas/authn.http_post"
                    },
                    {
                      "$ref": "#/components/schemas/authn.http_get"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_single"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_sharded"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_rs"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_single"
                    },
                    {
                      "$ref": "#/components/schemas/authn.postgresql"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mysql"
                    },
                    {
                      "$ref": "#/components/schemas/authn.builtin_db"
                    }
                  ]
                }
              }
            }
          },
          "204": {
            "description": "Authenticator not initialized"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update the configuration of the specified gateway authenticator, or disable the authenticator.",
        "tags": [
          "Gateway Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "lwm2m",
                "mqttsn",
                "stomp"
              ]
            },
            "example": "stomp"
          }
        ],
        "summary": "Update authenticator configuration",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "jwt": {
                    "value": {
                      "mechanism": "jwt",
                      "secret": "mysecret",
                      "algorithm": "hmac-based",
                      "secret_base64_encoded": false,
                      "use_jwks": false,
                      "verify_claims": {
                        "username": "${username}"
                      }
                    },
                    "summary": "JWT authentication"
                  },
                  "password_based:built_in_database": {
                    "value": {
                      "mechanism": "password_based",
                      "backend": "built_in_database",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "user_id_type": "username"
                    },
                    "summary": "Built-in password_based authentication"
                  },
                  "password_based:http": {
                    "value": {
                      "ssl": {
                        "enable": false
                      },
                      "connect_timeout": "5s",
                      "mechanism": "password_based",
                      "pool_size": 8,
                      "body": {
                        "password": "${password}",
                        "username": "${username}"
                      },
                      "headers": {
                        "content-type": "application/json"
                      },
                      "method": "post",
                      "url": "http://127.0.0.1:18083",
                      "backend": "http",
                      "request_timeout": "5s",
                      "enable_pipelining": 100
                    },
                    "summary": "password_based authentication through external HTTP API"
                  },
                  "password_based:mongodb": {
                    "value": {
                      "mechanism": "password_based",
                      "filter": {
                        "username": "${username}"
                      },
                      "server": "127.0.0.1:27017",
                      "database": "example",
                      "backend": "mongodb",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "collection": "users",
                      "is_superuser_field": "is_superuser",
                      "password_hash_field": "password_hash",
                      "salt_field": "salt"
                    },
                    "summary": "password_based authentication with MongoDB backend"
                  },
                  "password_based:redis": {
                    "value": {
                      "mechanism": "password_based",
                      "server": "127.0.0.1:6379",
                      "cmd": "HMGET ${username} password_hash salt",
                      "database": 0,
                      "backend": "redis",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "redis_type": "single"
                    },
                    "summary": "password_based authentication with Redis backend"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authn.ldap_deprecated"
                    },
                    {
                      "$ref": "#/components/schemas/authn.ldap"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_jwks"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_public_key"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_hmac"
                    },
                    {
                      "$ref": "#/components/schemas/authn.http_post"
                    },
                    {
                      "$ref": "#/components/schemas/authn.http_get"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_single"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_sharded"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_rs"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_single"
                    },
                    {
                      "$ref": "#/components/schemas/authn.postgresql"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mysql"
                    },
                    {
                      "$ref": "#/components/schemas/authn.builtin_db"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "jwt": {
                  "value": {
                    "mechanism": "jwt",
                    "secret": "mysecret",
                    "algorithm": "hmac-based",
                    "secret_base64_encoded": false,
                    "use_jwks": false,
                    "verify_claims": {
                      "username": "${username}"
                    }
                  },
                  "summary": "JWT authentication"
                },
                "password_based:built_in_database": {
                  "value": {
                    "mechanism": "password_based",
                    "backend": "built_in_database",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "user_id_type": "username"
                  },
                  "summary": "Built-in password_based authentication"
                },
                "password_based:http": {
                  "value": {
                    "ssl": {
                      "enable": false
                    },
                    "connect_timeout": "5s",
                    "mechanism": "password_based",
                    "pool_size": 8,
                    "body": {
                      "password": "${password}",
                      "username": "${username}"
                    },
                    "headers": {
                      "content-type": "application/json"
                    },
                    "method": "post",
                    "url": "http://127.0.0.1:18083",
                    "backend": "http",
                    "request_timeout": "5s",
                    "enable_pipelining": 100
                  },
                  "summary": "password_based authentication through external HTTP API"
                },
                "password_based:mongodb": {
                  "value": {
                    "mechanism": "password_based",
                    "filter": {
                      "username": "${username}"
                    },
                    "server": "127.0.0.1:27017",
                    "database": "example",
                    "backend": "mongodb",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "collection": "users",
                    "is_superuser_field": "is_superuser",
                    "password_hash_field": "password_hash",
                    "salt_field": "salt"
                  },
                  "summary": "password_based authentication with MongoDB backend"
                },
                "password_based:redis": {
                  "value": {
                    "mechanism": "password_based",
                    "server": "127.0.0.1:6379",
                    "cmd": "HMGET ${username} password_hash salt",
                    "database": 0,
                    "backend": "redis",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "redis_type": "single"
                  },
                  "summary": "password_based authentication with Redis backend"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/authn.ldap_deprecated"
                  },
                  {
                    "$ref": "#/components/schemas/authn.ldap"
                  },
                  {
                    "$ref": "#/components/schemas/authn.jwt_jwks"
                  },
                  {
                    "$ref": "#/components/schemas/authn.jwt_public_key"
                  },
                  {
                    "$ref": "#/components/schemas/authn.jwt_hmac"
                  },
                  {
                    "$ref": "#/components/schemas/authn.http_post"
                  },
                  {
                    "$ref": "#/components/schemas/authn.http_get"
                  },
                  {
                    "$ref": "#/components/schemas/authn.redis_sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/authn.redis_cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn.redis_single"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mongo_sharded"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mongo_rs"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mongo_single"
                  },
                  {
                    "$ref": "#/components/schemas/authn.postgresql"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mysql"
                  },
                  {
                    "$ref": "#/components/schemas/authn.builtin_db"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete the authenticator of the specified gateway.",
        "tags": [
          "Gateway Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "lwm2m",
                "mqttsn",
                "stomp"
              ]
            },
            "example": "stomp"
          }
        ],
        "summary": "Delete gateway authenticator",
        "responses": {
          "204": {
            "description": "Deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Enables the authenticator for client authentication for the specified gateway. <br/><br/>When the authenticator is not configured or turned off, all client connections are assumed to be allowed. <br/><br/>Note: Only one authenticator is allowed to be enabled at a time in the gateway, rather than allowing multiple authenticators to be configured to form an authentication chain as in MQTT.",
        "tags": [
          "Gateway Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "lwm2m",
                "mqttsn",
                "stomp"
              ]
            },
            "example": "stomp"
          }
        ],
        "summary": "Create authenticator for gateway",
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "jwt": {
                    "value": {
                      "mechanism": "jwt",
                      "secret": "mysecret",
                      "algorithm": "hmac-based",
                      "secret_base64_encoded": false,
                      "use_jwks": false,
                      "verify_claims": {
                        "username": "${username}"
                      }
                    },
                    "summary": "JWT authentication"
                  },
                  "password_based:built_in_database": {
                    "value": {
                      "mechanism": "password_based",
                      "backend": "built_in_database",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "user_id_type": "username"
                    },
                    "summary": "Built-in password_based authentication"
                  },
                  "password_based:http": {
                    "value": {
                      "ssl": {
                        "enable": false
                      },
                      "connect_timeout": "5s",
                      "mechanism": "password_based",
                      "pool_size": 8,
                      "body": {
                        "password": "${password}",
                        "username": "${username}"
                      },
                      "headers": {
                        "content-type": "application/json"
                      },
                      "method": "post",
                      "url": "http://127.0.0.1:18083",
                      "backend": "http",
                      "request_timeout": "5s",
                      "enable_pipelining": 100
                    },
                    "summary": "password_based authentication through external HTTP API"
                  },
                  "password_based:mongodb": {
                    "value": {
                      "mechanism": "password_based",
                      "filter": {
                        "username": "${username}"
                      },
                      "server": "127.0.0.1:27017",
                      "database": "example",
                      "backend": "mongodb",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "collection": "users",
                      "is_superuser_field": "is_superuser",
                      "password_hash_field": "password_hash",
                      "salt_field": "salt"
                    },
                    "summary": "password_based authentication with MongoDB backend"
                  },
                  "password_based:redis": {
                    "value": {
                      "mechanism": "password_based",
                      "server": "127.0.0.1:6379",
                      "cmd": "HMGET ${username} password_hash salt",
                      "database": 0,
                      "backend": "redis",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "redis_type": "single"
                    },
                    "summary": "password_based authentication with Redis backend"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authn.ldap_deprecated"
                    },
                    {
                      "$ref": "#/components/schemas/authn.ldap"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_jwks"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_public_key"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_hmac"
                    },
                    {
                      "$ref": "#/components/schemas/authn.http_post"
                    },
                    {
                      "$ref": "#/components/schemas/authn.http_get"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_single"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_sharded"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_rs"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_single"
                    },
                    {
                      "$ref": "#/components/schemas/authn.postgresql"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mysql"
                    },
                    {
                      "$ref": "#/components/schemas/authn.builtin_db"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "jwt": {
                  "value": {
                    "mechanism": "jwt",
                    "secret": "mysecret",
                    "algorithm": "hmac-based",
                    "secret_base64_encoded": false,
                    "use_jwks": false,
                    "verify_claims": {
                      "username": "${username}"
                    }
                  },
                  "summary": "JWT authentication"
                },
                "password_based:built_in_database": {
                  "value": {
                    "mechanism": "password_based",
                    "backend": "built_in_database",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "user_id_type": "username"
                  },
                  "summary": "Built-in password_based authentication"
                },
                "password_based:http": {
                  "value": {
                    "ssl": {
                      "enable": false
                    },
                    "connect_timeout": "5s",
                    "mechanism": "password_based",
                    "pool_size": 8,
                    "body": {
                      "password": "${password}",
                      "username": "${username}"
                    },
                    "headers": {
                      "content-type": "application/json"
                    },
                    "method": "post",
                    "url": "http://127.0.0.1:18083",
                    "backend": "http",
                    "request_timeout": "5s",
                    "enable_pipelining": 100
                  },
                  "summary": "password_based authentication through external HTTP API"
                },
                "password_based:mongodb": {
                  "value": {
                    "mechanism": "password_based",
                    "filter": {
                      "username": "${username}"
                    },
                    "server": "127.0.0.1:27017",
                    "database": "example",
                    "backend": "mongodb",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "collection": "users",
                    "is_superuser_field": "is_superuser",
                    "password_hash_field": "password_hash",
                    "salt_field": "salt"
                  },
                  "summary": "password_based authentication with MongoDB backend"
                },
                "password_based:redis": {
                  "value": {
                    "mechanism": "password_based",
                    "server": "127.0.0.1:6379",
                    "cmd": "HMGET ${username} password_hash salt",
                    "database": 0,
                    "backend": "redis",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "redis_type": "single"
                  },
                  "summary": "password_based authentication with Redis backend"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/authn.ldap_deprecated"
                  },
                  {
                    "$ref": "#/components/schemas/authn.ldap"
                  },
                  {
                    "$ref": "#/components/schemas/authn.jwt_jwks"
                  },
                  {
                    "$ref": "#/components/schemas/authn.jwt_public_key"
                  },
                  {
                    "$ref": "#/components/schemas/authn.jwt_hmac"
                  },
                  {
                    "$ref": "#/components/schemas/authn.http_post"
                  },
                  {
                    "$ref": "#/components/schemas/authn.http_get"
                  },
                  {
                    "$ref": "#/components/schemas/authn.redis_sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/authn.redis_cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn.redis_single"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mongo_sharded"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mongo_rs"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mongo_single"
                  },
                  {
                    "$ref": "#/components/schemas/authn.postgresql"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mysql"
                  },
                  {
                    "$ref": "#/components/schemas/authn.builtin_db"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/clients/{clientid}/unsubscribe/bulk": {
      "post": {
        "description": "Unsubscribe bulk",
        "tags": [
          "Clients"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Unsubscribe OK"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "CLIENTID_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Client ID not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_clients.unsubscribe"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/clients/{clientid}/subscribe/bulk": {
      "post": {
        "description": "Subscribe bulk",
        "tags": [
          "Clients"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/emqx_mgmt_api_subscriptions.subscription"
                  }
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "CLIENTID_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Client ID not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_clients.subscribe"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/sources/{id}/{operation}": {
      "post": {
        "description": "Start bridge on all nodes in the cluster.",
        "tags": [
          "Sources"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_action"
          },
          {
            "in": "path",
            "name": "operation",
            "description": "Operation can be one of: 'start'.",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "start"
              ]
            },
            "example": "start"
          }
        ],
        "summary": "Manually start a bridge",
        "responses": {
          "204": {
            "description": "Operation success"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Problem with configuration of external service"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bridge not found or invalid operation"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "501": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_IMPLEMENTED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Implemented"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Service unavailable"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/connectors/{id}/{operation}": {
      "post": {
        "description": "Start connector on all nodes in the cluster.",
        "tags": [
          "Connectors"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The connector id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_connector"
          },
          {
            "in": "path",
            "name": "operation",
            "description": "Operation can be one of: 'start'.",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "start"
              ]
            },
            "example": "start"
          }
        ],
        "summary": "Manually start a connector",
        "responses": {
          "204": {
            "description": "Operation success"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Problem with configuration of external service"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Connector not found or invalid operation"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "501": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_IMPLEMENTED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Implemented"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Service unavailable"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/configs/alarm": {
      "get": {
        "description": "Get the sub-configurations under *alarm*",
        "tags": [
          "Configs"
        ],
        "parameters": [],
        "summary": "Get the sub-configurations under *alarm*",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx.alarm"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "config not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update the sub-configurations under *alarm*",
        "tags": [
          "Configs"
        ],
        "parameters": [],
        "summary": "Update the sub-configurations under *alarm*",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx.alarm"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UPDATE_FAILED",
                        "INVALID_CONFIG"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "403": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UPDATE_FAILED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx.alarm"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/actions": {
      "get": {
        "description": "List all created bridges.",
        "tags": [
          "Actions"
        ],
        "parameters": [],
        "summary": "List bridges",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": [
                  {
                    "name": "my_http_action",
                    "status": "connected",
                    "type": "http",
                    "enable": true,
                    "parameters": {
                      "path": "/room/${room_no}",
                      "body": "${.}",
                      "headers": {},
                      "method": "post"
                    },
                    "connector": "my_http_connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "worker_pool_size": 16,
                      "query_mode": "async",
                      "health_check_interval": "15s"
                    }
                  },
                  {
                    "name": "mqtt_action",
                    "status": "connected",
                    "type": "mqtt",
                    "description": "My example mqtt action",
                    "enable": true,
                    "parameters": {
                      "retain": false,
                      "payload": "${.payload}",
                      "topic": "remote/topic",
                      "qos": 2
                    },
                    "connector": "mqtt_connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  }
                ],
                "schema": {
                  "type": "array",
                  "items": {
                    "oneOf": [
                      {
                        "$ref": "#/components/schemas/bridge_mqtt_publisher.get_bridge_v2"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_http.get_bridge_v2"
                      }
                    ]
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Create a new bridge by type and name.",
        "tags": [
          "Actions"
        ],
        "parameters": [],
        "summary": "Create bridge",
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "http": {
                    "value": {
                      "name": "my_http_action",
                      "status": "connected",
                      "type": "http",
                      "enable": true,
                      "parameters": {
                        "path": "/room/${room_no}",
                        "body": "${.}",
                        "headers": {},
                        "method": "post"
                      },
                      "connector": "my_http_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "worker_pool_size": 16,
                        "query_mode": "async",
                        "health_check_interval": "15s"
                      }
                    },
                    "summary": "HTTP Action"
                  },
                  "mqtt": {
                    "value": {
                      "name": "mqtt_action",
                      "status": "connected",
                      "type": "mqtt",
                      "description": "My example mqtt action",
                      "enable": true,
                      "parameters": {
                        "retain": false,
                        "payload": "${.payload}",
                        "topic": "remote/topic",
                        "qos": 2
                      },
                      "connector": "mqtt_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "MQTT Producer Action"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/bridge_mqtt_publisher.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_http.get_bridge_v2"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "ALREADY_EXISTS"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bridge already exists"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "http": {
                  "value": {
                    "name": "my_http_action",
                    "type": "http",
                    "enable": true,
                    "parameters": {
                      "path": "/room/${room_no}",
                      "body": "${.}",
                      "headers": {},
                      "method": "post"
                    },
                    "connector": "my_http_connector",
                    "resource_opts": {
                      "worker_pool_size": 16,
                      "query_mode": "async",
                      "health_check_interval": "15s"
                    }
                  },
                  "summary": "HTTP Action"
                },
                "mqtt": {
                  "value": {
                    "name": "mqtt_action",
                    "type": "mqtt",
                    "description": "My example mqtt action",
                    "enable": true,
                    "parameters": {
                      "retain": false,
                      "payload": "${.payload}",
                      "topic": "remote/topic",
                      "qos": 2
                    },
                    "connector": "mqtt_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "MQTT Producer Action"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/bridge_mqtt_publisher.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_http.post_bridge_v2"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/nodes/{node}": {
      "get": {
        "description": "Get node info",
        "tags": [
          "Nodes"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_mgmt_api_nodes.node_name"
          }
        ],
        "responses": {
          "200": {
            "description": "Get node info successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_nodes.node_info"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Node not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/mqtt/delayed/messages/{topic}": {
      "delete": {
        "description": "Delete delayed message",
        "tags": [
          "MQTT"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "topic",
            "description": "Topic",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Delete delayed message success"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "INVALID_TOPIC_NAME"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Topic Name"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "MESSAGE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not found delayed message for this topic"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/coap/clients/{clientid}/request": {
      "post": {
        "description": "Send a CoAP request message to the client",
        "tags": [
          "CoAP Gateways"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "summary": "Send a Request to a Client",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "id": {
                      "type": "integer",
                      "description": "Message ID"
                    },
                    "token": {
                      "type": "string",
                      "description": "Message token, can be empty"
                    },
                    "method": {
                      "type": "string",
                      "description": "Response code"
                    },
                    "payload": {
                      "type": "string",
                      "description": "The content of the payload"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "CLIENT_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Client not found error"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "504": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "CLIENT_NOT_RESPONSE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Waiting for client response timeout"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "token": {
                    "type": "string",
                    "description": "Message token, can be empty"
                  },
                  "method": {
                    "type": "string",
                    "enum": [
                      "get",
                      "put",
                      "post",
                      "delete"
                    ],
                    "description": "Request method type"
                  },
                  "timeout": {
                    "type": "string",
                    "description": "Timespan for response",
                    "example": "32s"
                  },
                  "content_type": {
                    "type": "string",
                    "enum": [
                      "text/plain",
                      "application/json",
                      "application/octet-stream"
                    ],
                    "description": "Payload type"
                  },
                  "payload": {
                    "type": "string",
                    "description": "The content of the payload"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/listeners/{id}/stop": {
      "post": {
        "description": "Stop the listener on all nodes.",
        "tags": [
          "Listeners"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/listeners.listener_id"
          }
        ],
        "responses": {
          "200": {
            "description": "Updated"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST",
                        "BAD_LISTENER_ID"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/topics": {
      "get": {
        "description": "Topics list",
        "tags": [
          "Topics"
        ],
        "parameters": [
          {
            "in": "query",
            "name": "topic",
            "description": "Topic Name",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": ""
          },
          {
            "in": "query",
            "name": "node",
            "description": "Node Name",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "emqx@127.0.0.1"
          },
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "data": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/emqx_mgmt_api_topics.topic"
                      }
                    },
                    "meta": {
                      "$ref": "#/components/schemas/public.meta"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/cluster/{node}/invite_async": {
      "put": {
        "description": "Send a join invitation to a node to join the cluster but do not wait for the join result. Join status can be retrieved with `GET api/<version>/invitation`",
        "tags": [
          "Cluster"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/cluster.node"
          }
        ],
        "responses": {
          "200": {
            "description": "ok"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/authorization/sources": {
      "get": {
        "description": "List all authorization sources",
        "tags": [
          "Authorization"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_authz_api_sources.sources"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Add a new source",
        "tags": [
          "Authorization"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": "Authorization source created successfully"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/authz.ldap"
                  },
                  {
                    "$ref": "#/components/schemas/authz.mongo_sharded"
                  },
                  {
                    "$ref": "#/components/schemas/authz.mongo_rs"
                  },
                  {
                    "$ref": "#/components/schemas/authz.mongo_single"
                  },
                  {
                    "$ref": "#/components/schemas/authz.postgresql"
                  },
                  {
                    "$ref": "#/components/schemas/authz.mysql"
                  },
                  {
                    "$ref": "#/components/schemas/authz.redis_cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authz.redis_sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/authz.redis_single"
                  },
                  {
                    "$ref": "#/components/schemas/authz.http_post"
                  },
                  {
                    "$ref": "#/components/schemas/authz.http_get"
                  },
                  {
                    "$ref": "#/components/schemas/authz.builtin_db"
                  },
                  {
                    "$ref": "#/components/schemas/authz.api_file"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/plugins": {
      "get": {
        "description": "Plugins are launched in top-down order.<br/>Use `POST /plugins/{name}/move` to change the boot order.",
        "tags": [
          "Plugins"
        ],
        "parameters": [],
        "summary": "List all installed plugins",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/plugins.plugin"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/login": {
      "post": {
        "description": "Get Dashboard Auth Token.",
        "tags": [
          "Dashboard"
        ],
        "parameters": [],
        "summary": "Dashboard authentication",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "token": {
                      "type": "string",
                      "description": "Dashboard Auth Token"
                    },
                    "version": {
                      "type": "string",
                      "description": "EMQX Version",
                      "example": "5.0.0"
                    },
                    "license": {
                      "properties": {
                        "edition": {
                          "type": "string",
                          "enum": [
                            "opensource",
                            "enterprise"
                          ],
                          "description": "EMQX License. opensource or enterprise",
                          "example": "opensource"
                        }
                      },
                      "type": "object"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "401": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_USERNAME_OR_PWD"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Login failed. Bad username or password"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "username": {
                    "type": "string",
                    "description": "Dashboard Username",
                    "maxLength": 100,
                    "example": "admin"
                  },
                  "password": {
                    "type": "string",
                    "description": "Dashboard Password",
                    "maxLength": 100,
                    "example": "public"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "security": []
      }
    },
    "/bridges/{id}": {
      "get": {
        "description": "Get a bridge by Id",
        "tags": [
          "Bridges"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge Id. Must be of format {type}:{name}",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:http_example"
          }
        ],
        "summary": "Get bridge",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "http_example": {
                    "value": {
                      "name": "http_example",
                      "type": "http",
                      "ssl": {
                        "enable": false
                      },
                      "connect_timeout": "15s",
                      "pool_size": 4,
                      "enable": true,
                      "body": "${payload}",
                      "method": "post",
                      "url": "http://localhost:9901/messages/${topic}",
                      "max_retries": 3,
                      "request_timeout": "15s",
                      "pool_type": "random",
                      "resource_opts": {
                        "worker_pool_size": 1,
                        "query_mode": "async",
                        "max_buffer_bytes": 104857600,
                        "inflight_window": 100,
                        "health_check_interval": 15000
                      },
                      "enable_pipelining": 100,
                      "local_topic": "emqx_http/#"
                    },
                    "summary": "HTTP"
                  },
                  "mqtt_example": {
                    "value": {
                      "name": "mqtt_example",
                      "type": "mqtt",
                      "keepalive": "300s",
                      "ssl": {
                        "enable": false
                      },
                      "server": "127.0.0.1:1883",
                      "enable": true,
                      "password": "******",
                      "username": "foo",
                      "proto_ver": "v4",
                      "clean_start": true,
                      "retry_interval": "15s",
                      "max_inflight": 100,
                      "resource_opts": {
                        "query_mode": "sync",
                        "max_buffer_bytes": 104857600,
                        "health_check_interval": "15s"
                      },
                      "ingress": {
                        "local": {
                          "retain": "${retain}",
                          "payload": "${payload}",
                          "topic": "from_aws/${topic}",
                          "qos": "${qos}"
                        },
                        "remote": {
                          "topic": "aws/#",
                          "qos": 1
                        }
                      },
                      "egress": {
                        "local": {
                          "topic": "emqx/#"
                        },
                        "remote": {
                          "retain": false,
                          "payload": "${payload}",
                          "topic": "from_emqx/${topic}",
                          "qos": "${qos}"
                        }
                      }
                    },
                    "summary": "MQTT Bridge"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/bridge_http.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mqtt.get"
                    }
                  ]
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bridge not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update a bridge by Id",
        "tags": [
          "Bridges"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge Id. Must be of format {type}:{name}",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:http_example"
          }
        ],
        "summary": "Update bridge",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "http_example": {
                    "value": {
                      "name": "http_example",
                      "type": "http",
                      "ssl": {
                        "enable": false
                      },
                      "connect_timeout": "15s",
                      "pool_size": 4,
                      "enable": true,
                      "body": "${payload}",
                      "method": "post",
                      "url": "http://localhost:9901/messages/${topic}",
                      "max_retries": 3,
                      "request_timeout": "15s",
                      "pool_type": "random",
                      "resource_opts": {
                        "worker_pool_size": 1,
                        "query_mode": "async",
                        "max_buffer_bytes": 104857600,
                        "inflight_window": 100,
                        "health_check_interval": 15000
                      },
                      "enable_pipelining": 100,
                      "local_topic": "emqx_http/#"
                    },
                    "summary": "HTTP"
                  },
                  "mqtt_example": {
                    "value": {
                      "name": "mqtt_example",
                      "type": "mqtt",
                      "keepalive": "300s",
                      "ssl": {
                        "enable": false
                      },
                      "server": "127.0.0.1:1883",
                      "enable": true,
                      "password": "******",
                      "username": "foo",
                      "proto_ver": "v4",
                      "clean_start": true,
                      "retry_interval": "15s",
                      "max_inflight": 100,
                      "resource_opts": {
                        "query_mode": "sync",
                        "max_buffer_bytes": 104857600,
                        "health_check_interval": "15s"
                      },
                      "ingress": {
                        "local": {
                          "retain": "${retain}",
                          "payload": "${payload}",
                          "topic": "from_aws/${topic}",
                          "qos": "${qos}"
                        },
                        "remote": {
                          "topic": "aws/#",
                          "qos": 1
                        }
                      },
                      "egress": {
                        "local": {
                          "topic": "emqx/#"
                        },
                        "remote": {
                          "retain": false,
                          "payload": "${payload}",
                          "topic": "from_emqx/${topic}",
                          "qos": "${qos}"
                        }
                      }
                    },
                    "summary": "MQTT Bridge"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/bridge_http.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mqtt.get"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Update bridge failed"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bridge not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "http_example": {
                  "value": {
                    "ssl": {
                      "enable": false
                    },
                    "connect_timeout": "15s",
                    "pool_size": 4,
                    "enable": true,
                    "body": "${payload}",
                    "method": "post",
                    "url": "http://localhost:9901/messages/${topic}",
                    "max_retries": 3,
                    "request_timeout": "15s",
                    "pool_type": "random",
                    "resource_opts": {
                      "worker_pool_size": 1,
                      "query_mode": "async",
                      "max_buffer_bytes": 104857600,
                      "inflight_window": 100,
                      "health_check_interval": 15000
                    },
                    "enable_pipelining": 100,
                    "local_topic": "emqx_http/#"
                  },
                  "summary": "HTTP"
                },
                "mqtt_example": {
                  "value": {
                    "keepalive": "300s",
                    "ssl": {
                      "enable": false
                    },
                    "server": "127.0.0.1:1883",
                    "enable": true,
                    "password": "******",
                    "username": "foo",
                    "proto_ver": "v4",
                    "clean_start": true,
                    "retry_interval": "15s",
                    "max_inflight": 100,
                    "resource_opts": {
                      "query_mode": "sync",
                      "max_buffer_bytes": 104857600,
                      "health_check_interval": "15s"
                    },
                    "ingress": {
                      "local": {
                        "retain": "${retain}",
                        "payload": "${payload}",
                        "topic": "from_aws/${topic}",
                        "qos": "${qos}"
                      },
                      "remote": {
                        "topic": "aws/#",
                        "qos": 1
                      }
                    },
                    "egress": {
                      "local": {
                        "topic": "emqx/#"
                      },
                      "remote": {
                        "retain": false,
                        "payload": "${payload}",
                        "topic": "from_emqx/${topic}",
                        "qos": "${qos}"
                      }
                    }
                  },
                  "summary": "MQTT Bridge"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/bridge_http.put"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mqtt.put"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete a bridge by Id",
        "tags": [
          "Bridges"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge Id. Must be of format {type}:{name}",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:http_example"
          }
        ],
        "summary": "Delete bridge",
        "responses": {
          "204": {
            "description": "Bridge deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "rules": {
                      "type": "array",
                      "description": "Dependent Rule IDs",
                      "items": {
                        "type": "string"
                      }
                    },
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Cannot delete bridge while active rules are defined for this bridge"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bridge not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Service unavailable"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/configs/dashboard": {
      "get": {
        "description": "Get the sub-configurations under *dashboard*",
        "tags": [
          "Configs"
        ],
        "parameters": [],
        "summary": "Get the sub-configurations under *dashboard*",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/dashboard.dashboard"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "config not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update the sub-configurations under *dashboard*",
        "tags": [
          "Configs"
        ],
        "parameters": [],
        "summary": "Update the sub-configurations under *dashboard*",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/dashboard.dashboard"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UPDATE_FAILED",
                        "INVALID_CONFIG"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "403": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UPDATE_FAILED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/dashboard.dashboard"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/{name}/clients/{clientid}/subscriptions": {
      "get": {
        "description": "Get the gateway client subscriptions",
        "tags": [
          "Gateway Clients"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "description": "Client ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "lwm2m",
                "mqttsn",
                "stomp"
              ]
            }
          }
        ],
        "summary": "List client's subscription",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "general_subscription_list": {
                    "value": [
                      {
                        "nl": 0,
                        "topic": "test/topic",
                        "qos": 1,
                        "rap": 0,
                        "rh": 0
                      }
                    ],
                    "summary": "A general subscription list"
                  },
                  "stomp_subscription_list": {
                    "value": [
                      "example_stomp_subscription"
                    ],
                    "summary": "The STOMP subscription list"
                  }
                },
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/emqx_gateway_api_clients.subscription"
                  }
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Create a subscription membership",
        "tags": [
          "Gateway Clients"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "description": "Client ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "lwm2m",
                "mqttsn",
                "stomp"
              ]
            }
          }
        ],
        "summary": "Add subscription for client",
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "general_subscription": {
                    "value": {
                      "nl": 0,
                      "topic": "test/topic",
                      "qos": 1,
                      "rap": 0,
                      "rh": 0
                    },
                    "summary": "A general subscription"
                  },
                  "stomp_subscription": {
                    "value": {
                      "nl": 0,
                      "topic": "stomp/topic",
                      "qos": 1,
                      "rap": 0,
                      "rh": 0,
                      "sub_props": {
                        "subid": "10"
                      }
                    },
                    "summary": "A STOMP subscription"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_gateway_api_clients.subscription"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "general_subscription": {
                  "value": {
                    "nl": 0,
                    "topic": "test/topic",
                    "qos": 1,
                    "rap": 0,
                    "rh": 0
                  },
                  "summary": "A general subscription"
                },
                "stomp_subscription": {
                  "value": {
                    "nl": 0,
                    "topic": "stomp/topic",
                    "qos": 1,
                    "rap": 0,
                    "rh": 0,
                    "sub_props": {
                      "subid": "10"
                    }
                  },
                  "summary": "A STOMP subscription"
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_gateway_api_clients.subscription"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/cluster/{node}/invite": {
      "put": {
        "description": "Invite node to cluster",
        "tags": [
          "Cluster"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/cluster.node"
          }
        ],
        "responses": {
          "200": {
            "description": "ok"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/cluster.timeout"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/cluster/topology": {
      "get": {
        "description": "Get RLOG cluster topology: connections between core and replicant nodes.",
        "tags": [
          "Cluster"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Cluster topology",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/cluster.core_replicants"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/mqtt/retainer/messages": {
      "get": {
        "description": "List retained messages.",
        "tags": [
          "Retainer"
        ],
        "parameters": [
          {
            "in": "query",
            "name": "topic",
            "description": "Topic filter, supports wildcards, omit this to match all messages.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "page",
            "description": "Page number of the results to fetch.",
            "schema": {
              "default": 1,
              "type": "integer",
              "minimum": 1
            },
            "example": 1
          },
          {
            "in": "query",
            "name": "limit",
            "description": "Results per page(max 10000)",
            "schema": {
              "default": 100,
              "maximum": 10000,
              "type": "integer",
              "minimum": 1
            },
            "example": 50
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "data": {
                      "type": "array",
                      "description": "Retained messages list.",
                      "items": {
                        "$ref": "#/components/schemas/retainer.message_summary"
                      }
                    },
                    "meta": {
                      "$ref": "#/components/schemas/public.meta"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Unsupported backend."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete all retained messages",
        "tags": [
          "Retainer"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": ""
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/plugins/{name}/move": {
      "post": {
        "description": "Setting the boot order of plugins.",
        "tags": [
          "Plugins"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/plugins.name"
          }
        ],
        "summary": "Move plugin within plugin hierarchy",
        "responses": {
          "204": {
            "description": "Boot order changed successfully"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "MOVE_FAILED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Move failed"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "move_to_after": {
                  "value": {
                    "position": "after:emqx_plugin_demo-5.1-rc.2"
                  },
                  "summary": "move plugin after other plugins"
                },
                "move_to_before": {
                  "value": {
                    "position": "before:emqx_plugin_demo-5.1-rc.2"
                  },
                  "summary": "move plugin before other plugins"
                },
                "move_to_front": {
                  "value": {
                    "position": "front"
                  },
                  "summary": "move plugin on the front"
                },
                "move_to_rear": {
                  "value": {
                    "position": "rear"
                  },
                  "summary": "move plugin on the rear"
                }
              },
              "schema": {
                "$ref": "#/components/schemas/plugins.position"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/configs/broker": {
      "get": {
        "description": "Get the sub-configurations under *broker*",
        "tags": [
          "Configs"
        ],
        "parameters": [],
        "summary": "Get the sub-configurations under *broker*",
        "responses": {
          "200": {
            "description": "Message broker options.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx.broker"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "config not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update the sub-configurations under *broker*",
        "tags": [
          "Configs"
        ],
        "parameters": [],
        "summary": "Update the sub-configurations under *broker*",
        "responses": {
          "200": {
            "description": "Message broker options.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx.broker"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UPDATE_FAILED",
                        "INVALID_CONFIG"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "403": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UPDATE_FAILED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx.broker"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/alarms": {
      "get": {
        "description": "List currently activated alarms or historical alarms, determined by query parameters.",
        "tags": [
          "Alarms"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          },
          {
            "in": "query",
            "name": "activated",
            "description": "It is used to specify the alarm type of the query.<br/>When true, it returns the currently activated alarm,<br/>and when it is false, it returns the historical alarm.<br/>The default is false.",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "data": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/emqx_mgmt_api_alarms.alarm"
                      }
                    },
                    "meta": {
                      "$ref": "#/components/schemas/public.meta"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Remove all historical alarms.",
        "tags": [
          "Alarms"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": "Historical alarms have been cleared successfully."
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/authorization/sources/built_in_database/rules/users/{username}": {
      "get": {
        "description": "Get rule for 'username'",
        "tags": [
          "Authorization"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_authz_api_mnesia.username"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "password_based:built_in_database": {
                    "value": {
                      "rules": [
                        {
                          "action": "publish",
                          "topic": "test/topic/1",
                          "permission": "allow"
                        },
                        {
                          "action": "subscribe",
                          "topic": "test/topic/2",
                          "permission": "allow"
                        },
                        {
                          "action": "all",
                          "topic": "eq test/#",
                          "permission": "deny"
                        },
                        {
                          "action": "publish",
                          "retain": "true",
                          "topic": "test/topic/3",
                          "qos": [
                            "1"
                          ],
                          "permission": "allow"
                        },
                        {
                          "action": "publish",
                          "retain": "all",
                          "topic": "test/topic/4",
                          "qos": [
                            "0",
                            "1",
                            "2"
                          ],
                          "permission": "allow"
                        }
                      ],
                      "username": "user1"
                    },
                    "summary": "Username"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authz_api_mnesia.rules_for_username"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Set rule for 'username'",
        "tags": [
          "Authorization"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_authz_api_mnesia.username"
          }
        ],
        "responses": {
          "204": {
            "description": "Updated"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad username or bad rule schema"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "password_based:built_in_database": {
                  "value": {
                    "rules": [
                      {
                        "action": "publish",
                        "topic": "test/topic/1",
                        "permission": "allow"
                      },
                      {
                        "action": "subscribe",
                        "topic": "test/topic/2",
                        "permission": "allow"
                      },
                      {
                        "action": "all",
                        "topic": "eq test/#",
                        "permission": "deny"
                      },
                      {
                        "action": "publish",
                        "retain": "true",
                        "topic": "test/topic/3",
                        "qos": [
                          "1"
                        ],
                        "permission": "allow"
                      },
                      {
                        "action": "publish",
                        "retain": "all",
                        "topic": "test/topic/4",
                        "qos": [
                          "0",
                          "1",
                          "2"
                        ],
                        "permission": "allow"
                      }
                    ],
                    "username": "user1"
                  },
                  "summary": "Username"
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authz_api_mnesia.rules_for_username"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete rule for 'username'",
        "tags": [
          "Authorization"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_authz_api_mnesia.username"
          }
        ],
        "responses": {
          "204": {
            "description": "Deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad username"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Username Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/subscriptions": {
      "get": {
        "description": "List subscriptions",
        "tags": [
          "Subscriptions"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          },
          {
            "in": "query",
            "name": "node",
            "description": "Node name",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "emqx@127.0.0.1"
          },
          {
            "in": "query",
            "name": "clientid",
            "description": "Client ID",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "qos",
            "description": "QoS",
            "required": false,
            "schema": {
              "maximum": 2,
              "type": "integer",
              "minimum": 0,
              "example": 0
            }
          },
          {
            "in": "query",
            "name": "topic",
            "description": "Topic, url encoding",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "match_topic",
            "description": "Match topic string, url encoding",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "share_group",
            "description": "Shared subscription group name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "durable",
            "description": "Filter subscriptions by durability",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/emqx_mgmt_api_subscriptions.subscription"
                  }
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "INVALID_PARAMETER"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Invalid parameter"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "500": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NODE_DOWN"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad RPC"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/error_codes": {
      "get": {
        "description": "API Error Codes",
        "tags": [
          "Error Codes"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/dashboard.error_code"
                  }
                }
              }
            }
          }
        },
        "security": []
      }
    },
    "/authorization/sources/built_in_database/rules": {
      "delete": {
        "description": "Delete all rules for all 'users', 'clients' and 'all'",
        "tags": [
          "Authorization"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": "Deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/authorization/sources/{type}/move": {
      "post": {
        "description": "Change the exection order of sources",
        "tags": [
          "Authorization"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "type",
            "description": "Authorization type",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "file",
                "built_in_database",
                "http",
                "redis",
                "mysql",
                "postgresql",
                "mongodb",
                "ldap"
              ]
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "rear": {
                  "value": {
                    "position": "rear"
                  },
                  "summary": "rear example"
                },
                "front": {
                  "value": {
                    "position": "front"
                  },
                  "summary": "front example"
                },
                "relative_after": {
                  "value": {
                    "position": "after:file"
                  },
                  "summary": "relative example"
                },
                "relative_before": {
                  "value": {
                    "position": "before:file"
                  },
                  "summary": "relative example"
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authz_api_sources.position"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/telemetry/data": {
      "get": {
        "description": "Get telemetry data",
        "tags": [
          "Telemetry"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Get telemetry data",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_telemetry_api.telemetry"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Telemetry is not enabled"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/{name}/listeners/{id}/authentication/users/{uid}": {
      "get": {
        "description": "Get user info from the gateway authenticator (only supports built_in_database)",
        "tags": [
          "Gateway Listeners"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "lwm2m",
                "mqttsn",
                "stomp"
              ]
            },
            "example": "stomp"
          },
          {
            "in": "path",
            "name": "id",
            "description": "Listener ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": ""
          },
          {
            "in": "path",
            "name": "uid",
            "description": "User ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": ""
          }
        ],
        "summary": "Get user info",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "regular_user": {
                    "value": {
                      "user_id": "user1"
                    },
                    "summary": "Regular user"
                  },
                  "super_user": {
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    },
                    "summary": "Superuser"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update the user info for the gateway authenticator (only supports built_in_database)",
        "tags": [
          "Gateway Listeners"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "lwm2m",
                "mqttsn",
                "stomp"
              ]
            },
            "example": "stomp"
          },
          {
            "in": "path",
            "name": "id",
            "description": "Listener ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": ""
          },
          {
            "in": "path",
            "name": "uid",
            "description": "User ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": ""
          }
        ],
        "summary": "Update user info",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "regular_user": {
                    "value": {
                      "user_id": "user1"
                    },
                    "summary": "Regular user"
                  },
                  "super_user": {
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    },
                    "summary": "Superuser"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "regular_user": {
                  "value": {
                    "password": "******"
                  },
                  "summary": "Update regular user"
                },
                "super_user": {
                  "value": {
                    "password": "******",
                    "is_superuser": true
                  },
                  "summary": "Update user and promote to superuser"
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authn_api.request_user_update"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete the user for the gateway authenticator (only supports built_in_database)",
        "tags": [
          "Gateway Listeners"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "lwm2m",
                "mqttsn",
                "stomp"
              ]
            },
            "example": "stomp"
          },
          {
            "in": "path",
            "name": "id",
            "description": "Listener ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": ""
          },
          {
            "in": "path",
            "name": "uid",
            "description": "User ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": ""
          }
        ],
        "summary": "Delete user",
        "responses": {
          "204": {
            "description": "Deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/authentication": {
      "get": {
        "description": "List authenticators for global authentication.",
        "tags": [
          "Authentication"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": [
                  {
                    "mechanism": "jwt",
                    "secret": "mysecret",
                    "algorithm": "hmac-based",
                    "secret_base64_encoded": false,
                    "use_jwks": false,
                    "verify_claims": {
                      "username": "${username}"
                    }
                  },
                  {
                    "mechanism": "password_based",
                    "backend": "built_in_database",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "user_id_type": "username"
                  },
                  {
                    "ssl": {
                      "enable": false
                    },
                    "connect_timeout": "5s",
                    "mechanism": "password_based",
                    "pool_size": 8,
                    "body": {
                      "password": "${password}",
                      "username": "${username}"
                    },
                    "headers": {
                      "content-type": "application/json"
                    },
                    "method": "post",
                    "url": "http://127.0.0.1:18083",
                    "backend": "http",
                    "request_timeout": "5s",
                    "enable_pipelining": 100
                  },
                  {
                    "mechanism": "password_based",
                    "filter": {
                      "username": "${username}"
                    },
                    "server": "127.0.0.1:27017",
                    "database": "example",
                    "backend": "mongodb",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "collection": "users",
                    "is_superuser_field": "is_superuser",
                    "password_hash_field": "password_hash",
                    "salt_field": "salt"
                  },
                  {
                    "mechanism": "password_based",
                    "server": "127.0.0.1:6379",
                    "cmd": "HMGET ${username} password_hash salt",
                    "database": 0,
                    "backend": "redis",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "redis_type": "single"
                  }
                ],
                "schema": {
                  "type": "array",
                  "items": {
                    "oneOf": [
                      {
                        "$ref": "#/components/schemas/authn.ldap_deprecated"
                      },
                      {
                        "$ref": "#/components/schemas/authn.ldap"
                      },
                      {
                        "$ref": "#/components/schemas/authn.scram"
                      },
                      {
                        "$ref": "#/components/schemas/authn.jwt_jwks"
                      },
                      {
                        "$ref": "#/components/schemas/authn.jwt_public_key"
                      },
                      {
                        "$ref": "#/components/schemas/authn.jwt_hmac"
                      },
                      {
                        "$ref": "#/components/schemas/authn.http_post"
                      },
                      {
                        "$ref": "#/components/schemas/authn.http_get"
                      },
                      {
                        "$ref": "#/components/schemas/authn.redis_sentinel"
                      },
                      {
                        "$ref": "#/components/schemas/authn.redis_cluster"
                      },
                      {
                        "$ref": "#/components/schemas/authn.redis_single"
                      },
                      {
                        "$ref": "#/components/schemas/authn.mongo_sharded"
                      },
                      {
                        "$ref": "#/components/schemas/authn.mongo_rs"
                      },
                      {
                        "$ref": "#/components/schemas/authn.mongo_single"
                      },
                      {
                        "$ref": "#/components/schemas/authn.postgresql"
                      },
                      {
                        "$ref": "#/components/schemas/authn.mysql"
                      },
                      {
                        "$ref": "#/components/schemas/authn.builtin_db"
                      }
                    ]
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Create authenticator for global authentication.",
        "tags": [
          "Authentication"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "jwt": {
                    "value": {
                      "mechanism": "jwt",
                      "secret": "mysecret",
                      "algorithm": "hmac-based",
                      "secret_base64_encoded": false,
                      "use_jwks": false,
                      "verify_claims": {
                        "username": "${username}"
                      }
                    },
                    "summary": "JWT authentication"
                  },
                  "password_based:built_in_database": {
                    "value": {
                      "mechanism": "password_based",
                      "backend": "built_in_database",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "user_id_type": "username"
                    },
                    "summary": "Built-in password_based authentication"
                  },
                  "password_based:http": {
                    "value": {
                      "ssl": {
                        "enable": false
                      },
                      "connect_timeout": "5s",
                      "mechanism": "password_based",
                      "pool_size": 8,
                      "body": {
                        "password": "${password}",
                        "username": "${username}"
                      },
                      "headers": {
                        "content-type": "application/json"
                      },
                      "method": "post",
                      "url": "http://127.0.0.1:18083",
                      "backend": "http",
                      "request_timeout": "5s",
                      "enable_pipelining": 100
                    },
                    "summary": "password_based authentication through external HTTP API"
                  },
                  "password_based:mongodb": {
                    "value": {
                      "mechanism": "password_based",
                      "filter": {
                        "username": "${username}"
                      },
                      "server": "127.0.0.1:27017",
                      "database": "example",
                      "backend": "mongodb",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "collection": "users",
                      "is_superuser_field": "is_superuser",
                      "password_hash_field": "password_hash",
                      "salt_field": "salt"
                    },
                    "summary": "password_based authentication with MongoDB backend"
                  },
                  "password_based:redis": {
                    "value": {
                      "mechanism": "password_based",
                      "server": "127.0.0.1:6379",
                      "cmd": "HMGET ${username} password_hash salt",
                      "database": 0,
                      "backend": "redis",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "redis_type": "single"
                    },
                    "summary": "password_based authentication with Redis backend"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authn.ldap_deprecated"
                    },
                    {
                      "$ref": "#/components/schemas/authn.ldap"
                    },
                    {
                      "$ref": "#/components/schemas/authn.scram"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_jwks"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_public_key"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_hmac"
                    },
                    {
                      "$ref": "#/components/schemas/authn.http_post"
                    },
                    {
                      "$ref": "#/components/schemas/authn.http_get"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_single"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_sharded"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_rs"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_single"
                    },
                    {
                      "$ref": "#/components/schemas/authn.postgresql"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mysql"
                    },
                    {
                      "$ref": "#/components/schemas/authn.builtin_db"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "409": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "ALREADY_EXISTS"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "ALREADY_EXISTS"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "jwt": {
                  "value": {
                    "mechanism": "jwt",
                    "secret": "mysecret",
                    "algorithm": "hmac-based",
                    "secret_base64_encoded": false,
                    "use_jwks": false,
                    "verify_claims": {
                      "username": "${username}"
                    }
                  },
                  "summary": "JWT authentication"
                },
                "password_based:built_in_database": {
                  "value": {
                    "mechanism": "password_based",
                    "backend": "built_in_database",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "user_id_type": "username"
                  },
                  "summary": "Built-in password_based authentication"
                },
                "password_based:http": {
                  "value": {
                    "ssl": {
                      "enable": false
                    },
                    "connect_timeout": "5s",
                    "mechanism": "password_based",
                    "pool_size": 8,
                    "body": {
                      "password": "${password}",
                      "username": "${username}"
                    },
                    "headers": {
                      "content-type": "application/json"
                    },
                    "method": "post",
                    "url": "http://127.0.0.1:18083",
                    "backend": "http",
                    "request_timeout": "5s",
                    "enable_pipelining": 100
                  },
                  "summary": "password_based authentication through external HTTP API"
                },
                "password_based:mongodb": {
                  "value": {
                    "mechanism": "password_based",
                    "filter": {
                      "username": "${username}"
                    },
                    "server": "127.0.0.1:27017",
                    "database": "example",
                    "backend": "mongodb",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "collection": "users",
                    "is_superuser_field": "is_superuser",
                    "password_hash_field": "password_hash",
                    "salt_field": "salt"
                  },
                  "summary": "password_based authentication with MongoDB backend"
                },
                "password_based:redis": {
                  "value": {
                    "mechanism": "password_based",
                    "server": "127.0.0.1:6379",
                    "cmd": "HMGET ${username} password_hash salt",
                    "database": 0,
                    "backend": "redis",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "redis_type": "single"
                  },
                  "summary": "password_based authentication with Redis backend"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/authn.ldap_deprecated"
                  },
                  {
                    "$ref": "#/components/schemas/authn.ldap"
                  },
                  {
                    "$ref": "#/components/schemas/authn.scram"
                  },
                  {
                    "$ref": "#/components/schemas/authn.jwt_jwks"
                  },
                  {
                    "$ref": "#/components/schemas/authn.jwt_public_key"
                  },
                  {
                    "$ref": "#/components/schemas/authn.jwt_hmac"
                  },
                  {
                    "$ref": "#/components/schemas/authn.http_post"
                  },
                  {
                    "$ref": "#/components/schemas/authn.http_get"
                  },
                  {
                    "$ref": "#/components/schemas/authn.redis_sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/authn.redis_cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn.redis_single"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mongo_sharded"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mongo_rs"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mongo_single"
                  },
                  {
                    "$ref": "#/components/schemas/authn.postgresql"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mysql"
                  },
                  {
                    "$ref": "#/components/schemas/authn.builtin_db_api"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/clients/{clientid}/subscribe": {
      "post": {
        "description": "Subscribe",
        "tags": [
          "Clients"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_subscriptions.subscription"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "CLIENTID_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Client ID not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx_mgmt_api_clients.subscribe"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/trace": {
      "get": {
        "description": "List all trace",
        "tags": [
          "Trace"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/trace.trace"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Clear all traces",
        "tags": [
          "Trace"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": "No Content"
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Create new trace",
        "tags": [
          "Trace"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/trace.trace"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "INVALID_PARAMS"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "invalid trace params"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "409": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "ALREADY_EXISTS",
                        "DUPLICATE_CONDITION",
                        "BAD_TYPE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "trace already exists"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "required": [
                  "name",
                  "type"
                ],
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Unique name of the trace. Only ASCII letters in a-z, A-Z, 0-9 and underscore '_' are allowed.",
                    "example": "EMQX-TRACE-1"
                  },
                  "type": {
                    "type": "string",
                    "enum": [
                      "clientid",
                      "topic",
                      "ip_address",
                      "ruleid"
                    ],
                    "description": "Filter type",
                    "example": "clientid"
                  },
                  "topic": {
                    "type": "string",
                    "description": "Specify the topic or topic filter if the trace 'type' is 'topic'.",
                    "example": "/dev/#"
                  },
                  "clientid": {
                    "type": "string",
                    "description": "Specify the MQTT clientid if the trace 'type' is 'clientid'.",
                    "example": "dev-001"
                  },
                  "ip_address": {
                    "type": "string",
                    "description": "Specify the client's IP address if the trace type is 'ip_address'.",
                    "example": "127.0.0.1"
                  },
                  "ruleid": {
                    "type": "string",
                    "example": "my_rule"
                  },
                  "payload_encode": {
                    "default": "text",
                    "type": "string",
                    "enum": [
                      "hex",
                      "text",
                      "hidden"
                    ],
                    "description": "Determine the format of the payload format in the trace file.<br/><br/>`text`: Text-based protocol or plain text protocol.<br/> It is recommended when payload is JSON encoded.<br/><br/>`hex`: Binary hexadecimal encode.It is recommended when payload is a custom binary protocol.<br/><br/>`hidden`: payload is obfuscated as `******`"
                  },
                  "start_at": {
                    "description": "rfc3339 timestamp or epoch second",
                    "example": "2021-11-04T18:17:38+08:00",
                    "oneOf": [
                      {
                        "type": "integer",
                        "description": "epoch-second",
                        "example": 1640995200
                      },
                      {
                        "type": "string",
                        "format": "date-time",
                        "example": "2022-01-01T00:00:00.000Z"
                      }
                    ]
                  },
                  "end_at": {
                    "description": "rfc3339 timestamp or epoch second",
                    "example": "2021-11-05T18:17:38+08:00",
                    "oneOf": [
                      {
                        "type": "integer",
                        "description": "epoch-second",
                        "example": 1640995200
                      },
                      {
                        "type": "string",
                        "format": "date-time",
                        "example": "2022-01-01T00:00:00.000Z"
                      }
                    ]
                  },
                  "formatter": {
                    "description": "The formatter that will be used to format the trace log entries. Set this to text to format the log entries as plain text (default). Set it to json to format each log entry as a JSON object.",
                    "example": "text",
                    "oneOf": [
                      {
                        "type": "string",
                        "enum": [
                          "json"
                        ]
                      },
                      {
                        "type": "string",
                        "enum": [
                          "text"
                        ]
                      }
                    ]
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/nodes/{node}/connectors/{id}/{operation}": {
      "post": {
        "description": "Start connector on a specific node.",
        "tags": [
          "Connectors"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "node",
            "description": "The node name, e.g. 'emqx@127.0.0.1'.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "emqx@127.0.0.1"
          },
          {
            "in": "path",
            "name": "id",
            "description": "The connector id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_connector"
          },
          {
            "in": "path",
            "name": "operation",
            "description": "Operation can be one of: 'start'.",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "start"
              ]
            },
            "example": "start"
          }
        ],
        "summary": "Manually start a connector on a given node",
        "responses": {
          "204": {
            "description": "Operation success"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Problem with configuration of external service or connector not enabled"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Connector or node not found or invalid operation"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "501": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_IMPLEMENTED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Implemented"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Service unavailable"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/clients/{clientid}/mqueue_messages": {
      "get": {
        "description": "Get client mqueue messages",
        "tags": [
          "Clients"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "payload",
            "description": "Client's inflight/mqueue messages payload encoding. If set to `none`, no payload is returned in the response.",
            "schema": {
              "default": "base64",
              "type": "string",
              "enum": [
                "none",
                "base64",
                "plain"
              ]
            }
          },
          {
            "in": "query",
            "name": "max_payload_bytes",
            "description": "Client's inflight/mqueue messages payload limit. The total payload size of all messages in the response will not exceed this value. Messages beyond the limit will be silently omitted in the response. The only exception to this rule is when the first message payload is already larger than the limit. In this case, the first message will be returned in the response.",
            "schema": {
              "default": "1MB",
              "type": "string",
              "example": "32MB"
            }
          },
          {
            "$ref": "#/components/parameters/public.position"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "data": [
                    {
                      "from_clientid": "mqttx_59ac0a87",
                      "from_username": "test-user",
                      "mqueue_priority": 0,
                      "msgid": "000611F460D57FA9F44500000D360002",
                      "payload": "eyJmb28iOiAiYmFyIn0=",
                      "publish_at": 1709055346487,
                      "qos": 0,
                      "topic": "t/test"
                    }
                  ],
                  "meta": {
                    "count": 100,
                    "last": "1710785444656449826_10"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_clients.mqueue_messages"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "INVALID_PARAMETER"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Invalid parameters"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "CLIENTID_NOT_FOUND",
                        "CLIENT_SHUTDOWN"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Client ID not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "501": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_IMPLEMENTED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "API not implemented"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/actions_probe": {
      "post": {
        "description": "Test creating a new bridge.",
        "tags": [
          "Actions"
        ],
        "parameters": [],
        "summary": "Test creating bridge",
        "responses": {
          "204": {
            "description": "Test bridge OK"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "TEST_FAILED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "bridge test failed"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "http": {
                  "value": {
                    "name": "my_http_action",
                    "type": "http",
                    "enable": true,
                    "parameters": {
                      "path": "/room/${room_no}",
                      "body": "${.}",
                      "headers": {},
                      "method": "post"
                    },
                    "connector": "my_http_connector",
                    "resource_opts": {
                      "worker_pool_size": 16,
                      "query_mode": "async",
                      "health_check_interval": "15s"
                    }
                  },
                  "summary": "HTTP Action"
                },
                "mqtt": {
                  "value": {
                    "name": "mqtt_action",
                    "type": "mqtt",
                    "description": "My example mqtt action",
                    "enable": true,
                    "parameters": {
                      "retain": false,
                      "payload": "${.payload}",
                      "topic": "remote/topic",
                      "qos": 2
                    },
                    "connector": "mqtt_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "MQTT Producer Action"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/bridge_mqtt_publisher.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_http.post_bridge_v2"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/clients/{clientid}/inflight_messages": {
      "get": {
        "description": "Get client in-flight messages",
        "tags": [
          "Clients"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "payload",
            "description": "Client's inflight/mqueue messages payload encoding. If set to `none`, no payload is returned in the response.",
            "schema": {
              "default": "base64",
              "type": "string",
              "enum": [
                "none",
                "base64",
                "plain"
              ]
            }
          },
          {
            "in": "query",
            "name": "max_payload_bytes",
            "description": "Client's inflight/mqueue messages payload limit. The total payload size of all messages in the response will not exceed this value. Messages beyond the limit will be silently omitted in the response. The only exception to this rule is when the first message payload is already larger than the limit. In this case, the first message will be returned in the response.",
            "schema": {
              "default": "1MB",
              "type": "string",
              "example": "32MB"
            }
          },
          {
            "$ref": "#/components/parameters/public.position"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "data": [
                    {
                      "from_clientid": "mqttx_59ac0a87",
                      "from_username": "test-user",
                      "msgid": "000611F460D57FA9F44500000D360002",
                      "payload": "eyJmb28iOiAiYmFyIn0=",
                      "publish_at": 1709055346487,
                      "qos": 0,
                      "topic": "t/test"
                    }
                  ],
                  "meta": {
                    "count": 100,
                    "last": "1710785444656449826"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_clients.inflight_messages"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "INVALID_PARAMETER"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Invalid parameters"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "CLIENTID_NOT_FOUND",
                        "CLIENT_SHUTDOWN"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Client ID not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "501": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_IMPLEMENTED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "API not implemented"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/relup/status": {
      "get": {
        "description": "Get the hot upgrade status of all nodes",
        "tags": [
          "Relup"
        ],
        "parameters": [],
        "summary": "Get the hot upgrade status of all nodes",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/relup.running_status"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/exhooks/{name}/move": {
      "post": {
        "description": "Move the server.<br/>NOTE: The position should be \"front | rear | before:{name} | after:{name}",
        "tags": [
          "ExHook"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "The Exhook server name",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "default"
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "500": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_RPC"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad RPC"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "rear": {
                  "value": {
                    "position": "rear"
                  },
                  "summary": "absolute position 'rear'"
                },
                "front": {
                  "value": {
                    "position": "front"
                  },
                  "summary": "absolute position 'front'"
                },
                "related_after": {
                  "value": {
                    "position": "after:default"
                  },
                  "summary": "relative position 'after'"
                },
                "related_before": {
                  "value": {
                    "position": "before:default"
                  },
                  "summary": "relative position 'before'"
                }
              },
              "schema": {
                "$ref": "#/components/schemas/exhook.move_req"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/slow_subscriptions/settings": {
      "get": {
        "description": "View slow subs settings",
        "tags": [
          "Slow Subscriptions"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/slow_subs.slow_subs"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update slow subs settings",
        "tags": [
          "Slow Subscriptions"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/slow_subs.slow_subs"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/slow_subs.slow_subs"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/prometheus/auth": {
      "get": {
        "description": "Get Prometheus Metrics for AuthN, AuthZ and Banned",
        "tags": [
          "Monitor"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_prometheus_api.mode"
          }
        ],
        "responses": {
          "200": {
            "description": "Get Prometheus Data.",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          }
        },
        "security": []
      }
    },
    "/mqtt/topic_metrics": {
      "get": {
        "description": "List topic metrics",
        "tags": [
          "MQTT"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "List topic metrics",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/emqx_topic_metrics_api.topic_metrics"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Reset telemetry status",
        "tags": [
          "MQTT"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": "Reset telemetry status"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "TOPIC_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found. Topic metrics not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "reset_all_topic_metrics": {
                  "value": {
                    "action": "reset"
                  },
                  "summary": "reset_all_topic_metrics"
                },
                "reset_specific_one_topic_metrics": {
                  "value": {
                    "action": "reset",
                    "topic": "testtopic/1"
                  },
                  "summary": "reset_specific_one_topic_metrics"
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_topic_metrics_api.reset"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Create topic metrics",
        "tags": [
          "MQTT"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": "Create topic metrics"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST",
                        "BAD_TOPIC"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request. Already exists or bad topic name"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "409": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "EXCEED_LIMIT"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Conflict. Topic metrics exceeded max limit 512"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "required": [
                  "topic"
                ],
                "properties": {
                  "topic": {
                    "type": "string",
                    "description": "Raw topic string",
                    "example": "testtopic/1"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/error_codes/{code}": {
      "get": {
        "description": "API Error Codes",
        "tags": [
          "Error Codes"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "code",
            "description": "API Error Codes",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "BAD_USERNAME_OR_PWD",
                "BAD_API_KEY_OR_SECRET",
                "BAD_REQUEST",
                "NOT_MATCH",
                "ALREADY_EXISTS",
                "BAD_CONFIG_SCHEMA",
                "BAD_LISTENER_ID",
                "BAD_NODE_NAME",
                "BAD_RPC",
                "BAD_TOPIC",
                "EXCEED_LIMIT",
                "INVALID_PARAMETER",
                "CONFLICT",
                "NO_DEFAULT_VALUE",
                "DEPENDENCY_EXISTS",
                "MESSAGE_ID_SCHEMA_ERROR",
                "INVALID_ID",
                "MESSAGE_ID_NOT_FOUND",
                "NOT_FOUND",
                "CLIENTID_NOT_FOUND",
                "CLIENT_NOT_FOUND",
                "RESOURCE_NOT_FOUND",
                "TOPIC_NOT_FOUND",
                "USER_NOT_FOUND",
                "INTERNAL_ERROR",
                "SERVICE_UNAVAILABLE",
                "SOURCE_ERROR",
                "UPDATE_FAILED",
                "REST_FAILED",
                "CLIENT_NOT_RESPONSE",
                "UNSUPPORTED_MEDIA_TYPE"
              ]
            },
            "example": "BAD_USERNAME_OR_PWD"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/dashboard.error_code"
                }
              }
            }
          }
        },
        "security": []
      }
    },
    "/bridges/{id}/{operation}": {
      "post": {
        "description": "Stop/Restart bridges on all nodes in the cluster.",
        "tags": [
          "Bridges"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge Id. Must be of format {type}:{name}",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:http_example"
          },
          {
            "in": "path",
            "name": "operation",
            "description": "Operations can be one of: stop, restart",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "start",
                "stop",
                "restart"
              ]
            },
            "example": "start"
          }
        ],
        "summary": "Stop or restart bridge",
        "responses": {
          "204": {
            "description": "Operation success"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Problem with configuration of external service"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bridge not found or invalid operation"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "501": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_IMPLEMENTED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Implemented"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Service unavailable"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/{name}/clients/{clientid}/subscriptions/{topic}": {
      "delete": {
        "description": "Delete a subscriptions membership",
        "tags": [
          "Gateway Clients"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "topic",
            "description": "Topic Filter/Name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "clientid",
            "description": "Client ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "lwm2m",
                "mqttsn",
                "stomp"
              ]
            }
          }
        ],
        "summary": "Delete client's subscription",
        "responses": {
          "204": {
            "description": "Unsubscribed"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/action_types": {
      "get": {
        "description": "Lists the available action types.",
        "tags": [
          "Actions"
        ],
        "parameters": [],
        "summary": "List available action types",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "types": {
                    "value": [
                      "http",
                      "mqtt"
                    ],
                    "summary": "Action types"
                  }
                },
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "enum": [
                      "http",
                      "mqtt"
                    ]
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/mqtt/delayed/messages": {
      "get": {
        "description": "List delayed messages",
        "tags": [
          "MQTT"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "data": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/emqx_delayed_api.message"
                      }
                    },
                    "meta": {
                      "properties": {
                        "page": {
                          "type": "integer",
                          "description": "View page",
                          "minimum": 1
                        },
                        "limit": {
                          "type": "integer",
                          "description": "Page limit",
                          "minimum": 1
                        },
                        "count": {
                          "type": "integer",
                          "description": "Count of delayed messages",
                          "minimum": 0
                        }
                      },
                      "type": "object"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/users/{username}": {
      "put": {
        "description": "Update dashboard user description",
        "tags": [
          "Dashboard"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "username",
            "description": "Dashboard Username",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "admin"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "username": {
                      "type": "string",
                      "description": "Dashboard Username",
                      "maxLength": 100,
                      "example": "admin"
                    },
                    "description": {
                      "type": "string",
                      "description": "Dashboard User Description",
                      "example": "administrator"
                    },
                    "backend": {
                      "type": "string",
                      "description": "User account source",
                      "example": "local"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "USER_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Dashboard user not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "description": {
                    "type": "string",
                    "description": "Dashboard User Description",
                    "example": "administrator"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete dashboard user",
        "tags": [
          "Dashboard"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "username",
            "description": "Dashboard Username",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "admin"
          }
        ],
        "responses": {
          "204": {
            "description": "Delete User successfully"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST",
                        "NOT_ALLOWED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Login failed. Bad username or password"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "USER_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Dashboard user not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/exhooks": {
      "get": {
        "description": "List all servers",
        "tags": [
          "ExHook"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/exhook.detail_server_info"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Add a server",
        "tags": [
          "ExHook"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/exhook.detail_server_info"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Already exists"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "500": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_RPC"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad RPC"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "example": {
                "name": "default",
                "ssl": {
                  "enable": false,
                  "certfile": "/etc/emqx/certs/cert.pem",
                  "keyfile": "/etc/emqx/certs/key.pem",
                  "cacertfile": "/etc/emqx/certs/cacert.pem"
                },
                "pool_size": 8,
                "enable": true,
                "url": "http://127.0.0.1:8081",
                "request_timeout": "5s",
                "auto_reconnect": "60s",
                "failed_action": "deny"
              },
              "schema": {
                "$ref": "#/components/schemas/exhook.server_config"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/lwm2m/clients/{clientid}/lookup": {
      "get": {
        "description": "Look up a resource",
        "tags": [
          "LwM2M Gateways"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "urn:oma:lwm2m:oma:2"
          },
          {
            "in": "query",
            "name": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "/3/0/7"
          },
          {
            "in": "query",
            "name": "action",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "discover"
          }
        ],
        "summary": "List Client's Resources",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "clientid": {
                      "type": "string",
                      "example": "urn:oma:lwm2m:oma:2"
                    },
                    "path": {
                      "type": "string",
                      "example": "/3/0/7"
                    },
                    "action": {
                      "type": "string",
                      "example": "discover"
                    },
                    "codeMsg": {
                      "type": "string",
                      "example": "reply_not_received"
                    },
                    "content": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/lwm2m.resource"
                      }
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "CLIENT_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Client not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/rules/{id}/metrics": {
      "get": {
        "description": "Get a rule's metrics by given Id",
        "tags": [
          "Rules"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "my_rule_id"
          }
        ],
        "summary": "Get rule metrics",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/rule_engine.rule_metrics"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Rule not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/slow_subscriptions": {
      "get": {
        "description": "View slow topics statistics record data",
        "tags": [
          "Slow Subscriptions"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "data": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/slow_subscribers_statistics.record"
                      }
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Clear current data and re count slow topic",
        "tags": [
          "Slow Subscriptions"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": "No Content"
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/{name}": {
      "get": {
        "description": "Get the gateway configurations",
        "tags": [
          "Gateways"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "lwm2m",
                "mqttsn",
                "stomp"
              ]
            },
            "example": "stomp"
          }
        ],
        "summary": "Get gateway",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "coap_gateway": {
                    "value": {
                      "name": "coap",
                      "enable": true,
                      "heartbeat": "30s",
                      "listeners": [
                        {
                          "name": "default",
                          "type": "udp",
                          "bind": "5683",
                          "max_connections": 1024000,
                          "max_conn_rate": 1000
                        }
                      ],
                      "idle_timeout": "30s",
                      "mountpoint": "coap/",
                      "connection_required": false,
                      "enable_stats": true,
                      "notify_type": "qos",
                      "publish_qos": "coap",
                      "subscribe_qos": "coap"
                    },
                    "summary": "A simple CoAP gateway config"
                  },
                  "exproto_gateway": {
                    "value": {
                      "name": "exproto",
                      "handler": {
                        "address": "http://127.0.0.1:9001"
                      },
                      "server": {
                        "bind": "9100"
                      },
                      "enable": true,
                      "listeners": [
                        {
                          "name": "default",
                          "type": "tcp",
                          "bind": "7993",
                          "max_connections": 1024000,
                          "max_conn_rate": 1000
                        }
                      ],
                      "idle_timeout": "30s",
                      "mountpoint": "exproto/",
                      "enable_stats": true
                    },
                    "summary": "A simple ExProto gateway config"
                  },
                  "gbt32960_gateway": {
                    "value": {
                      "message_queue_len": 10,
                      "name": "gbt32960",
                      "enable": true,
                      "listeners": [
                        {
                          "name": "default",
                          "type": "tcp",
                          "bind": "7325",
                          "max_connections": 1024000,
                          "max_conn_rate": 1000
                        }
                      ],
                      "mountpoint": "gbt32960/${clientid}",
                      "retry_interval": "8s",
                      "enable_stats": true,
                      "max_retry_times": 3
                    },
                    "summary": "A simple GBT32960 gateway config"
                  },
                  "lwm2m_gateway": {
                    "value": {
                      "name": "lwm2m",
                      "enable": true,
                      "listeners": [
                        {
                          "name": "default",
                          "type": "udp",
                          "bind": "5783",
                          "max_connections": 1024000,
                          "max_conn_rate": 1000
                        }
                      ],
                      "idle_timeout": "30s",
                      "mountpoint": "lwm2m/",
                      "enable_stats": true,
                      "auto_observe": false,
                      "lifetime_max": "86400s",
                      "lifetime_min": "1s",
                      "qmode_time_window": "22s",
                      "translators": {
                        "command": {
                          "topic": "dn/#"
                        },
                        "notify": {
                          "topic": "up/notify"
                        },
                        "register": {
                          "topic": "up/resp"
                        },
                        "update": {
                          "topic": "up/resp"
                        },
                        "response": {
                          "topic": "up/resp"
                        }
                      },
                      "update_msg_publish_condition": "always",
                      "xml_dir": "/etc/emqx/lwm2m_xml"
                    },
                    "summary": "A simple LwM2M gateway config"
                  },
                  "mqttsn_gateway": {
                    "value": {
                      "name": "mqttsn",
                      "broadcast": true,
                      "enable": true,
                      "predefined": [
                        {
                          "id": "1001",
                          "topic": "pred/1001"
                        },
                        {
                          "id": "1002",
                          "topic": "pred/1002"
                        }
                      ],
                      "listeners": [
                        {
                          "name": "default",
                          "type": "udp",
                          "bind": "1884",
                          "max_connections": 1024000,
                          "max_conn_rate": 1000
                        }
                      ],
                      "idle_timeout": "30s",
                      "mountpoint": "mqttsn/",
                      "enable_stats": true,
                      "enable_qos3": true,
                      "gateway_id": 1
                    },
                    "summary": "A simple MQTT-SN gateway config"
                  },
                  "ocpp_gateway": {
                    "value": {
                      "name": "ocpp",
                      "enable": true,
                      "upstream": {
                        "topic": "cp/${cid}",
                        "error_topic": "cp/${cid}/error",
                        "reply_topic": "cp/${cid}/reply"
                      },
                      "listeners": [
                        {
                          "name": "default",
                          "type": "ws",
                          "bind": "33033",
                          "max_connections": 1024000
                        }
                      ],
                      "mountpoint": "ocpp/",
                      "enable_stats": true,
                      "default_heartbeat_interval": "60s",
                      "dnstream": {
                        "topic": "cp/${cid}"
                      },
                      "message_format_checking": "disable"
                    },
                    "summary": "A simple OCPP gateway config"
                  },
                  "stomp_gateway": {
                    "value": {
                      "name": "stomp",
                      "enable": true,
                      "frame": {
                        "max_headers": 10,
                        "max_body_length": 65535,
                        "max_headers_length": 1024
                      },
                      "listeners": [
                        {
                          "name": "default",
                          "type": "tcp",
                          "bind": "61613",
                          "max_connections": 1024000,
                          "max_conn_rate": 1000
                        }
                      ],
                      "idle_timeout": "30s",
                      "mountpoint": "stomp/",
                      "enable_stats": true
                    },
                    "summary": "A simple STOMP gateway config"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.stomp"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.mqttsn"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.lwm2m"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.exproto"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.coap"
                    }
                  ]
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update the gateway basic configurations and running status.<br/><br/>Note: The Authentication and Listener configurations should be updated by other special APIs.",
        "tags": [
          "Gateways"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "lwm2m",
                "mqttsn",
                "stomp"
              ]
            },
            "example": "stomp"
          }
        ],
        "summary": "Load or update the gateway confs",
        "responses": {
          "204": {
            "description": "Gateway configuration updated"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "coap_gateway": {
                  "value": {
                    "enable": true,
                    "heartbeat": "30s",
                    "idle_timeout": "30s",
                    "mountpoint": "coap2/",
                    "connection_required": false,
                    "enable_stats": true,
                    "notify_type": "qos",
                    "publish_qos": "coap",
                    "subscribe_qos": "coap"
                  },
                  "summary": "A simple CoAP gateway config"
                },
                "exproto_gateway": {
                  "value": {
                    "handler": {
                      "address": "http://127.0.0.1:9001"
                    },
                    "server": {
                      "bind": "9100"
                    },
                    "enable": true,
                    "idle_timeout": "30s",
                    "mountpoint": "exproto2/",
                    "enable_stats": true
                  },
                  "summary": "A simple ExProto gateway config"
                },
                "gbt32960_gateway": {
                  "value": {
                    "message_queue_len": 10,
                    "enable": true,
                    "mountpoint": "gbt32960/${clientid}",
                    "retry_interval": "8s",
                    "enable_stats": true,
                    "max_retry_times": 3
                  },
                  "summary": "A simple GBT32960 gateway config"
                },
                "lwm2m_gateway": {
                  "value": {
                    "enable": true,
                    "idle_timeout": "30s",
                    "mountpoint": "lwm2m2/",
                    "enable_stats": true,
                    "auto_observe": false,
                    "lifetime_max": "86400s",
                    "lifetime_min": "1s",
                    "qmode_time_window": "22s",
                    "translators": {
                      "command": {
                        "topic": "dn/#"
                      },
                      "notify": {
                        "topic": "up/notify"
                      },
                      "register": {
                        "topic": "up/resp"
                      },
                      "update": {
                        "topic": "up/resp"
                      },
                      "response": {
                        "topic": "up/resp"
                      }
                    },
                    "update_msg_publish_condition": "always",
                    "xml_dir": "/etc/emqx/lwm2m_xml"
                  },
                  "summary": "A simple LwM2M gateway config"
                },
                "mqttsn_gateway": {
                  "value": {
                    "broadcast": true,
                    "enable": true,
                    "predefined": [
                      {
                        "id": "1003",
                        "topic": "pred/1003"
                      }
                    ],
                    "idle_timeout": "30s",
                    "mountpoint": "mqttsn2/",
                    "enable_stats": true,
                    "enable_qos3": false,
                    "gateway_id": 1
                  },
                  "summary": "A simple MQTT-SN gateway config"
                },
                "ocpp_gateway": {
                  "value": {
                    "enable": true,
                    "upstream": {
                      "topic": "cp/${cid}",
                      "error_topic": "cp/${cid}/error",
                      "reply_topic": "cp/${cid}/reply"
                    },
                    "mountpoint": "ocpp/",
                    "enable_stats": true,
                    "default_heartbeat_interval": "60s",
                    "dnstream": {
                      "topic": "cp/${cid}"
                    },
                    "message_format_checking": "disable"
                  },
                  "summary": "A simple OCPP gateway config"
                },
                "stomp_gateway": {
                  "value": {
                    "enable": true,
                    "frame": {
                      "max_headers": 100,
                      "max_body_length": 655350,
                      "max_headers_length": 10240
                    },
                    "idle_timeout": "30s",
                    "mountpoint": "stomp2/",
                    "enable_stats": true
                  },
                  "summary": "A simple STOMP gateway config"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.update_stomp"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.update_mqttsn"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.update_lwm2m"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.update_exproto"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.update_coap"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.stomp"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.mqttsn"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.lwm2m"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.exproto"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.coap"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/nodes": {
      "get": {
        "description": "List EMQX nodes",
        "tags": [
          "Nodes"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "List all EMQX nodes",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/emqx_mgmt_api_nodes.node_info"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/actions/{id}": {
      "get": {
        "description": "Get a bridge by id.",
        "tags": [
          "Actions"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_action"
          }
        ],
        "summary": "Get bridge",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "http": {
                    "value": {
                      "name": "my_http_action",
                      "status": "connected",
                      "type": "http",
                      "enable": true,
                      "parameters": {
                        "path": "/room/${room_no}",
                        "body": "${.}",
                        "headers": {},
                        "method": "post"
                      },
                      "connector": "my_http_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "worker_pool_size": 16,
                        "query_mode": "async",
                        "health_check_interval": "15s"
                      }
                    },
                    "summary": "HTTP Action"
                  },
                  "mqtt": {
                    "value": {
                      "name": "mqtt_action",
                      "status": "connected",
                      "type": "mqtt",
                      "description": "My example mqtt action",
                      "enable": true,
                      "parameters": {
                        "retain": false,
                        "payload": "${.payload}",
                        "topic": "remote/topic",
                        "qos": 2
                      },
                      "connector": "mqtt_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "MQTT Producer Action"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/bridge_mqtt_publisher.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_http.get_bridge_v2"
                    }
                  ]
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bridge not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update a bridge by id.",
        "tags": [
          "Actions"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_action"
          }
        ],
        "summary": "Update bridge",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "http": {
                    "value": {
                      "name": "my_http_action",
                      "status": "connected",
                      "type": "http",
                      "enable": true,
                      "parameters": {
                        "path": "/room/${room_no}",
                        "body": "${.}",
                        "headers": {},
                        "method": "post"
                      },
                      "connector": "my_http_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "worker_pool_size": 16,
                        "query_mode": "async",
                        "health_check_interval": "15s"
                      }
                    },
                    "summary": "HTTP Action"
                  },
                  "mqtt": {
                    "value": {
                      "name": "mqtt_action",
                      "status": "connected",
                      "type": "mqtt",
                      "description": "My example mqtt action",
                      "enable": true,
                      "parameters": {
                        "retain": false,
                        "payload": "${.payload}",
                        "topic": "remote/topic",
                        "qos": 2
                      },
                      "connector": "mqtt_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "MQTT Producer Action"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/bridge_mqtt_publisher.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_http.get_bridge_v2"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Update bridge failed"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bridge not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "http": {
                  "value": {
                    "enable": true,
                    "parameters": {
                      "path": "/room/${room_no}",
                      "body": "${.}",
                      "headers": {},
                      "method": "post"
                    },
                    "connector": "my_http_connector",
                    "resource_opts": {
                      "worker_pool_size": 16,
                      "query_mode": "async",
                      "health_check_interval": "15s"
                    }
                  },
                  "summary": "HTTP Action"
                },
                "mqtt": {
                  "value": {
                    "description": "My example mqtt action",
                    "enable": true,
                    "parameters": {
                      "retain": false,
                      "payload": "${.payload}",
                      "topic": "remote/topic",
                      "qos": 2
                    },
                    "connector": "mqtt_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "MQTT Producer Action"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/bridge_mqtt_publisher.put_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_http.put_bridge_v2"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete a bridge by id.",
        "tags": [
          "Actions"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_action"
          },
          {
            "in": "query",
            "name": "also_delete_dep_actions",
            "description": "Whether to cascade delete dependent actions.",
            "required": false,
            "schema": {
              "default": false,
              "type": "boolean"
            }
          }
        ],
        "summary": "Delete bridge",
        "responses": {
          "204": {
            "description": "Bridge deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "rules": {
                      "type": "array",
                      "description": "Dependent Rule IDs",
                      "items": {
                        "type": "string"
                      }
                    },
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Cannot delete bridge while active rules are defined for this bridge"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bridge not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Service unavailable"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/authorization/sources/{type}": {
      "get": {
        "description": "Get a authorization source",
        "tags": [
          "Authorization"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "type",
            "description": "Authorization type",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "file",
                "built_in_database",
                "http",
                "redis",
                "mysql",
                "postgresql",
                "mongodb",
                "ldap"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Authorization source",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authz.ldap"
                    },
                    {
                      "$ref": "#/components/schemas/authz.mongo_sharded"
                    },
                    {
                      "$ref": "#/components/schemas/authz.mongo_rs"
                    },
                    {
                      "$ref": "#/components/schemas/authz.mongo_single"
                    },
                    {
                      "$ref": "#/components/schemas/authz.postgresql"
                    },
                    {
                      "$ref": "#/components/schemas/authz.mysql"
                    },
                    {
                      "$ref": "#/components/schemas/authz.redis_cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authz.redis_sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authz.redis_single"
                    },
                    {
                      "$ref": "#/components/schemas/authz.http_post"
                    },
                    {
                      "$ref": "#/components/schemas/authz.http_get"
                    },
                    {
                      "$ref": "#/components/schemas/authz.builtin_db"
                    },
                    {
                      "$ref": "#/components/schemas/authz.api_file"
                    }
                  ]
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update source",
        "tags": [
          "Authorization"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "type",
            "description": "Authorization type",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "file",
                "built_in_database",
                "http",
                "redis",
                "mysql",
                "postgresql",
                "mongodb",
                "ldap"
              ]
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Authorization source updated successfully"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/authz.ldap"
                  },
                  {
                    "$ref": "#/components/schemas/authz.mongo_sharded"
                  },
                  {
                    "$ref": "#/components/schemas/authz.mongo_rs"
                  },
                  {
                    "$ref": "#/components/schemas/authz.mongo_single"
                  },
                  {
                    "$ref": "#/components/schemas/authz.postgresql"
                  },
                  {
                    "$ref": "#/components/schemas/authz.mysql"
                  },
                  {
                    "$ref": "#/components/schemas/authz.redis_cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authz.redis_sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/authz.redis_single"
                  },
                  {
                    "$ref": "#/components/schemas/authz.http_post"
                  },
                  {
                    "$ref": "#/components/schemas/authz.http_get"
                  },
                  {
                    "$ref": "#/components/schemas/authz.builtin_db"
                  },
                  {
                    "$ref": "#/components/schemas/authz.api_file"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete source",
        "tags": [
          "Authorization"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "type",
            "description": "Authorization type",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "file",
                "built_in_database",
                "http",
                "redis",
                "mysql",
                "postgresql",
                "mongodb",
                "ldap"
              ]
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Deleted successfully"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/{name}/authentication/import_users": {
      "post": {
        "description": "Import users into the gateway authenticator (only supports built_in_database)",
        "tags": [
          "Gateway Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "lwm2m",
                "mqttsn",
                "stomp"
              ]
            },
            "example": "stomp"
          }
        ],
        "summary": "Import users",
        "responses": {
          "204": {
            "description": "Imported"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "multipart/form-data": {
              "schema": {
                "type": "object",
                "properties": {
                  "filename": {
                    "type": "string",
                    "format": "binary"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/api_key": {
      "get": {
        "description": "Return api_key list. This API can only be requested using a bearer token.",
        "tags": [
          "API Keys"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "name": {
                      "type": "string",
                      "description": "Unique and format by [a-zA-Z0-9-_]",
                      "example": "EMQX-API-KEY-1"
                    },
                    "api_key": {
                      "type": "string",
                      "description": "TODO:uses HMAC-SHA256 for signing.",
                      "example": "a4697a5c75a769f6"
                    },
                    "expired_at": {
                      "default": "infinity",
                      "description": "No longer valid datetime",
                      "example": "2021-12-05T02:01:34.186Z",
                      "oneOf": [
                        {
                          "oneOf": [
                            {
                              "type": "integer",
                              "description": "epoch-second",
                              "example": 1640995200
                            },
                            {
                              "type": "string",
                              "format": "date-time",
                              "example": "2022-01-01T00:00:00.000Z"
                            }
                          ]
                        },
                        {
                          "type": "string",
                          "enum": [
                            "infinity"
                          ]
                        }
                      ]
                    },
                    "created_at": {
                      "description": "ApiKey create datetime",
                      "example": "2021-12-01T00:00:00.000Z",
                      "oneOf": [
                        {
                          "type": "integer",
                          "description": "epoch-second",
                          "example": 1640995200
                        },
                        {
                          "type": "string",
                          "format": "date-time",
                          "example": "2022-01-01T00:00:00.000Z"
                        }
                      ]
                    },
                    "desc": {
                      "type": "string",
                      "example": "Note"
                    },
                    "enable": {
                      "type": "boolean",
                      "description": "Enable/Disable"
                    },
                    "expired": {
                      "type": "boolean",
                      "description": "Expired"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Create new api_key. This API can only be requested using a bearer token.",
        "tags": [
          "API Keys"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/api_key.app"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Unique and format by [a-zA-Z0-9-_]",
                    "example": "EMQX-API-KEY-1"
                  },
                  "expired_at": {
                    "default": "infinity",
                    "description": "No longer valid datetime",
                    "example": "2021-12-05T02:01:34.186Z",
                    "oneOf": [
                      {
                        "oneOf": [
                          {
                            "type": "integer",
                            "description": "epoch-second",
                            "example": 1640995200
                          },
                          {
                            "type": "string",
                            "format": "date-time",
                            "example": "2022-01-01T00:00:00.000Z"
                          }
                        ]
                      },
                      {
                        "type": "string",
                        "enum": [
                          "infinity"
                        ]
                      }
                    ]
                  },
                  "desc": {
                    "type": "string",
                    "example": "Note"
                  },
                  "enable": {
                    "type": "boolean",
                    "description": "Enable/Disable"
                  },
                  "expired": {
                    "type": "boolean",
                    "description": "Expired"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "security": [
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/listeners/{id}/start": {
      "post": {
        "description": "Start the listener on all nodes.",
        "tags": [
          "Listeners"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/listeners.listener_id"
          }
        ],
        "responses": {
          "200": {
            "description": "Updated"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST",
                        "BAD_LISTENER_ID"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/banned": {
      "get": {
        "description": "List all currently banned client IDs, usernames and IP addresses.",
        "tags": [
          "Banned"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "data": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/emqx_mgmt_api_banned.ban"
                      }
                    },
                    "meta": {
                      "$ref": "#/components/schemas/public.meta"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Clear all banned data.",
        "tags": [
          "Banned"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": "No Content"
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Add a client ID, username or IP address to the blacklist.",
        "tags": [
          "Banned"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "data": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/emqx_mgmt_api_banned.ban"
                      }
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "ALREADY_EXISTS",
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request, possibly due to wrong parameters or the existence of a banned object."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx_mgmt_api_banned.ban"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/connectors/{id}/enable/{enable}": {
      "put": {
        "description": "Enable or Disable connector on all nodes in the cluster.",
        "tags": [
          "Connectors"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The connector id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_connector"
          },
          {
            "in": "path",
            "name": "enable",
            "description": "Whether to enable this connector.",
            "required": true,
            "schema": {
              "type": "boolean"
            },
            "example": true
          }
        ],
        "summary": "Enable or disable connector",
        "responses": {
          "204": {
            "description": "Success"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Connector not found or invalid operation"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Service unavailable"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/actions/{id}/metrics": {
      "get": {
        "description": "Get bridge metrics by id.",
        "tags": [
          "Actions"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_action"
          }
        ],
        "summary": "Get action metrics",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "metrics": {
                      "description": "Bridge metrics.",
                      "$ref": "#/components/schemas/bridge.metrics"
                    },
                    "node_metrics": {
                      "type": "array",
                      "description": "Node metrics.",
                      "items": {
                        "$ref": "#/components/schemas/bridge.node_metrics"
                      }
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Action not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/authorization/sources/order": {
      "put": {
        "description": "Reorder all authorization sources.",
        "tags": [
          "Authorization"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": "Authorization sources order updated"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/emqx_authz_api_sources.request_sources_order"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/trace/{name}/log": {
      "get": {
        "description": "view trace log",
        "tags": [
          "Trace"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/trace.name"
          },
          {
            "$ref": "#/components/parameters/trace.bytes"
          },
          {
            "$ref": "#/components/parameters/trace.position"
          },
          {
            "$ref": "#/components/parameters/trace.node"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "items": {
                      "type": "string",
                      "example": "TEXT-LOG-ITEMS"
                    },
                    "meta": {
                      "properties": {
                        "bytes": {
                          "default": 1000,
                          "maximum": 2147483647,
                          "type": "integer",
                          "description": "Maximum number of bytes to send in response",
                          "minimum": 0
                        },
                        "position": {
                          "default": 0,
                          "type": "integer",
                          "description": "Offset from the current trace position."
                        }
                      },
                      "type": "object"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad input parameter"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "NODE_ERROR"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Trace Name or Node Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Requested chunk size too big"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/connectors": {
      "get": {
        "description": "List all created connectors.",
        "tags": [
          "Connectors"
        ],
        "parameters": [],
        "summary": "List connectors",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": [
                  {
                    "name": "my_http_connector",
                    "status": "connected",
                    "type": "http",
                    "connect_timeout": "15s",
                    "pool_size": 1,
                    "enable": true,
                    "headers": {
                      "content-type": "application/json"
                    },
                    "url": "http://localhost:8080/api/v1",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "pool_type": "hash",
                    "enable_pipelining": 100
                  }
                ],
                "schema": {
                  "type": "array",
                  "items": {
                    "oneOf": [
                      {
                        "$ref": "#/components/schemas/connector_mqtt.get_connector"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_http.get_connector"
                      }
                    ]
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Create a new connector by type and name.",
        "tags": [
          "Connectors"
        ],
        "parameters": [],
        "summary": "Create connector",
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "http": {
                    "value": {
                      "name": "my_http_connector",
                      "status": "connected",
                      "type": "http",
                      "connect_timeout": "15s",
                      "pool_size": 1,
                      "enable": true,
                      "headers": {
                        "content-type": "application/json"
                      },
                      "url": "http://localhost:8080/api/v1",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "pool_type": "hash",
                      "enable_pipelining": 100
                    },
                    "summary": "HTTP Connector"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/connector_mqtt.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_http.get_connector"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "ALREADY_EXISTS"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Connector already exists"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "http": {
                  "value": {
                    "name": "my_http_connector",
                    "type": "http",
                    "connect_timeout": "15s",
                    "pool_size": 1,
                    "enable": true,
                    "headers": {
                      "content-type": "application/json"
                    },
                    "url": "http://localhost:8080/api/v1",
                    "pool_type": "hash",
                    "enable_pipelining": 100
                  },
                  "summary": "HTTP Connector"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/connector_mqtt.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_http.post_connector"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/authentication/order": {
      "put": {
        "description": "Reorder all authenticators in global authentication chain.",
        "tags": [
          "Authentication"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": "Authenticators order updated"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/emqx_authn_api.request_authn_order"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/trace/{name}": {
      "delete": {
        "description": "Delete specified trace",
        "tags": [
          "Trace"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/trace.name"
          }
        ],
        "responses": {
          "204": {
            "description": "Delete successfully"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Trace Name Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/nodes/{node}/actions/{id}/{operation}": {
      "post": {
        "description": "Start bridge on a specific node.",
        "tags": [
          "Actions"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "node",
            "description": "The node name, e.g. 'emqx@127.0.0.1'.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "emqx@127.0.0.1"
          },
          {
            "in": "path",
            "name": "id",
            "description": "The bridge id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_action"
          },
          {
            "in": "path",
            "name": "operation",
            "description": "Operation can be one of: 'start'.",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "start"
              ]
            },
            "example": "start"
          }
        ],
        "summary": "Manually start a bridge on a given node",
        "responses": {
          "204": {
            "description": "Operation success"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Problem with configuration of external service or bridge not enabled"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bridge or node not found or invalid operation"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "501": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_IMPLEMENTED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Implemented"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Service unavailable"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/trace/{name}/stop": {
      "put": {
        "description": "Stop trace by name",
        "tags": [
          "Trace"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/trace.name"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/trace.trace"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Trace Name Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/opentelemetry": {
      "get": {
        "description": "Get opentelmetry configuration",
        "tags": [
          "Monitor"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "exporter": {
                    "ssl_options": {},
                    "endpoint": "http://localhost:4317"
                  },
                  "metrics": {
                    "enable": true
                  },
                  "traces": {
                    "filter": {
                      "trace_all": false
                    },
                    "enable": true
                  },
                  "logs": {
                    "level": "warning",
                    "enable": true
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/opentelemetry.opentelemetry"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update opentelmetry configuration",
        "tags": [
          "Monitor"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "exporter": {
                    "ssl_options": {},
                    "endpoint": "http://localhost:4317"
                  },
                  "metrics": {
                    "enable": true
                  },
                  "traces": {
                    "filter": {
                      "trace_all": false
                    },
                    "enable": true
                  },
                  "logs": {
                    "level": "warning",
                    "enable": true
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/opentelemetry.opentelemetry"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Update Config Failed"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "example": {
                "exporter": {
                  "ssl_options": {},
                  "endpoint": "http://localhost:4317"
                },
                "metrics": {
                  "enable": true
                },
                "traces": {
                  "filter": {
                    "trace_all": false
                  },
                  "enable": true
                },
                "logs": {
                  "level": "warning",
                  "enable": true
                }
              },
              "schema": {
                "$ref": "#/components/schemas/opentelemetry.opentelemetry"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/listeners/{id}/restart": {
      "post": {
        "description": "Restart listeners on all nodes.",
        "tags": [
          "Listeners"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/listeners.listener_id"
          }
        ],
        "responses": {
          "200": {
            "description": "Updated"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST",
                        "BAD_LISTENER_ID"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/mqtt/retainer/message/{topic}": {
      "get": {
        "description": "Lookup a message by a topic without wildcards.",
        "tags": [
          "Retainer"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "topic",
            "description": "Topic.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Details of the message.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/retainer.message"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Unsupported backend."
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Viewed message doesn't exist."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete matching messages.",
        "tags": [
          "Retainer"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "topic",
            "description": "Topic.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": ""
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Unsupported backend."
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Viewed message doesn't exist."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/rule_events": {
      "get": {
        "description": "List all events can be used in rules",
        "tags": [
          "Rules"
        ],
        "parameters": [],
        "summary": "List rule events",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/rule_engine.rule_events"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/clients/{clientid}/unsubscribe": {
      "post": {
        "description": "Unsubscribe",
        "tags": [
          "Clients"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Unsubscribe OK"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "CLIENTID_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Client ID not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx_mgmt_api_clients.unsubscribe"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/plugins/install": {
      "post": {
        "description": "Upload a plugin tarball (plugin-vsn.tar.gz).Follow [emqx-plugin-template](https://github.com/emqx/emqx-plugin-template) to develop plugin.",
        "tags": [
          "Plugins"
        ],
        "parameters": [],
        "summary": "Install a new plugin",
        "responses": {
          "204": {
            "description": "Install plugin successfully"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UNEXPECTED_ERROR",
                        "ALREADY_INSTALLED",
                        "BAD_PLUGIN_INFO"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "multipart/form-data": {
              "encoding": {
                "plugin": {
                  "contentType": "application/gzip"
                }
              },
              "schema": {
                "type": "object",
                "properties": {
                  "plugin": {
                    "type": "string",
                    "format": "binary"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/lwm2m/clients/{clientid}/read": {
      "post": {
        "description": "Send a read command to a resource",
        "tags": [
          "LwM2M Gateways"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "urn:oma:lwm2m:oma:2"
          },
          {
            "in": "query",
            "name": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "/3/0/7"
          }
        ],
        "summary": "Read Value from a Resource Path",
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "CLIENT_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "clientid not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/banned/{as}/{who}": {
      "delete": {
        "description": "Remove a client ID, username or IP address from the blacklist.",
        "tags": [
          "Banned"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "as",
            "description": "Ban method, which can be exact client ID, client ID regular expression, exact username, username regular expression,<br/>IP address or an IP address range.",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "clientid",
                "username",
                "peerhost",
                "clientid_re",
                "username_re",
                "peerhost_net"
              ]
            },
            "example": "username"
          },
          {
            "in": "path",
            "name": "who",
            "description": "Ban object, specific client ID, username or IP address.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Badass"
          }
        ],
        "responses": {
          "204": {
            "description": "Delete banned success"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "The banned object was not found in the blacklist."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/configs_reset/{rootname}": {
      "post": {
        "description": "Reset the config entry specified by the query string parameter `conf_path`.<br/><br/>- For a config entry that has default value, this resets it to the default value;<br/>- For a config entry that has no default value, an error 400 will be returned",
        "tags": [
          "Configs"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "rootname",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "broker",
                "log",
                "sysmon",
                "sys_topics",
                "alarm",
                "dashboard"
              ]
            },
            "example": "sysmon"
          },
          {
            "in": "query",
            "name": "conf_path",
            "description": "The config path separated by '.' character",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "os.sysmem_high_watermark"
          }
        ],
        "responses": {
          "200": {
            "description": "Rest config successfully"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NO_DEFAULT_VALUE",
                        "REST_FAILED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "403": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "REST_FAILED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/mqtt/retainer": {
      "get": {
        "description": "View config",
        "tags": [
          "Retainer"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "The config content",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/retainer.retainer"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Config not found."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update retainer config.",
        "tags": [
          "Retainer"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Update configs successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/retainer.retainer"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UPDATE_FAILED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Update config failed"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/retainer.retainer"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/authorization/cache": {
      "delete": {
        "description": "Clean all authorization cache in the cluster.",
        "tags": [
          "Authorization"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/api_key/{name}": {
      "get": {
        "description": "Return the specific api_key. This API can only be requested using a bearer token.",
        "tags": [
          "API Keys"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/api_key.name"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "name": {
                      "type": "string",
                      "description": "Unique and format by [a-zA-Z0-9-_]",
                      "example": "EMQX-API-KEY-1"
                    },
                    "api_key": {
                      "type": "string",
                      "description": "TODO:uses HMAC-SHA256 for signing.",
                      "example": "a4697a5c75a769f6"
                    },
                    "expired_at": {
                      "default": "infinity",
                      "description": "No longer valid datetime",
                      "example": "2021-12-05T02:01:34.186Z",
                      "oneOf": [
                        {
                          "oneOf": [
                            {
                              "type": "integer",
                              "description": "epoch-second",
                              "example": 1640995200
                            },
                            {
                              "type": "string",
                              "format": "date-time",
                              "example": "2022-01-01T00:00:00.000Z"
                            }
                          ]
                        },
                        {
                          "type": "string",
                          "enum": [
                            "infinity"
                          ]
                        }
                      ]
                    },
                    "created_at": {
                      "description": "ApiKey create datetime",
                      "example": "2021-12-01T00:00:00.000Z",
                      "oneOf": [
                        {
                          "type": "integer",
                          "description": "epoch-second",
                          "example": 1640995200
                        },
                        {
                          "type": "string",
                          "format": "date-time",
                          "example": "2022-01-01T00:00:00.000Z"
                        }
                      ]
                    },
                    "desc": {
                      "type": "string",
                      "example": "Note"
                    },
                    "enable": {
                      "type": "boolean",
                      "description": "Enable/Disable"
                    },
                    "expired": {
                      "type": "boolean",
                      "description": "Expired"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update the specific api_key. This API can only be requested using a bearer token.",
        "tags": [
          "API Keys"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/api_key.name"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "name": {
                      "type": "string",
                      "description": "Unique and format by [a-zA-Z0-9-_]",
                      "example": "EMQX-API-KEY-1"
                    },
                    "api_key": {
                      "type": "string",
                      "description": "TODO:uses HMAC-SHA256 for signing.",
                      "example": "a4697a5c75a769f6"
                    },
                    "expired_at": {
                      "default": "infinity",
                      "description": "No longer valid datetime",
                      "example": "2021-12-05T02:01:34.186Z",
                      "oneOf": [
                        {
                          "oneOf": [
                            {
                              "type": "integer",
                              "description": "epoch-second",
                              "example": 1640995200
                            },
                            {
                              "type": "string",
                              "format": "date-time",
                              "example": "2022-01-01T00:00:00.000Z"
                            }
                          ]
                        },
                        {
                          "type": "string",
                          "enum": [
                            "infinity"
                          ]
                        }
                      ]
                    },
                    "created_at": {
                      "description": "ApiKey create datetime",
                      "example": "2021-12-01T00:00:00.000Z",
                      "oneOf": [
                        {
                          "type": "integer",
                          "description": "epoch-second",
                          "example": 1640995200
                        },
                        {
                          "type": "string",
                          "format": "date-time",
                          "example": "2022-01-01T00:00:00.000Z"
                        }
                      ]
                    },
                    "desc": {
                      "type": "string",
                      "example": "Note"
                    },
                    "enable": {
                      "type": "boolean",
                      "description": "Enable/Disable"
                    },
                    "expired": {
                      "type": "boolean",
                      "description": "Expired"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "expired_at": {
                    "default": "infinity",
                    "description": "No longer valid datetime",
                    "example": "2021-12-05T02:01:34.186Z",
                    "oneOf": [
                      {
                        "oneOf": [
                          {
                            "type": "integer",
                            "description": "epoch-second",
                            "example": 1640995200
                          },
                          {
                            "type": "string",
                            "format": "date-time",
                            "example": "2022-01-01T00:00:00.000Z"
                          }
                        ]
                      },
                      {
                        "type": "string",
                        "enum": [
                          "infinity"
                        ]
                      }
                    ]
                  },
                  "desc": {
                    "type": "string",
                    "example": "Note"
                  },
                  "enable": {
                    "type": "boolean",
                    "description": "Enable/Disable"
                  },
                  "expired": {
                    "type": "boolean",
                    "description": "Expired"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete the specific api_key. This API can only be requested using a bearer token.",
        "tags": [
          "API Keys"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/api_key.name"
          }
        ],
        "responses": {
          "204": {
            "description": "Delete successfully"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/clients/{clientid}/subscriptions": {
      "get": {
        "description": "Get client subscriptions",
        "tags": [
          "Clients"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/emqx_mgmt_api_subscriptions.subscription"
                  }
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "CLIENTID_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Client ID not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/cluster/invitation": {
      "get": {
        "description": "Get the execution status of all asynchronous invite status per node",
        "tags": [
          "Cluster"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Get invitation progress created by async operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/cluster.invitation_status"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/configs": {
      "get": {
        "description": "Get all the configurations of the specified keys, including hot and non-hot updatable items.",
        "tags": [
          "Configs"
        ],
        "parameters": [
          {
            "in": "query",
            "name": "key",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "actions",
                "alarm",
                "api_key",
                "authentication",
                "authorization",
                "auto_subscribe",
                "banned",
                "bridges",
                "cluster",
                "conn_congestion",
                "connectors",
                "crl_cache",
                "dashboard",
                "delayed",
                "durable_sessions",
                "durable_storage",
                "exhook",
                "flapping_detect",
                "force_gc",
                "force_shutdown",
                "gateway",
                "limiter",
                "listeners",
                "log",
                "mqtt",
                "node",
                "opentelemetry",
                "overload_protection",
                "prometheus",
                "psk_authentication",
                "retainer",
                "rewrite",
                "rpc",
                "rule_engine",
                "slow_subs",
                "sources",
                "sys_topics",
                "sysmon",
                "telemetry",
                "topic_metrics"
              ]
            },
            "example": "sysmon"
          },
          {
            "in": "query",
            "name": "node",
            "description": "Node's name. Will deprecated in 5.2.0.",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string",
                  "example": "\n    sysmon {\n      os {\n        cpu_check_interval = 60s\n        cpu_high_watermark = 80%\n        cpu_low_watermark = 60%\n        mem_check_interval = 60s\n        procmem_high_watermark = 5%\n        sysmem_high_watermark = 70%\n        }\n        vm {\n        busy_dist_port = true\n        busy_port = true\n        large_heap = 32MB\n        long_gc = disabled\n        long_schedule = 240ms\n        process_check_interval = 30s\n        process_high_watermark = 80%\n        process_low_watermark = 60%\n        }\n    }\n    "
                }
              },
              "application/json": {
                "schema": {
                  "type": "object",
                  "example": {
                    "deprecated": true
                  }
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "INVALID_ACCEPT"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "500": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_NODE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update the configurations of the specified keys.",
        "tags": [
          "Configs"
        ],
        "parameters": [
          {
            "in": "query",
            "name": "mode",
            "required": false,
            "schema": {
              "default": "merge",
              "type": "string",
              "enum": [
                "replace",
                "merge"
              ]
            }
          },
          {
            "in": "query",
            "name": "ignore_readonly",
            "required": false,
            "schema": {
              "default": false,
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Configurations updated"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UPDATE_FAILED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "text/plain": {
              "schema": {
                "type": "string",
                "example": "\n    sysmon {\n      os {\n        cpu_check_interval = 60s\n        cpu_high_watermark = 80%\n        cpu_low_watermark = 60%\n        mem_check_interval = 60s\n        procmem_high_watermark = 5%\n        sysmem_high_watermark = 70%\n        }\n        vm {\n        busy_dist_port = true\n        busy_port = true\n        large_heap = 32MB\n        long_gc = disabled\n        long_schedule = 240ms\n        process_check_interval = 30s\n        process_high_watermark = 80%\n        process_low_watermark = 60%\n        }\n    }\n    "
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/clients": {
      "get": {
        "description": "List clients",
        "tags": [
          "Clients"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "in": "query",
            "name": "node",
            "description": "Node name",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "emqx@127.0.0.1"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          },
          {
            "in": "query",
            "name": "username",
            "description": "User name, multiple values can be specified by repeating the parameter: username=u1&username=u2",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "in": "query",
            "name": "ip_address",
            "description": "Client's IP address",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "127.0.0.1"
          },
          {
            "in": "query",
            "name": "conn_state",
            "description": "The current connection status of the client, the possible values are connected,idle,disconnected",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "connected",
                "idle",
                "disconnected"
              ]
            }
          },
          {
            "in": "query",
            "name": "clean_start",
            "description": "Whether the client uses a new session",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "in": "query",
            "name": "proto_ver",
            "description": "Client protocol version",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "like_clientid",
            "description": "Fuzzy search `clientid` as substring",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "like_username",
            "description": "Fuzzy search `username` as substring",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "gte_created_at",
            "description": "Search client session creation time by greater than or equal method, rfc3339 or timestamp(millisecond)",
            "required": false,
            "schema": {
              "oneOf": [
                {
                  "type": "integer",
                  "description": "epoch-millisecond",
                  "example": 1640995200000
                },
                {
                  "type": "string",
                  "format": "date-time",
                  "example": "2022-01-01T00:00:00.000Z"
                }
              ]
            }
          },
          {
            "in": "query",
            "name": "lte_created_at",
            "description": "Search client session creation time by less than or equal method, rfc3339 or timestamp(millisecond)",
            "required": false,
            "schema": {
              "oneOf": [
                {
                  "type": "integer",
                  "description": "epoch-millisecond",
                  "example": 1640995200000
                },
                {
                  "type": "string",
                  "format": "date-time",
                  "example": "2022-01-01T00:00:00.000Z"
                }
              ]
            }
          },
          {
            "in": "query",
            "name": "gte_connected_at",
            "description": "Search client connection creation time by greater than or equal method, rfc3339 or timestamp(epoch millisecond)",
            "required": false,
            "schema": {
              "oneOf": [
                {
                  "type": "integer",
                  "description": "epoch-millisecond",
                  "example": 1640995200000
                },
                {
                  "type": "string",
                  "format": "date-time",
                  "example": "2022-01-01T00:00:00.000Z"
                }
              ]
            }
          },
          {
            "in": "query",
            "name": "lte_connected_at",
            "description": "Search client connection creation time by less than or equal method, rfc3339 or timestamp(millisecond)",
            "required": false,
            "schema": {
              "oneOf": [
                {
                  "type": "integer",
                  "description": "epoch-millisecond",
                  "example": 1640995200000
                },
                {
                  "type": "string",
                  "format": "date-time",
                  "example": "2022-01-01T00:00:00.000Z"
                }
              ]
            }
          },
          {
            "in": "query",
            "name": "clientid",
            "description": "Client ID, multiple values can be specified by repeating the parameter: clientid=c1&clientid=c2",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "$ref": "#/components/parameters/emqx_mgmt_api_clients.requested_client_fields"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "data": [
                    {
                      "heap_size": 610,
                      "send_msg.dropped.expired": 0,
                      "send_oct": 31,
                      "recv_msg.qos1": 0,
                      "is_persistent": false,
                      "send_pkt": 4,
                      "clean_start": true,
                      "inflight_cnt": 0,
                      "node": "emqx@127.0.0.1",
                      "send_msg.dropped.queue_full": 0,
                      "awaiting_rel_cnt": 0,
                      "inflight_max": 32,
                      "created_at": "2024-01-01T12:34:56.789+08:00",
                      "subscriptions_cnt": 1,
                      "mailbox_len": 0,
                      "send_cnt": 4,
                      "connected": true,
                      "ip_address": "127.0.0.1",
                      "awaiting_rel_max": 100,
                      "recv_msg.qos2": 0,
                      "proto_ver": 5,
                      "mountpoint": "null",
                      "proto_name": "MQTT",
                      "durable": false,
                      "port": 52571,
                      "connected_at": "2024-01-01T12:34:56.789+08:00",
                      "enable_authn": true,
                      "expiry_interval": 0,
                      "username": null,
                      "recv_msg": 0,
                      "recv_oct": 49,
                      "send_msg.dropped.too_large": 0,
                      "keepalive": 60,
                      "send_msg.qos1": 0,
                      "send_msg.qos2": 0,
                      "recv_msg.qos0": 0,
                      "send_msg.qos0": 0,
                      "subscriptions_max": "infinity",
                      "mqueue_max": 1000,
                      "mqueue_dropped": 0,
                      "clientid": "01",
                      "is_bridge": false,
                      "peerport": 52571,
                      "send_msg": 0,
                      "listener": "tcp:default",
                      "recv_cnt": 4,
                      "recv_pkt": 4,
                      "recv_msg.dropped": 0,
                      "send_msg.dropped": 0,
                      "recv_msg.dropped.await_pubrel_timeout": 0,
                      "reductions": 6836,
                      "mqueue_len": 0
                    }
                  ],
                  "meta": {
                    "count": 1,
                    "hasnext": false,
                    "limit": 50,
                    "page": 1
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_clients.clients"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "INVALID_PARAMETER"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Invalid parameters"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/{name}/authentication/users": {
      "get": {
        "description": "Get the users for the authenticator (only supported by <code>built_in_database</code>).",
        "tags": [
          "Gateway Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "lwm2m",
                "mqttsn",
                "stomp"
              ]
            },
            "example": "stomp"
          },
          {
            "in": "query",
            "name": "page",
            "description": "Page number of the results to fetch.",
            "schema": {
              "default": 1,
              "type": "integer",
              "minimum": 1
            },
            "example": 1
          },
          {
            "in": "query",
            "name": "limit",
            "description": "Results per page(max 10000)",
            "schema": {
              "default": 100,
              "maximum": 10000,
              "type": "integer",
              "minimum": 1
            },
            "example": 50
          },
          {
            "in": "query",
            "name": "like_user_id",
            "description": "Fuzzy search using user ID (username or clientid), only supports search by substring.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "test_"
          },
          {
            "in": "query",
            "name": "is_superuser",
            "description": "Is superuser",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "summary": "List users for gateway authenticator",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "data": [
                    {
                      "user_id": "user1"
                    },
                    {
                      "is_superuser": true,
                      "user_id": "user2"
                    }
                  ],
                  "meta": {
                    "count": 300,
                    "limit": 20,
                    "page": 0
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_users"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Add user for the authenticator (only supports built_in_database).",
        "tags": [
          "Gateway Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "lwm2m",
                "mqttsn",
                "stomp"
              ]
            },
            "example": "stomp"
          }
        ],
        "summary": "Add user for gateway authenticator",
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "regular_user": {
                    "value": {
                      "user_id": "user1"
                    },
                    "summary": "Regular user"
                  },
                  "super_user": {
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    },
                    "summary": "Superuser"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "regular_user": {
                  "value": {
                    "password": "******",
                    "user_id": "user1"
                  },
                  "summary": "Regular user"
                },
                "super_user": {
                  "value": {
                    "password": "******",
                    "is_superuser": true,
                    "user_id": "user2"
                  },
                  "summary": "Superuser"
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authn_api.request_user_create"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/listeners/{id}": {
      "get": {
        "description": "List all running node's listeners for the specified id.",
        "tags": [
          "Listeners"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/listeners.listener_id"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "id": "tcp:demo",
                  "running": true,
                  "type": "tcp",
                  "bind": "0.0.0.0:1884",
                  "tcp_options": {
                    "buffer": "4KB",
                    "high_watermark": "1MB",
                    "nodelay": false,
                    "reuseaddr": true,
                    "send_timeout": "15s",
                    "send_timeout_close": true,
                    "backlog": 1024,
                    "active_n": 100
                  },
                  "acceptors": 16,
                  "proxy_protocol": false,
                  "max_connections": 204800,
                  "access_rules": [
                    "allow all"
                  ],
                  "proxy_protocol_timeout": "3s",
                  "zone": "default",
                  "mountpoint": "/",
                  "current_connections": 10240
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/listeners.wss_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.ws_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.tcp_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.ssl_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.quic_required_bind"
                    }
                  ]
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_LISTENER_ID",
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Listener id not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update the specified listener on all nodes.",
        "tags": [
          "Listeners"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/listeners.listener_id"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "id": "tcp:demo",
                  "running": true,
                  "type": "tcp",
                  "bind": "0.0.0.0:1884",
                  "tcp_options": {
                    "buffer": "4KB",
                    "high_watermark": "1MB",
                    "nodelay": false,
                    "reuseaddr": true,
                    "send_timeout": "15s",
                    "send_timeout_close": true,
                    "backlog": 1024,
                    "active_n": 100
                  },
                  "acceptors": 16,
                  "proxy_protocol": false,
                  "max_connections": 204800,
                  "access_rules": [
                    "allow all"
                  ],
                  "proxy_protocol_timeout": "3s",
                  "zone": "default",
                  "mountpoint": "/",
                  "current_connections": 10240
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/listeners.wss_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.ws_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.tcp_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.ssl_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.quic_required_bind"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_LISTENER_ID",
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Listener id not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "example": {
                "id": "tcp:demo",
                "running": true,
                "type": "tcp",
                "bind": "0.0.0.0:1884",
                "tcp_options": {
                  "buffer": "4KB",
                  "high_watermark": "1MB",
                  "nodelay": false,
                  "reuseaddr": true,
                  "send_timeout": "15s",
                  "send_timeout_close": true,
                  "backlog": 1024,
                  "active_n": 100
                },
                "acceptors": 16,
                "proxy_protocol": false,
                "max_connections": 204800,
                "access_rules": [
                  "allow all"
                ],
                "proxy_protocol_timeout": "3s",
                "zone": "default",
                "mountpoint": "/",
                "current_connections": 10240
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/listeners.wss_not_required_bind"
                  },
                  {
                    "$ref": "#/components/schemas/listeners.ws_not_required_bind"
                  },
                  {
                    "$ref": "#/components/schemas/listeners.tcp_not_required_bind"
                  },
                  {
                    "$ref": "#/components/schemas/listeners.ssl_not_required_bind"
                  },
                  {
                    "$ref": "#/components/schemas/listeners.quic_not_required_bind"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete the specified listener on all nodes.",
        "tags": [
          "Listeners"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/listeners.listener_id"
          }
        ],
        "responses": {
          "204": {
            "description": "Listener deleted"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_LISTENER_ID"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/users/{username}/change_pwd": {
      "post": {
        "description": "Change dashboard user password",
        "tags": [
          "Dashboard"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "username",
            "description": "Dashboard Username",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "admin"
          }
        ],
        "responses": {
          "204": {
            "description": "Update user password successfully"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST",
                        "ERROR_PWD_NOT_MATCH"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Login failed. Bad username or password"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "USER_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Dashboard user not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "old_pwd": {
                    "type": "string",
                    "description": "Old password"
                  },
                  "new_pwd": {
                    "type": "string",
                    "description": "New password"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/{name}/clients": {
      "get": {
        "description": "Get the gateway client list",
        "tags": [
          "Gateway Clients"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "lwm2m",
                "mqttsn",
                "stomp"
              ]
            }
          },
          {
            "in": "query",
            "name": "node",
            "description": "Match the client's node name",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": ""
          },
          {
            "in": "query",
            "name": "clientid",
            "description": "Match the client's ID",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": ""
          },
          {
            "in": "query",
            "name": "username",
            "description": "Match the client's Username",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": ""
          },
          {
            "in": "query",
            "name": "ip_address",
            "description": "Match the client's ip address",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": ""
          },
          {
            "in": "query",
            "name": "conn_state",
            "description": "Match the client's connection state",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": ""
          },
          {
            "in": "query",
            "name": "proto_ver",
            "description": "Match the client's protocol version",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": ""
          },
          {
            "in": "query",
            "name": "clean_start",
            "description": "Match the client's clean start flag",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "example": ""
          },
          {
            "in": "query",
            "name": "like_clientid",
            "description": "Use sub-string to match client's ID",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": ""
          },
          {
            "in": "query",
            "name": "like_username",
            "description": "Use sub-string to match client's username",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": ""
          },
          {
            "in": "query",
            "name": "gte_created_at",
            "description": "Match the session created datetime greater than a certain value",
            "required": false,
            "schema": {
              "oneOf": [
                {
                  "type": "integer",
                  "description": "epoch-millisecond",
                  "example": 1640995200000
                },
                {
                  "type": "string",
                  "format": "date-time",
                  "example": "2022-01-01T00:00:00.000Z"
                }
              ]
            },
            "example": ""
          },
          {
            "in": "query",
            "name": "lte_created_at",
            "description": "Match the session created datetime less than a certain value",
            "required": false,
            "schema": {
              "oneOf": [
                {
                  "type": "integer",
                  "description": "epoch-millisecond",
                  "example": 1640995200000
                },
                {
                  "type": "string",
                  "format": "date-time",
                  "example": "2022-01-01T00:00:00.000Z"
                }
              ]
            },
            "example": ""
          },
          {
            "in": "query",
            "name": "gte_connected_at",
            "description": "Match the client socket connected datetime greater than a certain value",
            "required": false,
            "schema": {
              "oneOf": [
                {
                  "type": "integer",
                  "description": "epoch-millisecond",
                  "example": 1640995200000
                },
                {
                  "type": "string",
                  "format": "date-time",
                  "example": "2022-01-01T00:00:00.000Z"
                }
              ]
            },
            "example": ""
          },
          {
            "in": "query",
            "name": "lte_connected_at",
            "description": "Match the client socket connected datatime less than a certain value",
            "required": false,
            "schema": {
              "oneOf": [
                {
                  "type": "integer",
                  "description": "epoch-millisecond",
                  "example": 1640995200000
                },
                {
                  "type": "string",
                  "format": "date-time",
                  "example": "2022-01-01T00:00:00.000Z"
                }
              ]
            },
            "example": ""
          },
          {
            "in": "query",
            "name": "endpoint_name",
            "description": "Match the lwm2m client's endpoint name",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": ""
          },
          {
            "in": "query",
            "name": "like_endpoint_name",
            "description": "Use sub-string to match lwm2m client's endpoint name",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": ""
          },
          {
            "in": "query",
            "name": "gte_lifetime",
            "description": "Match the lwm2m client registered lifetime greater than a certain value",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": ""
          },
          {
            "in": "query",
            "name": "lte_lifetime",
            "description": "Match the lwm2m client registered lifetime less than a certain value",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": ""
          },
          {
            "in": "query",
            "name": "page",
            "description": "Page number of the results to fetch.",
            "schema": {
              "default": 1,
              "type": "integer",
              "minimum": 1
            },
            "example": 1
          },
          {
            "in": "query",
            "name": "limit",
            "description": "Results per page(max 10000)",
            "schema": {
              "default": 100,
              "maximum": 10000,
              "type": "integer",
              "minimum": 1
            },
            "example": 50
          }
        ],
        "summary": "List gateway's clients",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "data": {
                      "oneOf": [
                        {
                          "type": "array",
                          "items": {
                            "$ref": "#/components/schemas/emqx_gateway_api_clients.exproto_client"
                          }
                        },
                        {
                          "type": "array",
                          "items": {
                            "$ref": "#/components/schemas/emqx_gateway_api_clients.lwm2m_client"
                          }
                        },
                        {
                          "type": "array",
                          "items": {
                            "$ref": "#/components/schemas/emqx_gateway_api_clients.coap_client"
                          }
                        },
                        {
                          "type": "array",
                          "items": {
                            "$ref": "#/components/schemas/emqx_gateway_api_clients.mqttsn_client"
                          }
                        },
                        {
                          "type": "array",
                          "items": {
                            "$ref": "#/components/schemas/emqx_gateway_api_clients.stomp_client"
                          }
                        }
                      ]
                    },
                    "meta": {
                      "$ref": "#/components/schemas/public.meta"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/{name}/authentication/users/{uid}": {
      "get": {
        "description": "Get user info from the gateway authenticator (only supports built_in_database)",
        "tags": [
          "Gateway Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "lwm2m",
                "mqttsn",
                "stomp"
              ]
            },
            "example": "stomp"
          },
          {
            "in": "path",
            "name": "uid",
            "description": "User ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "test_username"
          }
        ],
        "summary": "Get user info for gateway authenticator",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "regular_user": {
                    "value": {
                      "user_id": "user1"
                    },
                    "summary": "Regular user"
                  },
                  "super_user": {
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    },
                    "summary": "Superuser"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update the user info for the gateway authenticator (only supports built_in_database)",
        "tags": [
          "Gateway Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "lwm2m",
                "mqttsn",
                "stomp"
              ]
            },
            "example": "stomp"
          },
          {
            "in": "path",
            "name": "uid",
            "description": "User ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "test_username"
          }
        ],
        "summary": "Update user info for gateway authenticator",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "regular_user": {
                    "value": {
                      "user_id": "user1"
                    },
                    "summary": "Regular user"
                  },
                  "super_user": {
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    },
                    "summary": "Superuser"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "regular_user": {
                  "value": {
                    "password": "******"
                  },
                  "summary": "Update regular user"
                },
                "super_user": {
                  "value": {
                    "password": "******",
                    "is_superuser": true
                  },
                  "summary": "Update user and promote to superuser"
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authn_api.request_user_update"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete the user for the gateway authenticator (only supports built_in_database)",
        "tags": [
          "Gateway Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "lwm2m",
                "mqttsn",
                "stomp"
              ]
            },
            "example": "stomp"
          },
          {
            "in": "path",
            "name": "uid",
            "description": "User ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "test_username"
          }
        ],
        "summary": "Delete user for gateway authenticator",
        "responses": {
          "204": {
            "description": "User Deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/{name}/listeners/{id}/authentication/import_users": {
      "post": {
        "description": "Import users into the gateway authenticator (only supports built_in_database)",
        "tags": [
          "Gateway Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "lwm2m",
                "mqttsn",
                "stomp"
              ]
            },
            "example": "stomp"
          },
          {
            "in": "path",
            "name": "id",
            "description": "Listener ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "stomp:tcp:def"
          }
        ],
        "summary": "Import users",
        "responses": {
          "204": {
            "description": "Imported"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "multipart/form-data": {
              "schema": {
                "type": "object",
                "properties": {
                  "filename": {
                    "type": "string",
                    "format": "binary"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/rules/{id}/metrics/reset": {
      "put": {
        "description": "Reset a rule metrics",
        "tags": [
          "Rules"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "my_rule_id"
          }
        ],
        "summary": "Reset rule metrics",
        "responses": {
          "204": {
            "description": "Reset Success"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Rule not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/{name}/listeners/{id}/authentication/users": {
      "get": {
        "description": "Get the users for the authenticator (only supported by <code>built_in_database</code>)",
        "tags": [
          "Gateway Listeners"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "lwm2m",
                "mqttsn",
                "stomp"
              ]
            },
            "example": "stomp"
          },
          {
            "in": "path",
            "name": "id",
            "description": "Listener ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": ""
          },
          {
            "in": "query",
            "name": "page",
            "description": "Page number of the results to fetch.",
            "schema": {
              "default": 1,
              "type": "integer",
              "minimum": 1
            },
            "example": 1
          },
          {
            "in": "query",
            "name": "limit",
            "description": "Results per page(max 10000)",
            "schema": {
              "default": 100,
              "maximum": 10000,
              "type": "integer",
              "minimum": 1
            },
            "example": 50
          }
        ],
        "summary": "List authenticator's users",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "regular_user": {
                    "value": {
                      "user_id": "user1"
                    },
                    "summary": "Regular user"
                  },
                  "super_user": {
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    },
                    "summary": "Superuser"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Add user for the authenticator (only supports built_in_database)",
        "tags": [
          "Gateway Listeners"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "lwm2m",
                "mqttsn",
                "stomp"
              ]
            },
            "example": "stomp"
          },
          {
            "in": "path",
            "name": "id",
            "description": "Listener ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": ""
          }
        ],
        "summary": "Add user for an authenticator",
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "regular_user": {
                    "value": {
                      "user_id": "user1"
                    },
                    "summary": "Regular user"
                  },
                  "super_user": {
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    },
                    "summary": "Superuser"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "regular_user": {
                  "value": {
                    "password": "******",
                    "user_id": "user1"
                  },
                  "summary": "Regular user"
                },
                "super_user": {
                  "value": {
                    "password": "******",
                    "is_superuser": true,
                    "user_id": "user2"
                  },
                  "summary": "Superuser"
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authn_api.request_user_create"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/schemas/{name}": {
      "get": {
        "description": "Get the schema JSON of the specified name. NOTE: only intended for EMQX Dashboard.",
        "tags": [
          "Dashboard"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "hotconf",
                "bridges",
                "actions",
                "connectors"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The JSON schema of the specified name.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          }
        },
        "security": []
      }
    },
    "/authorization/settings": {
      "get": {
        "description": "Get authorization settings",
        "tags": [
          "Authorization"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "deny_action",
                    "no_match"
                  ],
                  "properties": {
                    "no_match": {
                      "default": "allow",
                      "type": "string",
                      "enum": [
                        "allow",
                        "deny"
                      ],
                      "description": "Default access control action if the user or client matches no ACL rules,<br/>or if no such user or client is found by the configurable authorization<br/>sources such as built_in_database, an HTTP API, or a query against PostgreSQL.<br/>Find more details in 'authorization.sources' config."
                    },
                    "deny_action": {
                      "default": "ignore",
                      "type": "string",
                      "enum": [
                        "ignore",
                        "disconnect"
                      ],
                      "description": "The action when the authorization check rejects an operation."
                    },
                    "cache": {
                      "$ref": "#/components/schemas/emqx.authz_cache"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update authorization settings",
        "tags": [
          "Authorization"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "deny_action",
                    "no_match"
                  ],
                  "properties": {
                    "no_match": {
                      "default": "allow",
                      "type": "string",
                      "enum": [
                        "allow",
                        "deny"
                      ],
                      "description": "Default access control action if the user or client matches no ACL rules,<br/>or if no such user or client is found by the configurable authorization<br/>sources such as built_in_database, an HTTP API, or a query against PostgreSQL.<br/>Find more details in 'authorization.sources' config."
                    },
                    "deny_action": {
                      "default": "ignore",
                      "type": "string",
                      "enum": [
                        "ignore",
                        "disconnect"
                      ],
                      "description": "The action when the authorization check rejects an operation."
                    },
                    "cache": {
                      "$ref": "#/components/schemas/emqx.authz_cache"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "required": [
                  "deny_action",
                  "no_match"
                ],
                "properties": {
                  "no_match": {
                    "default": "allow",
                    "type": "string",
                    "enum": [
                      "allow",
                      "deny"
                    ],
                    "description": "Default access control action if the user or client matches no ACL rules,<br/>or if no such user or client is found by the configurable authorization<br/>sources such as built_in_database, an HTTP API, or a query against PostgreSQL.<br/>Find more details in 'authorization.sources' config."
                  },
                  "deny_action": {
                    "default": "ignore",
                    "type": "string",
                    "enum": [
                      "ignore",
                      "disconnect"
                    ],
                    "description": "The action when the authorization check rejects an operation."
                  },
                  "cache": {
                    "$ref": "#/components/schemas/emqx.authz_cache"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/lwm2m/clients/{clientid}/write": {
      "post": {
        "description": "Send a write command to a resource",
        "tags": [
          "LwM2M Gateways"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "urn:oma:lwm2m:oma:2"
          },
          {
            "in": "query",
            "name": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "/3/0/7"
          },
          {
            "in": "query",
            "name": "type",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "Integer",
                "Float",
                "Time",
                "String",
                "Boolean",
                "Opaque",
                "Objlnk"
              ]
            },
            "example": "Integer"
          },
          {
            "in": "query",
            "name": "value",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": 123
          }
        ],
        "summary": "Write a Value to Resource Path",
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "CLIENT_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Clientid not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/configs/log": {
      "get": {
        "description": "Get the sub-configurations under *log*",
        "tags": [
          "Configs"
        ],
        "parameters": [],
        "summary": "Get the sub-configurations under *log*",
        "responses": {
          "200": {
            "description": "EMQX provides support for two primary log handlers: `file` and `console`, with an additional `audit` handler specifically designed to always direct logs to files.<br/>The system's default log handling behavior can be configured via the environment variable `EMQX_DEFAULT_LOG_HANDLER`, which accepts the following settings:<br/><br/>- `file`: Directs log output exclusively to files.<br/>- `console`: Channels log output solely to the console.<br/><br/>It's noteworthy that `EMQX_DEFAULT_LOG_HANDLER` is set to `file` when EMQX is initiated via systemd's `emqx.service` file.<br/>In scenarios outside systemd initiation, `console` serves as the default log handler.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx.log"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "config not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update the sub-configurations under *log*",
        "tags": [
          "Configs"
        ],
        "parameters": [],
        "summary": "Update the sub-configurations under *log*",
        "responses": {
          "200": {
            "description": "EMQX provides support for two primary log handlers: `file` and `console`, with an additional `audit` handler specifically designed to always direct logs to files.<br/>The system's default log handling behavior can be configured via the environment variable `EMQX_DEFAULT_LOG_HANDLER`, which accepts the following settings:<br/><br/>- `file`: Directs log output exclusively to files.<br/>- `console`: Channels log output solely to the console.<br/><br/>It's noteworthy that `EMQX_DEFAULT_LOG_HANDLER` is set to `file` when EMQX is initiated via systemd's `emqx.service` file.<br/>In scenarios outside systemd initiation, `console` serves as the default log handler.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx.log"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UPDATE_FAILED",
                        "INVALID_CONFIG"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "403": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UPDATE_FAILED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx.log"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/rules/{id}": {
      "get": {
        "description": "Get a rule by given Id",
        "tags": [
          "Rules"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "my_rule_id"
          }
        ],
        "summary": "Get rule",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/rule_engine.rule_info"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Rule not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update a rule by given Id to all nodes in the cluster",
        "tags": [
          "Rules"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "my_rule_id"
          }
        ],
        "summary": "Update rule",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/rule_engine.rule_info"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Invalid Parameters"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/rule_engine.rule_creation"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete a rule by given Id from all nodes in the cluster",
        "tags": [
          "Rules"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "my_rule_id"
          }
        ],
        "summary": "Delete rule",
        "responses": {
          "204": {
            "description": "Delete rule successfully"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Rule not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/exhooks/{name}/hooks": {
      "get": {
        "description": "Get the hooks information of server",
        "tags": [
          "ExHook"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "The Exhook server name",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "default"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/exhook.list_hook_info"
                  }
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/bridges": {
      "get": {
        "description": "List all created bridges",
        "tags": [
          "Bridges"
        ],
        "parameters": [],
        "summary": "List bridges",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": [
                  {
                    "name": "http_example",
                    "type": "http",
                    "ssl": {
                      "enable": false
                    },
                    "connect_timeout": "15s",
                    "pool_size": 4,
                    "enable": true,
                    "body": "${payload}",
                    "method": "post",
                    "url": "http://localhost:9901/messages/${topic}",
                    "max_retries": 3,
                    "request_timeout": "15s",
                    "pool_type": "random",
                    "resource_opts": {
                      "worker_pool_size": 1,
                      "query_mode": "async",
                      "max_buffer_bytes": 104857600,
                      "inflight_window": 100,
                      "health_check_interval": 15000
                    },
                    "enable_pipelining": 100,
                    "local_topic": "emqx_http/#"
                  },
                  {
                    "name": "mqtt_example",
                    "type": "mqtt",
                    "keepalive": "300s",
                    "ssl": {
                      "enable": false
                    },
                    "server": "127.0.0.1:1883",
                    "enable": true,
                    "password": "******",
                    "username": "foo",
                    "proto_ver": "v4",
                    "clean_start": true,
                    "retry_interval": "15s",
                    "max_inflight": 100,
                    "resource_opts": {
                      "query_mode": "sync",
                      "max_buffer_bytes": 104857600,
                      "health_check_interval": "15s"
                    },
                    "ingress": {
                      "local": {
                        "retain": "${retain}",
                        "payload": "${payload}",
                        "topic": "from_aws/${topic}",
                        "qos": "${qos}"
                      },
                      "remote": {
                        "topic": "aws/#",
                        "qos": 1
                      }
                    },
                    "egress": {
                      "local": {
                        "topic": "emqx/#"
                      },
                      "remote": {
                        "retain": false,
                        "payload": "${payload}",
                        "topic": "from_emqx/${topic}",
                        "qos": "${qos}"
                      }
                    }
                  }
                ],
                "schema": {
                  "type": "array",
                  "items": {
                    "oneOf": [
                      {
                        "$ref": "#/components/schemas/bridge_http.get"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_mqtt.get"
                      }
                    ]
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Create a new bridge by type and name",
        "tags": [
          "Bridges"
        ],
        "parameters": [],
        "summary": "Create bridge",
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "http_example": {
                    "value": {
                      "name": "http_example",
                      "type": "http",
                      "ssl": {
                        "enable": false
                      },
                      "connect_timeout": "15s",
                      "pool_size": 4,
                      "enable": true,
                      "body": "${payload}",
                      "method": "post",
                      "url": "http://localhost:9901/messages/${topic}",
                      "max_retries": 3,
                      "request_timeout": "15s",
                      "pool_type": "random",
                      "resource_opts": {
                        "worker_pool_size": 1,
                        "query_mode": "async",
                        "max_buffer_bytes": 104857600,
                        "inflight_window": 100,
                        "health_check_interval": 15000
                      },
                      "enable_pipelining": 100,
                      "local_topic": "emqx_http/#"
                    },
                    "summary": "HTTP"
                  },
                  "mqtt_example": {
                    "value": {
                      "name": "mqtt_example",
                      "type": "mqtt",
                      "keepalive": "300s",
                      "ssl": {
                        "enable": false
                      },
                      "server": "127.0.0.1:1883",
                      "enable": true,
                      "password": "******",
                      "username": "foo",
                      "proto_ver": "v4",
                      "clean_start": true,
                      "retry_interval": "15s",
                      "max_inflight": 100,
                      "resource_opts": {
                        "query_mode": "sync",
                        "max_buffer_bytes": 104857600,
                        "health_check_interval": "15s"
                      },
                      "ingress": {
                        "local": {
                          "retain": "${retain}",
                          "payload": "${payload}",
                          "topic": "from_aws/${topic}",
                          "qos": "${qos}"
                        },
                        "remote": {
                          "topic": "aws/#",
                          "qos": 1
                        }
                      },
                      "egress": {
                        "local": {
                          "topic": "emqx/#"
                        },
                        "remote": {
                          "retain": false,
                          "payload": "${payload}",
                          "topic": "from_emqx/${topic}",
                          "qos": "${qos}"
                        }
                      }
                    },
                    "summary": "MQTT Bridge"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/bridge_http.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mqtt.get"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "ALREADY_EXISTS"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bridge already exists"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "http_example": {
                  "value": {
                    "name": "http_example",
                    "type": "http",
                    "ssl": {
                      "enable": false
                    },
                    "connect_timeout": "15s",
                    "pool_size": 4,
                    "enable": true,
                    "body": "${payload}",
                    "method": "post",
                    "url": "http://localhost:9901/messages/${topic}",
                    "max_retries": 3,
                    "request_timeout": "15s",
                    "pool_type": "random",
                    "resource_opts": {
                      "worker_pool_size": 1,
                      "query_mode": "async",
                      "max_buffer_bytes": 104857600,
                      "inflight_window": 100,
                      "health_check_interval": 15000
                    },
                    "enable_pipelining": 100,
                    "local_topic": "emqx_http/#"
                  },
                  "summary": "HTTP"
                },
                "mqtt_example": {
                  "value": {
                    "name": "mqtt_example",
                    "type": "mqtt",
                    "keepalive": "300s",
                    "ssl": {
                      "enable": false
                    },
                    "server": "127.0.0.1:1883",
                    "enable": true,
                    "password": "******",
                    "username": "foo",
                    "proto_ver": "v4",
                    "clean_start": true,
                    "retry_interval": "15s",
                    "max_inflight": 100,
                    "resource_opts": {
                      "query_mode": "sync",
                      "max_buffer_bytes": 104857600,
                      "health_check_interval": "15s"
                    },
                    "ingress": {
                      "local": {
                        "retain": "${retain}",
                        "payload": "${payload}",
                        "topic": "from_aws/${topic}",
                        "qos": "${qos}"
                      },
                      "remote": {
                        "topic": "aws/#",
                        "qos": 1
                      }
                    },
                    "egress": {
                      "local": {
                        "topic": "emqx/#"
                      },
                      "remote": {
                        "retain": false,
                        "payload": "${payload}",
                        "topic": "from_emqx/${topic}",
                        "qos": "${qos}"
                      }
                    }
                  },
                  "summary": "MQTT Bridge"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/bridge_http.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mqtt.post"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/listeners_status": {
      "get": {
        "description": "List all running node's listeners live status. group by listener type",
        "tags": [
          "Listeners"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": [
                  {
                    "status": {
                      "running": true,
                      "max_connections": 2048000,
                      "current_connections": 21
                    },
                    "type": "tcp",
                    "enable": false,
                    "node_status": [
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "running": true,
                          "max_connections": 1024000,
                          "current_connections": 11
                        }
                      },
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "running": true,
                          "max_connections": 1024000,
                          "current_connections": 10
                        }
                      }
                    ],
                    "ids": [
                      "tcp:demo"
                    ]
                  },
                  {
                    "status": {
                      "running": true,
                      "max_connections": "infinity",
                      "current_connections": 71
                    },
                    "type": "ssl",
                    "enable": false,
                    "node_status": [
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "running": true,
                          "max_connections": "infinity",
                          "current_connections": 31
                        }
                      },
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "running": true,
                          "max_connections": "infinity",
                          "current_connections": 40
                        }
                      }
                    ],
                    "ids": [
                      "ssl:default"
                    ]
                  }
                ],
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/listeners.listener_type_status"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/monitor": {
      "get": {
        "description": "List monitor (statistics) data for the whole cluster.",
        "tags": [
          "Metrics"
        ],
        "parameters": [
          {
            "in": "query",
            "name": "latest",
            "description": "The latest N seconds data. Like 300 for 5 min.",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 1
            },
            "example": 300
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/emqx_dashboard_monitor_api.sampler"
                  }
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_RPC"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad RPC"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/relup/package": {
      "get": {
        "description": "Get information of the installed hot upgrade package.<br/>",
        "tags": [
          "Relup"
        ],
        "parameters": [],
        "summary": "Get the installed hot upgrade package",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/relup.package"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "No relup package is installed"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete the installed hot upgrade package.<br/>",
        "tags": [
          "Relup"
        ],
        "parameters": [],
        "summary": "Delete the installed hot upgrade package",
        "responses": {
          "204": {
            "description": "Packages are deleted successfully"
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/logout": {
      "post": {
        "description": "Dashboard user logout.<br/>This endpoint is only for the Dashboard, not the `API Key`.<br/>The token from the `/login` endpoint must be a bearer authorization in the headers.",
        "tags": [
          "Dashboard"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": "Dashboard logout successfully"
          },
          "401": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_USERNAME_OR_PWD"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Login failed. Bad username or password"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "username": {
                    "type": "string",
                    "description": "Dashboard Username",
                    "maxLength": 100,
                    "example": "admin"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "security": [
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/authorization/sources/built_in_database/rules/all": {
      "get": {
        "description": "Show the list of rules for 'all'",
        "tags": [
          "Authorization"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "password_based:built_in_database": {
                    "value": {
                      "rules": [
                        {
                          "action": "publish",
                          "topic": "test/topic/1",
                          "permission": "allow"
                        },
                        {
                          "action": "subscribe",
                          "topic": "test/topic/2",
                          "permission": "allow"
                        },
                        {
                          "action": "all",
                          "topic": "eq test/#",
                          "permission": "deny"
                        },
                        {
                          "action": "publish",
                          "retain": "true",
                          "topic": "test/topic/3",
                          "qos": [
                            "1"
                          ],
                          "permission": "allow"
                        },
                        {
                          "action": "publish",
                          "retain": "all",
                          "topic": "test/topic/4",
                          "qos": [
                            "0",
                            "1",
                            "2"
                          ],
                          "permission": "allow"
                        }
                      ]
                    },
                    "summary": "All"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authz_api_mnesia.rules"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete rules for 'all'",
        "tags": [
          "Authorization"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Create/Update the list of rules for 'all'.",
        "tags": [
          "Authorization"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": "Updated"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad rule schema"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "password_based:built_in_database": {
                  "value": {
                    "rules": [
                      {
                        "action": "publish",
                        "topic": "test/topic/1",
                        "permission": "allow"
                      },
                      {
                        "action": "subscribe",
                        "topic": "test/topic/2",
                        "permission": "allow"
                      },
                      {
                        "action": "all",
                        "topic": "eq test/#",
                        "permission": "deny"
                      },
                      {
                        "action": "publish",
                        "retain": "true",
                        "topic": "test/topic/3",
                        "qos": [
                          "1"
                        ],
                        "permission": "allow"
                      },
                      {
                        "action": "publish",
                        "retain": "all",
                        "topic": "test/topic/4",
                        "qos": [
                          "0",
                          "1",
                          "2"
                        ],
                        "permission": "allow"
                      }
                    ]
                  },
                  "summary": "All"
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authz_api_mnesia.rules"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/relup/status/{node}": {
      "get": {
        "description": "Get the hot upgrade status of a specified node",
        "tags": [
          "Relup"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/relup.node_name"
          }
        ],
        "summary": "Get the hot upgrade status of a specified node",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/relup.running_status"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/rule_engine": {
      "get": {
        "description": "Get rule engine configuration.",
        "tags": [
          "Rules"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/rule_engine.rule_engine"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update rule engine configuration.",
        "tags": [
          "Rules"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/rule_engine.rule_engine"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Invalid request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/rule_engine.rule_engine"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    }
  },
  "servers": [
    {
      "url": "/api/v5"
    }
  ],
  "openapi": "3.0.0"
}
