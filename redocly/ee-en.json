{
  "info": {
    "version": "5.8.0",
    "title": "EMQX Enterprise API"
  },
  "components": {
    "parameters": {
      "file_transfer.client_id": {
        "in": "path",
        "name": "clientid",
        "description": "MQTT Client ID",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "file_transfer.file_id": {
        "in": "path",
        "name": "fileid",
        "description": "File ID",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "file_transfer.file_node": {
        "in": "query",
        "name": "node",
        "description": "Node under which the file is located",
        "required": true,
        "schema": {
          "type": "string"
        },
        "example": "emqx@127.0.0.1"
      },
      "file_transfer.file_ref": {
        "in": "query",
        "name": "fileref",
        "description": "File reference",
        "required": true,
        "schema": {
          "type": "string"
        },
        "example": "file1"
      },
      "file_transfer.following": {
        "in": "query",
        "name": "following",
        "description": "Cursor to start listing files from",
        "required": false,
        "schema": {
          "type": "string"
        }
      },
      "public.limit": {
        "in": "query",
        "name": "limit",
        "description": "Results per page(max 10000)",
        "schema": {
          "default": 100,
          "maximum": 10000,
          "type": "integer",
          "minimum": 1
        },
        "example": 50
      },
      "public.page": {
        "in": "query",
        "name": "page",
        "description": "Page number of the results to fetch.",
        "schema": {
          "default": 1,
          "type": "integer",
          "minimum": 1
        },
        "example": 1
      }
    },
    "schemas": {
      "redis.put_bridge_v2": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "The parameters of the action.",
            "$ref": "#/components/schemas/bridge_redis.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/redis.action_resource_opts"
          }
        },
        "type": "object"
      },
      "pulsar.get_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "pulsar"
            ]
          },
          "name": {
            "type": "string"
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Action specific configs.",
            "$ref": "#/components/schemas/pulsar.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/pulsar.action_resource_opts"
          }
        },
        "type": "object"
      },
      "action_couchbase.get_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "couchbase"
            ]
          },
          "name": {
            "type": "string"
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Set of parameters for the action.",
            "$ref": "#/components/schemas/action_couchbase.parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/action_couchbase.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_iotdb.auth_basic": {
        "required": [
          "password",
          "username"
        ],
        "properties": {
          "username": {
            "type": "string",
            "description": "The username as configured at the IoTDB REST interface"
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password as configured at the IoTDB REST interface",
            "example": "R4ND0M/S∃CЯ∃T"
          }
        },
        "type": "object"
      },
      "bridge_greptimedb.get_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "greptimedb"
            ]
          },
          "name": {
            "type": "string"
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Additional parameters specific to this action type",
            "$ref": "#/components/schemas/bridge_greptimedb.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "schema_validation_http_api.metrics": {
        "properties": {
          "matched": {
            "type": "integer",
            "minimum": 0
          },
          "succeeded": {
            "type": "integer",
            "minimum": 0
          },
          "failed": {
            "type": "integer",
            "minimum": 0
          }
        },
        "type": "object"
      },
      "bridge_cassa.get": {
        "required": [
          "keyspace",
          "name",
          "servers",
          "type"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "cassandra"
            ],
            "description": "The Bridge Type"
          },
          "name": {
            "type": "string",
            "description": "Bridge name."
          },
          "cql": {
            "default": "insert into mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic},  ${qos}, ${payload}, ${timestamp})",
            "type": "string",
            "format": "sql",
            "description": "CQL Template"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to Cassandra. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "servers": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port][,Host2:Port]`.<br/><br/>The Cassandra default port 9042 is used if `[:Port]` is not specified."
          },
          "keyspace": {
            "type": "string",
            "description": "Keyspace name to connect to."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "bridge_redis.post_sentinel": {
        "required": [
          "command_template",
          "name",
          "sentinel",
          "servers",
          "type"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to Redis. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: If this action is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "command_template": {
            "type": "array",
            "description": "Redis command template used to export messages. Each list element stands for a command name or its argument.<br/>For example, to push payloads in a Redis list by key `msgs`, the elements should be the following:<br/>`rpush`, `msgs`, `${payload}`.",
            "items": {
              "type": "string"
            }
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_redis.creation_opts_redis_sentinel"
          },
          "servers": {
            "type": "string",
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The Redis default port 6379 is used if `[:Port]` is not specified."
          },
          "redis_type": {
            "default": "sentinel",
            "type": "string",
            "enum": [
              "sentinel"
            ],
            "description": "Sentinel mode. Must be set to 'sentinel' when Redis server is running in sentinel mode."
          },
          "sentinel": {
            "type": "string",
            "description": "The cluster name in Redis sentinel mode."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "database": {
            "default": 0,
            "type": "integer",
            "description": "Redis database ID.",
            "minimum": 0
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "type": {
            "type": "string",
            "enum": [
              "redis_sentinel"
            ],
            "description": "The Action Type"
          },
          "name": {
            "type": "string",
            "description": "Action name, used as a human-readable identifier."
          }
        },
        "type": "object"
      },
      "bridge_kafka.producer_buffer": {
        "properties": {
          "mode": {
            "default": "memory",
            "type": "string",
            "enum": [
              "memory",
              "disk",
              "hybrid"
            ],
            "description": "Message buffer mode.<br/><br/><code>memory</code>: Buffer all messages in memory. The messages will be lost in case of EMQX node restart<br/><code>disk</code>: Buffer all messages on disk. The messages on disk are able to survive EMQX node restart.<br/><code>hybrid</code>: Buffer message in memory first, when up to certain limit (see <code>segment_bytes</code> config for more information), then start offloading messages to disk, Like <code>memory</code> mode, the messages will be lost in case of EMQX node restart."
          },
          "per_partition_limit": {
            "default": "2GB",
            "type": "string",
            "description": "Number of bytes allowed to buffer for each partition. When this limit is exceeded, older messages will be discarded to make room for new messages to be buffered.",
            "example": "32MB"
          },
          "segment_bytes": {
            "default": "100MB",
            "type": "string",
            "description": "Applicable when buffer mode is set to <code>disk</code> or <code>hybrid</code>.<br/>This setting specifies the size of each buffer file stored on disk.",
            "example": "32MB"
          },
          "memory_overload_protection": {
            "default": false,
            "type": "boolean",
            "description": "Applicable when buffer mode is set to <code>memory</code><br/>EMQX will drop old buffered messages under high memory pressure. The high memory threshold is defined in config <code>sysmon.os.sysmem_high_watermark</code>. NOTE: This config only works on Linux."
          }
        },
        "type": "object"
      },
      "rule_engine.ctx_pub": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "type": "string",
            "enum": [
              "message_publish"
            ],
            "description": "Event Type"
          },
          "id": {
            "type": "string",
            "description": "Message ID"
          },
          "clientid": {
            "type": "string",
            "description": "The Client ID"
          },
          "username": {
            "type": "string",
            "description": "Username"
          },
          "payload": {
            "type": "string",
            "description": "The Message Payload"
          },
          "peerhost": {
            "type": "string",
            "description": "The IP Address of the Peer Client"
          },
          "topic": {
            "type": "string",
            "description": "Message Topic"
          },
          "publish_received_at": {
            "type": "integer",
            "description": "The Time that this Message is Received"
          },
          "qos": {
            "maximum": 2,
            "type": "integer",
            "description": "The Message QoS",
            "minimum": 0,
            "example": 0
          }
        },
        "type": "object"
      },
      "rule_engine.builtin_action_republish": {
        "properties": {
          "function": {
            "type": "string",
            "enum": [
              "republish"
            ],
            "description": "Republish the message as a new MQTT message"
          },
          "args": {
            "default": {},
            "$ref": "#/components/schemas/rule_engine.republish_args"
          }
        },
        "type": "object"
      },
      "bridge_kinesis.action_parameters": {
        "required": [
          "partition_key",
          "stream_name"
        ],
        "properties": {
          "payload_template": {
            "default": "${.}",
            "type": "string",
            "description": "The template for formatting the outgoing messages.  If undefined, will send all the available context in JSON format."
          },
          "stream_name": {
            "type": "string",
            "description": "The Amazon Kinesis Stream to publish messages to."
          },
          "partition_key": {
            "type": "string",
            "description": "The Amazon Kinesis Partition Key associated to published message. Placeholders in format of ${var} are supported."
          }
        },
        "type": "object"
      },
      "bridge_tdengine.post": {
        "required": [
          "database",
          "name",
          "password",
          "server",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "tdengine"
            ],
            "description": "The Bridge Type"
          },
          "name": {
            "type": "string",
            "description": "Bridge name."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "sql": {
            "default": "insert into t_mqtt_msg(ts, msgid, mqtt_topic, qos, payload, arrived) values (${ts}, '${id}', '${topic}', ${qos}, '${payload}', ${timestamp})",
            "type": "string",
            "format": "sql",
            "description": "SQL Template"
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to TDengine. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The TDengine default port 6041 is used if `[:Port]` is not specified."
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "default": "root",
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          }
        },
        "type": "object"
      },
      "bridge_influxdb.post_api_v1": {
        "required": [
          "database",
          "name",
          "type",
          "write_syntax"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to the InfluxDB. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "write_syntax": {
            "type": "string",
            "format": "sql",
            "description": "Conf of InfluxDB line protocol to write data points. It is a text-based format that provides the measurement, tag set, field set, and timestamp of a data point, and placeholder supported.<br/>See also [InfluxDB 2.3 Line Protocol](https://docs.influxdata.com/influxdb/v2.3/reference/syntax/line-protocol/) and<br/>[InfluxDB 1.8 Line Protocol](https://docs.influxdata.com/influxdb/v1.8/write_protocols/line_protocol_tutorial/) <br/><br/>TLDR:<br/><br/>```<br/><measurement>[,<tag_key>=<tag_value>[,<tag_key>=<tag_value>]] <field_key>=<field_value>[,<field_key>=<field_value>] [<timestamp>]<br/>```<br/>Please note that a placeholder for an integer value must be annotated with a suffix `i`. For example `${payload.int_value}i`."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "default": "127.0.0.1:8086",
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The InfluxDB default port 8086 is used if `[:Port]` is not specified."
          },
          "precision": {
            "default": "ms",
            "type": "string",
            "enum": [
              "ns",
              "us",
              "ms",
              "s"
            ],
            "description": "InfluxDB time precision."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "database": {
            "type": "string",
            "description": "InfluxDB database."
          },
          "username": {
            "type": "string",
            "description": "InfluxDB username."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "InfluxDB password.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "type": {
            "type": "string",
            "enum": [
              "influxdb_api_v1"
            ],
            "description": "The Bridge Type."
          },
          "name": {
            "type": "string",
            "description": "Bridge name."
          }
        },
        "type": "object"
      },
      "bridge_mongodb.action_resource_opts": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "maximum": 1024,
            "type": "integer",
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 1
          },
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "query_mode": {
            "default": "async",
            "type": "string",
            "enum": [
              "sync",
              "async"
            ],
            "description": "Query mode. Optional 'sync/async', default 'async'."
          },
          "request_ttl": {
            "default": "45s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "string",
                "example": "32s"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "type": "integer",
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "type": "string",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB"
          }
        },
        "type": "object"
      },
      "bridge_sqlserver.action_parameters": {
        "properties": {
          "sql": {
            "default": "insert into t_mqtt_msg(msgid, topic, qos, payload) values ( ${id}, ${topic}, ${qos}, ${payload} )",
            "type": "string",
            "format": "sql",
            "description": "SQL Template"
          }
        },
        "type": "object"
      },
      "bridge_azure_event_hub.post_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "azure_event_hub_producer"
            ],
            "description": "The type of the bridge."
          },
          "name": {
            "type": "string",
            "description": "Bridge name, used as a human-readable description of the bridge."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in Azure Event Hubs."
          },
          "parameters": {
            "description": "Azure Event Hubs producer configs.",
            "$ref": "#/components/schemas/bridge_azure_event_hub.producer_kafka_opts"
          },
          "resource_opts": {
            "default": {},
            "$ref": "#/components/schemas/bridge_kafka.resource_opts"
          }
        },
        "type": "object"
      },
      "message_transformation_http_api.metrics": {
        "properties": {
          "matched": {
            "type": "integer",
            "minimum": 0
          },
          "succeeded": {
            "type": "integer",
            "minimum": 0
          },
          "failed": {
            "type": "integer",
            "minimum": 0
          }
        },
        "type": "object"
      },
      "bridge_tdengine.post_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "tdengine"
            ]
          },
          "name": {
            "type": "string"
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "TDengine action parameters",
            "$ref": "#/components/schemas/bridge_tdengine.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_mongodb.creation_opts": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "maximum": 1024,
            "type": "integer",
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 1
          },
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "start_after_created": {
            "default": true,
            "type": "boolean",
            "description": "Whether start the resource right after created."
          },
          "start_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "example": "32s"
          },
          "auto_restart_interval": {
            "default": "15s",
            "deprecated": true,
            "oneOf": [
              {
                "type": "string",
                "example": "32s"
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "query_mode": {
            "default": "async",
            "type": "string",
            "enum": [
              "sync",
              "async"
            ],
            "description": "Query mode. Optional 'sync/async', default 'async'."
          },
          "request_ttl": {
            "default": "45s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "string",
                "example": "32s"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "type": "integer",
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1
          },
          "enable_queue": {
            "default": false,
            "type": "boolean",
            "deprecated": true,
            "description": "Enable disk buffer queue (only applicable for egress bridges).<br/>When Enabled, messages will be buffered on disk when the bridge connection is down.<br/>When disabled the messages are buffered in RAM only."
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "type": "string",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB"
          }
        },
        "type": "object"
      },
      "bridge_opents.action_parameters_data": {
        "required": [
          "metric",
          "tags",
          "value"
        ],
        "properties": {
          "timestamp": {
            "type": "string",
            "description": "Timestamp. Placeholders in the format of ${var} are supported"
          },
          "metric": {
            "type": "string",
            "description": "Metric. Placeholders in the format of ${var} are supported"
          },
          "tags": {
            "description": "Tags. Only supports with placeholder to extract tags from a variable or a tags map",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "object",
                "example": {}
              }
            ]
          },
          "value": {
            "description": "Value. Placeholders in the format of ${var} are supported",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              },
              {
                "type": "integer"
              }
            ]
          }
        },
        "type": "object"
      },
      "connector_mqtt.ingress_local": {
        "properties": {
          "topic": {
            "type": "string",
            "description": "Send messages to which topic of the local broker.<br/><br/>Template with variables is allowed."
          },
          "qos": {
            "default": "${qos}",
            "description": "The QoS of the MQTT message to be sent.<br/><br/>Template with variables is allowed.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "maximum": 2,
                "type": "integer",
                "minimum": 0,
                "example": 0
              }
            ]
          },
          "retain": {
            "default": "${retain}",
            "description": "The 'retain' flag of the MQTT message to be sent.<br/><br/>Template with variables is allowed.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "boolean"
              }
            ]
          },
          "payload": {
            "type": "string",
            "description": "The payload of the MQTT message to be sent.<br/><br/>Template with variables is allowed."
          }
        },
        "type": "object"
      },
      "bridge_oracle.get": {
        "required": [
          "name",
          "server",
          "type",
          "username"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "oracle"
            ],
            "description": "The Bridge Type"
          },
          "name": {
            "type": "string",
            "description": "Bridge name."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "sql": {
            "default": "insert into t_mqtt_msgs(msgid, topic, qos, payload) values (${id}, ${topic}, ${qos}, ${payload})",
            "type": "string",
            "format": "sql",
            "description": "SQL Template. The template string can contain placeholders for message metadata and payload field. The placeholders are inserted without any checking and special formatting, so it is important to ensure that the inserted values are formatted and escaped correctly."
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to Oracle Database. All MQTT 'PUBLISH' messages with the topic matching the local_topic will be forwarded.<br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is configured, then both the data got from the rule and the MQTT messages that match local_topic will be forwarded."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The Oracle Database default port 1521 is used if `[:Port]` is not specified."
          },
          "sid": {
            "type": "string",
            "description": "Sid for Oracle Database."
          },
          "service_name": {
            "type": "string",
            "description": "Service Name for Oracle Database."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          }
        },
        "type": "object"
      },
      "file_transfer.file_transfer": {
        "properties": {
          "enable": {
            "default": false,
            "type": "boolean",
            "description": "Enable the File Transfer feature.<br/><br/>Enabling File Transfer implies reserving special MQTT topics in order to serve the protocol.<br/><br/>This toggle also affects the availability of the File Transfer REST API and<br/>storage-dependent background activities (e.g. garbage collection)."
          },
          "init_timeout": {
            "default": "10s",
            "type": "string",
            "description": "Timeout for EMQX to initialize the file transfer.<br/><br/>After reaching the timeout (e.g. due to system is overloaded), the PUBACK message for `init` will contain error code (0x80).",
            "example": "32s"
          },
          "store_segment_timeout": {
            "default": "5m",
            "type": "string",
            "description": "Timeout for storing a file segment.<br/><br/>After reaching the timeout (e.g. due to system overloaded), the PUBACK message will contain error code (0x80).",
            "example": "32s"
          },
          "assemble_timeout": {
            "default": "5m",
            "type": "string",
            "description": "Timeout for assembling and exporting file segments into a final file.<br/><br/>After reaching the timeout (e.g. due to system is overloaded), the PUBACK message for `fin` will contain error code (0x80)",
            "example": "32s"
          },
          "storage": {
            "default": {
              "local": {}
            },
            "description": "Storage settings for file transfer.",
            "$ref": "#/components/schemas/file_transfer.storage_backend"
          }
        },
        "type": "object"
      },
      "bridge_mysql.post_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "mysql"
            ]
          },
          "name": {
            "type": "string"
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Additional parameters specific to this action type",
            "$ref": "#/components/schemas/bridge_mysql.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_pulsar.producer_buffer": {
        "properties": {
          "mode": {
            "default": "memory",
            "type": "string",
            "enum": [
              "memory",
              "disk",
              "hybrid"
            ],
            "description": "Message buffer mode.<br/><code>memory</code>: Buffer all messages in memory. The messages will be lost<br/> in case of EMQX node restart\\n<code>disk</code>: Buffer all messages on disk.<br/> The messages on disk are able to survive EMQX node restart.<br/><code>hybrid</code>: Buffer message in memory first, when up to certain limit<br/> (see <code>segment_bytes</code> config for more information), then start offloading<br/> messages to disk, Like <code>memory</code> mode, the messages will be lost in<br/> case of EMQX node restart."
          },
          "per_partition_limit": {
            "default": "2GB",
            "type": "string",
            "description": "Number of bytes allowed to buffer for each Pulsar partition.<br/> When this limit is exceeded, old messages will be dropped in a trade for credits<br/> for new messages to be buffered.",
            "example": "32MB"
          },
          "segment_bytes": {
            "default": "100MB",
            "type": "string",
            "description": "Applicable when buffer mode is set to <code>disk</code> or <code>hybrid</code>.<br/>This value is to specify the size of each on-disk buffer file.",
            "example": "32MB"
          },
          "memory_overload_protection": {
            "default": false,
            "type": "boolean",
            "description": "Applicable when buffer mode is set to <code>memory</code><br/>EMQX will drop old buffered messages under high memory pressure.<br/>The high memory threshold is defined in config <code>sysmon.os.sysmem_high_watermark</code>.<br/> NOTE: This config only works on Linux."
          }
        },
        "type": "object"
      },
      "bridge_http.post_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "http"
            ],
            "description": "The action type."
          },
          "name": {
            "type": "string",
            "description": "Action name, used as a human-readable identifier."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "parameters": {
            "description": "The parameters for HTTP action.",
            "$ref": "#/components/schemas/bridge_http.parameters_opts"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_http.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_clickhouse.post_connector": {
        "required": [
          "database",
          "name",
          "type",
          "url"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "clickhouse"
            ],
            "description": "The type of the connector."
          },
          "name": {
            "type": "string",
            "description": "The name of the connector."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this connector."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "url": {
            "type": "string",
            "description": "The HTTP URL to the Clickhouse server that you want to connect to (for example http://myhostname:8123)",
            "example": "http://127.0.0.1"
          },
          "connect_timeout": {
            "default": "15s",
            "type": "string",
            "description": "The timeout when connecting to the Clickhouse server.",
            "example": "32s"
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_clickhouse.connector_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_http.post": {
        "required": [
          "name",
          "type",
          "url"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "webhook",
              "http"
            ],
            "description": "The action type."
          },
          "name": {
            "type": "string",
            "description": "Action name, used as a human-readable identifier."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this action."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "connect_timeout": {
            "default": "15s",
            "type": "string",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s"
          },
          "retry_interval": {
            "type": "string",
            "deprecated": true,
            "example": "12m"
          },
          "pool_type": {
            "default": "random",
            "type": "string",
            "enum": [
              "random",
              "hash"
            ],
            "description": "The type of the pool. Can be one of `random`, `hash`."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "The pool size.",
            "minimum": 1
          },
          "enable_pipelining": {
            "default": 100,
            "type": "integer",
            "description": "The maximum number of HTTP requests that can be sent before an HTTP response is received.<br/><br/>Setting this to 1 is equivalent to turning off HTTP pipelining, and the EMQX must receive a response to the previous HTTP request before sending the next HTTP request.",
            "minimum": 1
          },
          "request": {
            "type": "object",
            "deprecated": true,
            "description": "This field is never used, so we deprecated it since 5.3.2.",
            "example": {}
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "url": {
            "type": "string",
            "description": "The URL of the HTTP action.<br/><br/>Template with variables is allowed in the path, but variables cannot be used in the scheme, host,<br/>or port part.<br/><br/>For example, <code> http://localhost:9901/${topic} </code> is allowed, but<br/><code> http://${host}:9901/message </code> or <code> http://localhost:${port}/message </code><br/>is not allowed."
          },
          "direction": {
            "type": "string",
            "enum": [
              "egress"
            ],
            "deprecated": true
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to the HTTP server. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: If this action is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "method": {
            "default": "post",
            "type": "string",
            "enum": [
              "post",
              "put",
              "get",
              "delete"
            ],
            "description": "The method of the HTTP request. All the available methods are: post, put, get, delete.<br/><br/>Template with variables is allowed."
          },
          "headers": {
            "default": {
              "accept": "application/json",
              "cache-control": "no-cache",
              "connection": "keep-alive",
              "content-type": "application/json",
              "keep-alive": "timeout=5"
            },
            "type": "object",
            "description": "The headers of the HTTP request.<br/><br/>Template with variables is allowed.",
            "example": {},
            "is_template": true
          },
          "body": {
            "type": "string",
            "description": "The body of the HTTP request.<br/><br/>If not provided, the body will be a JSON object of all the available fields.<br/><br/>There, 'all the available fields' means the context of a MQTT message when<br/>this webhook is triggered by receiving a MQTT message (the `local_topic` is set),<br/>or the context of the event when this webhook is triggered by a rule (i.e. this<br/>webhook is used as an action of a rule).<br/><br/>Template with variables is allowed."
          },
          "max_retries": {
            "default": 2,
            "type": "integer",
            "description": "HTTP request max retry times if failed.",
            "minimum": 0
          },
          "request_timeout": {
            "default": "15s",
            "type": "string",
            "deprecated": true,
            "description": "HTTP request timeout.",
            "example": "32s"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_http.v1_resource_opts"
          }
        },
        "type": "object"
      },
      "message_transformation_http_api.dryrun_transformation": {
        "required": [
          "message",
          "transformation"
        ],
        "properties": {
          "transformation": {
            "$ref": "#/components/schemas/message_transformation.transformation"
          },
          "message": {
            "$ref": "#/components/schemas/message_transformation_http_api.dryrun_input_message"
          }
        },
        "type": "object"
      },
      "schema_validation_http_api.reorder": {
        "required": [
          "order"
        ],
        "properties": {
          "order": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "type": "object"
      },
      "bridge_influxdb.get_api_v2": {
        "required": [
          "bucket",
          "name",
          "org",
          "token",
          "type",
          "write_syntax"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to the InfluxDB. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "write_syntax": {
            "type": "string",
            "format": "sql",
            "description": "Conf of InfluxDB line protocol to write data points. It is a text-based format that provides the measurement, tag set, field set, and timestamp of a data point, and placeholder supported.<br/>See also [InfluxDB 2.3 Line Protocol](https://docs.influxdata.com/influxdb/v2.3/reference/syntax/line-protocol/) and<br/>[InfluxDB 1.8 Line Protocol](https://docs.influxdata.com/influxdb/v1.8/write_protocols/line_protocol_tutorial/) <br/><br/>TLDR:<br/><br/>```<br/><measurement>[,<tag_key>=<tag_value>[,<tag_key>=<tag_value>]] <field_key>=<field_value>[,<field_key>=<field_value>] [<timestamp>]<br/>```<br/>Please note that a placeholder for an integer value must be annotated with a suffix `i`. For example `${payload.int_value}i`."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "default": "127.0.0.1:8086",
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The InfluxDB default port 8086 is used if `[:Port]` is not specified."
          },
          "precision": {
            "default": "ms",
            "type": "string",
            "enum": [
              "ns",
              "us",
              "ms",
              "s"
            ],
            "description": "InfluxDB time precision."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "bucket": {
            "type": "string",
            "description": "InfluxDB bucket name."
          },
          "org": {
            "type": "string",
            "description": "Organization name of InfluxDB."
          },
          "token": {
            "type": "string",
            "format": "password",
            "description": "InfluxDB token.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "type": {
            "type": "string",
            "enum": [
              "influxdb_api_v2"
            ],
            "description": "The Bridge Type."
          },
          "name": {
            "type": "string",
            "description": "Bridge name."
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          }
        },
        "type": "object"
      },
      "bridge_influxdb.put_api_v2": {
        "required": [
          "bucket",
          "org",
          "token",
          "write_syntax"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to the InfluxDB. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "write_syntax": {
            "type": "string",
            "format": "sql",
            "description": "Conf of InfluxDB line protocol to write data points. It is a text-based format that provides the measurement, tag set, field set, and timestamp of a data point, and placeholder supported.<br/>See also [InfluxDB 2.3 Line Protocol](https://docs.influxdata.com/influxdb/v2.3/reference/syntax/line-protocol/) and<br/>[InfluxDB 1.8 Line Protocol](https://docs.influxdata.com/influxdb/v1.8/write_protocols/line_protocol_tutorial/) <br/><br/>TLDR:<br/><br/>```<br/><measurement>[,<tag_key>=<tag_value>[,<tag_key>=<tag_value>]] <field_key>=<field_value>[,<field_key>=<field_value>] [<timestamp>]<br/>```<br/>Please note that a placeholder for an integer value must be annotated with a suffix `i`. For example `${payload.int_value}i`."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "default": "127.0.0.1:8086",
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The InfluxDB default port 8086 is used if `[:Port]` is not specified."
          },
          "precision": {
            "default": "ms",
            "type": "string",
            "enum": [
              "ns",
              "us",
              "ms",
              "s"
            ],
            "description": "InfluxDB time precision."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "bucket": {
            "type": "string",
            "description": "InfluxDB bucket name."
          },
          "org": {
            "type": "string",
            "description": "Organization name of InfluxDB."
          },
          "token": {
            "type": "string",
            "format": "password",
            "description": "InfluxDB token.",
            "example": "R4ND0M/S∃CЯ∃T"
          }
        },
        "type": "object"
      },
      "bridge_redis.creation_opts_redis_single": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "maximum": 1024,
            "type": "integer",
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 1
          },
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "start_after_created": {
            "default": true,
            "type": "boolean",
            "description": "Whether start the resource right after created."
          },
          "start_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "example": "32s"
          },
          "auto_restart_interval": {
            "default": "15s",
            "deprecated": true,
            "oneOf": [
              {
                "type": "string",
                "example": "32s"
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "query_mode": {
            "default": "async",
            "type": "string",
            "enum": [
              "sync",
              "async"
            ],
            "description": "Query mode. Optional 'sync/async', default 'async'."
          },
          "request_ttl": {
            "default": "45s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "string",
                "example": "32s"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "type": "integer",
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1
          },
          "batch_size": {
            "default": 1,
            "type": "integer",
            "description": "Maximum batch count. If equal to 1, there's effectively no batching.",
            "minimum": 1
          },
          "batch_time": {
            "default": "0ms",
            "type": "string",
            "description": "Maximum waiting interval when accumulating a batch at a low message rates for more efficient resource usage.",
            "example": "32s"
          },
          "enable_queue": {
            "default": false,
            "type": "boolean",
            "deprecated": true,
            "description": "Enable disk buffer queue (only applicable for egress bridges).<br/>When Enabled, messages will be buffered on disk when the bridge connection is down.<br/>When disabled the messages are buffered in RAM only."
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "type": "string",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB"
          }
        },
        "type": "object"
      },
      "bridge_gcp_pubsub.consumer_resource_opts": {
        "properties": {
          "health_check_interval": {
            "default": "30s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "request_ttl": {
            "default": "45s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "string",
                "example": "32s"
              }
            ]
          }
        },
        "type": "object"
      },
      "bridge_mongodb.post_rs": {
        "required": [
          "database",
          "mongo_type",
          "name",
          "replica_set_name",
          "resource_opts",
          "servers",
          "type"
        ],
        "properties": {
          "mongo_type": {
            "default": "rs",
            "type": "string",
            "enum": [
              "rs"
            ],
            "description": "Replica set. Must be set to 'rs' when MongoDB server is running in 'replica set' mode."
          },
          "servers": {
            "type": "string",
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The MongoDB default port 27017 is used if `[:Port]` is not specified."
          },
          "w_mode": {
            "default": "unsafe",
            "type": "string",
            "enum": [
              "unsafe",
              "safe"
            ],
            "description": "Write mode."
          },
          "r_mode": {
            "default": "master",
            "type": "string",
            "enum": [
              "master",
              "slave_ok"
            ],
            "description": "Read mode."
          },
          "replica_set_name": {
            "type": "string",
            "description": "Name of the replica set."
          },
          "srv_record": {
            "default": false,
            "type": "boolean",
            "description": "Use DNS SRV record."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "use_legacy_protocol": {
            "default": "auto",
            "type": "string",
            "enum": [
              "auto",
              true,
              false
            ],
            "description": "Whether to use MongoDB's legacy protocol for communicating with the database.  The default is to attempt to automatically determine if the newer protocol is supported."
          },
          "auth_source": {
            "type": "string",
            "description": "Database name associated with the user's credentials."
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "topology": {
            "$ref": "#/components/schemas/mongo.topology"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this MongoDB Action"
          },
          "collection": {
            "default": "mqtt",
            "type": "string",
            "description": "The collection where data will be stored into"
          },
          "payload_template": {
            "type": "string",
            "description": "The template for formatting the outgoing messages.  If undefined, rule engine will use JSON format to serialize all visible inputs, such as clientid, topic, payload etc."
          },
          "resource_opts": {
            "description": "Creation options.",
            "$ref": "#/components/schemas/bridge_mongodb.creation_opts"
          },
          "type": {
            "type": "string",
            "enum": [
              "mongodb_rs"
            ]
          },
          "name": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge_http.put_bridge_v2": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "parameters": {
            "description": "The parameters for HTTP action.",
            "$ref": "#/components/schemas/bridge_http.parameters_opts"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_http.action_resource_opts"
          }
        },
        "type": "object"
      },
      "emqx.ssl_client_opts": {
        "properties": {
          "cacertfile": {
            "type": "string",
            "description": "Trusted PEM format CA certificates bundle file.<br/><br/>The certificates in this file are used to verify the TLS peer's certificates.<br/>Append new certificates to the file if new CAs are to be trusted.<br/>There is no need to restart EMQX to have the updated file loaded, because<br/>the system regularly checks if file has been updated (and reload).<br/><br/>NOTE: invalidating (deleting) a certificate from the file will not affect<br/>already established connections."
          },
          "cacerts": {
            "default": false,
            "type": "boolean",
            "deprecated": true
          },
          "certfile": {
            "type": "string",
            "description": "PEM format certificates chain file.<br/><br/>The certificates in this file should be in reversed order of the certificate<br/>issue chain. That is, the host's certificate should be placed in the beginning<br/>of the file, followed by the immediate issuer certificate and so on.<br/>Although the root CA certificate is optional, it should be placed at the end of<br/>the file if it is to be added."
          },
          "keyfile": {
            "type": "string",
            "description": "PEM format private key file."
          },
          "verify": {
            "default": "verify_none",
            "type": "string",
            "enum": [
              "verify_peer",
              "verify_none"
            ],
            "description": "Enable or disable peer verification."
          },
          "reuse_sessions": {
            "default": true,
            "type": "boolean",
            "description": "Enable TLS session reuse.<br/><br/>Has no effect when TLS version is configured (or negotiated) to 1.3"
          },
          "depth": {
            "default": 10,
            "type": "integer",
            "description": "Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path.<br/>So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly;<br/><br/>if 1 the path can be PEER, Intermediate-CA, ROOT-CA;<br/><br/>if 2 the path can be PEER, Intermediate-CA1, Intermediate-CA2, ROOT-CA.",
            "minimum": 0
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "String containing the user's password. Only used if the private key file is password-protected.",
            "example": ""
          },
          "versions": {
            "default": [
              "tlsv1.3",
              "tlsv1.2"
            ],
            "type": "array",
            "description": "All TLS/DTLS versions to be supported.<br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.<br/><br/>In case PSK cipher suites are intended, make sure to configure<br/><code>['tlsv1.2', 'tlsv1.1']</code> here.",
            "items": {
              "type": "string"
            }
          },
          "ciphers": {
            "default": [],
            "type": "array",
            "description": "This config holds TLS cipher suite names separated by comma,<br/>or as an array of strings. e.g.<br/><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or<br/><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.<br/><br/><br/>Ciphers (and their ordering) define the way in which the<br/>client and server encrypts information over the network connection.<br/>Selecting a good cipher suite is critical for the<br/>application's data security, confidentiality and performance.<br/><br/>The names should be in OpenSSL string format (not RFC format).<br/>All default values and examples provided by EMQX config<br/>documentation are all in OpenSSL format.<br/><br/><br/>NOTE: Certain cipher suites are only compatible with<br/>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')<br/>incompatible cipher suites will be silently dropped.<br/>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,<br/>configuring cipher suites for other versions will have no effect.<br/><br/><br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br/><br/>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.<br/><br/>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,<br/>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,<br/>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,<br/>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code>",
            "items": {
              "type": "string"
            }
          },
          "secure_renegotiate": {
            "default": true,
            "type": "boolean",
            "description": "Whether to reject TLS renegotiation attempts that are not compliant with [RFC 5746](http://www.ietf.org/rfc/rfc5746.txt).<br/><br/>By default, `secure_renegotiate` is set to `true`, which forces secure renegotiation.<br/>If set to `false`, secure renegotiation will still be used, but will fall back to insecure renegotiation if the peer does not support [RFC 5746](http://www.ietf.org/rfc/rfc5746.txt), which increases the risk of a MitM attack.<br/><br/>Has no effect when TLS version is configured (or negotiated) to 1.3."
          },
          "log_level": {
            "default": "notice",
            "type": "string",
            "enum": [
              "emergency",
              "alert",
              "critical",
              "error",
              "warning",
              "notice",
              "info",
              "debug",
              "none",
              "all"
            ],
            "description": "The minimum level of logging allowed for SSL output.<br/><br/>The default is `notice`, set to a lower `debug` level for more detailed logging that can be used to investigate SSL handshake issues."
          },
          "hibernate_after": {
            "default": "5s",
            "type": "string",
            "description": "Specifies the amount of time that an SSL process will hibernate after being idle, thus reducing its memory footprint.<br/><br/>The hibernating process will be woken up when a new message arrives.<br/>Hibernating and waking up too often can cause CPU utilization to increase, as they both perform garbage collection on the process.",
            "example": "12m"
          },
          "partial_chain": {
            "type": "string",
            "enum": [
              true,
              false,
              "two_cacerts_from_cacertfile",
              "cacert_from_cacertfile"
            ],
            "description": "Enable or disable peer verification with partial_chain.<br/>When local verifies a peer certificate during the x509 path validation<br/>process, it constructs a certificate chain that starts with the peer<br/>certificate and ends with a trust anchor.<br/>By default, if it is set to `false`, the trust anchor is the<br/>Root CA, and the certificate chain must be complete.<br/>However, if the setting is set to `true` or `cacert_from_cacertfile`,<br/>the last certificate in `cacertfile` will be used as the trust anchor<br/>certificate (intermediate CA). This creates a partial chain<br/>in the path validation.<br/>Alternatively, if it is configured with `two_cacerts_from_cacertfile`,<br/>one of the last two certificates in `cacertfile` will be used as the<br/>trust anchor certificate, forming a partial chain. This option is<br/>particularly useful for intermediate CA certificate rotation.<br/>However, please note that it incurs some additional overhead, so it<br/>should only be used for certificate rotation purposes."
          },
          "verify_peer_ext_key_usage": {
            "type": "string",
            "description": "Verify extended key usage in peer's certificate<br/>For additional peer certificate validation, the value defined here must present in the<br/>'Extended Key Usage' of peer certificate defined in<br/>[rfc5280](https://www.rfc-editor.org/rfc/rfc5280#section-4.2.1.12).<br/><br/>Allowed values are<br/>- `clientAuth`<br/>- `serverAuth`<br/>- `codeSigning`<br/>- `emailProtection`<br/>- `timeStamping`<br/>- `ocspSigning`<br/>- raw OID, for example: \"OID:1.3.6.1.5.5.7.3.2\" means `id-pk 2` which is equivalent to `clientAuth`<br/><br/>Comma-separated string is also supported for validating more than one key usages.<br/><br/>For example, `\"serverAuth,OID:1.3.6.1.5.5.7.3.2\"`"
          },
          "enable": {
            "default": false,
            "type": "boolean",
            "description": "Enable TLS."
          },
          "server_name_indication": {
            "description": "Specify the host name to be used in TLS Server Name Indication extension.<br/><br/>For instance, when connecting to \"server.example.net\", the genuine server<br/>which accepts the connection and performs TLS handshake may differ from the<br/>host the TLS client initially connects to, e.g. when connecting to an IP address<br/>or when the host has multiple resolvable DNS records <br/><br/>If not specified, it will default to the host name string which is used<br/>to establish the connection, unless it is IP address used.<br/><br/>The host name is then also used in the host name verification of the peer<br/>certificate.<br/> The special value 'disable' prevents the Server Name<br/>Indication extension from being sent and disables the hostname<br/>verification check.",
            "example": "disable",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "string",
                "enum": [
                  "disable"
                ]
              }
            ]
          }
        },
        "type": "object"
      },
      "bridge_clickhouse.creation_opts": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "maximum": 1024,
            "type": "integer",
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 1
          },
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "start_after_created": {
            "default": true,
            "type": "boolean",
            "description": "Whether start the resource right after created."
          },
          "start_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "example": "32s"
          },
          "auto_restart_interval": {
            "default": "15s",
            "deprecated": true,
            "oneOf": [
              {
                "type": "string",
                "example": "32s"
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "query_mode": {
            "default": "async",
            "type": "string",
            "enum": [
              "sync",
              "async"
            ],
            "description": "Query mode. Optional 'sync/async', default 'async'."
          },
          "request_ttl": {
            "default": "45s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "string",
                "example": "32s"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "type": "integer",
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1
          },
          "batch_size": {
            "default": 1,
            "type": "integer",
            "description": "Maximum batch count. If equal to 1, there's effectively no batching.",
            "minimum": 1
          },
          "batch_time": {
            "default": "0ms",
            "type": "string",
            "description": "Maximum waiting interval when accumulating a batch at a low message rates for more efficient resource usage.",
            "example": "32s"
          },
          "enable_queue": {
            "default": false,
            "type": "boolean",
            "deprecated": true,
            "description": "Enable disk buffer queue (only applicable for egress bridges).<br/>When Enabled, messages will be buffered on disk when the bridge connection is down.<br/>When disabled the messages are buffered in RAM only."
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "type": "string",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB"
          }
        },
        "type": "object"
      },
      "bridge_clickhouse.put": {
        "required": [
          "database",
          "url"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "sql": {
            "default": "INSERT INTO messages(data, arrived) VALUES ('${payload}', ${timestamp})",
            "type": "string",
            "format": "sql",
            "description": "The template string can contain ${field} placeholders for message metadata and payload field. Make sure that the inserted values are formatted and escaped correctly. [Prepared Statement](https://docs.emqx.com/en/enterprise/v5.0/data-integration/data-bridges.html#Prepared-Statement) is not supported."
          },
          "batch_value_separator": {
            "default": ", ",
            "type": "string",
            "description": "The default value ',' works for the VALUES format. You can also use other separator if other format is specified. See [INSERT INTO Statement](https://clickhouse.com/docs/en/sql-reference/statements/insert-into)."
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to Clickhouse. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_clickhouse.creation_opts"
          },
          "url": {
            "type": "string",
            "description": "The HTTP URL to the Clickhouse server that you want to connect to (for example http://myhostname:8123)",
            "example": "http://127.0.0.1"
          },
          "connect_timeout": {
            "default": "15s",
            "type": "string",
            "description": "The timeout when connecting to the Clickhouse server.",
            "example": "32s"
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          }
        },
        "type": "object"
      },
      "rule_engine.rule_engine": {
        "properties": {
          "ignore_sys_message": {
            "default": true,
            "type": "boolean",
            "description": "When set to 'true' (default), rule-engine will ignore messages published to $SYS topics."
          },
          "jq_function_default_timeout": {
            "default": "10s",
            "type": "string",
            "description": "Default timeout for the `jq` rule engine function",
            "example": "32s"
          }
        },
        "type": "object"
      },
      "bridge_mysql.get_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "mysql"
            ]
          },
          "name": {
            "type": "string"
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Additional parameters specific to this action type",
            "$ref": "#/components/schemas/bridge_mysql.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_s3.post_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "s3"
            ]
          },
          "name": {
            "type": "string"
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Action that takes incoming events and uploads them to the S3 API compatible service.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/bridge_s3.s3_direct_upload_parameters"
              },
              {
                "$ref": "#/components/schemas/bridge_s3.s3_aggregated_upload_parameters"
              }
            ]
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_s3.s3_upload_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_rabbitmq.post_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "rabbitmq"
            ]
          },
          "name": {
            "type": "string"
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "The action config defines how this bridge send messages to the remote RabbitMQ broker",
            "$ref": "#/components/schemas/bridge_rabbitmq.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_rabbitmq.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_tdengine.get_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "tdengine"
            ]
          },
          "name": {
            "type": "string"
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "TDengine action parameters",
            "$ref": "#/components/schemas/bridge_tdengine.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_clickhouse.put_connector": {
        "required": [
          "database",
          "url"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this connector."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "url": {
            "type": "string",
            "description": "The HTTP URL to the Clickhouse server that you want to connect to (for example http://myhostname:8123)",
            "example": "http://127.0.0.1"
          },
          "connect_timeout": {
            "default": "15s",
            "type": "string",
            "description": "The timeout when connecting to the Clickhouse server.",
            "example": "32s"
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_clickhouse.connector_resource_opts"
          }
        },
        "type": "object"
      },
      "message_transformation_http_api.reorder": {
        "required": [
          "order"
        ],
        "properties": {
          "order": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "type": "object"
      },
      "bridge_mongodb.put_rs": {
        "required": [
          "database",
          "mongo_type",
          "replica_set_name",
          "resource_opts",
          "servers"
        ],
        "properties": {
          "mongo_type": {
            "default": "rs",
            "type": "string",
            "enum": [
              "rs"
            ],
            "description": "Replica set. Must be set to 'rs' when MongoDB server is running in 'replica set' mode."
          },
          "servers": {
            "type": "string",
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The MongoDB default port 27017 is used if `[:Port]` is not specified."
          },
          "w_mode": {
            "default": "unsafe",
            "type": "string",
            "enum": [
              "unsafe",
              "safe"
            ],
            "description": "Write mode."
          },
          "r_mode": {
            "default": "master",
            "type": "string",
            "enum": [
              "master",
              "slave_ok"
            ],
            "description": "Read mode."
          },
          "replica_set_name": {
            "type": "string",
            "description": "Name of the replica set."
          },
          "srv_record": {
            "default": false,
            "type": "boolean",
            "description": "Use DNS SRV record."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "use_legacy_protocol": {
            "default": "auto",
            "type": "string",
            "enum": [
              "auto",
              true,
              false
            ],
            "description": "Whether to use MongoDB's legacy protocol for communicating with the database.  The default is to attempt to automatically determine if the newer protocol is supported."
          },
          "auth_source": {
            "type": "string",
            "description": "Database name associated with the user's credentials."
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "topology": {
            "$ref": "#/components/schemas/mongo.topology"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this MongoDB Action"
          },
          "collection": {
            "default": "mqtt",
            "type": "string",
            "description": "The collection where data will be stored into"
          },
          "payload_template": {
            "type": "string",
            "description": "The template for formatting the outgoing messages.  If undefined, rule engine will use JSON format to serialize all visible inputs, such as clientid, topic, payload etc."
          },
          "resource_opts": {
            "description": "Creation options.",
            "$ref": "#/components/schemas/bridge_mongodb.creation_opts"
          }
        },
        "type": "object"
      },
      "bridge_kafka.put_bridge_v2": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in Kafka."
          },
          "parameters": {
            "description": "Kafka producer configs.",
            "$ref": "#/components/schemas/bridge_kafka.producer_kafka_opts"
          },
          "resource_opts": {
            "default": {},
            "$ref": "#/components/schemas/bridge_kafka.resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_oracle.get_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "oracle"
            ]
          },
          "name": {
            "type": "string"
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Action specific configuration.",
            "$ref": "#/components/schemas/bridge_oracle.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_dynamo.get_connector": {
        "required": [
          "aws_access_key_id",
          "aws_secret_access_key",
          "name",
          "region",
          "type",
          "url"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "dynamo"
            ],
            "description": "The type of the connector."
          },
          "name": {
            "type": "string",
            "description": "The name of the connector."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this connector."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the connector<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the connector passes the health probes.<br/><br/>- <code>disconnected</code>: when the connector can not pass health probes.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a connector is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/connector.node_status"
            }
          },
          "actions": {
            "type": "array",
            "description": "List of actions added to this connector.",
            "items": {
              "type": "string"
            },
            "example": [
              "my_action"
            ]
          },
          "url": {
            "type": "string",
            "description": "The url of DynamoDB endpoint."
          },
          "region": {
            "type": "string",
            "description": "Region of AWS Dynamo"
          },
          "aws_access_key_id": {
            "type": "string",
            "description": "Access Key ID for connecting to DynamoDB."
          },
          "aws_secret_access_key": {
            "type": "string",
            "format": "password",
            "description": "AWS Secret Access Key for connecting to DynamoDB.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_dynamo.connector_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_rabbitmq.put_source": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "parameters": {
            "description": "The source config defines how this bridge receive messages from the remote RabbitMQ broker",
            "$ref": "#/components/schemas/bridge_rabbitmq.source_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.source_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_gcp_pubsub.consumer": {
        "required": [
          "topic_mapping"
        ],
        "properties": {
          "pull_max_messages": {
            "default": 100,
            "type": "integer",
            "description": "The maximum number of messages to retrieve from GCP PubSub in a single pull request. The actual number may be less than the specified value.",
            "minimum": 1
          },
          "topic_mapping": {
            "type": "array",
            "description": "Defines the mapping between GCP PubSub topics and MQTT topics. Must contain at least one item.",
            "items": {
              "$ref": "#/components/schemas/bridge_gcp_pubsub.consumer_topic_mapping"
            }
          }
        },
        "type": "object"
      },
      "bridge_kinesis.put_producer": {
        "required": [
          "aws_access_key_id",
          "aws_secret_access_key",
          "endpoint",
          "partition_key",
          "stream_name"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Creation options.",
            "$ref": "#/components/schemas/bridge_kinesis.creation_opts"
          },
          "aws_access_key_id": {
            "type": "string",
            "description": "Access Key ID for connecting to Amazon Kinesis."
          },
          "aws_secret_access_key": {
            "type": "string",
            "format": "password",
            "description": "AWS Secret Access Key for connecting to Amazon Kinesis.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "endpoint": {
            "type": "string",
            "description": "The url of Amazon Kinesis endpoint.",
            "example": "https://kinesis.us-east-1.amazonaws.com"
          },
          "max_retries": {
            "default": 2,
            "type": "integer",
            "description": "Max retry times if an error occurs when sending a request.",
            "minimum": 0
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "The pool size.",
            "minimum": 1
          },
          "payload_template": {
            "default": "${.}",
            "type": "string",
            "description": "The template for formatting the outgoing messages.  If undefined, will send all the available context in JSON format."
          },
          "stream_name": {
            "type": "string",
            "description": "The Amazon Kinesis Stream to publish messages to."
          },
          "partition_key": {
            "type": "string",
            "description": "The Amazon Kinesis Partition Key associated to published message. Placeholders in format of ${var} are supported."
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to Amazon Kinesis. All MQTT `PUBLISH` messages with the topic<br/>matching the `local_topic` will be forwarded.<br/><br/>NOTE: If this action is used as the action of a rule (EMQX rule engine), and also `local_topic` is<br/>configured, then both the data got from the rule and the MQTT messages that match `local_topic`<br/>will be forwarded."
          }
        },
        "type": "object"
      },
      "bridge_hstreamdb.get_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "hstreamdb"
            ]
          },
          "name": {
            "type": "string"
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Action specific configuration.",
            "$ref": "#/components/schemas/bridge_hstreamdb.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_dynamo.action_parameters": {
        "required": [
          "hash_key",
          "table"
        ],
        "properties": {
          "template": {
            "default": "",
            "type": "string",
            "description": "Template, the default value is empty. When this value is empty the whole message will be stored in the database.<br><br/>The template can be any valid JSON with placeholders and make sure all keys for table are here, example:<br><br/>  <code>{\"id\" : \"${id}\", \"clientid\" : \"${clientid}\", \"data\" : \"${payload.data}\"}</code>"
          },
          "hash_key": {
            "type": "string",
            "description": "DynamoDB Hash Key"
          },
          "range_key": {
            "type": "string",
            "description": "DynamoDB Range Key"
          },
          "table": {
            "type": "string",
            "description": "DynamoDB Table."
          }
        },
        "type": "object"
      },
      "rocketmq.get": {
        "required": [
          "name",
          "servers",
          "type"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "rocketmq"
            ],
            "description": "The Bridge Type"
          },
          "name": {
            "type": "string",
            "description": "Bridge name."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "template": {
            "default": "",
            "type": "string",
            "description": "Template, the default value is empty. When this value is empty the whole message will be stored in the RocketMQ.<br><br/>            The template can be any valid string with placeholders, example:<br><br/>            - ${id}, ${username}, ${clientid}, ${timestamp}<br><br/>            - {\"id\" : ${id}, \"username\" : ${username}}"
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to RocketMQ. All MQTT `PUBLISH` messages with the topic<br/>matching the `local_topic` will be forwarded.<br/><br/>NOTE: if the bridge is used as a rule action, `local_topic` should be left empty otherwise the messages will be duplicated."
          },
          "strategy": {
            "default": "roundrobin",
            "description": "Producer key dispatch strategy, the default is `roundrobin`, also supports placeholders, such as: `clientid`, `messageid`, `username`.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "string",
                "enum": [
                  "roundrobin"
                ]
              }
            ]
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "servers": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The RocketMQ default port 9876 is used if `[:Port]` is not specified."
          },
          "namespace": {
            "type": "string",
            "description": "The namespace field MUST be set if you are using the RocketMQ service in<br/>aliyun cloud and also the namespace is enabled,<br/>or if you have configured a namespace in your RocketMQ server.<br/>For RocketMQ in aliyun cloud, the namespace is the instance ID."
          },
          "topic": {
            "default": "TopicTest",
            "type": "string",
            "description": "RocketMQ Topic"
          },
          "access_key": {
            "default": "",
            "type": "string",
            "description": "RocketMQ server `accessKey`."
          },
          "secret_key": {
            "default": "",
            "type": "string",
            "format": "password",
            "description": "RocketMQ server `secretKey`.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "security_token": {
            "default": "",
            "type": "string",
            "format": "password",
            "description": "RocketMQ Server Security Token",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "sync_timeout": {
            "default": "3s",
            "type": "string",
            "description": "Timeout of RocketMQ driver synchronous call.",
            "example": "12m"
          },
          "refresh_interval": {
            "default": "3s",
            "type": "string",
            "description": "RocketMQ Topic Route Refresh Interval.",
            "example": "12m"
          },
          "send_buffer": {
            "default": "1024KB",
            "type": "string",
            "description": "The socket send buffer size of the RocketMQ driver client.",
            "example": "32MB"
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "bridge_elasticsearch.action_update": {
        "required": [
          "action",
          "id",
          "index"
        ],
        "properties": {
          "action": {
            "type": "string",
            "enum": [
              "update"
            ],
            "description": "update"
          },
          "index": {
            "type": "string",
            "description": "Name of index, or index alias to perform the action on.<br/>This parameter is required.",
            "example": "${payload.index}"
          },
          "id": {
            "type": "string",
            "description": "The document ID. If no ID is specified, a document ID is automatically generated.",
            "example": "${payload.id}"
          },
          "doc": {
            "type": "string",
            "description": "JSON document. If undefined, rule engine will use JSON format to serialize all visible inputs, such as clientid, topic, payload etc.",
            "example": "${payload.doc}"
          },
          "doc_as_upsert": {
            "default": false,
            "type": "boolean",
            "description": "Instead of sending a partial doc plus an upsert doc,<br/>you can set doc_as_upsert to true to use the contents of doc as the upsert value."
          },
          "routing": {
            "type": "string",
            "description": "Custom value used to route operations to a specific shard.",
            "example": "${payload.routing}"
          },
          "require_alias": {
            "type": "boolean",
            "description": "If true, the request’s actions must target an index alias. Defaults to false"
          },
          "max_retries": {
            "default": 2,
            "type": "integer",
            "description": "HTTP request max retry times if failed.",
            "minimum": 0
          }
        },
        "type": "object"
      },
      "rule_engine.republish_args": {
        "required": [
          "topic"
        ],
        "properties": {
          "topic": {
            "type": "string",
            "description": "The target topic of message to be re-published.<br/>Template with variables is allowed, see description of the 'republish_args'.",
            "example": "a/1"
          },
          "qos": {
            "default": "${qos}",
            "description": "The qos of the message to be re-published.<br/>Template with variables is allowed, see description of the 'republish_args'.<br/>Defaults to ${qos}. If variable ${qos} is not found from the selected result of the rule,<br/>0 is used.",
            "example": "${qos}",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "maximum": 2,
                "type": "integer",
                "minimum": 0,
                "example": 0
              }
            ]
          },
          "retain": {
            "default": "${retain}",
            "description": "The 'retain' flag of the message to be re-published.<br/>Template with variables is allowed, see description of the 'republish_args'.<br/>Defaults to ${retain}. If variable ${retain} is not found from the selected result<br/>of the rule, false is used.",
            "example": "${retain}",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "boolean"
              }
            ]
          },
          "payload": {
            "default": "${payload}",
            "type": "string",
            "description": "The payload of the message to be re-published.<br/>Template with variables is allowed, see description of the 'republish_args'.<br/>Defaults to ${payload}. If variable ${payload} is not found from the selected result<br/>of the rule, then the string \"undefined\" is used.",
            "example": "${payload}"
          },
          "mqtt_properties": {
            "default": {},
            "description": "From which variable should the MQTT Publish Properties of the message be taken.<br/>Placeholders like <code>${.payload.content_type}</code> may be used.",
            "$ref": "#/components/schemas/rule_engine.republish_mqtt_properties"
          },
          "user_properties": {
            "default": "${user_properties}",
            "type": "string",
            "description": "From which variable should the MQTT message's User-Property pairs be taken from.<br/>The value must be a map.<br/>You may configure it to <code>${pub_props.'User-Property'}</code> or<br/>use <code>SELECT *,pub_props.'User-Property' as user_properties</code><br/>to forward the original user properties to the republished message.<br/>You may also call <code>map_put</code> function like<br/><code>map_put('my-prop-name', 'my-prop-value', user_properties) as user_properties</code><br/>to inject user properties.<br/>NOTE: MQTT spec allows duplicated user property names, but EMQX Rule-Engine does not.",
            "example": "${pub_props.'User-Property'}"
          },
          "direct_dispatch": {
            "default": false,
            "description": "Enable direct dispatch to subscribers without initiating a new message publish event.<br/>When set to `true`, this prevents the recursive processing of a message by the same action<br/>and is used when the output message does not require further processing.<br/><br/>However, enabling this feature has several limitations:<br/><br/>- The output message from this action is not retained.<br/>- It does not trigger other rules that operate based on the output topic of this action.<br/>- It does not activate rules that select from the `$events/message_publish`.<br/>- It does not trigger plugins that use the `'message.publish'` hook.<br/>- Topic metrics are not collected for the output message of this action.<br/>- Message schema validation is not applied (feature of EMQX Enterprise).<br/>- Message transformation processes are not applied (feature of EMQX Enterprise).",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "boolean"
              }
            ]
          }
        },
        "type": "object"
      },
      "pulsar.post_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "pulsar"
            ]
          },
          "name": {
            "type": "string"
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Action specific configs.",
            "$ref": "#/components/schemas/pulsar.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/pulsar.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_mysql.put_bridge_v2": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Additional parameters specific to this action type",
            "$ref": "#/components/schemas/bridge_mysql.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "redis.get_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "redis"
            ],
            "description": "The Action Type"
          },
          "name": {
            "type": "string",
            "description": "Action name, used as a human-readable identifier."
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "The parameters of the action.",
            "$ref": "#/components/schemas/bridge_redis.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/redis.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_opents.action_parameters": {
        "properties": {
          "data": {
            "default": [],
            "type": "array",
            "description": "OpenTSDB action parameter data",
            "items": {
              "$ref": "#/components/schemas/bridge_opents.action_parameters_data"
            }
          }
        },
        "type": "object"
      },
      "syskeeper.post_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "syskeeper_forwarder"
            ],
            "description": "The action type."
          },
          "name": {
            "type": "string",
            "description": "Action name."
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Syskeeper action parameters",
            "$ref": "#/components/schemas/syskeeper.parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/syskeeper.creation_opts"
          }
        },
        "type": "object"
      },
      "bridge.metrics": {
        "properties": {
          "dropped": {
            "type": "integer",
            "description": "Count of messages dropped."
          },
          "dropped.other": {
            "type": "integer",
            "description": "Count of messages dropped due to other reasons."
          },
          "dropped.queue_full": {
            "type": "integer",
            "description": "Count of messages dropped due to the queue is full."
          },
          "dropped.resource_not_found": {
            "type": "integer",
            "description": "Count of messages dropped due to the resource is not found."
          },
          "dropped.resource_stopped": {
            "type": "integer",
            "description": "Count of messages dropped due to the resource is stopped."
          },
          "matched": {
            "type": "integer",
            "description": "Count of this bridge is matched and queried."
          },
          "queuing": {
            "type": "integer",
            "description": "Count of messages that are currently queuing."
          },
          "retried": {
            "type": "integer",
            "description": "Times of retried."
          },
          "failed": {
            "type": "integer",
            "description": "Count of messages that sent failed."
          },
          "inflight": {
            "type": "integer",
            "description": "Count of messages that were sent asynchronously but ACKs are not yet received."
          },
          "success": {
            "type": "integer",
            "description": "Count of messages that sent successfully."
          },
          "rate": {
            "type": "number",
            "description": "The rate of matched, times/second"
          },
          "rate_max": {
            "type": "number",
            "description": "The max rate of matched, times/second"
          },
          "rate_last5m": {
            "type": "number",
            "description": "The average rate of matched in the last 5 minutes, times/second"
          },
          "received": {
            "type": "number",
            "description": "Count of messages that is received from the remote system."
          }
        },
        "type": "object"
      },
      "audit.audit_list": {
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/audit.audit"
            }
          },
          "meta": {
            "$ref": "#/components/schemas/public.meta"
          }
        },
        "type": "object"
      },
      "bridge_influxdb.get_api_v1": {
        "required": [
          "database",
          "name",
          "type",
          "write_syntax"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to the InfluxDB. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "write_syntax": {
            "type": "string",
            "format": "sql",
            "description": "Conf of InfluxDB line protocol to write data points. It is a text-based format that provides the measurement, tag set, field set, and timestamp of a data point, and placeholder supported.<br/>See also [InfluxDB 2.3 Line Protocol](https://docs.influxdata.com/influxdb/v2.3/reference/syntax/line-protocol/) and<br/>[InfluxDB 1.8 Line Protocol](https://docs.influxdata.com/influxdb/v1.8/write_protocols/line_protocol_tutorial/) <br/><br/>TLDR:<br/><br/>```<br/><measurement>[,<tag_key>=<tag_value>[,<tag_key>=<tag_value>]] <field_key>=<field_value>[,<field_key>=<field_value>] [<timestamp>]<br/>```<br/>Please note that a placeholder for an integer value must be annotated with a suffix `i`. For example `${payload.int_value}i`."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "default": "127.0.0.1:8086",
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The InfluxDB default port 8086 is used if `[:Port]` is not specified."
          },
          "precision": {
            "default": "ms",
            "type": "string",
            "enum": [
              "ns",
              "us",
              "ms",
              "s"
            ],
            "description": "InfluxDB time precision."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "database": {
            "type": "string",
            "description": "InfluxDB database."
          },
          "username": {
            "type": "string",
            "description": "InfluxDB username."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "InfluxDB password.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "type": {
            "type": "string",
            "enum": [
              "influxdb_api_v1"
            ],
            "description": "The Bridge Type."
          },
          "name": {
            "type": "string",
            "description": "Bridge name."
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          }
        },
        "type": "object"
      },
      "rule_engine.ctx_bridge_mqtt": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "type": "string",
            "enum": [
              "$bridges/mqtt:*"
            ],
            "description": "Event Type"
          },
          "id": {
            "type": "string",
            "description": "Message ID"
          },
          "payload": {
            "type": "string",
            "description": "The Message Payload"
          },
          "topic": {
            "type": "string",
            "description": "Message Topic"
          },
          "server": {
            "type": "string",
            "description": "The IP address (or hostname) and port of the MQTT broker, in IP:Port format"
          },
          "dup": {
            "type": "string",
            "description": "The DUP flag of the MQTT message"
          },
          "retain": {
            "type": "string",
            "description": "If is a retain message"
          },
          "message_received_at": {
            "type": "integer",
            "description": "The Time that this Message is Received"
          },
          "qos": {
            "maximum": 2,
            "type": "integer",
            "description": "The Message QoS",
            "minimum": 0,
            "example": 0
          }
        },
        "type": "object"
      },
      "bridge_cassa.action_parameters": {
        "properties": {
          "cql": {
            "default": "insert into mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic},  ${qos}, ${payload}, ${timestamp})",
            "type": "string",
            "format": "sql",
            "description": "CQL Template"
          }
        },
        "type": "object"
      },
      "connector_aggregator.container_csv": {
        "required": [
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "csv"
            ],
            "description": "Records (events) will be aggregated and uploaded as a CSV file."
          },
          "column_order": {
            "default": [],
            "type": "array",
            "description": "Event fields that will be ordered first as columns in the resulting CSV file.<br/><br/>Regardless of this setting, resulting CSV will contain all the fields of aggregated events, but all the columns not explicitly mentioned here will be ordered after the ones listed here in the lexicographical order.",
            "items": {
              "type": "string"
            }
          }
        },
        "type": "object"
      },
      "bridge_mysql.put": {
        "required": [
          "database",
          "server"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this action"
          },
          "sql": {
            "default": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, FROM_UNIXTIME(${timestamp}/1000))",
            "type": "string",
            "format": "sql",
            "description": "SQL Template"
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to MySQL. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: If this action is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The MySQL default port 3306 is used if `[:Port]` is not specified."
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "default": "root",
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "bridge_mongodb.post_sharded": {
        "required": [
          "database",
          "mongo_type",
          "name",
          "resource_opts",
          "servers",
          "type"
        ],
        "properties": {
          "mongo_type": {
            "default": "sharded",
            "type": "string",
            "enum": [
              "sharded"
            ],
            "description": "Sharded cluster. Must be set to 'sharded' when MongoDB server is running in 'sharded' mode."
          },
          "servers": {
            "type": "string",
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The MongoDB default port 27017 is used if `[:Port]` is not specified."
          },
          "w_mode": {
            "default": "unsafe",
            "type": "string",
            "enum": [
              "unsafe",
              "safe"
            ],
            "description": "Write mode."
          },
          "srv_record": {
            "default": false,
            "type": "boolean",
            "description": "Use DNS SRV record."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "use_legacy_protocol": {
            "default": "auto",
            "type": "string",
            "enum": [
              "auto",
              true,
              false
            ],
            "description": "Whether to use MongoDB's legacy protocol for communicating with the database.  The default is to attempt to automatically determine if the newer protocol is supported."
          },
          "auth_source": {
            "type": "string",
            "description": "Database name associated with the user's credentials."
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "topology": {
            "$ref": "#/components/schemas/mongo.topology"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this MongoDB Action"
          },
          "collection": {
            "default": "mqtt",
            "type": "string",
            "description": "The collection where data will be stored into"
          },
          "payload_template": {
            "type": "string",
            "description": "The template for formatting the outgoing messages.  If undefined, rule engine will use JSON format to serialize all visible inputs, such as clientid, topic, payload etc."
          },
          "resource_opts": {
            "description": "Creation options.",
            "$ref": "#/components/schemas/bridge_mongodb.creation_opts"
          },
          "type": {
            "type": "string",
            "enum": [
              "mongodb_sharded"
            ]
          },
          "name": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge_clickhouse.post_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "clickhouse"
            ]
          },
          "name": {
            "type": "string"
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Action specific configs.",
            "$ref": "#/components/schemas/bridge_clickhouse.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge.node_status": {
        "properties": {
          "node": {
            "type": "string",
            "description": "The node name.",
            "example": "emqx@127.0.0.1"
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ]
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          }
        },
        "type": "object"
      },
      "bridge_iotdb.post": {
        "required": [
          "base_url",
          "name",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "iotdb"
            ]
          },
          "name": {
            "type": "string"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "authentication": {
            "default": "auth_basic",
            "description": "Authentication configuration",
            "oneOf": [
              {
                "$ref": "#/components/schemas/bridge_iotdb.auth_basic"
              }
            ]
          },
          "is_aligned": {
            "default": false,
            "type": "boolean",
            "description": "Whether to align the timeseries"
          },
          "device_id": {
            "type": "string",
            "description": "The IoTDB device ID this data should be inserted for.<br/>If left empty, the MQTT message payload must contain a `device_id` field,<br/>or EMQX's rule-engine SQL must produce a `device_id` field."
          },
          "iotdb_version": {
            "default": "v1.3.x",
            "type": "string",
            "enum": [
              "v1.3.x",
              "v1.1.x",
              "v1.0.x",
              "v0.13.x"
            ],
            "description": "The version of the IoTDB system to connect to."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_iotdb.creation_opts"
          },
          "connect_timeout": {
            "default": "15s",
            "type": "string",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s"
          },
          "retry_interval": {
            "type": "string",
            "deprecated": true,
            "example": "12m"
          },
          "pool_type": {
            "default": "random",
            "type": "string",
            "enum": [
              "random",
              "hash"
            ],
            "description": "The type of the pool. Can be one of `random`, `hash`."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "The pool size.",
            "minimum": 1
          },
          "enable_pipelining": {
            "default": 100,
            "type": "integer",
            "description": "The maximum number of HTTP requests that can be sent before an HTTP response is received.<br/><br/>Setting this to 1 is equivalent to turning off HTTP pipelining, and the EMQX must receive a response to the previous HTTP request before sending the next HTTP request.",
            "minimum": 1
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "base_url": {
            "type": "string",
            "description": "The base URL of the external IoTDB service's REST interface.",
            "example": "http://127.0.0.1"
          },
          "max_retries": {
            "default": 2,
            "type": "integer",
            "description": "HTTP request max retry times if failed.",
            "minimum": 0
          }
        },
        "type": "object"
      },
      "bridge_mysql.action_parameters": {
        "properties": {
          "sql": {
            "default": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, FROM_UNIXTIME(${timestamp}/1000))",
            "type": "string",
            "format": "sql",
            "description": "SQL Template"
          }
        },
        "type": "object"
      },
      "bridge_hstreamdb.action_parameters": {
        "required": [
          "stream"
        ],
        "properties": {
          "stream": {
            "type": "string",
            "description": "HStreamDB Stream Name."
          },
          "partition_key": {
            "type": "string",
            "description": "HStreamDB Partition Key. Placeholders supported."
          },
          "grpc_flush_timeout": {
            "default": "10s",
            "type": "string",
            "description": "Time interval for flushing gRPC calls to the HStreamDB server.",
            "example": "32s"
          },
          "record_template": {
            "default": "${payload}",
            "type": "string",
            "description": "The HStream Record template to be forwarded to the HStreamDB. Placeholders supported.<br><br/>NOTE: When you use `raw record` template (which means the data is not a valid JSON), you should use `read` or `subscription` in HStream to get the data."
          },
          "aggregation_pool_size": {
            "default": 8,
            "type": "integer",
            "description": "The size of the record aggregation pool. A larger aggregation pool size can lead to enhanced parallelization but may also result in reduced efficiency due to smaller batch sizes.",
            "minimum": 1
          },
          "max_batches": {
            "default": 500,
            "type": "integer",
            "description": "Maximum number of unconfirmed batches in the flush queue.",
            "minimum": 1
          },
          "writer_pool_size": {
            "default": 8,
            "type": "integer",
            "description": "The size of the writer pool. A larger pool may increase parallelization and concurrent write operations, potentially boosting throughput. Trade-offs include greater memory consumption and possible resource contention.",
            "minimum": 1
          },
          "batch_size": {
            "default": 100,
            "type": "integer",
            "description": "Maximum number of insert data clauses that can be sent in a single request.",
            "minimum": 1
          },
          "batch_interval": {
            "default": "500ms",
            "type": "string",
            "description": "Maximum interval that is allowed between two successive (batch) request.",
            "example": "32s"
          }
        },
        "type": "object"
      },
      "bridge_opents.post": {
        "required": [
          "name",
          "server",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "opents"
            ],
            "description": "The Bridge Type"
          },
          "name": {
            "type": "string",
            "description": "Bridge name."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "type": "string",
            "description": "The URL of OpenTSDB endpoint."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "summary": {
            "default": true,
            "type": "boolean",
            "description": "Whether to return summary information."
          },
          "details": {
            "default": false,
            "type": "boolean",
            "description": "Whether to return detailed information."
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          }
        },
        "type": "object"
      },
      "bridge_datalayers.connector_resource_opts": {
        "properties": {
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "start_after_created": {
            "default": true,
            "type": "boolean",
            "description": "Whether start the resource right after created."
          },
          "start_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "example": "32s"
          }
        },
        "type": "object"
      },
      "bridge_azure_event_hub.post_producer": {
        "required": [
          "authentication",
          "bootstrap_hosts",
          "kafka",
          "name",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "azure_event_hub_producer"
            ],
            "description": "The action type."
          },
          "name": {
            "type": "string",
            "description": "Bridge name, used as a human-readable description of the bridge."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this connector."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "bootstrap_hosts": {
            "type": "string",
            "description": "A comma separated list of Azure Event Hubs Kafka <code>host[:port]</code> namespace endpoints to bootstrap the client.  Default port number is 9093."
          },
          "connect_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Maximum wait time for TCP connection establishment (including authentication time if enabled).",
            "example": "32s"
          },
          "min_metadata_refresh_interval": {
            "default": "3s",
            "type": "string",
            "description": "Minimum time interval the client has to wait before refreshing Azure Event Hubs Kafka broker and topic metadata. Setting too small value may add extra load on Azure Event Hubs.",
            "example": "32s"
          },
          "metadata_request_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Maximum wait time when fetching metadata from Azure Event Hubs.",
            "example": "32s"
          },
          "authentication": {
            "default": {},
            "description": "Authentication configs.",
            "$ref": "#/components/schemas/bridge_azure_event_hub.auth_username_password"
          },
          "socket_opts": {
            "description": "Extra socket options.",
            "$ref": "#/components/schemas/bridge_kafka.socket_opts"
          },
          "health_check_topic": {
            "type": "string",
            "description": "Topic name used exclusively for more accurate connector health checks."
          },
          "ssl": {
            "default": {
              "enable": true
            },
            "$ref": "#/components/schemas/bridge_azure_event_hub.ssl_client_opts"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_kafka.connector_resource_opts"
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in Azure Event Hubs."
          },
          "kafka": {
            "description": "Azure Event Hubs producer configs.",
            "$ref": "#/components/schemas/bridge_azure_event_hub.producer_kafka_opts"
          }
        },
        "type": "object"
      },
      "action_couchbase.post_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "couchbase"
            ]
          },
          "name": {
            "type": "string"
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Set of parameters for the action.",
            "$ref": "#/components/schemas/action_couchbase.parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/action_couchbase.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_mongodb.action_parameters": {
        "properties": {
          "collection": {
            "default": "mqtt",
            "type": "string",
            "description": "The collection where data will be stored into"
          },
          "payload_template": {
            "type": "string",
            "description": "The template for formatting the outgoing messages.  If undefined, rule engine will use JSON format to serialize all visible inputs, such as clientid, topic, payload etc."
          }
        },
        "type": "object"
      },
      "bridge_sqlserver.post_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "sqlserver"
            ]
          },
          "name": {
            "type": "string"
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Action specific configuration.",
            "$ref": "#/components/schemas/bridge_sqlserver.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_influxdb.post_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "influxdb"
            ]
          },
          "name": {
            "type": "string"
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Additional parameters specific to this action type",
            "$ref": "#/components/schemas/bridge_influxdb.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "action_couchbase.action_resource_opts": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "maximum": 1024,
            "type": "integer",
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 1
          },
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "query_mode": {
            "default": "async",
            "type": "string",
            "enum": [
              "sync",
              "async"
            ],
            "description": "Query mode. Optional 'sync/async', default 'async'."
          },
          "request_ttl": {
            "default": "45s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "string",
                "example": "32s"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "type": "integer",
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "type": "string",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB"
          }
        },
        "type": "object"
      },
      "file_transfer.storage_backend": {
        "properties": {
          "local": {
            "description": "Local file system backend to store uploaded fragments and temporary data.",
            "$ref": "#/components/schemas/file_transfer.local_storage"
          }
        },
        "type": "object"
      },
      "bridge_mqtt_publisher.get_source": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "mqtt"
            ]
          },
          "name": {
            "type": "string"
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "parameters": {
            "$ref": "#/components/schemas/bridge_mqtt_publisher.ingress_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_mqtt_publisher.source_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_s3.put_bridge_v2": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Action that takes incoming events and uploads them to the S3 API compatible service.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/bridge_s3.s3_direct_upload_parameters"
              },
              {
                "$ref": "#/components/schemas/bridge_s3.s3_aggregated_upload_parameters"
              }
            ]
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_s3.s3_upload_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_clickhouse.get_connector": {
        "required": [
          "database",
          "name",
          "type",
          "url"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "clickhouse"
            ],
            "description": "The type of the connector."
          },
          "name": {
            "type": "string",
            "description": "The name of the connector."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this connector."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the connector<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the connector passes the health probes.<br/><br/>- <code>disconnected</code>: when the connector can not pass health probes.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a connector is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/connector.node_status"
            }
          },
          "actions": {
            "type": "array",
            "description": "List of actions added to this connector.",
            "items": {
              "type": "string"
            },
            "example": [
              "my_action"
            ]
          },
          "url": {
            "type": "string",
            "description": "The HTTP URL to the Clickhouse server that you want to connect to (for example http://myhostname:8123)",
            "example": "http://127.0.0.1"
          },
          "connect_timeout": {
            "default": "15s",
            "type": "string",
            "description": "The timeout when connecting to the Clickhouse server.",
            "example": "32s"
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_clickhouse.connector_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_cassa.get_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "cassandra"
            ]
          },
          "name": {
            "type": "string"
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Action specific configs.",
            "$ref": "#/components/schemas/bridge_cassa.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_hstreamdb.post": {
        "required": [
          "name",
          "stream",
          "type",
          "url"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "direction": {
            "default": "egress",
            "type": "string",
            "enum": [
              "egress"
            ],
            "description": "The direction of this bridge, MUST be 'egress'"
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to the HStreamDB. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: If this action is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "record_template": {
            "default": "${payload}",
            "type": "string",
            "description": "The HStream Record template to be forwarded to the HStreamDB. Placeholders supported.<br><br/>NOTE: When you use `raw record` template (which means the data is not a valid JSON), you should use `read` or `subscription` in HStream to get the data."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "url": {
            "default": "http://127.0.0.1:6570",
            "type": "string",
            "description": "HStreamDB Server URL. This URL will be used as the gRPC HTTP server address."
          },
          "stream": {
            "type": "string",
            "description": "HStreamDB Stream Name."
          },
          "partition_key": {
            "type": "string",
            "description": "HStreamDB Partition Key. Placeholders supported."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "grpc_timeout": {
            "default": "30s",
            "type": "string",
            "description": "The timeout for HStreamDB gRPC requests.",
            "example": "32s"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "type": {
            "type": "string",
            "enum": [
              "hstreamdb"
            ],
            "description": "The type of the action."
          },
          "name": {
            "type": "string",
            "description": "Action name, a human-readable identifier."
          }
        },
        "type": "object"
      },
      "rule_engine.ctx_connack": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "type": "string",
            "enum": [
              "client_connack"
            ],
            "description": "Event Type"
          },
          "reason_code": {
            "type": "string",
            "description": "The reason code"
          },
          "clientid": {
            "type": "string",
            "description": "The Client ID"
          },
          "clean_start": {
            "default": true,
            "type": "boolean",
            "description": "Clean Start"
          },
          "username": {
            "type": "string",
            "description": "Username"
          },
          "peername": {
            "type": "string",
            "description": "The IP Address and Port of the Peer Client"
          },
          "sockname": {
            "type": "string",
            "description": "The IP Address and Port of the Local Listener"
          },
          "proto_name": {
            "type": "string",
            "description": "Protocol Name"
          },
          "proto_ver": {
            "type": "string",
            "description": "Protocol Version"
          },
          "keepalive": {
            "type": "integer",
            "description": "KeepAlive"
          },
          "expiry_interval": {
            "type": "integer",
            "description": "Expiry Interval"
          },
          "connected_at": {
            "type": "integer",
            "description": "The Time that this Client is Connected"
          }
        },
        "type": "object"
      },
      "bridge_dynamo.post_connector": {
        "required": [
          "aws_access_key_id",
          "aws_secret_access_key",
          "name",
          "region",
          "type",
          "url"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "dynamo"
            ],
            "description": "The type of the connector."
          },
          "name": {
            "type": "string",
            "description": "The name of the connector."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this connector."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "url": {
            "type": "string",
            "description": "The url of DynamoDB endpoint."
          },
          "region": {
            "type": "string",
            "description": "Region of AWS Dynamo"
          },
          "aws_access_key_id": {
            "type": "string",
            "description": "Access Key ID for connecting to DynamoDB."
          },
          "aws_secret_access_key": {
            "type": "string",
            "format": "password",
            "description": "AWS Secret Access Key for connecting to DynamoDB.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_dynamo.connector_resource_opts"
          }
        },
        "type": "object"
      },
      "rule_engine.ctx_delivered": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "type": "string",
            "enum": [
              "message_delivered"
            ],
            "description": "Event Type"
          },
          "id": {
            "type": "string",
            "description": "Message ID"
          },
          "from_clientid": {
            "type": "string",
            "description": "The Client ID"
          },
          "from_username": {
            "type": "string",
            "description": "The User Name"
          },
          "clientid": {
            "type": "string",
            "description": "The Client ID"
          },
          "username": {
            "type": "string",
            "description": "Username"
          },
          "payload": {
            "type": "string",
            "description": "The Message Payload"
          },
          "peerhost": {
            "type": "string",
            "description": "The IP Address of the Peer Client"
          },
          "topic": {
            "type": "string",
            "description": "Message Topic"
          },
          "publish_received_at": {
            "type": "integer",
            "description": "The Time that this Message is Received"
          },
          "qos": {
            "maximum": 2,
            "type": "integer",
            "description": "The Message QoS",
            "minimum": 0,
            "example": 0
          }
        },
        "type": "object"
      },
      "bridge_redis.get_sentinel": {
        "required": [
          "command_template",
          "name",
          "sentinel",
          "servers",
          "type"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to Redis. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: If this action is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "command_template": {
            "type": "array",
            "description": "Redis command template used to export messages. Each list element stands for a command name or its argument.<br/>For example, to push payloads in a Redis list by key `msgs`, the elements should be the following:<br/>`rpush`, `msgs`, `${payload}`.",
            "items": {
              "type": "string"
            }
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_redis.creation_opts_redis_sentinel"
          },
          "servers": {
            "type": "string",
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The Redis default port 6379 is used if `[:Port]` is not specified."
          },
          "redis_type": {
            "default": "sentinel",
            "type": "string",
            "enum": [
              "sentinel"
            ],
            "description": "Sentinel mode. Must be set to 'sentinel' when Redis server is running in sentinel mode."
          },
          "sentinel": {
            "type": "string",
            "description": "The cluster name in Redis sentinel mode."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "database": {
            "default": 0,
            "type": "integer",
            "description": "Redis database ID.",
            "minimum": 0
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "type": {
            "type": "string",
            "enum": [
              "redis_sentinel"
            ],
            "description": "The Action Type"
          },
          "name": {
            "type": "string",
            "description": "Action name, used as a human-readable identifier."
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          }
        },
        "type": "object"
      },
      "bridge.node_metrics": {
        "properties": {
          "node": {
            "type": "string",
            "description": "The node name.",
            "example": "emqx@127.0.0.1"
          },
          "metrics": {
            "$ref": "#/components/schemas/bridge.metrics"
          }
        },
        "type": "object"
      },
      "bridge_iotdb.put_bridge_v2": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "IoTDB action parameters",
            "$ref": "#/components/schemas/bridge_iotdb.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_iotdb.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_sqlserver.get": {
        "required": [
          "database",
          "name",
          "server",
          "type"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "sqlserver"
            ],
            "description": "The Bridge Type"
          },
          "name": {
            "type": "string",
            "description": "Bridge name."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "sql": {
            "default": "insert into t_mqtt_msg(msgid, topic, qos, payload) values ( ${id}, ${topic}, ${qos}, ${payload} )",
            "type": "string",
            "format": "sql",
            "description": "SQL Template"
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to Microsoft SQL Server. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_sqlserver.creation_opts"
          },
          "driver": {
            "default": "ms-sql",
            "type": "string",
            "description": "SQL Server Driver Name"
          },
          "server": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The SQL Server default port 1433 is used if `[:Port]` is not specified."
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "default": "sa",
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          }
        },
        "type": "object"
      },
      "bridge_s3.s3_direct_upload_parameters": {
        "required": [
          "bucket",
          "key"
        ],
        "properties": {
          "bucket": {
            "type": "string",
            "description": "The name of the S3 bucket."
          },
          "key": {
            "type": "string",
            "description": "Key of the S3 object."
          },
          "acl": {
            "type": "string",
            "enum": [
              "private",
              "public_read",
              "public_read_write",
              "authenticated_read",
              "bucket_owner_read",
              "bucket_owner_full_control"
            ],
            "description": "The ACL to use for the uploaded objects."
          },
          "headers": {
            "type": "object",
            "description": "HTTP headers to include in the S3 object upload request.<br/><br/>Useful to specify content type, content encoding, etc. of the S3 object.",
            "example": {}
          },
          "mode": {
            "default": "direct",
            "type": "string",
            "enum": [
              "direct"
            ],
            "description": "Enables uploading of events to the S3 service as separate objects."
          },
          "content": {
            "default": "${.}",
            "type": "string",
            "description": "Content of the S3 object being uploaded. Supports templates."
          }
        },
        "type": "object"
      },
      "rule_engine.ctx_dropped": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "type": "string",
            "enum": [
              "message_dropped"
            ],
            "description": "Event Type"
          },
          "id": {
            "type": "string",
            "description": "Message ID"
          },
          "reason": {
            "type": "string",
            "description": "The Reason for Dropping"
          },
          "clientid": {
            "type": "string",
            "description": "The Client ID"
          },
          "username": {
            "type": "string",
            "description": "Username"
          },
          "payload": {
            "type": "string",
            "description": "The Message Payload"
          },
          "peerhost": {
            "type": "string",
            "description": "The IP Address of the Peer Client"
          },
          "topic": {
            "type": "string",
            "description": "Message Topic"
          },
          "publish_received_at": {
            "type": "integer",
            "description": "The Time that this Message is Received"
          },
          "qos": {
            "maximum": 2,
            "type": "integer",
            "description": "The Message QoS",
            "minimum": 0,
            "example": 0
          }
        },
        "type": "object"
      },
      "bridge_elasticsearch.put_bridge_v2": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "parameters": {
            "description": "ElasticSearch action parameters",
            "oneOf": [
              {
                "$ref": "#/components/schemas/bridge_elasticsearch.action_update"
              },
              {
                "$ref": "#/components/schemas/bridge_elasticsearch.action_delete"
              },
              {
                "$ref": "#/components/schemas/bridge_elasticsearch.action_create"
              }
            ]
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_elasticsearch.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_mqtt_publisher.get_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "mqtt"
            ]
          },
          "name": {
            "type": "string"
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Action specific configs.",
            "$ref": "#/components/schemas/bridge_mqtt_publisher.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_mqtt_publisher.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_mqtt.creation_opts": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "maximum": 1024,
            "type": "integer",
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 1
          },
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "start_after_created": {
            "default": true,
            "type": "boolean",
            "description": "Whether start the resource right after created."
          },
          "start_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "example": "32s"
          },
          "auto_restart_interval": {
            "default": "15s",
            "deprecated": true,
            "oneOf": [
              {
                "type": "string",
                "example": "32s"
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "query_mode": {
            "default": "async",
            "type": "string",
            "enum": [
              "sync",
              "async"
            ],
            "description": "Query mode. Optional 'sync/async', default 'async'."
          },
          "request_ttl": {
            "default": "45s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "string",
                "example": "32s"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "type": "integer",
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1
          },
          "enable_queue": {
            "default": false,
            "type": "boolean",
            "deprecated": true,
            "description": "Enable disk buffer queue (only applicable for egress bridges).<br/>When Enabled, messages will be buffered on disk when the bridge connection is down.<br/>When disabled the messages are buffered in RAM only."
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "type": "string",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB"
          }
        },
        "type": "object"
      },
      "bridge_matrix.put_bridge_v2": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Configuration Parameters Specific to the PostgreSQL Action",
            "$ref": "#/components/schemas/bridge_pgsql.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_kafka.auth_username_password": {
        "required": [
          "mechanism",
          "password",
          "username"
        ],
        "properties": {
          "mechanism": {
            "type": "string",
            "enum": [
              "plain",
              "scram_sha_256",
              "scram_sha_512"
            ],
            "description": "SASL authentication mechanism."
          },
          "username": {
            "type": "string",
            "description": "SASL authentication username."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "SASL authentication password.",
            "example": "R4ND0M/S∃CЯ∃T"
          }
        },
        "type": "object"
      },
      "node_eviction.status_disabled": {
        "properties": {
          "status": {
            "default": "disabled",
            "type": "string",
            "enum": [
              "disabled"
            ]
          }
        },
        "type": "object"
      },
      "bridge_dynamo.get": {
        "required": [
          "aws_access_key_id",
          "aws_secret_access_key",
          "hash_key",
          "name",
          "region",
          "table",
          "type",
          "url"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "dynamo"
            ],
            "description": "The Bridge Type"
          },
          "name": {
            "type": "string",
            "description": "Bridge name."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "template": {
            "default": "",
            "type": "string",
            "description": "Template, the default value is empty. When this value is empty the whole message will be stored in the database.<br><br/>The template can be any valid JSON with placeholders and make sure all keys for table are here, example:<br><br/>  <code>{\"id\" : \"${id}\", \"clientid\" : \"${clientid}\", \"data\" : \"${payload.data}\"}</code>"
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to DynamoDB. All MQTT `PUBLISH` messages with the topic<br/>matching the `local_topic` will be forwarded.<br/><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also `local_topic` is<br/>configured, then both the data got from the rule and the MQTT messages that match `local_topic`<br/>will be forwarded."
          },
          "hash_key": {
            "type": "string",
            "description": "DynamoDB Hash Key"
          },
          "range_key": {
            "type": "string",
            "description": "DynamoDB Range Key"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_dynamo.creation_opts"
          },
          "url": {
            "type": "string",
            "description": "The url of DynamoDB endpoint."
          },
          "region": {
            "type": "string",
            "description": "Region of AWS Dynamo"
          },
          "table": {
            "type": "string",
            "description": "DynamoDB Table."
          },
          "aws_access_key_id": {
            "type": "string",
            "description": "Access Key ID for connecting to DynamoDB."
          },
          "aws_secret_access_key": {
            "type": "string",
            "format": "password",
            "description": "AWS Secret Access Key for connecting to DynamoDB.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          }
        },
        "type": "object"
      },
      "gcp_pubsub_consumer.get_source": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "gcp_pubsub_consumer"
            ]
          },
          "name": {
            "type": "string"
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "parameters": {
            "description": "Source configs.",
            "$ref": "#/components/schemas/gcp_pubsub_consumer.source_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/gcp_pubsub_consumer.source_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_kafka.v1_producer_kafka_opts": {
        "required": [
          "topic"
        ],
        "properties": {
          "topic": {
            "type": "string",
            "description": "Kafka topic name.  Supports templates (e.g.: `t-${payload.t}`)."
          },
          "message": {
            "description": "Template for rendering a message.",
            "$ref": "#/components/schemas/bridge_kafka.kafka_message"
          },
          "max_batch_bytes": {
            "default": "896KB",
            "type": "string",
            "description": "Maximum bytes to collect in a Kafka message batch. Most of the Kafka brokers default to a limit of 1 MB batch size. EMQX's default value is less than 1 MB in order to compensate Kafka message encoding overheads (especially when each individual message is very small). When a single message is over the limit, it is still sent (as a single element batch).",
            "example": "32MB"
          },
          "compression": {
            "default": "no_compression",
            "type": "string",
            "enum": [
              "no_compression",
              "snappy",
              "gzip"
            ],
            "description": "Specify the method of compression."
          },
          "partition_strategy": {
            "default": "random",
            "type": "string",
            "enum": [
              "random",
              "key_dispatch"
            ],
            "description": "Partition strategy is to tell the producer how to dispatch messages to partitions.<br/><br/><code>random</code>: Randomly pick a partition for each message.<br/><code>key_dispatch</code>: Assigns messages to partitions based on a hash of the message key,<br/>ensuring consistent partition for messages with the same key."
          },
          "required_acks": {
            "default": "all_isr",
            "type": "string",
            "enum": [
              "all_isr",
              "leader_only",
              "none"
            ],
            "description": "The acknowledgement criteria for the partition leader. It determines the level of confirmation required from partition replicas before sending an acknowledgement back to the producer.<br/><br/><code>all_isr</code>: Require all in-sync replicas to acknowledge.<br/><code>leader_only</code>: Require only the partition-leader's acknowledgement.<br/><code>none</code>: No need for Kafka to acknowledge at all."
          },
          "kafka_headers": {
            "type": "string",
            "description": "Provide a placeholder for message headers<br/><br/>e.g. <code>${pub_props}</code><br/><br/>Note that the value of the placeholder must be either an object:<br/><code>{\"foo\": \"bar\"}</code><br/>or an array of key-value pairs:<br/><code>[{\"key\": \"foo\", \"value\": \"bar\"}]</code>"
          },
          "kafka_ext_headers": {
            "type": "array",
            "description": "Provide more key-value pairs for message headers<br/><br/>The key-value pairs here will be combined with the<br/>value of <code>kafka_headers</code> field before sending producing.",
            "items": {
              "$ref": "#/components/schemas/bridge_kafka.producer_kafka_ext_headers"
            }
          },
          "kafka_header_value_encode_mode": {
            "default": "none",
            "type": "string",
            "enum": [
              "none",
              "json"
            ],
            "description": "The encoding mode for headers.<br/><br/> - `none`: Add only strings are added as header values<br/> - `json`: Encode header values as JSON string"
          },
          "partition_count_refresh_interval": {
            "default": "60s",
            "type": "string",
            "description": "The time interval for Kafka producer to discover increased number of partitions.<br/>After the number of partitions is increased in Kafka, EMQX will start taking the<br/>discovered partitions into account when dispatching messages per <code>partition_strategy</code>.",
            "example": "1h"
          },
          "partitions_limit": {
            "default": "all_partitions",
            "description": "Limit the number of partitions to produce data for the given topic.<br/>The special value `all_partitions` is to utilize all partitions for the topic.<br/>Setting this to a value which is greater than the total number of partitions in has no effect.",
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1
              },
              {
                "type": "string",
                "enum": [
                  "all_partitions"
                ]
              }
            ]
          },
          "max_inflight": {
            "default": 10,
            "type": "integer",
            "description": "The maximum number of message batches that the producer can send to each partition before it must wait for an acknowledgement.<br/>Setting a higher number can enhance throughput. However, value above 1 may lead to potential message reordering risks.",
            "minimum": 1
          },
          "buffer": {
            "description": "Configure producer message buffer.<br/><br/>Tell Kafka producer how to buffer messages when EMQX has more messages to send than Kafka can keep up, or when Kafka is down.",
            "$ref": "#/components/schemas/bridge_kafka.producer_buffer"
          },
          "query_mode": {
            "default": "async",
            "type": "string",
            "enum": [
              "async",
              "sync"
            ],
            "description": "Query mode. Optional 'sync/async', default 'async'."
          },
          "sync_query_timeout": {
            "default": "5s",
            "type": "string",
            "description": "This parameter defines the timeout limit for synchronous queries. It applies only when the query mode is configured to 'sync'.",
            "example": "32s"
          }
        },
        "type": "object"
      },
      "bridge_mqtt_publisher.ingress_parameters": {
        "required": [
          "topic"
        ],
        "properties": {
          "topic": {
            "type": "string",
            "description": "Receive messages from which topic of the remote broker"
          },
          "qos": {
            "default": 1,
            "maximum": 2,
            "type": "integer",
            "description": "The QoS level to be used when subscribing to the remote broker",
            "minimum": 0,
            "example": 0
          }
        },
        "type": "object"
      },
      "kafka_consumer.put_source": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "parameters": {
            "description": "Source configs.",
            "$ref": "#/components/schemas/kafka_consumer.source_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.source_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_mqtt_publisher.source_resource_opts": {
        "properties": {
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          }
        },
        "type": "object"
      },
      "bridge_elasticsearch.action_create": {
        "required": [
          "action",
          "index"
        ],
        "properties": {
          "action": {
            "type": "string",
            "enum": [
              "create"
            ],
            "description": "create"
          },
          "index": {
            "type": "string",
            "description": "Name of index, or index alias to perform the action on.<br/>This parameter is required.",
            "example": "${payload.index}"
          },
          "id": {
            "type": "string",
            "description": "The document ID. If no ID is specified, a document ID is automatically generated.",
            "example": "${payload.id}"
          },
          "doc": {
            "type": "string",
            "description": "JSON document. If undefined, rule engine will use JSON format to serialize all visible inputs, such as clientid, topic, payload etc.",
            "example": "${payload.doc}"
          },
          "routing": {
            "type": "string",
            "description": "Custom value used to route operations to a specific shard.",
            "example": "${payload.routing}"
          },
          "require_alias": {
            "type": "boolean",
            "description": "If true, the request’s actions must target an index alias. Defaults to false"
          },
          "overwrite": {
            "default": true,
            "type": "boolean",
            "description": "Set to false If a document with the specified _id already exists(conflict), the operation will fail."
          },
          "max_retries": {
            "default": 2,
            "type": "integer",
            "description": "HTTP request max retry times if failed.",
            "minimum": 0
          }
        },
        "type": "object"
      },
      "file_transfer.local_storage_segments_gc": {
        "properties": {
          "interval": {
            "default": "1h",
            "type": "string",
            "description": "Interval of periodic garbage collection.",
            "example": "32s"
          },
          "maximum_segments_ttl": {
            "default": "24h",
            "type": "string",
            "description": "Maximum TTL of a segment kept in the local file system.<br/><br/>This is a hard limit: no segment will outlive this TTL, even if some file transfer specifies a<br/>TTL more than that.",
            "example": "1h"
          },
          "minimum_segments_ttl": {
            "default": "5m",
            "type": "string",
            "description": "Minimum TTL of a segment kept in the local file system.<br/><br/>This is a hard limit: no segment will be garbage collected before reaching this TTL,<br/>even if some file transfer specifies a TTL less than that.",
            "example": "1h"
          }
        },
        "type": "object"
      },
      "bridge_matrix.post": {
        "required": [
          "database",
          "name",
          "server",
          "type",
          "username"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "matrix"
            ],
            "description": "The Bridge Type"
          },
          "name": {
            "type": "string",
            "description": "Bridge name."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "sql": {
            "default": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
            "type": "string",
            "format": "sql",
            "description": "SQL Template"
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to PostgreSQL. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The PostgreSQL default port 5432 is used if `[:Port]` is not specified."
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "bridge_influxdb.put_api_v1": {
        "required": [
          "database",
          "write_syntax"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to the InfluxDB. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "write_syntax": {
            "type": "string",
            "format": "sql",
            "description": "Conf of InfluxDB line protocol to write data points. It is a text-based format that provides the measurement, tag set, field set, and timestamp of a data point, and placeholder supported.<br/>See also [InfluxDB 2.3 Line Protocol](https://docs.influxdata.com/influxdb/v2.3/reference/syntax/line-protocol/) and<br/>[InfluxDB 1.8 Line Protocol](https://docs.influxdata.com/influxdb/v1.8/write_protocols/line_protocol_tutorial/) <br/><br/>TLDR:<br/><br/>```<br/><measurement>[,<tag_key>=<tag_value>[,<tag_key>=<tag_value>]] <field_key>=<field_value>[,<field_key>=<field_value>] [<timestamp>]<br/>```<br/>Please note that a placeholder for an integer value must be annotated with a suffix `i`. For example `${payload.int_value}i`."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "default": "127.0.0.1:8086",
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The InfluxDB default port 8086 is used if `[:Port]` is not specified."
          },
          "precision": {
            "default": "ms",
            "type": "string",
            "enum": [
              "ns",
              "us",
              "ms",
              "s"
            ],
            "description": "InfluxDB time precision."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "database": {
            "type": "string",
            "description": "InfluxDB database."
          },
          "username": {
            "type": "string",
            "description": "InfluxDB username."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "InfluxDB password.",
            "example": "R4ND0M/S∃CЯ∃T"
          }
        },
        "type": "object"
      },
      "bridge_rabbitmq.post": {
        "required": [
          "exchange",
          "name",
          "password",
          "routing_key",
          "type",
          "username"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "rabbitmq"
            ],
            "description": "The Bridge Type"
          },
          "name": {
            "type": "string",
            "description": "Bridge name."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to RabbitMQ. All MQTT 'PUBLISH' messages with the topic matching the local_topic will be forwarded.<br/>    NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is configured, then both the data got from the rule and the MQTT messages that match local_topic will be forwarded."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_rabbitmq.creation_opts"
          },
          "server": {
            "default": "localhost",
            "type": "string",
            "description": "The RabbitMQ server address that you want to connect to (for example, localhost)."
          },
          "port": {
            "default": 5672,
            "maximum": 65535,
            "type": "integer",
            "description": "The RabbitMQ server address that you want to connect to (for example, localhost).",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username used to authenticate with the RabbitMQ server."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "The size of the connection pool.",
            "minimum": 1
          },
          "timeout": {
            "default": "5s",
            "type": "string",
            "description": "The timeout for waiting on the connection to be established.",
            "example": "32s"
          },
          "virtual_host": {
            "default": "/",
            "type": "string",
            "description": "The virtual host to use when connecting to the RabbitMQ server."
          },
          "heartbeat": {
            "default": "30s",
            "type": "string",
            "description": "The interval for sending heartbeat messages to the RabbitMQ server.",
            "example": "32s"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "wait_for_publish_confirmations": {
            "default": true,
            "type": "boolean",
            "description": "A boolean value that indicates whether to wait for RabbitMQ to confirm message publication when using publisher confirms."
          },
          "publish_confirmation_timeout": {
            "default": "30s",
            "type": "string",
            "description": "The timeout for waiting on the connection to be established.",
            "example": "32s"
          },
          "exchange": {
            "type": "string",
            "description": "The name of the RabbitMQ exchange where the messages will be sent."
          },
          "routing_key": {
            "type": "string",
            "description": "The routing key used to route messages to the correct queue in the RabbitMQ exchange."
          },
          "delivery_mode": {
            "default": "non_persistent",
            "type": "string",
            "enum": [
              "non_persistent",
              "persistent"
            ],
            "description": "The delivery mode for messages published to RabbitMQ. Delivery mode non_persistent (1) is suitable for messages that don't require persistence across RabbitMQ restarts, whereas delivery mode persistent (2) is designed for messages that must survive RabbitMQ restarts."
          },
          "payload_template": {
            "default": "",
            "type": "string",
            "description": "The template for formatting the payload of the message before sending it to RabbitMQ. Template placeholders, such as ${field1.sub_field}, will be substituted with the respective field's value. When left empty, the entire input message will be used as the payload, formatted as a JSON text. This behavior is equivalent to specifying ${.} as the payload template."
          }
        },
        "type": "object"
      },
      "bridge_dynamo.put_bridge_v2": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Action specific configuration.",
            "$ref": "#/components/schemas/bridge_dynamo.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_pgsql.put": {
        "required": [
          "database",
          "server",
          "username"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "sql": {
            "default": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
            "type": "string",
            "format": "sql",
            "description": "SQL Template"
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to PostgreSQL. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The PostgreSQL default port 5432 is used if `[:Port]` is not specified."
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "bridge_azure_event_hub.post_connector": {
        "required": [
          "authentication",
          "bootstrap_hosts",
          "name",
          "ssl",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "azure_event_hub_producer"
            ],
            "description": "The type of the connector."
          },
          "name": {
            "type": "string",
            "description": "The name of the connector."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this connector."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "bootstrap_hosts": {
            "type": "string",
            "description": "A comma separated list of Azure Event Hubs Kafka <code>host[:port]</code> namespace endpoints to bootstrap the client.  Default port number is 9093."
          },
          "connect_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Maximum wait time for TCP connection establishment (including authentication time if enabled).",
            "example": "32s"
          },
          "min_metadata_refresh_interval": {
            "default": "3s",
            "type": "string",
            "description": "Minimum time interval the client has to wait before refreshing Azure Event Hubs Kafka broker and topic metadata. Setting too small value may add extra load on Azure Event Hubs.",
            "example": "32s"
          },
          "metadata_request_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Maximum wait time when fetching metadata from Azure Event Hubs.",
            "example": "32s"
          },
          "authentication": {
            "default": {},
            "description": "Authentication configs.",
            "$ref": "#/components/schemas/bridge_azure_event_hub.auth_username_password"
          },
          "socket_opts": {
            "description": "Extra socket options.",
            "$ref": "#/components/schemas/bridge_kafka.socket_opts"
          },
          "health_check_topic": {
            "type": "string",
            "description": "Topic name used exclusively for more accurate connector health checks."
          },
          "ssl": {
            "default": {
              "enable": true
            },
            "$ref": "#/components/schemas/bridge_azure_event_hub.ssl_client_opts"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_kafka.connector_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_azure_event_hub.get_connector": {
        "required": [
          "authentication",
          "bootstrap_hosts",
          "name",
          "ssl",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "azure_event_hub_producer"
            ],
            "description": "The type of the connector."
          },
          "name": {
            "type": "string",
            "description": "The name of the connector."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this connector."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the connector<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the connector passes the health probes.<br/><br/>- <code>disconnected</code>: when the connector can not pass health probes.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a connector is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/connector.node_status"
            }
          },
          "actions": {
            "type": "array",
            "description": "List of actions added to this connector.",
            "items": {
              "type": "string"
            },
            "example": [
              "my_action"
            ]
          },
          "bootstrap_hosts": {
            "type": "string",
            "description": "A comma separated list of Azure Event Hubs Kafka <code>host[:port]</code> namespace endpoints to bootstrap the client.  Default port number is 9093."
          },
          "connect_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Maximum wait time for TCP connection establishment (including authentication time if enabled).",
            "example": "32s"
          },
          "min_metadata_refresh_interval": {
            "default": "3s",
            "type": "string",
            "description": "Minimum time interval the client has to wait before refreshing Azure Event Hubs Kafka broker and topic metadata. Setting too small value may add extra load on Azure Event Hubs.",
            "example": "32s"
          },
          "metadata_request_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Maximum wait time when fetching metadata from Azure Event Hubs.",
            "example": "32s"
          },
          "authentication": {
            "default": {},
            "description": "Authentication configs.",
            "$ref": "#/components/schemas/bridge_azure_event_hub.auth_username_password"
          },
          "socket_opts": {
            "description": "Extra socket options.",
            "$ref": "#/components/schemas/bridge_kafka.socket_opts"
          },
          "health_check_topic": {
            "type": "string",
            "description": "Topic name used exclusively for more accurate connector health checks."
          },
          "ssl": {
            "default": {
              "enable": true
            },
            "$ref": "#/components/schemas/bridge_azure_event_hub.ssl_client_opts"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_kafka.connector_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_pgsql.post": {
        "required": [
          "database",
          "name",
          "server",
          "type",
          "username"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "pgsql"
            ],
            "description": "The Bridge Type"
          },
          "name": {
            "type": "string",
            "description": "Bridge name."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "sql": {
            "default": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
            "type": "string",
            "format": "sql",
            "description": "SQL Template"
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to PostgreSQL. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The PostgreSQL default port 5432 is used if `[:Port]` is not specified."
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "bridge_kafka.ssl_client_opts": {
        "properties": {
          "cacertfile": {
            "type": "string",
            "description": "Trusted PEM format CA certificates bundle file.<br/><br/>The certificates in this file are used to verify the TLS peer's certificates.<br/>Append new certificates to the file if new CAs are to be trusted.<br/>There is no need to restart EMQX to have the updated file loaded, because<br/>the system regularly checks if file has been updated (and reload).<br/><br/>NOTE: invalidating (deleting) a certificate from the file will not affect<br/>already established connections."
          },
          "cacerts": {
            "default": false,
            "type": "boolean",
            "deprecated": true
          },
          "certfile": {
            "type": "string",
            "description": "PEM format certificates chain file.<br/><br/>The certificates in this file should be in reversed order of the certificate<br/>issue chain. That is, the host's certificate should be placed in the beginning<br/>of the file, followed by the immediate issuer certificate and so on.<br/>Although the root CA certificate is optional, it should be placed at the end of<br/>the file if it is to be added."
          },
          "keyfile": {
            "type": "string",
            "description": "PEM format private key file."
          },
          "verify": {
            "default": "verify_none",
            "type": "string",
            "enum": [
              "verify_peer",
              "verify_none"
            ],
            "description": "Enable or disable peer verification."
          },
          "reuse_sessions": {
            "default": true,
            "type": "boolean",
            "description": "Enable TLS session reuse.<br/><br/>Has no effect when TLS version is configured (or negotiated) to 1.3"
          },
          "depth": {
            "default": 10,
            "type": "integer",
            "description": "Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path.<br/>So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly;<br/><br/>if 1 the path can be PEER, Intermediate-CA, ROOT-CA;<br/><br/>if 2 the path can be PEER, Intermediate-CA1, Intermediate-CA2, ROOT-CA.",
            "minimum": 0
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "String containing the user's password. Only used if the private key file is password-protected.",
            "example": ""
          },
          "versions": {
            "default": [
              "tlsv1.3",
              "tlsv1.2"
            ],
            "type": "array",
            "description": "All TLS/DTLS versions to be supported.<br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.<br/><br/>In case PSK cipher suites are intended, make sure to configure<br/><code>['tlsv1.2', 'tlsv1.1']</code> here.",
            "items": {
              "type": "string"
            }
          },
          "ciphers": {
            "default": [],
            "type": "array",
            "description": "This config holds TLS cipher suite names separated by comma,<br/>or as an array of strings. e.g.<br/><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or<br/><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.<br/><br/><br/>Ciphers (and their ordering) define the way in which the<br/>client and server encrypts information over the network connection.<br/>Selecting a good cipher suite is critical for the<br/>application's data security, confidentiality and performance.<br/><br/>The names should be in OpenSSL string format (not RFC format).<br/>All default values and examples provided by EMQX config<br/>documentation are all in OpenSSL format.<br/><br/><br/>NOTE: Certain cipher suites are only compatible with<br/>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')<br/>incompatible cipher suites will be silently dropped.<br/>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,<br/>configuring cipher suites for other versions will have no effect.<br/><br/><br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br/><br/>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.<br/><br/>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,<br/>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,<br/>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,<br/>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code>",
            "items": {
              "type": "string"
            }
          },
          "secure_renegotiate": {
            "default": true,
            "type": "boolean",
            "description": "Whether to reject TLS renegotiation attempts that are not compliant with [RFC 5746](http://www.ietf.org/rfc/rfc5746.txt).<br/><br/>By default, `secure_renegotiate` is set to `true`, which forces secure renegotiation.<br/>If set to `false`, secure renegotiation will still be used, but will fall back to insecure renegotiation if the peer does not support [RFC 5746](http://www.ietf.org/rfc/rfc5746.txt), which increases the risk of a MitM attack.<br/><br/>Has no effect when TLS version is configured (or negotiated) to 1.3."
          },
          "log_level": {
            "default": "notice",
            "type": "string",
            "enum": [
              "emergency",
              "alert",
              "critical",
              "error",
              "warning",
              "notice",
              "info",
              "debug",
              "none",
              "all"
            ],
            "description": "The minimum level of logging allowed for SSL output.<br/><br/>The default is `notice`, set to a lower `debug` level for more detailed logging that can be used to investigate SSL handshake issues."
          },
          "hibernate_after": {
            "default": "5s",
            "type": "string",
            "description": "Specifies the amount of time that an SSL process will hibernate after being idle, thus reducing its memory footprint.<br/><br/>The hibernating process will be woken up when a new message arrives.<br/>Hibernating and waking up too often can cause CPU utilization to increase, as they both perform garbage collection on the process.",
            "example": "12m"
          },
          "partial_chain": {
            "type": "string",
            "enum": [
              true,
              false,
              "two_cacerts_from_cacertfile",
              "cacert_from_cacertfile"
            ],
            "description": "Enable or disable peer verification with partial_chain.<br/>When local verifies a peer certificate during the x509 path validation<br/>process, it constructs a certificate chain that starts with the peer<br/>certificate and ends with a trust anchor.<br/>By default, if it is set to `false`, the trust anchor is the<br/>Root CA, and the certificate chain must be complete.<br/>However, if the setting is set to `true` or `cacert_from_cacertfile`,<br/>the last certificate in `cacertfile` will be used as the trust anchor<br/>certificate (intermediate CA). This creates a partial chain<br/>in the path validation.<br/>Alternatively, if it is configured with `two_cacerts_from_cacertfile`,<br/>one of the last two certificates in `cacertfile` will be used as the<br/>trust anchor certificate, forming a partial chain. This option is<br/>particularly useful for intermediate CA certificate rotation.<br/>However, please note that it incurs some additional overhead, so it<br/>should only be used for certificate rotation purposes."
          },
          "verify_peer_ext_key_usage": {
            "type": "string",
            "description": "Verify extended key usage in peer's certificate<br/>For additional peer certificate validation, the value defined here must present in the<br/>'Extended Key Usage' of peer certificate defined in<br/>[rfc5280](https://www.rfc-editor.org/rfc/rfc5280#section-4.2.1.12).<br/><br/>Allowed values are<br/>- `clientAuth`<br/>- `serverAuth`<br/>- `codeSigning`<br/>- `emailProtection`<br/>- `timeStamping`<br/>- `ocspSigning`<br/>- raw OID, for example: \"OID:1.3.6.1.5.5.7.3.2\" means `id-pk 2` which is equivalent to `clientAuth`<br/><br/>Comma-separated string is also supported for validating more than one key usages.<br/><br/>For example, `\"serverAuth,OID:1.3.6.1.5.5.7.3.2\"`"
          },
          "enable": {
            "default": false,
            "type": "boolean",
            "description": "Enable TLS."
          },
          "server_name_indication": {
            "default": "auto",
            "description": "Server Name Indication (SNI) setting for TLS handshake.<br/><br/>- <code>auto</code>: Allow the client to automatically determine the appropriate SNI.<br/><br/>- <code>disable</code>: If you wish to prevent the client from sending the SNI.<br/><br/>- Other string values will be sent as-is.",
            "example": "auto",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "string",
                "enum": [
                  "disable"
                ]
              },
              {
                "type": "string",
                "enum": [
                  "auto"
                ]
              }
            ]
          }
        },
        "type": "object"
      },
      "pulsar.action_parameters": {
        "required": [
          "pulsar_topic"
        ],
        "properties": {
          "message": {
            "description": "Template to render a Pulsar message.",
            "$ref": "#/components/schemas/pulsar.producer_pulsar_message"
          },
          "sync_timeout": {
            "default": "3s",
            "type": "string",
            "description": "Maximum wait time for receiving a receipt from Pulsar when publishing synchronously.",
            "example": "32s"
          },
          "pulsar_topic": {
            "type": "string",
            "description": "Pulsar topic name"
          },
          "batch_size": {
            "default": 100,
            "type": "integer",
            "description": "Maximum number of individual requests to batch in a Pulsar message.",
            "minimum": 1
          },
          "compression": {
            "default": "no_compression",
            "type": "string",
            "enum": [
              "no_compression",
              "snappy",
              "zlib"
            ],
            "description": "Compression method."
          },
          "send_buffer": {
            "default": "1MB",
            "type": "string",
            "description": "Fine tune the socket send buffer. The default value is tuned for high throughput.",
            "example": "32MB"
          },
          "retention_period": {
            "default": "infinity",
            "description": "The amount of time messages will be buffered while there is no connection to<br/> the Pulsar broker.  Longer times mean that more memory/disk will be used",
            "oneOf": [
              {
                "type": "string",
                "example": "32s"
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "max_batch_bytes": {
            "default": "900KB",
            "type": "string",
            "description": "Maximum bytes to collect in a Pulsar message batch. Most of the Pulsar brokers<br/> default to a limit of 5 MB batch size. EMQX's default value is less than 5 MB in<br/> order to compensate Pulsar message encoding overheads (especially when each individual<br/> message is very small). When a single message is over the limit, it is still<br/> sent (as a single element batch).",
            "example": "32MB"
          },
          "strategy": {
            "default": "random",
            "type": "string",
            "enum": [
              "random",
              "roundrobin",
              "key_dispatch"
            ],
            "description": "Partition strategy is to tell the producer how to dispatch messages to Pulsar partitions.<br/><br/><code>random</code>: Randomly pick a partition for each message.<br/><code>roundrobin</code>: Pick each available producer in turn for each message.<br/><code>key_dispatch</code>: Hash Pulsar message key of the first message in a batch<br/> to a partition number."
          },
          "buffer": {
            "description": "Configure producer message buffer.\"<br/>Tell Pulsar producer how to buffer messages when EMQX has more messages to\"<br/> send than Pulsar can keep up, or when Pulsar is down.",
            "$ref": "#/components/schemas/bridge_pulsar.producer_buffer"
          }
        },
        "type": "object"
      },
      "bridge_hstreamdb.post_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "hstreamdb"
            ]
          },
          "name": {
            "type": "string"
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Action specific configuration.",
            "$ref": "#/components/schemas/bridge_hstreamdb.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_timescale.get_bridge_v2": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Configuration Parameters Specific to the PostgreSQL Action",
            "$ref": "#/components/schemas/bridge_pgsql.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_hstreamdb.put": {
        "required": [
          "stream",
          "url"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "direction": {
            "default": "egress",
            "type": "string",
            "enum": [
              "egress"
            ],
            "description": "The direction of this bridge, MUST be 'egress'"
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to the HStreamDB. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: If this action is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "record_template": {
            "default": "${payload}",
            "type": "string",
            "description": "The HStream Record template to be forwarded to the HStreamDB. Placeholders supported.<br><br/>NOTE: When you use `raw record` template (which means the data is not a valid JSON), you should use `read` or `subscription` in HStream to get the data."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "url": {
            "default": "http://127.0.0.1:6570",
            "type": "string",
            "description": "HStreamDB Server URL. This URL will be used as the gRPC HTTP server address."
          },
          "stream": {
            "type": "string",
            "description": "HStreamDB Stream Name."
          },
          "partition_key": {
            "type": "string",
            "description": "HStreamDB Partition Key. Placeholders supported."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "grpc_timeout": {
            "default": "30s",
            "type": "string",
            "description": "The timeout for HStreamDB gRPC requests.",
            "example": "32s"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "bridge_kinesis.action_resource_opts": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "maximum": 1024,
            "type": "integer",
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 1
          },
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "query_mode": {
            "default": "async",
            "type": "string",
            "enum": [
              "sync",
              "async"
            ],
            "description": "Query mode. Optional 'sync/async', default 'async'."
          },
          "request_ttl": {
            "default": "45s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "string",
                "example": "32s"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "type": "integer",
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1
          },
          "batch_size": {
            "default": 1,
            "maximum": 500,
            "type": "integer",
            "description": "Maximum batch count. If equal to 1, there's effectively no batching.",
            "minimum": 1
          },
          "batch_time": {
            "default": "0ms",
            "type": "string",
            "description": "Maximum waiting interval when accumulating a batch at a low message rates for more efficient resource usage.",
            "example": "32s"
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "type": "string",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB"
          }
        },
        "type": "object"
      },
      "bridge_gcp_pubsub.key_value_pair": {
        "required": [
          "key",
          "value"
        ],
        "properties": {
          "key": {
            "type": "string",
            "description": "Key"
          },
          "value": {
            "type": "string",
            "description": "Value"
          }
        },
        "type": "object"
      },
      "bridge_kinesis.get_producer": {
        "required": [
          "aws_access_key_id",
          "aws_secret_access_key",
          "endpoint",
          "name",
          "partition_key",
          "stream_name",
          "type"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "kinesis_producer"
            ],
            "description": "The action type."
          },
          "name": {
            "type": "string",
            "description": "Action name."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Creation options.",
            "$ref": "#/components/schemas/bridge_kinesis.creation_opts"
          },
          "aws_access_key_id": {
            "type": "string",
            "description": "Access Key ID for connecting to Amazon Kinesis."
          },
          "aws_secret_access_key": {
            "type": "string",
            "format": "password",
            "description": "AWS Secret Access Key for connecting to Amazon Kinesis.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "endpoint": {
            "type": "string",
            "description": "The url of Amazon Kinesis endpoint.",
            "example": "https://kinesis.us-east-1.amazonaws.com"
          },
          "max_retries": {
            "default": 2,
            "type": "integer",
            "description": "Max retry times if an error occurs when sending a request.",
            "minimum": 0
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "The pool size.",
            "minimum": 1
          },
          "payload_template": {
            "default": "${.}",
            "type": "string",
            "description": "The template for formatting the outgoing messages.  If undefined, will send all the available context in JSON format."
          },
          "stream_name": {
            "type": "string",
            "description": "The Amazon Kinesis Stream to publish messages to."
          },
          "partition_key": {
            "type": "string",
            "description": "The Amazon Kinesis Partition Key associated to published message. Placeholders in format of ${var} are supported."
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to Amazon Kinesis. All MQTT `PUBLISH` messages with the topic<br/>matching the `local_topic` will be forwarded.<br/><br/>NOTE: If this action is used as the action of a rule (EMQX rule engine), and also `local_topic` is<br/>configured, then both the data got from the rule and the MQTT messages that match `local_topic`<br/>will be forwarded."
          }
        },
        "type": "object"
      },
      "bridge_http.v1_resource_opts": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "maximum": 1024,
            "type": "integer",
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 1
          },
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "start_after_created": {
            "default": true,
            "type": "boolean",
            "description": "Whether start the resource right after created."
          },
          "start_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "example": "32s"
          },
          "auto_restart_interval": {
            "default": "15s",
            "deprecated": true,
            "oneOf": [
              {
                "type": "string",
                "example": "32s"
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "query_mode": {
            "default": "async",
            "type": "string",
            "enum": [
              "sync",
              "async"
            ],
            "description": "Query mode. Optional 'sync/async', default 'async'."
          },
          "request_ttl": {
            "default": "45s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "string",
                "example": "32s"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "type": "integer",
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1
          },
          "enable_queue": {
            "default": false,
            "type": "boolean",
            "deprecated": true,
            "description": "Enable disk buffer queue (only applicable for egress bridges).<br/>When Enabled, messages will be buffered on disk when the bridge connection is down.<br/>When disabled the messages are buffered in RAM only."
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "type": "string",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB"
          }
        },
        "type": "object"
      },
      "bridge_s3.s3_aggregated_container_csv": {
        "required": [
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "csv"
            ],
            "description": "Records (events) will be aggregated and uploaded as a CSV file."
          },
          "column_order": {
            "default": [],
            "type": "array",
            "description": "Event fields that will be ordered first as columns in the resulting CSV file.<br/><br/>Regardless of this setting, resulting CSV will contain all the fields of aggregated events, but all the columns not explicitly mentioned here will be ordered after the ones listed here in the lexicographical order.",
            "items": {
              "type": "string"
            }
          }
        },
        "type": "object"
      },
      "bridge_influxdb.action_parameters": {
        "required": [
          "write_syntax"
        ],
        "properties": {
          "write_syntax": {
            "type": "string",
            "format": "sql",
            "description": "Conf of InfluxDB line protocol to write data points. It is a text-based format that provides the measurement, tag set, field set, and timestamp of a data point, and placeholder supported.<br/>See also [InfluxDB 2.3 Line Protocol](https://docs.influxdata.com/influxdb/v2.3/reference/syntax/line-protocol/) and<br/>[InfluxDB 1.8 Line Protocol](https://docs.influxdata.com/influxdb/v1.8/write_protocols/line_protocol_tutorial/) <br/><br/>TLDR:<br/><br/>```<br/><measurement>[,<tag_key>=<tag_value>[,<tag_key>=<tag_value>]] <field_key>=<field_value>[,<field_key>=<field_value>] [<timestamp>]<br/>```<br/>Please note that a placeholder for an integer value must be annotated with a suffix `i`. For example `${payload.int_value}i`."
          },
          "precision": {
            "default": "ms",
            "type": "string",
            "enum": [
              "ns",
              "us",
              "ms",
              "s"
            ],
            "description": "InfluxDB time precision."
          }
        },
        "type": "object"
      },
      "bridge_dynamo.connector_resource_opts": {
        "properties": {
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "start_after_created": {
            "default": true,
            "type": "boolean",
            "description": "Whether start the resource right after created."
          },
          "start_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "example": "32s"
          }
        },
        "type": "object"
      },
      "bridge_mongodb.get_sharded": {
        "required": [
          "database",
          "mongo_type",
          "name",
          "resource_opts",
          "servers",
          "type"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "mongo_type": {
            "default": "sharded",
            "type": "string",
            "enum": [
              "sharded"
            ],
            "description": "Sharded cluster. Must be set to 'sharded' when MongoDB server is running in 'sharded' mode."
          },
          "servers": {
            "type": "string",
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The MongoDB default port 27017 is used if `[:Port]` is not specified."
          },
          "w_mode": {
            "default": "unsafe",
            "type": "string",
            "enum": [
              "unsafe",
              "safe"
            ],
            "description": "Write mode."
          },
          "srv_record": {
            "default": false,
            "type": "boolean",
            "description": "Use DNS SRV record."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "use_legacy_protocol": {
            "default": "auto",
            "type": "string",
            "enum": [
              "auto",
              true,
              false
            ],
            "description": "Whether to use MongoDB's legacy protocol for communicating with the database.  The default is to attempt to automatically determine if the newer protocol is supported."
          },
          "auth_source": {
            "type": "string",
            "description": "Database name associated with the user's credentials."
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "topology": {
            "$ref": "#/components/schemas/mongo.topology"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this MongoDB Action"
          },
          "collection": {
            "default": "mqtt",
            "type": "string",
            "description": "The collection where data will be stored into"
          },
          "payload_template": {
            "type": "string",
            "description": "The template for formatting the outgoing messages.  If undefined, rule engine will use JSON format to serialize all visible inputs, such as clientid, topic, payload etc."
          },
          "resource_opts": {
            "description": "Creation options.",
            "$ref": "#/components/schemas/bridge_mongodb.creation_opts"
          },
          "type": {
            "type": "string",
            "enum": [
              "mongodb_sharded"
            ]
          },
          "name": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge_mongodb.post_single": {
        "required": [
          "database",
          "mongo_type",
          "name",
          "resource_opts",
          "server",
          "type"
        ],
        "properties": {
          "mongo_type": {
            "default": "single",
            "type": "string",
            "enum": [
              "single"
            ],
            "description": "Standalone instance. Must be set to 'single' when MongoDB server is running in standalone mode."
          },
          "server": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The MongoDB default port 27017 is used if `[:Port]` is not specified."
          },
          "w_mode": {
            "default": "unsafe",
            "type": "string",
            "enum": [
              "unsafe",
              "safe"
            ],
            "description": "Write mode."
          },
          "srv_record": {
            "default": false,
            "type": "boolean",
            "description": "Use DNS SRV record."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "use_legacy_protocol": {
            "default": "auto",
            "type": "string",
            "enum": [
              "auto",
              true,
              false
            ],
            "description": "Whether to use MongoDB's legacy protocol for communicating with the database.  The default is to attempt to automatically determine if the newer protocol is supported."
          },
          "auth_source": {
            "type": "string",
            "description": "Database name associated with the user's credentials."
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "topology": {
            "$ref": "#/components/schemas/mongo.topology"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this MongoDB Action"
          },
          "collection": {
            "default": "mqtt",
            "type": "string",
            "description": "The collection where data will be stored into"
          },
          "payload_template": {
            "type": "string",
            "description": "The template for formatting the outgoing messages.  If undefined, rule engine will use JSON format to serialize all visible inputs, such as clientid, topic, payload etc."
          },
          "resource_opts": {
            "description": "Creation options.",
            "$ref": "#/components/schemas/bridge_mongodb.creation_opts"
          },
          "type": {
            "type": "string",
            "enum": [
              "mongodb_single"
            ]
          },
          "name": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge_kinesis.post_producer": {
        "required": [
          "aws_access_key_id",
          "aws_secret_access_key",
          "endpoint",
          "name",
          "partition_key",
          "stream_name",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "kinesis_producer"
            ],
            "description": "The action type."
          },
          "name": {
            "type": "string",
            "description": "Action name."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Creation options.",
            "$ref": "#/components/schemas/bridge_kinesis.creation_opts"
          },
          "aws_access_key_id": {
            "type": "string",
            "description": "Access Key ID for connecting to Amazon Kinesis."
          },
          "aws_secret_access_key": {
            "type": "string",
            "format": "password",
            "description": "AWS Secret Access Key for connecting to Amazon Kinesis.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "endpoint": {
            "type": "string",
            "description": "The url of Amazon Kinesis endpoint.",
            "example": "https://kinesis.us-east-1.amazonaws.com"
          },
          "max_retries": {
            "default": 2,
            "type": "integer",
            "description": "Max retry times if an error occurs when sending a request.",
            "minimum": 0
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "The pool size.",
            "minimum": 1
          },
          "payload_template": {
            "default": "${.}",
            "type": "string",
            "description": "The template for formatting the outgoing messages.  If undefined, will send all the available context in JSON format."
          },
          "stream_name": {
            "type": "string",
            "description": "The Amazon Kinesis Stream to publish messages to."
          },
          "partition_key": {
            "type": "string",
            "description": "The Amazon Kinesis Partition Key associated to published message. Placeholders in format of ${var} are supported."
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to Amazon Kinesis. All MQTT `PUBLISH` messages with the topic<br/>matching the `local_topic` will be forwarded.<br/><br/>NOTE: If this action is used as the action of a rule (EMQX rule engine), and also `local_topic` is<br/>configured, then both the data got from the rule and the MQTT messages that match `local_topic`<br/>will be forwarded."
          }
        },
        "type": "object"
      },
      "file_transfer.local_storage_segments": {
        "properties": {
          "root": {
            "type": "string",
            "description": "File system path to keep uploaded fragments and temporary data."
          },
          "gc": {
            "description": "Garbage collection settings for the intermediate and temporary files in the local file system.",
            "$ref": "#/components/schemas/file_transfer.local_storage_segments_gc"
          }
        },
        "type": "object"
      },
      "bridge_rabbitmq.put": {
        "required": [
          "exchange",
          "password",
          "routing_key",
          "username"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to RabbitMQ. All MQTT 'PUBLISH' messages with the topic matching the local_topic will be forwarded.<br/>    NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is configured, then both the data got from the rule and the MQTT messages that match local_topic will be forwarded."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_rabbitmq.creation_opts"
          },
          "server": {
            "default": "localhost",
            "type": "string",
            "description": "The RabbitMQ server address that you want to connect to (for example, localhost)."
          },
          "port": {
            "default": 5672,
            "maximum": 65535,
            "type": "integer",
            "description": "The RabbitMQ server address that you want to connect to (for example, localhost).",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username used to authenticate with the RabbitMQ server."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "The size of the connection pool.",
            "minimum": 1
          },
          "timeout": {
            "default": "5s",
            "type": "string",
            "description": "The timeout for waiting on the connection to be established.",
            "example": "32s"
          },
          "virtual_host": {
            "default": "/",
            "type": "string",
            "description": "The virtual host to use when connecting to the RabbitMQ server."
          },
          "heartbeat": {
            "default": "30s",
            "type": "string",
            "description": "The interval for sending heartbeat messages to the RabbitMQ server.",
            "example": "32s"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "wait_for_publish_confirmations": {
            "default": true,
            "type": "boolean",
            "description": "A boolean value that indicates whether to wait for RabbitMQ to confirm message publication when using publisher confirms."
          },
          "publish_confirmation_timeout": {
            "default": "30s",
            "type": "string",
            "description": "The timeout for waiting on the connection to be established.",
            "example": "32s"
          },
          "exchange": {
            "type": "string",
            "description": "The name of the RabbitMQ exchange where the messages will be sent."
          },
          "routing_key": {
            "type": "string",
            "description": "The routing key used to route messages to the correct queue in the RabbitMQ exchange."
          },
          "delivery_mode": {
            "default": "non_persistent",
            "type": "string",
            "enum": [
              "non_persistent",
              "persistent"
            ],
            "description": "The delivery mode for messages published to RabbitMQ. Delivery mode non_persistent (1) is suitable for messages that don't require persistence across RabbitMQ restarts, whereas delivery mode persistent (2) is designed for messages that must survive RabbitMQ restarts."
          },
          "payload_template": {
            "default": "",
            "type": "string",
            "description": "The template for formatting the payload of the message before sending it to RabbitMQ. Template placeholders, such as ${field1.sub_field}, will be substituted with the respective field's value. When left empty, the entire input message will be used as the payload, formatted as a JSON text. This behavior is equivalent to specifying ${.} as the payload template."
          }
        },
        "type": "object"
      },
      "bridge_cassa.get_connector": {
        "required": [
          "keyspace",
          "name",
          "servers",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "cassandra"
            ],
            "description": "The type of the connector."
          },
          "name": {
            "type": "string",
            "description": "The name of the connector."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this connector."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the connector<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the connector passes the health probes.<br/><br/>- <code>disconnected</code>: when the connector can not pass health probes.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a connector is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/connector.node_status"
            }
          },
          "actions": {
            "type": "array",
            "description": "List of actions added to this connector.",
            "items": {
              "type": "string"
            },
            "example": [
              "my_action"
            ]
          },
          "servers": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port][,Host2:Port]`.<br/><br/>The Cassandra default port 9042 is used if `[:Port]` is not specified."
          },
          "keyspace": {
            "type": "string",
            "description": "Keyspace name to connect to."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_cassa.connector_resource_opts"
          }
        },
        "type": "object"
      },
      "rule_engine.ctx_message_transformation_failed": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "type": "string",
            "enum": [
              "message_transformation_failed"
            ],
            "description": "Event Type"
          },
          "transformation": {
            "type": "string",
            "description": "Transformation"
          },
          "clientid": {
            "type": "string",
            "description": "The Client ID"
          },
          "username": {
            "type": "string",
            "description": "Username"
          },
          "payload": {
            "type": "string",
            "description": "The Message Payload"
          },
          "peerhost": {
            "type": "string",
            "description": "The IP Address of the Peer Client"
          },
          "topic": {
            "type": "string",
            "description": "Message Topic"
          },
          "publish_received_at": {
            "type": "integer",
            "description": "The Time that this Message is Received"
          },
          "qos": {
            "maximum": 2,
            "type": "integer",
            "description": "The Message QoS",
            "minimum": 0,
            "example": 0
          }
        },
        "type": "object"
      },
      "bridge_cassa.put": {
        "required": [
          "keyspace",
          "servers"
        ],
        "properties": {
          "cql": {
            "default": "insert into mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic},  ${qos}, ${payload}, ${timestamp})",
            "type": "string",
            "format": "sql",
            "description": "CQL Template"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to Cassandra. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "servers": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port][,Host2:Port]`.<br/><br/>The Cassandra default port 9042 is used if `[:Port]` is not specified."
          },
          "keyspace": {
            "type": "string",
            "description": "Keyspace name to connect to."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "confluent.producer_kafka_opts": {
        "required": [
          "topic"
        ],
        "properties": {
          "topic": {
            "type": "string",
            "description": "Kafka topic name.  Supports templates (e.g.: `t-${payload.t}`)."
          },
          "message": {
            "description": "Template for rendering a message.",
            "$ref": "#/components/schemas/confluent.kafka_message"
          },
          "max_batch_bytes": {
            "default": "896KB",
            "type": "string",
            "description": "Maximum bytes to collect in a Confluent message batch. Most of the Kafka brokers default to a limit of 1 MB batch size. EMQX's default value is less than 1 MB in order to compensate Kafka message encoding overheads (especially when each individual message is very small). When a single message is over the limit, it is still sent (as a single element batch).",
            "example": "32MB"
          },
          "compression": {
            "default": "no_compression",
            "type": "string",
            "enum": [
              "no_compression",
              "snappy",
              "gzip"
            ],
            "description": "Specify the method of compression."
          },
          "partition_strategy": {
            "default": "random",
            "type": "string",
            "enum": [
              "random",
              "key_dispatch"
            ],
            "description": "Partition strategy is to tell the producer how to dispatch messages to partitions.<br/><br/><code>random</code>: Randomly pick a partition for each message.<br/><code>key_dispatch</code>: Assigns messages to partitions based on a hash of the message key,<br/>ensuring consistent partition for messages with the same key."
          },
          "required_acks": {
            "default": "all_isr",
            "type": "string",
            "enum": [
              "all_isr",
              "leader_only",
              "none"
            ],
            "description": "The acknowledgement criteria for the partition leader. It determines the level of confirmation required from partition replicas before sending an acknowledgement back to the producer.<br/><br/><code>all_isr</code>: Require all in-sync replicas to acknowledge.<br/><code>leader_only</code>: Require only the partition-leader's acknowledgement.<br/><code>none</code>: No need for Kafka to acknowledge at all."
          },
          "kafka_headers": {
            "type": "string",
            "description": "Provide a placeholder for message headers<br/><br/>e.g. <code>${pub_props}</code><br/><br/>Note that the value of the placeholder must be either an object:<br/><code>{\"foo\": \"bar\"}</code><br/>or an array of key-value pairs:<br/><code>[{\"key\": \"foo\", \"value\": \"bar\"}]</code>"
          },
          "kafka_ext_headers": {
            "type": "array",
            "description": "Please provide more key-value pairs for Confluent headers<br/><br/>The key-value pairs here will be combined with the<br/>value of <code>kafka_headers</code> field before sending to Confluent.",
            "items": {
              "$ref": "#/components/schemas/bridge_kafka.producer_kafka_ext_headers"
            }
          },
          "kafka_header_value_encode_mode": {
            "default": "none",
            "type": "string",
            "enum": [
              "none",
              "json"
            ],
            "description": "The encoding mode for headers.<br/><br/> - `none`: Add only strings are added as header values<br/> - `json`: Encode header values as JSON string"
          },
          "partition_count_refresh_interval": {
            "default": "60s",
            "type": "string",
            "description": "The time interval for Confluent producer to discover increased number of partitions.<br/>After the number of partitions is increased in Confluent, EMQX will start taking the<br/>discovered partitions into account when dispatching messages per <code>partition_strategy</code>.",
            "example": "1h"
          },
          "partitions_limit": {
            "default": "all_partitions",
            "description": "Limit the number of partitions to produce data for the given topic.<br/>The special value `all_partitions` is to utilize all partitions for the topic.<br/>Setting this to a value which is greater than the total number of partitions in has no effect.",
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1
              },
              {
                "type": "string",
                "enum": [
                  "all_partitions"
                ]
              }
            ]
          },
          "max_inflight": {
            "default": 10,
            "type": "integer",
            "description": "The maximum number of message batches that the producer can send to each partition before it must wait for an acknowledgement.<br/>Setting a higher number can enhance throughput. However, value above 1 may lead to potential message reordering risks.",
            "minimum": 1
          },
          "buffer": {
            "description": "Configure producer message buffer.<br/><br/>Tell Confluent producer how to buffer messages when EMQX has more messages to send than Confluent can keep up, or when Confluent is down.",
            "$ref": "#/components/schemas/bridge_kafka.producer_buffer"
          },
          "query_mode": {
            "default": "async",
            "type": "string",
            "enum": [
              "async",
              "sync"
            ],
            "description": "Query mode. Optional 'sync/async', default 'async'."
          },
          "sync_query_timeout": {
            "default": "5s",
            "type": "string",
            "description": "This parameter defines the timeout limit for synchronous queries. It applies only when the action query mode is configured to 'sync'.",
            "example": "32s"
          }
        },
        "type": "object"
      },
      "bridge_oracle.post": {
        "required": [
          "name",
          "server",
          "type",
          "username"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "oracle"
            ],
            "description": "The Bridge Type"
          },
          "name": {
            "type": "string",
            "description": "Bridge name."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "sql": {
            "default": "insert into t_mqtt_msgs(msgid, topic, qos, payload) values (${id}, ${topic}, ${qos}, ${payload})",
            "type": "string",
            "format": "sql",
            "description": "SQL Template. The template string can contain placeholders for message metadata and payload field. The placeholders are inserted without any checking and special formatting, so it is important to ensure that the inserted values are formatted and escaped correctly."
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to Oracle Database. All MQTT 'PUBLISH' messages with the topic matching the local_topic will be forwarded.<br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is configured, then both the data got from the rule and the MQTT messages that match local_topic will be forwarded."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The Oracle Database default port 1521 is used if `[:Port]` is not specified."
          },
          "sid": {
            "type": "string",
            "description": "Sid for Oracle Database."
          },
          "service_name": {
            "type": "string",
            "description": "Service Name for Oracle Database."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          }
        },
        "type": "object"
      },
      "bridge_rabbitmq.put_bridge_v2": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "The action config defines how this bridge send messages to the remote RabbitMQ broker",
            "$ref": "#/components/schemas/bridge_rabbitmq.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_rabbitmq.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_iotdb.post_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "iotdb"
            ]
          },
          "name": {
            "type": "string"
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "IoTDB action parameters",
            "$ref": "#/components/schemas/bridge_iotdb.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_iotdb.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_kafka.post_consumer": {
        "required": [
          "bootstrap_hosts",
          "name",
          "topic_mapping",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "kafka",
              "kafka_producer",
              "kafka_consumer"
            ],
            "description": "The Action Type"
          },
          "name": {
            "type": "string",
            "description": "Action name, used as a human-readable identifier."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this connector."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "bootstrap_hosts": {
            "type": "string",
            "description": "A comma separated list of Kafka <code>host:port</code> endpoints to bootstrap the client."
          },
          "connect_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Maximum wait time for TCP connection establishment (including authentication time if enabled).",
            "example": "32s"
          },
          "min_metadata_refresh_interval": {
            "default": "3s",
            "type": "string",
            "description": "Minimum time interval the client has to wait before refreshing Kafka broker and topic metadata. Setting too small value may add extra load on Kafka.",
            "example": "32s"
          },
          "metadata_request_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Maximum wait time when fetching topic metadata.",
            "example": "32s"
          },
          "authentication": {
            "default": "none",
            "description": "Authentication configs.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/bridge_kafka.auth_gssapi_kerberos"
              },
              {
                "$ref": "#/components/schemas/bridge_kafka.auth_username_password"
              },
              {
                "type": "string",
                "enum": [
                  "none"
                ]
              }
            ]
          },
          "socket_opts": {
            "description": "Extra socket options.",
            "$ref": "#/components/schemas/bridge_kafka.socket_opts"
          },
          "health_check_topic": {
            "type": "string",
            "description": "Topic name used exclusively for more accurate connector health checks."
          },
          "ssl": {
            "$ref": "#/components/schemas/bridge_kafka.ssl_client_opts"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_kafka.connector_resource_opts"
          },
          "kafka": {
            "description": "Kafka consumer configs.",
            "$ref": "#/components/schemas/bridge_kafka.consumer_kafka_opts"
          },
          "topic_mapping": {
            "type": "array",
            "description": "Defines the mapping between Kafka topics and MQTT topics. Must contain at least one item.",
            "items": {
              "$ref": "#/components/schemas/bridge_kafka.consumer_topic_mapping"
            }
          },
          "key_encoding_mode": {
            "default": "none",
            "type": "string",
            "enum": [
              "none",
              "base64"
            ],
            "description": "Defines how the key from the Kafka message is encoded before being forwarded via MQTT.<br/><code>none</code> Uses the key from the Kafka message unchanged.  Note: in this case, the key must be a valid UTF-8 string.<br/><code>base64</code> Uses base-64 encoding on the received key."
          },
          "value_encoding_mode": {
            "default": "none",
            "type": "string",
            "enum": [
              "none",
              "base64"
            ],
            "description": "Defines how the value from the Kafka message is encoded before being forwarded via MQTT.<br/><code>none</code> Uses the value from the Kafka message unchanged.  Note: in this case, the value must be a valid UTF-8 string.<br/><code>base64</code> Uses base-64 encoding on the received value."
          }
        },
        "type": "object"
      },
      "bridge_dynamo.post": {
        "required": [
          "aws_access_key_id",
          "aws_secret_access_key",
          "hash_key",
          "name",
          "region",
          "table",
          "type",
          "url"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "dynamo"
            ],
            "description": "The Bridge Type"
          },
          "name": {
            "type": "string",
            "description": "Bridge name."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "template": {
            "default": "",
            "type": "string",
            "description": "Template, the default value is empty. When this value is empty the whole message will be stored in the database.<br><br/>The template can be any valid JSON with placeholders and make sure all keys for table are here, example:<br><br/>  <code>{\"id\" : \"${id}\", \"clientid\" : \"${clientid}\", \"data\" : \"${payload.data}\"}</code>"
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to DynamoDB. All MQTT `PUBLISH` messages with the topic<br/>matching the `local_topic` will be forwarded.<br/><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also `local_topic` is<br/>configured, then both the data got from the rule and the MQTT messages that match `local_topic`<br/>will be forwarded."
          },
          "hash_key": {
            "type": "string",
            "description": "DynamoDB Hash Key"
          },
          "range_key": {
            "type": "string",
            "description": "DynamoDB Range Key"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_dynamo.creation_opts"
          },
          "url": {
            "type": "string",
            "description": "The url of DynamoDB endpoint."
          },
          "region": {
            "type": "string",
            "description": "Region of AWS Dynamo"
          },
          "table": {
            "type": "string",
            "description": "DynamoDB Table."
          },
          "aws_access_key_id": {
            "type": "string",
            "description": "Access Key ID for connecting to DynamoDB."
          },
          "aws_secret_access_key": {
            "type": "string",
            "format": "password",
            "description": "AWS Secret Access Key for connecting to DynamoDB.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          }
        },
        "type": "object"
      },
      "bridge_clickhouse.get": {
        "required": [
          "database",
          "name",
          "type",
          "url"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "clickhouse"
            ],
            "description": "The Bridge Type"
          },
          "name": {
            "type": "string",
            "description": "Bridge name."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "sql": {
            "default": "INSERT INTO messages(data, arrived) VALUES ('${payload}', ${timestamp})",
            "type": "string",
            "format": "sql",
            "description": "The template string can contain ${field} placeholders for message metadata and payload field. Make sure that the inserted values are formatted and escaped correctly. [Prepared Statement](https://docs.emqx.com/en/enterprise/v5.0/data-integration/data-bridges.html#Prepared-Statement) is not supported."
          },
          "batch_value_separator": {
            "default": ", ",
            "type": "string",
            "description": "The default value ',' works for the VALUES format. You can also use other separator if other format is specified. See [INSERT INTO Statement](https://clickhouse.com/docs/en/sql-reference/statements/insert-into)."
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to Clickhouse. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_clickhouse.creation_opts"
          },
          "url": {
            "type": "string",
            "description": "The HTTP URL to the Clickhouse server that you want to connect to (for example http://myhostname:8123)",
            "example": "http://127.0.0.1"
          },
          "connect_timeout": {
            "default": "15s",
            "type": "string",
            "description": "The timeout when connecting to the Clickhouse server.",
            "example": "32s"
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          }
        },
        "type": "object"
      },
      "bridge_azure_event_hub.producer_kafka_opts": {
        "required": [
          "topic"
        ],
        "properties": {
          "topic": {
            "type": "string",
            "description": "Event Hubs name.  Supports templates (e.g.: `t-${payload.t}`)."
          },
          "message": {
            "description": "Template for rendering a message.",
            "$ref": "#/components/schemas/bridge_azure_event_hub.kafka_message"
          },
          "max_batch_bytes": {
            "default": "896KB",
            "type": "string",
            "description": "Maximum bytes to collect in an Azure Event Hubs message batch.",
            "example": "32MB"
          },
          "partition_strategy": {
            "default": "random",
            "type": "string",
            "enum": [
              "random",
              "key_dispatch"
            ],
            "description": "Partition strategy is to tell the producer how to dispatch messages to partitions.<br/><br/><code>random</code>: Randomly pick a partition for each message.<br/><code>key_dispatch</code>: Assigns messages to partitions based on a hash of the message key,<br/>ensuring consistent partition for messages with the same key."
          },
          "required_acks": {
            "default": "all_isr",
            "type": "string",
            "enum": [
              "all_isr",
              "leader_only"
            ],
            "description": "The acknowledgement criteria for the partition leader. It determines the level of confirmation required from partition replicas before sending an acknowledgement back to the producer.<br/><br/><code>all_isr</code>: Require all in-sync replicas to acknowledge.<br/><code>leader_only</code>: Require only the partition-leader's acknowledgement.<br/><code>none</code>: No need for Kafka to acknowledge at all."
          },
          "kafka_headers": {
            "type": "string",
            "description": "Provide a placeholder for message headers<br/><br/>e.g. <code>${pub_props}</code><br/><br/>Note that the value of the placeholder must be either an object:<br/><code>{\"foo\": \"bar\"}</code><br/>or an array of key-value pairs:<br/><code>[{\"key\": \"foo\", \"value\": \"bar\"}]</code>"
          },
          "kafka_ext_headers": {
            "type": "array",
            "description": "Please provide more key-value pairs for Azure Event Hubs headers<br/><br/>The key-value pairs here will be combined with the<br/>value of <code>kafka_headers</code> field before sending to Azure Event Hubs.",
            "items": {
              "$ref": "#/components/schemas/bridge_kafka.producer_kafka_ext_headers"
            }
          },
          "kafka_header_value_encode_mode": {
            "default": "none",
            "type": "string",
            "enum": [
              "none",
              "json"
            ],
            "description": "The encoding mode for headers.<br/><br/> - `none`: Add only strings are added as header values<br/> - `json`: Encode header values as JSON string"
          },
          "partition_count_refresh_interval": {
            "default": "60s",
            "type": "string",
            "description": "The time interval for Azure Event Hubs producer to discover increased number of partitions.<br/>After the number of partitions is increased in Azure Event Hubs, EMQX will start taking the<br/>discovered partitions into account when dispatching messages per <code>partition_strategy</code>.",
            "example": "1h"
          },
          "partitions_limit": {
            "default": "all_partitions",
            "description": "Limit the number of partitions to produce data for the given topic.<br/>The special value `all_partitions` is to utilize all partitions for the topic.<br/>Setting this to a value which is greater than the total number of partitions in has no effect.",
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1
              },
              {
                "type": "string",
                "enum": [
                  "all_partitions"
                ]
              }
            ]
          },
          "max_inflight": {
            "default": 10,
            "type": "integer",
            "description": "The maximum number of message batches that the producer can send to each partition before it must wait for an acknowledgement.<br/>Setting a higher number can enhance throughput. However, value above 1 may lead to potential message reordering risks.",
            "minimum": 1
          },
          "buffer": {
            "description": "Configure producer message buffer.<br/><br/>Tell Azure Event Hubs producer how to buffer messages when EMQX has more messages to send than Azure Event Hubs can keep up, or when Azure Event Hubs is down.",
            "$ref": "#/components/schemas/bridge_kafka.producer_buffer"
          },
          "query_mode": {
            "default": "async",
            "type": "string",
            "enum": [
              "async",
              "sync"
            ],
            "description": "Query mode. Optional 'sync/async', default 'async'."
          },
          "sync_query_timeout": {
            "default": "5s",
            "type": "string",
            "description": "This parameter defines the timeout limit for synchronous queries. It applies only when the bridge query mode is configured to 'sync'.",
            "example": "32s"
          }
        },
        "type": "object"
      },
      "bridge_matrix.put": {
        "required": [
          "database",
          "server",
          "username"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "sql": {
            "default": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
            "type": "string",
            "format": "sql",
            "description": "SQL Template"
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to PostgreSQL. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The PostgreSQL default port 5432 is used if `[:Port]` is not specified."
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "message_transformation_http_api.node_metrics": {
        "properties": {
          "node": {
            "type": "string"
          },
          "matched": {
            "type": "integer",
            "minimum": 0
          },
          "succeeded": {
            "type": "integer",
            "minimum": 0
          },
          "failed": {
            "type": "integer",
            "minimum": 0
          }
        },
        "type": "object"
      },
      "bridge_mongodb.get_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "mongodb"
            ]
          },
          "name": {
            "type": "string"
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Additional parameters specific to this action type",
            "$ref": "#/components/schemas/bridge_mongodb.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_mongodb.action_resource_opts"
          }
        },
        "type": "object"
      },
      "connector_mqtt.egress_remote": {
        "required": [
          "topic"
        ],
        "properties": {
          "topic": {
            "type": "string",
            "description": "Forward to which topic of the remote broker.<br/><br/>Template with variables is allowed."
          },
          "qos": {
            "default": 1,
            "description": "The QoS of the MQTT message to be sent.<br/><br/>Template with variables is allowed.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "maximum": 2,
                "type": "integer",
                "minimum": 0,
                "example": 0
              }
            ]
          },
          "retain": {
            "default": false,
            "description": "The 'retain' flag of the MQTT message to be sent.<br/><br/>Template with variables is allowed.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "boolean"
              }
            ]
          },
          "payload": {
            "type": "string",
            "description": "The payload of the MQTT message to be sent.<br/><br/>Template with variables is allowed."
          }
        },
        "type": "object"
      },
      "syskeeper.put_bridge_v2": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Syskeeper action parameters",
            "$ref": "#/components/schemas/syskeeper.parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/syskeeper.creation_opts"
          }
        },
        "type": "object"
      },
      "message_transformation_http_api.dryrun_input_message": {
        "required": [
          "payload",
          "topic"
        ],
        "properties": {
          "client_attrs": {
            "default": {},
            "type": "object",
            "example": {}
          },
          "clientid": {
            "default": "test-clientid",
            "type": "string"
          },
          "payload": {
            "type": "string"
          },
          "peername": {
            "default": "127.0.0.1:19872",
            "type": "string",
            "example": "127.0.0.1:80"
          },
          "pub_props": {
            "default": {},
            "type": "object",
            "example": {}
          },
          "qos": {
            "default": 0,
            "maximum": 2,
            "type": "integer",
            "minimum": 0
          },
          "retain": {
            "default": false,
            "type": "boolean"
          },
          "topic": {
            "type": "string"
          },
          "user_property": {
            "default": {},
            "type": "object",
            "example": {}
          },
          "username": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge_opents.get_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "opents"
            ]
          },
          "name": {
            "type": "string"
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "OpenTSDB action parameters",
            "$ref": "#/components/schemas/bridge_opents.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_mongodb.get_rs": {
        "required": [
          "database",
          "mongo_type",
          "name",
          "replica_set_name",
          "resource_opts",
          "servers",
          "type"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "mongo_type": {
            "default": "rs",
            "type": "string",
            "enum": [
              "rs"
            ],
            "description": "Replica set. Must be set to 'rs' when MongoDB server is running in 'replica set' mode."
          },
          "servers": {
            "type": "string",
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The MongoDB default port 27017 is used if `[:Port]` is not specified."
          },
          "w_mode": {
            "default": "unsafe",
            "type": "string",
            "enum": [
              "unsafe",
              "safe"
            ],
            "description": "Write mode."
          },
          "r_mode": {
            "default": "master",
            "type": "string",
            "enum": [
              "master",
              "slave_ok"
            ],
            "description": "Read mode."
          },
          "replica_set_name": {
            "type": "string",
            "description": "Name of the replica set."
          },
          "srv_record": {
            "default": false,
            "type": "boolean",
            "description": "Use DNS SRV record."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "use_legacy_protocol": {
            "default": "auto",
            "type": "string",
            "enum": [
              "auto",
              true,
              false
            ],
            "description": "Whether to use MongoDB's legacy protocol for communicating with the database.  The default is to attempt to automatically determine if the newer protocol is supported."
          },
          "auth_source": {
            "type": "string",
            "description": "Database name associated with the user's credentials."
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "topology": {
            "$ref": "#/components/schemas/mongo.topology"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this MongoDB Action"
          },
          "collection": {
            "default": "mqtt",
            "type": "string",
            "description": "The collection where data will be stored into"
          },
          "payload_template": {
            "type": "string",
            "description": "The template for formatting the outgoing messages.  If undefined, rule engine will use JSON format to serialize all visible inputs, such as clientid, topic, payload etc."
          },
          "resource_opts": {
            "description": "Creation options.",
            "$ref": "#/components/schemas/bridge_mongodb.creation_opts"
          },
          "type": {
            "type": "string",
            "enum": [
              "mongodb_rs"
            ]
          },
          "name": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "schema_validation.check_protobuf": {
        "required": [
          "message_type",
          "schema"
        ],
        "properties": {
          "type": {
            "default": "protobuf",
            "type": "string",
            "enum": [
              "protobuf"
            ],
            "description": "Protobuf schema check"
          },
          "schema": {
            "type": "string",
            "description": "Schema name to use during check."
          },
          "message_type": {
            "type": "string",
            "description": "Message name to use during check."
          }
        },
        "type": "object"
      },
      "rule_engine.node_metrics": {
        "properties": {
          "node": {
            "type": "string",
            "description": "The node name",
            "example": "emqx@127.0.0.1"
          },
          "matched": {
            "type": "integer",
            "description": "How many times the FROM clause of the SQL is matched.",
            "minimum": 0
          },
          "matched.rate": {
            "type": "number",
            "description": "The rate of matched, times/second"
          },
          "matched.rate.max": {
            "type": "number",
            "description": "The max rate of matched, times/second"
          },
          "matched.rate.last5m": {
            "type": "number",
            "description": "The average rate of matched in last 5 minutes, times/second"
          },
          "passed": {
            "type": "integer",
            "description": "How many times the SQL is passed",
            "minimum": 0
          },
          "failed": {
            "type": "integer",
            "description": "How many times the SQL statement has failed",
            "minimum": 0
          },
          "failed.exception": {
            "type": "integer",
            "description": "How many times the SQL is failed due to exceptions. This may because of a crash when calling a SQL function, or trying to do arithmetic operation on undefined variables",
            "minimum": 0
          },
          "failed.unknown": {
            "type": "integer",
            "description": "How many times the SQL is failed due to an unknown error.",
            "minimum": 0
          },
          "actions.total": {
            "type": "integer",
            "description": "How many times the actions are called by the rule. This value may several times of 'matched', depending on the number of the actions of the rule.",
            "minimum": 0
          },
          "actions.success": {
            "type": "integer",
            "description": "How many times the rule successided to call the actions.",
            "minimum": 0
          },
          "actions.failed": {
            "type": "integer",
            "description": "How many times the rule failed to call the actions.",
            "minimum": 0
          },
          "actions.failed.out_of_service": {
            "type": "integer",
            "description": "How many times the rule has failed to call actions due to the action is out of service. For example, a bridge is disabled or stopped.",
            "minimum": 0
          },
          "actions.failed.unknown": {
            "type": "integer",
            "description": "The number of action failures that have occurred due to unanticipated reasons. For more information on these errors, please refer to the EMQX log file.",
            "minimum": 0
          }
        },
        "type": "object"
      },
      "bridge_kafka.put_consumer": {
        "required": [
          "bootstrap_hosts",
          "topic_mapping"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this connector."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "bootstrap_hosts": {
            "type": "string",
            "description": "A comma separated list of Kafka <code>host:port</code> endpoints to bootstrap the client."
          },
          "connect_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Maximum wait time for TCP connection establishment (including authentication time if enabled).",
            "example": "32s"
          },
          "min_metadata_refresh_interval": {
            "default": "3s",
            "type": "string",
            "description": "Minimum time interval the client has to wait before refreshing Kafka broker and topic metadata. Setting too small value may add extra load on Kafka.",
            "example": "32s"
          },
          "metadata_request_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Maximum wait time when fetching topic metadata.",
            "example": "32s"
          },
          "authentication": {
            "default": "none",
            "description": "Authentication configs.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/bridge_kafka.auth_gssapi_kerberos"
              },
              {
                "$ref": "#/components/schemas/bridge_kafka.auth_username_password"
              },
              {
                "type": "string",
                "enum": [
                  "none"
                ]
              }
            ]
          },
          "socket_opts": {
            "description": "Extra socket options.",
            "$ref": "#/components/schemas/bridge_kafka.socket_opts"
          },
          "health_check_topic": {
            "type": "string",
            "description": "Topic name used exclusively for more accurate connector health checks."
          },
          "ssl": {
            "$ref": "#/components/schemas/bridge_kafka.ssl_client_opts"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_kafka.connector_resource_opts"
          },
          "kafka": {
            "description": "Kafka consumer configs.",
            "$ref": "#/components/schemas/bridge_kafka.consumer_kafka_opts"
          },
          "topic_mapping": {
            "type": "array",
            "description": "Defines the mapping between Kafka topics and MQTT topics. Must contain at least one item.",
            "items": {
              "$ref": "#/components/schemas/bridge_kafka.consumer_topic_mapping"
            }
          },
          "key_encoding_mode": {
            "default": "none",
            "type": "string",
            "enum": [
              "none",
              "base64"
            ],
            "description": "Defines how the key from the Kafka message is encoded before being forwarded via MQTT.<br/><code>none</code> Uses the key from the Kafka message unchanged.  Note: in this case, the key must be a valid UTF-8 string.<br/><code>base64</code> Uses base-64 encoding on the received key."
          },
          "value_encoding_mode": {
            "default": "none",
            "type": "string",
            "enum": [
              "none",
              "base64"
            ],
            "description": "Defines how the value from the Kafka message is encoded before being forwarded via MQTT.<br/><code>none</code> Uses the value from the Kafka message unchanged.  Note: in this case, the value must be a valid UTF-8 string.<br/><code>base64</code> Uses base-64 encoding on the received value."
          }
        },
        "type": "object"
      },
      "bridge_greptimedb.action_parameters": {
        "required": [
          "write_syntax"
        ],
        "properties": {
          "write_syntax": {
            "type": "string",
            "format": "sql",
            "description": "Conf of GreptimeDB gRPC protocol to write data points. Write syntax is a text-based format that provides the measurement, tag set, field set, and timestamp of a data point, and placeholder supported, which is the same as InfluxDB line protocol.<br/>See also [InfluxDB 2.3 Line Protocol](https://docs.influxdata.com/influxdb/v2.3/reference/syntax/line-protocol/) and<br/>[GreptimeDB 1.8 Line Protocol](https://docs.influxdata.com/influxdb/v1.8/write_protocols/line_protocol_tutorial/) <br/><br/>TLDR:<br/><br/>```<br/><measurement>[,<tag_key>=<tag_value>[,<tag_key>=<tag_value>]] <field_key>=<field_value>[,<field_key>=<field_value>] [<timestamp>]<br/>```<br/>Please note that a placeholder for an integer value must be annotated with a suffix `i`. For example `${payload.int_value}i`."
          },
          "precision": {
            "default": "ms",
            "type": "string",
            "enum": [
              "ns",
              "us",
              "ms",
              "s"
            ],
            "description": "GreptimeDB time precision."
          }
        },
        "type": "object"
      },
      "pulsar.action_resource_opts": {
        "properties": {
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "query_mode": {
            "default": "async",
            "type": "string",
            "enum": [
              "sync",
              "async"
            ],
            "description": "Query mode. Optional 'sync/async', default 'async'."
          },
          "request_ttl": {
            "default": "45s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "string",
                "example": "32s"
              }
            ]
          }
        },
        "type": "object"
      },
      "bridge_pgsql.get_bridge_v2": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Configuration Parameters Specific to the PostgreSQL Action",
            "$ref": "#/components/schemas/bridge_pgsql.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_mongodb.put_single": {
        "required": [
          "database",
          "mongo_type",
          "resource_opts",
          "server"
        ],
        "properties": {
          "mongo_type": {
            "default": "single",
            "type": "string",
            "enum": [
              "single"
            ],
            "description": "Standalone instance. Must be set to 'single' when MongoDB server is running in standalone mode."
          },
          "server": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The MongoDB default port 27017 is used if `[:Port]` is not specified."
          },
          "w_mode": {
            "default": "unsafe",
            "type": "string",
            "enum": [
              "unsafe",
              "safe"
            ],
            "description": "Write mode."
          },
          "srv_record": {
            "default": false,
            "type": "boolean",
            "description": "Use DNS SRV record."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "use_legacy_protocol": {
            "default": "auto",
            "type": "string",
            "enum": [
              "auto",
              true,
              false
            ],
            "description": "Whether to use MongoDB's legacy protocol for communicating with the database.  The default is to attempt to automatically determine if the newer protocol is supported."
          },
          "auth_source": {
            "type": "string",
            "description": "Database name associated with the user's credentials."
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "topology": {
            "$ref": "#/components/schemas/mongo.topology"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this MongoDB Action"
          },
          "collection": {
            "default": "mqtt",
            "type": "string",
            "description": "The collection where data will be stored into"
          },
          "payload_template": {
            "type": "string",
            "description": "The template for formatting the outgoing messages.  If undefined, rule engine will use JSON format to serialize all visible inputs, such as clientid, topic, payload etc."
          },
          "resource_opts": {
            "description": "Creation options.",
            "$ref": "#/components/schemas/bridge_mongodb.creation_opts"
          }
        },
        "type": "object"
      },
      "audit.http_request": {
        "properties": {
          "bindings": {
            "type": "object",
            "example": {}
          },
          "body": {
            "type": "object",
            "example": {}
          },
          "headers": {
            "type": "object",
            "example": {}
          },
          "method": {
            "type": "string",
            "enum": [
              "post",
              "put",
              "delete"
            ]
          }
        },
        "type": "object"
      },
      "bridge_datalayers.get_connector": {
        "required": [
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "datalayers"
            ],
            "description": "The type of the connector."
          },
          "name": {
            "type": "string",
            "description": "The name of the connector."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this connector."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the connector<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the connector passes the health probes.<br/><br/>- <code>disconnected</code>: when the connector can not pass health probes.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a connector is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/connector.node_status"
            }
          },
          "actions": {
            "type": "array",
            "description": "List of actions added to this connector.",
            "items": {
              "type": "string"
            },
            "example": [
              "my_action"
            ]
          },
          "server": {
            "default": "127.0.0.1:8361",
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The Datalayers default port 8361 is used if `[:Port]` is not specified."
          },
          "parameters": {
            "description": "Set of parameters specific for the given type of this Datalayers connector.",
            "$ref": "#/components/schemas/connector_datalayers.datalayers_parameters"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_datalayers.connector_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_pgsql.action_parameters": {
        "properties": {
          "sql": {
            "default": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
            "type": "string",
            "format": "sql",
            "description": "SQL Template"
          }
        },
        "type": "object"
      },
      "bridge_greptimedb.put_grpc_v1": {
        "required": [
          "dbname",
          "write_syntax"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to the GreptimeDB. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: If this Sink is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "write_syntax": {
            "type": "string",
            "format": "sql",
            "description": "Conf of GreptimeDB gRPC protocol to write data points. Write syntax is a text-based format that provides the measurement, tag set, field set, and timestamp of a data point, and placeholder supported, which is the same as InfluxDB line protocol.<br/>See also [InfluxDB 2.3 Line Protocol](https://docs.influxdata.com/influxdb/v2.3/reference/syntax/line-protocol/) and<br/>[GreptimeDB 1.8 Line Protocol](https://docs.influxdata.com/influxdb/v1.8/write_protocols/line_protocol_tutorial/) <br/><br/>TLDR:<br/><br/>```<br/><measurement>[,<tag_key>=<tag_value>[,<tag_key>=<tag_value>]] <field_key>=<field_value>[,<field_key>=<field_value>] [<timestamp>]<br/>```<br/>Please note that a placeholder for an integer value must be annotated with a suffix `i`. For example `${payload.int_value}i`."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "default": "127.0.0.1:4001",
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The GreptimeDB default port 8086 is used if `[:Port]` is not specified."
          },
          "precision": {
            "default": "ms",
            "type": "string",
            "enum": [
              "ns",
              "us",
              "ms",
              "s"
            ],
            "description": "GreptimeDB time precision."
          },
          "dbname": {
            "type": "string",
            "description": "GreptimeDB database."
          },
          "username": {
            "type": "string",
            "description": "GreptimeDB username."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "GreptimeDB password.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "bridge_s3.s3_aggregation": {
        "properties": {
          "time_interval": {
            "default": "30m",
            "type": "string",
            "description": "Amount of time events will be aggregated in a single object before uploading.",
            "example": "1h"
          },
          "max_records": {
            "default": "100000",
            "type": "integer",
            "description": "Number of records (events) allowed per each aggregated object. Each aggregated upload will contain no more than that number of events, but may contain less.<br/><br/>If event rate is high enough, there obviously may be more than one aggregated upload during the same time interval. These uploads will have different, but consecutive sequence numbers, which will be a part of S3 object key.",
            "minimum": 1
          }
        },
        "type": "object"
      },
      "public.meta": {
        "required": [
          "hasnext"
        ],
        "properties": {
          "page": {
            "default": 1,
            "type": "integer",
            "description": "Page number of the results to fetch.",
            "minimum": 1,
            "example": 1
          },
          "limit": {
            "default": 100,
            "maximum": 10000,
            "type": "integer",
            "description": "Results per page(max 10000)",
            "minimum": 1,
            "example": 50
          },
          "count": {
            "type": "integer",
            "description": "Total number of records matching the query.<br/>Note: this field is present only if the query can be optimized and does not require a full table scan.",
            "minimum": 0
          },
          "hasnext": {
            "type": "boolean",
            "description": "Flag indicating whether there are more results available on next pages."
          }
        },
        "type": "object"
      },
      "bridge_gcp_pubsub.put_consumer": {
        "required": [
          "consumer",
          "resource_opts",
          "service_account_json"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "description": "Creation options.",
            "$ref": "#/components/schemas/bridge_gcp_pubsub.consumer_resource_opts"
          },
          "connect_timeout": {
            "default": "15s",
            "type": "string",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s"
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "The pool size.",
            "minimum": 1
          },
          "pipelining": {
            "default": 100,
            "type": "integer",
            "description": "A positive integer. Whether to send HTTP requests continuously, when set to 1, it means that after each HTTP request is sent, you need to wait for the server to return and then continue to send the next request.",
            "minimum": 1
          },
          "max_retries": {
            "default": 2,
            "type": "integer",
            "description": "Max retry times if an error occurs when sending a request.",
            "minimum": 0
          },
          "request_timeout": {
            "default": "15s",
            "type": "string",
            "deprecated": true,
            "example": "32s"
          },
          "service_account_json": {
            "type": "string",
            "description": "JSON containing the GCP Service Account credentials to be used with PubSub.<br/>When a GCP Service Account is created (as described in https://developers.google.com/identity/protocols/oauth2/service-account#creatinganaccount), you have the option of downloading the credentials in JSON form.  That's the file needed."
          },
          "consumer": {
            "description": "Local MQTT publish and GCP PubSub consumer configs.",
            "$ref": "#/components/schemas/bridge_gcp_pubsub.consumer"
          }
        },
        "type": "object"
      },
      "connector_mqtt.ingress": {
        "properties": {
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the pool of MQTT clients that will ingest messages from the remote broker.<br/><br/>This value will be respected only if 'remote.topic' is a shared subscription topic or topic-filter<br/>(for example `$share/name1/topic1` or `$share/name2/topic2/#`), otherwise only a single MQTT client will be used.<br/>Each MQTT client will be assigned 'clientid' of the form '${clientid_prefix}:${bridge_name}:ingress:${node}:${n}'<br/>where 'n' is the number of a client inside the pool.<br/>NOTE: Non-shared subscription will not work well when EMQX is clustered.",
            "minimum": 1
          },
          "remote": {
            "description": "The configs about subscribing to the remote broker.",
            "$ref": "#/components/schemas/connector_mqtt.ingress_remote"
          },
          "local": {
            "description": "The configs about sending message to the local broker.",
            "$ref": "#/components/schemas/connector_mqtt.ingress_local"
          }
        },
        "type": "object"
      },
      "bridge_azure_event_hub.auth_username_password": {
        "required": [
          "password"
        ],
        "properties": {
          "password": {
            "type": "string",
            "format": "password",
            "description": "The Connection String for connecting to Azure Event Hubs.  Should be the \"connection string-primary key\" of a Namespace shared access policy.",
            "example": "R4ND0M/S∃CЯ∃T"
          }
        },
        "type": "object"
      },
      "bridge_http.get_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "http"
            ],
            "description": "The action type."
          },
          "name": {
            "type": "string",
            "description": "Action name, used as a human-readable identifier."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "parameters": {
            "description": "The parameters for HTTP action.",
            "$ref": "#/components/schemas/bridge_http.parameters_opts"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_http.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_pulsar.get_producer": {
        "required": [
          "name",
          "pulsar_topic",
          "servers",
          "type"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "pulsar_producer"
            ],
            "description": "The Bridge Type"
          },
          "name": {
            "type": "string",
            "description": "Bridge name, used as a human-readable description of the bridge."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this Pulsar bridge."
          },
          "servers": {
            "type": "string",
            "description": "A comma separated list of Pulsar URLs in the form <code>scheme://host[:port]</code><br/> for the client to connect to. The supported schemes are <code>pulsar://</code> (default)<br/> and <code>pulsar+ssl://</code>. The default port is 6650."
          },
          "authentication": {
            "default": "none",
            "description": "Authentication configs.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/bridge_pulsar.auth_token"
              },
              {
                "$ref": "#/components/schemas/bridge_pulsar.auth_basic"
              },
              {
                "type": "string",
                "enum": [
                  "none"
                ]
              }
            ]
          },
          "connect_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Maximum wait time for TCP connection establishment (including authentication time if enabled).",
            "example": "32s"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "message": {
            "description": "Template to render a Pulsar message.",
            "$ref": "#/components/schemas/pulsar.producer_pulsar_message"
          },
          "sync_timeout": {
            "default": "3s",
            "type": "string",
            "description": "Maximum wait time for receiving a receipt from Pulsar when publishing synchronously.",
            "example": "32s"
          },
          "pulsar_topic": {
            "type": "string",
            "description": "Pulsar topic name"
          },
          "batch_size": {
            "default": 100,
            "type": "integer",
            "description": "Maximum number of individual requests to batch in a Pulsar message.",
            "minimum": 1
          },
          "compression": {
            "default": "no_compression",
            "type": "string",
            "enum": [
              "no_compression",
              "snappy",
              "zlib"
            ],
            "description": "Compression method."
          },
          "send_buffer": {
            "default": "1MB",
            "type": "string",
            "description": "Fine tune the socket send buffer. The default value is tuned for high throughput.",
            "example": "32MB"
          },
          "retention_period": {
            "default": "infinity",
            "description": "The amount of time messages will be buffered while there is no connection to<br/> the Pulsar broker.  Longer times mean that more memory/disk will be used",
            "oneOf": [
              {
                "type": "string",
                "example": "32s"
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "max_batch_bytes": {
            "default": "900KB",
            "type": "string",
            "description": "Maximum bytes to collect in a Pulsar message batch. Most of the Pulsar brokers<br/> default to a limit of 5 MB batch size. EMQX's default value is less than 5 MB in<br/> order to compensate Pulsar message encoding overheads (especially when each individual<br/> message is very small). When a single message is over the limit, it is still<br/> sent (as a single element batch).",
            "example": "32MB"
          },
          "strategy": {
            "default": "random",
            "type": "string",
            "enum": [
              "random",
              "roundrobin",
              "key_dispatch"
            ],
            "description": "Partition strategy is to tell the producer how to dispatch messages to Pulsar partitions.<br/><br/><code>random</code>: Randomly pick a partition for each message.<br/><code>roundrobin</code>: Pick each available producer in turn for each message.<br/><code>key_dispatch</code>: Hash Pulsar message key of the first message in a batch<br/> to a partition number."
          },
          "buffer": {
            "description": "Configure producer message buffer.\"<br/>Tell Pulsar producer how to buffer messages when EMQX has more messages to\"<br/> send than Pulsar can keep up, or when Pulsar is down.",
            "$ref": "#/components/schemas/bridge_pulsar.producer_buffer"
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (bridge input)<br/> If rule action is used as data source, this config should be left empty,<br/> otherwise messages will be duplicated in Pulsar."
          },
          "resource_opts": {
            "description": "Creation options.",
            "$ref": "#/components/schemas/bridge_pulsar.producer_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_rabbitmq.get": {
        "required": [
          "exchange",
          "name",
          "password",
          "routing_key",
          "type",
          "username"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "rabbitmq"
            ],
            "description": "The Bridge Type"
          },
          "name": {
            "type": "string",
            "description": "Bridge name."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to RabbitMQ. All MQTT 'PUBLISH' messages with the topic matching the local_topic will be forwarded.<br/>    NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is configured, then both the data got from the rule and the MQTT messages that match local_topic will be forwarded."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_rabbitmq.creation_opts"
          },
          "server": {
            "default": "localhost",
            "type": "string",
            "description": "The RabbitMQ server address that you want to connect to (for example, localhost)."
          },
          "port": {
            "default": 5672,
            "maximum": 65535,
            "type": "integer",
            "description": "The RabbitMQ server address that you want to connect to (for example, localhost).",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username used to authenticate with the RabbitMQ server."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "The size of the connection pool.",
            "minimum": 1
          },
          "timeout": {
            "default": "5s",
            "type": "string",
            "description": "The timeout for waiting on the connection to be established.",
            "example": "32s"
          },
          "virtual_host": {
            "default": "/",
            "type": "string",
            "description": "The virtual host to use when connecting to the RabbitMQ server."
          },
          "heartbeat": {
            "default": "30s",
            "type": "string",
            "description": "The interval for sending heartbeat messages to the RabbitMQ server.",
            "example": "32s"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "wait_for_publish_confirmations": {
            "default": true,
            "type": "boolean",
            "description": "A boolean value that indicates whether to wait for RabbitMQ to confirm message publication when using publisher confirms."
          },
          "publish_confirmation_timeout": {
            "default": "30s",
            "type": "string",
            "description": "The timeout for waiting on the connection to be established.",
            "example": "32s"
          },
          "exchange": {
            "type": "string",
            "description": "The name of the RabbitMQ exchange where the messages will be sent."
          },
          "routing_key": {
            "type": "string",
            "description": "The routing key used to route messages to the correct queue in the RabbitMQ exchange."
          },
          "delivery_mode": {
            "default": "non_persistent",
            "type": "string",
            "enum": [
              "non_persistent",
              "persistent"
            ],
            "description": "The delivery mode for messages published to RabbitMQ. Delivery mode non_persistent (1) is suitable for messages that don't require persistence across RabbitMQ restarts, whereas delivery mode persistent (2) is designed for messages that must survive RabbitMQ restarts."
          },
          "payload_template": {
            "default": "",
            "type": "string",
            "description": "The template for formatting the payload of the message before sending it to RabbitMQ. Template placeholders, such as ${field1.sub_field}, will be substituted with the respective field's value. When left empty, the entire input message will be used as the payload, formatted as a JSON text. This behavior is equivalent to specifying ${.} as the payload template."
          }
        },
        "type": "object"
      },
      "gcp_pubsub_consumer.source_resource_opts": {
        "properties": {
          "health_check_interval": {
            "default": "30s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "request_ttl": {
            "default": "45s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "string",
                "example": "32s"
              }
            ]
          }
        },
        "type": "object"
      },
      "bridge_cassa.connector_resource_opts": {
        "properties": {
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "start_after_created": {
            "default": true,
            "type": "boolean",
            "description": "Whether start the resource right after created."
          },
          "start_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "example": "32s"
          }
        },
        "type": "object"
      },
      "confluent.kafka_message": {
        "properties": {
          "key": {
            "default": "${.clientid}",
            "type": "string",
            "description": "Template for rendering message key. If the template is rendered into a NULL value (i.e. there is no such data field in Rule Engine context) then <code>NULL</code> (but not empty string) is used."
          },
          "value": {
            "default": "${.}",
            "type": "string",
            "description": "Template to render Confluent message value. If the template is rendered into a NULL value (i.e. there is no such data field in Rule Engine context) then Confluent's <code>NULL</code> (but not empty string) is used."
          }
        },
        "type": "object"
      },
      "bridge_redis.put_cluster": {
        "required": [
          "command_template",
          "servers"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to Redis. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: If this action is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "command_template": {
            "type": "array",
            "description": "Redis command template used to export messages. Each list element stands for a command name or its argument.<br/>For example, to push payloads in a Redis list by key `msgs`, the elements should be the following:<br/>`rpush`, `msgs`, `${payload}`.",
            "items": {
              "type": "string"
            }
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_redis.creation_opts_redis_cluster"
          },
          "servers": {
            "type": "string",
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The Redis default port 6379 is used if `[:Port]` is not specified."
          },
          "redis_type": {
            "default": "cluster",
            "type": "string",
            "enum": [
              "cluster"
            ],
            "description": "Cluster mode. Must be set to 'cluster' when Redis server is running in clustered mode."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "schema_validation_http_api.get_metrics": {
        "properties": {
          "metrics": {
            "$ref": "#/components/schemas/schema_validation_http_api.metrics"
          },
          "node_metrics": {
            "$ref": "#/components/schemas/schema_validation_http_api.node_metrics"
          }
        },
        "type": "object"
      },
      "rule_engine.ctx_connected": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "type": "string",
            "enum": [
              "client_connected"
            ],
            "description": "Event Type"
          },
          "clientid": {
            "type": "string",
            "description": "The Client ID"
          },
          "username": {
            "type": "string",
            "description": "Username"
          },
          "mountpoint": {
            "type": "string",
            "description": "The Mountpoint"
          },
          "peername": {
            "type": "string",
            "description": "The IP Address and Port of the Peer Client"
          },
          "sockname": {
            "type": "string",
            "description": "The IP Address and Port of the Local Listener"
          },
          "proto_name": {
            "type": "string",
            "description": "Protocol Name"
          },
          "proto_ver": {
            "type": "string",
            "description": "Protocol Version"
          },
          "keepalive": {
            "type": "integer",
            "description": "KeepAlive"
          },
          "clean_start": {
            "default": true,
            "type": "boolean",
            "description": "Clean Start"
          },
          "expiry_interval": {
            "type": "integer",
            "description": "Expiry Interval"
          },
          "is_bridge": {
            "default": false,
            "type": "boolean",
            "description": "Is Bridge"
          },
          "connected_at": {
            "type": "integer",
            "description": "The Time that this Client is Connected"
          }
        },
        "type": "object"
      },
      "kafka_consumer.post_source": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "kafka_consumer"
            ]
          },
          "name": {
            "type": "string"
          },
          "parameters": {
            "description": "Source configs.",
            "$ref": "#/components/schemas/kafka_consumer.source_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.source_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_http.put": {
        "required": [
          "url"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this action."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "connect_timeout": {
            "default": "15s",
            "type": "string",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s"
          },
          "retry_interval": {
            "type": "string",
            "deprecated": true,
            "example": "12m"
          },
          "pool_type": {
            "default": "random",
            "type": "string",
            "enum": [
              "random",
              "hash"
            ],
            "description": "The type of the pool. Can be one of `random`, `hash`."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "The pool size.",
            "minimum": 1
          },
          "enable_pipelining": {
            "default": 100,
            "type": "integer",
            "description": "The maximum number of HTTP requests that can be sent before an HTTP response is received.<br/><br/>Setting this to 1 is equivalent to turning off HTTP pipelining, and the EMQX must receive a response to the previous HTTP request before sending the next HTTP request.",
            "minimum": 1
          },
          "request": {
            "type": "object",
            "deprecated": true,
            "description": "This field is never used, so we deprecated it since 5.3.2.",
            "example": {}
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "url": {
            "type": "string",
            "description": "The URL of the HTTP action.<br/><br/>Template with variables is allowed in the path, but variables cannot be used in the scheme, host,<br/>or port part.<br/><br/>For example, <code> http://localhost:9901/${topic} </code> is allowed, but<br/><code> http://${host}:9901/message </code> or <code> http://localhost:${port}/message </code><br/>is not allowed."
          },
          "direction": {
            "type": "string",
            "enum": [
              "egress"
            ],
            "deprecated": true
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to the HTTP server. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: If this action is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "method": {
            "default": "post",
            "type": "string",
            "enum": [
              "post",
              "put",
              "get",
              "delete"
            ],
            "description": "The method of the HTTP request. All the available methods are: post, put, get, delete.<br/><br/>Template with variables is allowed."
          },
          "headers": {
            "default": {
              "accept": "application/json",
              "cache-control": "no-cache",
              "connection": "keep-alive",
              "content-type": "application/json",
              "keep-alive": "timeout=5"
            },
            "type": "object",
            "description": "The headers of the HTTP request.<br/><br/>Template with variables is allowed.",
            "example": {},
            "is_template": true
          },
          "body": {
            "type": "string",
            "description": "The body of the HTTP request.<br/><br/>If not provided, the body will be a JSON object of all the available fields.<br/><br/>There, 'all the available fields' means the context of a MQTT message when<br/>this webhook is triggered by receiving a MQTT message (the `local_topic` is set),<br/>or the context of the event when this webhook is triggered by a rule (i.e. this<br/>webhook is used as an action of a rule).<br/><br/>Template with variables is allowed."
          },
          "max_retries": {
            "default": 2,
            "type": "integer",
            "description": "HTTP request max retry times if failed.",
            "minimum": 0
          },
          "request_timeout": {
            "default": "15s",
            "type": "string",
            "deprecated": true,
            "description": "HTTP request timeout.",
            "example": "32s"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_http.v1_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_pulsar.post_producer": {
        "required": [
          "name",
          "pulsar_topic",
          "servers",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "pulsar_producer"
            ],
            "description": "The Bridge Type"
          },
          "name": {
            "type": "string",
            "description": "Bridge name, used as a human-readable description of the bridge."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this Pulsar bridge."
          },
          "servers": {
            "type": "string",
            "description": "A comma separated list of Pulsar URLs in the form <code>scheme://host[:port]</code><br/> for the client to connect to. The supported schemes are <code>pulsar://</code> (default)<br/> and <code>pulsar+ssl://</code>. The default port is 6650."
          },
          "authentication": {
            "default": "none",
            "description": "Authentication configs.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/bridge_pulsar.auth_token"
              },
              {
                "$ref": "#/components/schemas/bridge_pulsar.auth_basic"
              },
              {
                "type": "string",
                "enum": [
                  "none"
                ]
              }
            ]
          },
          "connect_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Maximum wait time for TCP connection establishment (including authentication time if enabled).",
            "example": "32s"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "message": {
            "description": "Template to render a Pulsar message.",
            "$ref": "#/components/schemas/pulsar.producer_pulsar_message"
          },
          "sync_timeout": {
            "default": "3s",
            "type": "string",
            "description": "Maximum wait time for receiving a receipt from Pulsar when publishing synchronously.",
            "example": "32s"
          },
          "pulsar_topic": {
            "type": "string",
            "description": "Pulsar topic name"
          },
          "batch_size": {
            "default": 100,
            "type": "integer",
            "description": "Maximum number of individual requests to batch in a Pulsar message.",
            "minimum": 1
          },
          "compression": {
            "default": "no_compression",
            "type": "string",
            "enum": [
              "no_compression",
              "snappy",
              "zlib"
            ],
            "description": "Compression method."
          },
          "send_buffer": {
            "default": "1MB",
            "type": "string",
            "description": "Fine tune the socket send buffer. The default value is tuned for high throughput.",
            "example": "32MB"
          },
          "retention_period": {
            "default": "infinity",
            "description": "The amount of time messages will be buffered while there is no connection to<br/> the Pulsar broker.  Longer times mean that more memory/disk will be used",
            "oneOf": [
              {
                "type": "string",
                "example": "32s"
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "max_batch_bytes": {
            "default": "900KB",
            "type": "string",
            "description": "Maximum bytes to collect in a Pulsar message batch. Most of the Pulsar brokers<br/> default to a limit of 5 MB batch size. EMQX's default value is less than 5 MB in<br/> order to compensate Pulsar message encoding overheads (especially when each individual<br/> message is very small). When a single message is over the limit, it is still<br/> sent (as a single element batch).",
            "example": "32MB"
          },
          "strategy": {
            "default": "random",
            "type": "string",
            "enum": [
              "random",
              "roundrobin",
              "key_dispatch"
            ],
            "description": "Partition strategy is to tell the producer how to dispatch messages to Pulsar partitions.<br/><br/><code>random</code>: Randomly pick a partition for each message.<br/><code>roundrobin</code>: Pick each available producer in turn for each message.<br/><code>key_dispatch</code>: Hash Pulsar message key of the first message in a batch<br/> to a partition number."
          },
          "buffer": {
            "description": "Configure producer message buffer.\"<br/>Tell Pulsar producer how to buffer messages when EMQX has more messages to\"<br/> send than Pulsar can keep up, or when Pulsar is down.",
            "$ref": "#/components/schemas/bridge_pulsar.producer_buffer"
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (bridge input)<br/> If rule action is used as data source, this config should be left empty,<br/> otherwise messages will be duplicated in Pulsar."
          },
          "resource_opts": {
            "description": "Creation options.",
            "$ref": "#/components/schemas/bridge_pulsar.producer_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_pgsql.post_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "pgsql"
            ],
            "description": "The Bridge Type"
          },
          "name": {
            "type": "string",
            "description": "Bridge name."
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Configuration Parameters Specific to the PostgreSQL Action",
            "$ref": "#/components/schemas/bridge_pgsql.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_clickhouse.post": {
        "required": [
          "database",
          "name",
          "type",
          "url"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "clickhouse"
            ],
            "description": "The Bridge Type"
          },
          "name": {
            "type": "string",
            "description": "Bridge name."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "sql": {
            "default": "INSERT INTO messages(data, arrived) VALUES ('${payload}', ${timestamp})",
            "type": "string",
            "format": "sql",
            "description": "The template string can contain ${field} placeholders for message metadata and payload field. Make sure that the inserted values are formatted and escaped correctly. [Prepared Statement](https://docs.emqx.com/en/enterprise/v5.0/data-integration/data-bridges.html#Prepared-Statement) is not supported."
          },
          "batch_value_separator": {
            "default": ", ",
            "type": "string",
            "description": "The default value ',' works for the VALUES format. You can also use other separator if other format is specified. See [INSERT INTO Statement](https://clickhouse.com/docs/en/sql-reference/statements/insert-into)."
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to Clickhouse. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_clickhouse.creation_opts"
          },
          "url": {
            "type": "string",
            "description": "The HTTP URL to the Clickhouse server that you want to connect to (for example http://myhostname:8123)",
            "example": "http://127.0.0.1"
          },
          "connect_timeout": {
            "default": "15s",
            "type": "string",
            "description": "The timeout when connecting to the Clickhouse server.",
            "example": "32s"
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          }
        },
        "type": "object"
      },
      "bridge_cassa.put_bridge_v2": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Action specific configs.",
            "$ref": "#/components/schemas/bridge_cassa.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "message_transformation.operation": {
        "required": [
          "key",
          "value"
        ],
        "properties": {
          "key": {
            "type": "string"
          },
          "value": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge_hstreamdb.put_bridge_v2": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Action specific configuration.",
            "$ref": "#/components/schemas/bridge_hstreamdb.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "connector_mqtt.egress_local": {
        "properties": {
          "topic": {
            "type": "string",
            "description": "The local topic to be forwarded to the remote broker"
          }
        },
        "type": "object"
      },
      "bridge_opents.put_bridge_v2": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "OpenTSDB action parameters",
            "$ref": "#/components/schemas/bridge_opents.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_rabbitmq.get_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "rabbitmq"
            ]
          },
          "name": {
            "type": "string"
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "The action config defines how this bridge send messages to the remote RabbitMQ broker",
            "$ref": "#/components/schemas/bridge_rabbitmq.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_rabbitmq.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_mongodb.put_bridge_v2": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Additional parameters specific to this action type",
            "$ref": "#/components/schemas/bridge_mongodb.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_mongodb.action_resource_opts"
          }
        },
        "type": "object"
      },
      "gcp_pubsub_producer.post_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "gcp_pubsub_producer"
            ]
          },
          "name": {
            "type": "string"
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Action configs.",
            "$ref": "#/components/schemas/gcp_pubsub_producer.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_kafka.consumer_topic_mapping": {
        "required": [
          "kafka_topic",
          "mqtt_topic"
        ],
        "properties": {
          "kafka_topic": {
            "type": "string",
            "description": "Kafka topic to consume from."
          },
          "mqtt_topic": {
            "type": "string",
            "description": "Local topic to which consumed Kafka messages should be published to."
          },
          "qos": {
            "default": 0,
            "maximum": 2,
            "type": "integer",
            "description": "MQTT QoS used to publish messages consumed from Kafka.",
            "minimum": 0,
            "example": 0
          },
          "payload_template": {
            "default": "${.}",
            "type": "string",
            "description": "The template for transforming the incoming Kafka message.  By default, it will use JSON format to serialize inputs from the Kafka message.  Such fields are:<br/><code>headers</code>: an object containing string key-value pairs.<br/><code>key</code>: Kafka message key (uses the chosen key encoding).<br/><code>offset</code>: offset for the message.<br/><code>topic</code>: Kafka topic.<br/><code>ts</code>: message timestamp.<br/><code>ts_type</code>: message timestamp type, which is one of <code>create</code>, <code>append</code> or <code>undefined</code>.<br/><code>value</code>: Kafka message value (uses the chosen value encoding)."
          }
        },
        "type": "object"
      },
      "schema_validation.check_avro": {
        "required": [
          "schema"
        ],
        "properties": {
          "type": {
            "default": "avro",
            "type": "string",
            "enum": [
              "avro"
            ],
            "description": "Avro schema check"
          },
          "schema": {
            "type": "string",
            "description": "Schema name to use during check."
          }
        },
        "type": "object"
      },
      "action_couchbase.parameters": {
        "required": [
          "sql"
        ],
        "properties": {
          "sql": {
            "type": "string",
            "description": "SQL Template"
          },
          "max_retries": {
            "default": 3,
            "type": "integer",
            "description": "Max retry times if error on sending request.",
            "minimum": 0
          }
        },
        "type": "object"
      },
      "action_azure_blob_storage.action_resource_opts": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "maximum": 1024,
            "type": "integer",
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 1
          },
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "query_mode": {
            "default": "async",
            "type": "string",
            "enum": [
              "sync",
              "async"
            ],
            "description": "Query mode. Optional 'sync/async', default 'async'."
          },
          "request_ttl": {
            "default": "45s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "string",
                "example": "32s"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "type": "integer",
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1
          },
          "batch_size": {
            "default": 100,
            "type": "integer",
            "description": "Maximum batch count. If equal to 1, there's effectively no batching.",
            "minimum": 1
          },
          "batch_time": {
            "default": "10ms",
            "type": "string",
            "description": "Maximum waiting interval when accumulating a batch at a low message rates for more efficient resource usage.",
            "example": "32s"
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "type": "string",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB"
          }
        },
        "type": "object"
      },
      "action_couchbase.put_bridge_v2": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Set of parameters for the action.",
            "$ref": "#/components/schemas/action_couchbase.parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/action_couchbase.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_influxdb.post_api_v2": {
        "required": [
          "bucket",
          "name",
          "org",
          "token",
          "type",
          "write_syntax"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to the InfluxDB. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "write_syntax": {
            "type": "string",
            "format": "sql",
            "description": "Conf of InfluxDB line protocol to write data points. It is a text-based format that provides the measurement, tag set, field set, and timestamp of a data point, and placeholder supported.<br/>See also [InfluxDB 2.3 Line Protocol](https://docs.influxdata.com/influxdb/v2.3/reference/syntax/line-protocol/) and<br/>[InfluxDB 1.8 Line Protocol](https://docs.influxdata.com/influxdb/v1.8/write_protocols/line_protocol_tutorial/) <br/><br/>TLDR:<br/><br/>```<br/><measurement>[,<tag_key>=<tag_value>[,<tag_key>=<tag_value>]] <field_key>=<field_value>[,<field_key>=<field_value>] [<timestamp>]<br/>```<br/>Please note that a placeholder for an integer value must be annotated with a suffix `i`. For example `${payload.int_value}i`."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "default": "127.0.0.1:8086",
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The InfluxDB default port 8086 is used if `[:Port]` is not specified."
          },
          "precision": {
            "default": "ms",
            "type": "string",
            "enum": [
              "ns",
              "us",
              "ms",
              "s"
            ],
            "description": "InfluxDB time precision."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "bucket": {
            "type": "string",
            "description": "InfluxDB bucket name."
          },
          "org": {
            "type": "string",
            "description": "Organization name of InfluxDB."
          },
          "token": {
            "type": "string",
            "format": "password",
            "description": "InfluxDB token.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "type": {
            "type": "string",
            "enum": [
              "influxdb_api_v2"
            ],
            "description": "The Bridge Type."
          },
          "name": {
            "type": "string",
            "description": "Bridge name."
          }
        },
        "type": "object"
      },
      "bridge_iotdb.get_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "iotdb"
            ]
          },
          "name": {
            "type": "string"
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "IoTDB action parameters",
            "$ref": "#/components/schemas/bridge_iotdb.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_iotdb.action_resource_opts"
          }
        },
        "type": "object"
      },
      "confluent.put_bridge_v2": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in Confluent."
          },
          "parameters": {
            "description": "Confluent producer configs.",
            "$ref": "#/components/schemas/confluent.producer_kafka_opts"
          },
          "resource_opts": {
            "default": {},
            "$ref": "#/components/schemas/bridge_kafka.resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_azure_event_hub.ssl_client_opts": {
        "properties": {
          "cacertfile": {
            "type": "string",
            "description": "Trusted PEM format CA certificates bundle file.<br/><br/>The certificates in this file are used to verify the TLS peer's certificates.<br/>Append new certificates to the file if new CAs are to be trusted.<br/>There is no need to restart EMQX to have the updated file loaded, because<br/>the system regularly checks if file has been updated (and reload).<br/><br/>NOTE: invalidating (deleting) a certificate from the file will not affect<br/>already established connections."
          },
          "cacerts": {
            "default": false,
            "type": "boolean",
            "deprecated": true
          },
          "certfile": {
            "type": "string",
            "description": "PEM format certificates chain file.<br/><br/>The certificates in this file should be in reversed order of the certificate<br/>issue chain. That is, the host's certificate should be placed in the beginning<br/>of the file, followed by the immediate issuer certificate and so on.<br/>Although the root CA certificate is optional, it should be placed at the end of<br/>the file if it is to be added."
          },
          "keyfile": {
            "type": "string",
            "description": "PEM format private key file."
          },
          "verify": {
            "default": "verify_none",
            "type": "string",
            "enum": [
              "verify_peer",
              "verify_none"
            ],
            "description": "Enable or disable peer verification."
          },
          "reuse_sessions": {
            "default": true,
            "type": "boolean",
            "description": "Enable TLS session reuse.<br/><br/>Has no effect when TLS version is configured (or negotiated) to 1.3"
          },
          "depth": {
            "default": 10,
            "type": "integer",
            "description": "Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path.<br/>So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly;<br/><br/>if 1 the path can be PEER, Intermediate-CA, ROOT-CA;<br/><br/>if 2 the path can be PEER, Intermediate-CA1, Intermediate-CA2, ROOT-CA.",
            "minimum": 0
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "String containing the user's password. Only used if the private key file is password-protected.",
            "example": ""
          },
          "versions": {
            "default": [
              "tlsv1.3",
              "tlsv1.2"
            ],
            "type": "array",
            "description": "All TLS/DTLS versions to be supported.<br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.<br/><br/>In case PSK cipher suites are intended, make sure to configure<br/><code>['tlsv1.2', 'tlsv1.1']</code> here.",
            "items": {
              "type": "string"
            }
          },
          "ciphers": {
            "default": [],
            "type": "array",
            "description": "This config holds TLS cipher suite names separated by comma,<br/>or as an array of strings. e.g.<br/><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or<br/><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.<br/><br/><br/>Ciphers (and their ordering) define the way in which the<br/>client and server encrypts information over the network connection.<br/>Selecting a good cipher suite is critical for the<br/>application's data security, confidentiality and performance.<br/><br/>The names should be in OpenSSL string format (not RFC format).<br/>All default values and examples provided by EMQX config<br/>documentation are all in OpenSSL format.<br/><br/><br/>NOTE: Certain cipher suites are only compatible with<br/>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')<br/>incompatible cipher suites will be silently dropped.<br/>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,<br/>configuring cipher suites for other versions will have no effect.<br/><br/><br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br/><br/>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.<br/><br/>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,<br/>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,<br/>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,<br/>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code>",
            "items": {
              "type": "string"
            }
          },
          "secure_renegotiate": {
            "default": true,
            "type": "boolean",
            "description": "Whether to reject TLS renegotiation attempts that are not compliant with [RFC 5746](http://www.ietf.org/rfc/rfc5746.txt).<br/><br/>By default, `secure_renegotiate` is set to `true`, which forces secure renegotiation.<br/>If set to `false`, secure renegotiation will still be used, but will fall back to insecure renegotiation if the peer does not support [RFC 5746](http://www.ietf.org/rfc/rfc5746.txt), which increases the risk of a MitM attack.<br/><br/>Has no effect when TLS version is configured (or negotiated) to 1.3."
          },
          "log_level": {
            "default": "notice",
            "type": "string",
            "enum": [
              "emergency",
              "alert",
              "critical",
              "error",
              "warning",
              "notice",
              "info",
              "debug",
              "none",
              "all"
            ],
            "description": "The minimum level of logging allowed for SSL output.<br/><br/>The default is `notice`, set to a lower `debug` level for more detailed logging that can be used to investigate SSL handshake issues."
          },
          "hibernate_after": {
            "default": "5s",
            "type": "string",
            "description": "Specifies the amount of time that an SSL process will hibernate after being idle, thus reducing its memory footprint.<br/><br/>The hibernating process will be woken up when a new message arrives.<br/>Hibernating and waking up too often can cause CPU utilization to increase, as they both perform garbage collection on the process.",
            "example": "12m"
          },
          "partial_chain": {
            "type": "string",
            "enum": [
              true,
              false,
              "two_cacerts_from_cacertfile",
              "cacert_from_cacertfile"
            ],
            "description": "Enable or disable peer verification with partial_chain.<br/>When local verifies a peer certificate during the x509 path validation<br/>process, it constructs a certificate chain that starts with the peer<br/>certificate and ends with a trust anchor.<br/>By default, if it is set to `false`, the trust anchor is the<br/>Root CA, and the certificate chain must be complete.<br/>However, if the setting is set to `true` or `cacert_from_cacertfile`,<br/>the last certificate in `cacertfile` will be used as the trust anchor<br/>certificate (intermediate CA). This creates a partial chain<br/>in the path validation.<br/>Alternatively, if it is configured with `two_cacerts_from_cacertfile`,<br/>one of the last two certificates in `cacertfile` will be used as the<br/>trust anchor certificate, forming a partial chain. This option is<br/>particularly useful for intermediate CA certificate rotation.<br/>However, please note that it incurs some additional overhead, so it<br/>should only be used for certificate rotation purposes."
          },
          "verify_peer_ext_key_usage": {
            "type": "string",
            "description": "Verify extended key usage in peer's certificate<br/>For additional peer certificate validation, the value defined here must present in the<br/>'Extended Key Usage' of peer certificate defined in<br/>[rfc5280](https://www.rfc-editor.org/rfc/rfc5280#section-4.2.1.12).<br/><br/>Allowed values are<br/>- `clientAuth`<br/>- `serverAuth`<br/>- `codeSigning`<br/>- `emailProtection`<br/>- `timeStamping`<br/>- `ocspSigning`<br/>- raw OID, for example: \"OID:1.3.6.1.5.5.7.3.2\" means `id-pk 2` which is equivalent to `clientAuth`<br/><br/>Comma-separated string is also supported for validating more than one key usages.<br/><br/>For example, `\"serverAuth,OID:1.3.6.1.5.5.7.3.2\"`"
          },
          "enable": {
            "default": true,
            "type": "string",
            "enum": [
              true
            ],
            "description": "Enable TLS."
          },
          "server_name_indication": {
            "default": "auto",
            "description": "Server Name Indication (SNI) setting for TLS handshake.<br/><br/>- <code>auto</code>: The client will use <code>\"servicebus.windows.net\"</code> as SNI.<br/><br/>- <code>disable</code>: If you wish to prevent the client from sending the SNI.<br/><br/>- Other string values it will be sent as-is.",
            "example": "auto",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "string",
                "enum": [
                  "disable"
                ]
              },
              {
                "type": "string",
                "enum": [
                  "auto"
                ]
              }
            ]
          }
        },
        "type": "object"
      },
      "bridge_azure_event_hub.kafka_message": {
        "properties": {
          "key": {
            "default": "${.clientid}",
            "type": "string",
            "description": "Template for rendering message key. If the template is rendered into a NULL value (i.e. there is no such data field in Rule Engine context) then <code>NULL</code> (but not empty string) is used."
          },
          "value": {
            "default": "${.}",
            "type": "string",
            "description": "Template to render Azure Event Hubs message value. If the template is rendered into a NULL value (i.e. there is no such data field in Rule Engine context) then Azure Event Hubs' <code>NULL</code> (but not empty string) is used."
          }
        },
        "type": "object"
      },
      "bridge_pulsar.auth_token": {
        "required": [
          "jwt"
        ],
        "properties": {
          "jwt": {
            "type": "string",
            "format": "password",
            "description": "JWT authentication token.",
            "example": "R4ND0M/S∃CЯ∃T"
          }
        },
        "type": "object"
      },
      "bridge_gcp_pubsub.put_producer": {
        "required": [
          "pubsub_topic",
          "service_account_json"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "connect_timeout": {
            "default": "15s",
            "type": "string",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s"
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "The pool size.",
            "minimum": 1
          },
          "pipelining": {
            "default": 100,
            "type": "integer",
            "description": "A positive integer. Whether to send HTTP requests continuously, when set to 1, it means that after each HTTP request is sent, you need to wait for the server to return and then continue to send the next request.",
            "minimum": 1
          },
          "max_retries": {
            "default": 2,
            "type": "integer",
            "description": "Max retry times if an error occurs when sending a request.",
            "minimum": 0
          },
          "request_timeout": {
            "default": "15s",
            "type": "string",
            "deprecated": true,
            "example": "32s"
          },
          "service_account_json": {
            "type": "string",
            "description": "JSON containing the GCP Service Account credentials to be used with PubSub.<br/>When a GCP Service Account is created (as described in https://developers.google.com/identity/protocols/oauth2/service-account#creatinganaccount), you have the option of downloading the credentials in JSON form.  That's the file needed."
          },
          "attributes_template": {
            "default": [],
            "type": "array",
            "description": "The template for formatting the outgoing message attributes.  Undefined values will be rendered as empty string values.  Empty keys are removed from the attribute map.",
            "items": {
              "$ref": "#/components/schemas/bridge_gcp_pubsub.key_value_pair"
            }
          },
          "ordering_key_template": {
            "default": "",
            "type": "string",
            "description": "The template for formatting the outgoing message ordering key.  Undefined values will be rendered as empty string values.  This value will not be added to the message if it's empty."
          },
          "payload_template": {
            "default": "",
            "type": "string",
            "description": "The template for formatting the outgoing messages.  If undefined, will send all the available context in JSON format."
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to GCP PubSub. All MQTT 'PUBLISH' messages with the topic<br/>matching `local_topic` will be forwarded.<br/><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "pubsub_topic": {
            "type": "string",
            "description": "The GCP PubSub topic to publish messages to."
          }
        },
        "type": "object"
      },
      "rule_engine.rule_metrics": {
        "required": [
          "id"
        ],
        "properties": {
          "id": {
            "type": "string",
            "description": "The ID of the rule",
            "example": "293fb66f"
          },
          "metrics": {
            "description": "The metrics of the rule",
            "$ref": "#/components/schemas/rule_engine.metrics"
          },
          "node_metrics": {
            "type": "array",
            "description": "The metrics of the rule for each node",
            "items": {
              "$ref": "#/components/schemas/rule_engine.node_metrics"
            }
          }
        },
        "type": "object"
      },
      "rule_engine.ctx_sub": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "type": "string",
            "enum": [
              "session_subscribed"
            ],
            "description": "Event Type"
          },
          "clientid": {
            "type": "string",
            "description": "The Client ID"
          },
          "username": {
            "type": "string",
            "description": "Username"
          },
          "payload": {
            "type": "string",
            "description": "The Message Payload"
          },
          "peerhost": {
            "type": "string",
            "description": "The IP Address of the Peer Client"
          },
          "topic": {
            "type": "string",
            "description": "Message Topic"
          },
          "publish_received_at": {
            "type": "integer",
            "description": "The Time that this Message is Received"
          },
          "qos": {
            "maximum": 2,
            "type": "integer",
            "description": "The Message QoS",
            "minimum": 0,
            "example": 0
          }
        },
        "type": "object"
      },
      "bridge_kafka.post_producer": {
        "required": [
          "bootstrap_hosts",
          "kafka",
          "name",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "kafka",
              "kafka_producer",
              "kafka_consumer"
            ],
            "description": "The Action Type"
          },
          "name": {
            "type": "string",
            "description": "Action name, used as a human-readable identifier."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this connector."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "bootstrap_hosts": {
            "type": "string",
            "description": "A comma separated list of Kafka <code>host:port</code> endpoints to bootstrap the client."
          },
          "connect_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Maximum wait time for TCP connection establishment (including authentication time if enabled).",
            "example": "32s"
          },
          "min_metadata_refresh_interval": {
            "default": "3s",
            "type": "string",
            "description": "Minimum time interval the client has to wait before refreshing Kafka broker and topic metadata. Setting too small value may add extra load on Kafka.",
            "example": "32s"
          },
          "metadata_request_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Maximum wait time when fetching topic metadata.",
            "example": "32s"
          },
          "authentication": {
            "default": "none",
            "description": "Authentication configs.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/bridge_kafka.auth_gssapi_kerberos"
              },
              {
                "$ref": "#/components/schemas/bridge_kafka.auth_username_password"
              },
              {
                "type": "string",
                "enum": [
                  "none"
                ]
              }
            ]
          },
          "socket_opts": {
            "description": "Extra socket options.",
            "$ref": "#/components/schemas/bridge_kafka.socket_opts"
          },
          "health_check_topic": {
            "type": "string",
            "description": "Topic name used exclusively for more accurate connector health checks."
          },
          "ssl": {
            "$ref": "#/components/schemas/bridge_kafka.ssl_client_opts"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_kafka.connector_resource_opts"
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in Kafka."
          },
          "kafka": {
            "description": "Kafka producer configs.",
            "$ref": "#/components/schemas/bridge_kafka.v1_producer_kafka_opts"
          }
        },
        "type": "object"
      },
      "bridge_mqtt_publisher.action_parameters": {
        "required": [
          "topic"
        ],
        "properties": {
          "topic": {
            "type": "string",
            "description": "Forward to which topic of the remote broker.<br/><br/>Template with variables is allowed."
          },
          "qos": {
            "default": 1,
            "description": "The QoS of the MQTT message to be sent.<br/><br/>Template with variables is allowed.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "maximum": 2,
                "type": "integer",
                "minimum": 0,
                "example": 0
              }
            ]
          },
          "retain": {
            "default": false,
            "description": "The 'retain' flag of the MQTT message to be sent.<br/><br/>Template with variables is allowed.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "boolean"
              }
            ]
          },
          "payload": {
            "type": "string",
            "description": "The payload of the MQTT message to be sent.<br/><br/>Template with variables is allowed."
          }
        },
        "type": "object"
      },
      "schema_validation.check_sql": {
        "required": [
          "sql"
        ],
        "properties": {
          "type": {
            "default": "sql",
            "type": "string",
            "enum": [
              "sql"
            ],
            "description": "Use rule-engine's SQL to validate the message. SQL here is the same as in rule-engine,<br/>  just with the different that the `FROM` clause must be omitted.<br/>  A SQL statement which yields any value is considered successfully validated, otherwise failed.<br/>  For example <code>SELECT payload.foo + payload.bar as sum WHERE sum > 0</code><br/>  validates that the sum of field `foo` and `bar` is a positive value."
          },
          "sql": {
            "type": "string",
            "description": "Use rule-engine's SQL to validate the message. SQL here is the same as in rule-engine,<br/>  just with the different that the `FROM` clause must be omitted.<br/>  A SQL statement which yields any value is considered successfully validated, otherwise failed.<br/>  For example <code>SELECT payload.foo + payload.bar as sum WHERE sum > 0</code><br/>  validates that the sum of field `foo` and `bar` is a positive value."
          }
        },
        "type": "object"
      },
      "bridge_azure_event_hub.put_connector": {
        "required": [
          "authentication",
          "bootstrap_hosts",
          "ssl"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this connector."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "bootstrap_hosts": {
            "type": "string",
            "description": "A comma separated list of Azure Event Hubs Kafka <code>host[:port]</code> namespace endpoints to bootstrap the client.  Default port number is 9093."
          },
          "connect_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Maximum wait time for TCP connection establishment (including authentication time if enabled).",
            "example": "32s"
          },
          "min_metadata_refresh_interval": {
            "default": "3s",
            "type": "string",
            "description": "Minimum time interval the client has to wait before refreshing Azure Event Hubs Kafka broker and topic metadata. Setting too small value may add extra load on Azure Event Hubs.",
            "example": "32s"
          },
          "metadata_request_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Maximum wait time when fetching metadata from Azure Event Hubs.",
            "example": "32s"
          },
          "authentication": {
            "default": {},
            "description": "Authentication configs.",
            "$ref": "#/components/schemas/bridge_azure_event_hub.auth_username_password"
          },
          "socket_opts": {
            "description": "Extra socket options.",
            "$ref": "#/components/schemas/bridge_kafka.socket_opts"
          },
          "health_check_topic": {
            "type": "string",
            "description": "Topic name used exclusively for more accurate connector health checks."
          },
          "ssl": {
            "default": {
              "enable": true
            },
            "$ref": "#/components/schemas/bridge_azure_event_hub.ssl_client_opts"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_kafka.connector_resource_opts"
          }
        },
        "type": "object"
      },
      "file_transfer.local_storage_exporter_backend": {
        "properties": {
          "local": {
            "description": "Exporter to the local file system.",
            "$ref": "#/components/schemas/file_transfer.local_storage_exporter"
          },
          "s3": {
            "description": "Exporter to the S3 API compatible object storage.",
            "$ref": "#/components/schemas/file_transfer.s3_exporter"
          }
        },
        "type": "object"
      },
      "bridge_kafka.get_producer": {
        "required": [
          "bootstrap_hosts",
          "kafka",
          "name",
          "type"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "kafka",
              "kafka_producer",
              "kafka_consumer"
            ],
            "description": "The Action Type"
          },
          "name": {
            "type": "string",
            "description": "Action name, used as a human-readable identifier."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this connector."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "bootstrap_hosts": {
            "type": "string",
            "description": "A comma separated list of Kafka <code>host:port</code> endpoints to bootstrap the client."
          },
          "connect_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Maximum wait time for TCP connection establishment (including authentication time if enabled).",
            "example": "32s"
          },
          "min_metadata_refresh_interval": {
            "default": "3s",
            "type": "string",
            "description": "Minimum time interval the client has to wait before refreshing Kafka broker and topic metadata. Setting too small value may add extra load on Kafka.",
            "example": "32s"
          },
          "metadata_request_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Maximum wait time when fetching topic metadata.",
            "example": "32s"
          },
          "authentication": {
            "default": "none",
            "description": "Authentication configs.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/bridge_kafka.auth_gssapi_kerberos"
              },
              {
                "$ref": "#/components/schemas/bridge_kafka.auth_username_password"
              },
              {
                "type": "string",
                "enum": [
                  "none"
                ]
              }
            ]
          },
          "socket_opts": {
            "description": "Extra socket options.",
            "$ref": "#/components/schemas/bridge_kafka.socket_opts"
          },
          "health_check_topic": {
            "type": "string",
            "description": "Topic name used exclusively for more accurate connector health checks."
          },
          "ssl": {
            "$ref": "#/components/schemas/bridge_kafka.ssl_client_opts"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_kafka.connector_resource_opts"
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in Kafka."
          },
          "kafka": {
            "description": "Kafka producer configs.",
            "$ref": "#/components/schemas/bridge_kafka.v1_producer_kafka_opts"
          }
        },
        "type": "object"
      },
      "bridge_azure_event_hub.get_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "azure_event_hub_producer"
            ],
            "description": "The type of the bridge."
          },
          "name": {
            "type": "string",
            "description": "Bridge name, used as a human-readable description of the bridge."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in Azure Event Hubs."
          },
          "parameters": {
            "description": "Azure Event Hubs producer configs.",
            "$ref": "#/components/schemas/bridge_azure_event_hub.producer_kafka_opts"
          },
          "resource_opts": {
            "default": {},
            "$ref": "#/components/schemas/bridge_kafka.resource_opts"
          }
        },
        "type": "object"
      },
      "gcp_pubsub_producer.action_parameters": {
        "required": [
          "pubsub_topic"
        ],
        "properties": {
          "attributes_template": {
            "default": [],
            "type": "array",
            "description": "The template for formatting the outgoing message attributes.  Undefined values will be rendered as empty string values.  Empty keys are removed from the attribute map.",
            "items": {
              "$ref": "#/components/schemas/bridge_gcp_pubsub.key_value_pair"
            }
          },
          "ordering_key_template": {
            "default": "",
            "type": "string",
            "description": "The template for formatting the outgoing message ordering key.  Undefined values will be rendered as empty string values.  This value will not be added to the message if it's empty."
          },
          "payload_template": {
            "default": "",
            "type": "string",
            "description": "The template for formatting the outgoing messages.  If undefined, will send all the available context in JSON format."
          },
          "pubsub_topic": {
            "type": "string",
            "description": "The GCP PubSub topic to publish messages to."
          }
        },
        "type": "object"
      },
      "connector_mqtt.egress": {
        "required": [
          "remote"
        ],
        "properties": {
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the pool of MQTT clients that will publish messages to the remote broker.<br/><br/>Each MQTT client will be assigned 'clientid' of the form '${clientid_prefix}:${bridge_name}:egress:${node}:${n}'<br/>where 'n' is the number of a client inside the pool.",
            "minimum": 1
          },
          "local": {
            "description": "The configs about receiving messages from local broker.",
            "$ref": "#/components/schemas/connector_mqtt.egress_local"
          },
          "remote": {
            "description": "The configs about sending message to the remote broker.",
            "$ref": "#/components/schemas/connector_mqtt.egress_remote"
          }
        },
        "type": "object"
      },
      "bridge_elasticsearch.action_delete": {
        "required": [
          "action",
          "id",
          "index"
        ],
        "properties": {
          "action": {
            "type": "string",
            "enum": [
              "delete"
            ],
            "description": "delete"
          },
          "index": {
            "type": "string",
            "description": "Name of index, or index alias to perform the action on.<br/>This parameter is required.",
            "example": "${payload.index}"
          },
          "id": {
            "type": "string",
            "description": "The document ID. If no ID is specified, a document ID is automatically generated.",
            "example": "${payload.id}"
          },
          "routing": {
            "type": "string",
            "description": "Custom value used to route operations to a specific shard.",
            "example": "${payload.routing}"
          },
          "max_retries": {
            "default": 2,
            "type": "integer",
            "description": "HTTP request max retry times if failed.",
            "minimum": 0
          }
        },
        "type": "object"
      },
      "message_transformation.log_failure": {
        "properties": {
          "level": {
            "default": "info",
            "type": "string",
            "enum": [
              "error",
              "warning",
              "notice",
              "info",
              "debug",
              "none"
            ]
          }
        },
        "type": "object"
      },
      "bridge_gcp_pubsub.post_consumer": {
        "required": [
          "consumer",
          "name",
          "resource_opts",
          "service_account_json",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "gcp_pubsub_consumer"
            ],
            "description": "The action type."
          },
          "name": {
            "type": "string",
            "description": "Action name, used as a human-readable identifier."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "description": "Creation options.",
            "$ref": "#/components/schemas/bridge_gcp_pubsub.consumer_resource_opts"
          },
          "connect_timeout": {
            "default": "15s",
            "type": "string",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s"
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "The pool size.",
            "minimum": 1
          },
          "pipelining": {
            "default": 100,
            "type": "integer",
            "description": "A positive integer. Whether to send HTTP requests continuously, when set to 1, it means that after each HTTP request is sent, you need to wait for the server to return and then continue to send the next request.",
            "minimum": 1
          },
          "max_retries": {
            "default": 2,
            "type": "integer",
            "description": "Max retry times if an error occurs when sending a request.",
            "minimum": 0
          },
          "request_timeout": {
            "default": "15s",
            "type": "string",
            "deprecated": true,
            "example": "32s"
          },
          "service_account_json": {
            "type": "string",
            "description": "JSON containing the GCP Service Account credentials to be used with PubSub.<br/>When a GCP Service Account is created (as described in https://developers.google.com/identity/protocols/oauth2/service-account#creatinganaccount), you have the option of downloading the credentials in JSON form.  That's the file needed."
          },
          "consumer": {
            "description": "Local MQTT publish and GCP PubSub consumer configs.",
            "$ref": "#/components/schemas/bridge_gcp_pubsub.consumer"
          }
        },
        "type": "object"
      },
      "bridge_cassa.post_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "cassandra"
            ]
          },
          "name": {
            "type": "string"
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Action specific configs.",
            "$ref": "#/components/schemas/bridge_cassa.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_oracle.put_bridge_v2": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Action specific configuration.",
            "$ref": "#/components/schemas/bridge_oracle.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_tdengine.put_bridge_v2": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "TDengine action parameters",
            "$ref": "#/components/schemas/bridge_tdengine.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_rabbitmq.post_source": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "rabbitmq"
            ]
          },
          "name": {
            "type": "string"
          },
          "parameters": {
            "description": "The source config defines how this bridge receive messages from the remote RabbitMQ broker",
            "$ref": "#/components/schemas/bridge_rabbitmq.source_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.source_resource_opts"
          }
        },
        "type": "object"
      },
      "action_azure_blob_storage.post_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "azure_blob_storage"
            ]
          },
          "name": {
            "type": "string"
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Set of parameters for the action.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/action_azure_blob_storage.direct_parameters"
              },
              {
                "$ref": "#/components/schemas/action_azure_blob_storage.aggreg_parameters"
              }
            ]
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/action_azure_blob_storage.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_rabbitmq.creation_opts": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "maximum": 1024,
            "type": "integer",
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 1
          },
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "start_after_created": {
            "default": true,
            "type": "boolean",
            "description": "Whether start the resource right after created."
          },
          "start_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "example": "32s"
          },
          "auto_restart_interval": {
            "default": "15s",
            "deprecated": true,
            "oneOf": [
              {
                "type": "string",
                "example": "32s"
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "query_mode": {
            "default": "async",
            "type": "string",
            "enum": [
              "sync",
              "async"
            ],
            "description": "Query mode. Optional 'sync/async', default 'async'."
          },
          "request_ttl": {
            "default": "45s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "string",
                "example": "32s"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "type": "integer",
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1
          },
          "batch_size": {
            "default": 1,
            "type": "integer",
            "description": "Maximum batch count. If equal to 1, there's effectively no batching.",
            "minimum": 1
          },
          "batch_time": {
            "default": "0ms",
            "type": "string",
            "description": "Maximum waiting interval when accumulating a batch at a low message rates for more efficient resource usage.",
            "example": "32s"
          },
          "enable_queue": {
            "default": false,
            "type": "boolean",
            "deprecated": true,
            "description": "Enable disk buffer queue (only applicable for egress bridges).<br/>When Enabled, messages will be buffered on disk when the bridge connection is down.<br/>When disabled the messages are buffered in RAM only."
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "type": "string",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB"
          }
        },
        "type": "object"
      },
      "rule_engine.ctx_check_authz_complete": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "type": "string",
            "enum": [
              "client_check_authz_complete"
            ],
            "description": "Event Type"
          },
          "clientid": {
            "type": "string",
            "description": "The Client ID"
          },
          "username": {
            "type": "string",
            "description": "Username"
          },
          "peerhost": {
            "type": "string",
            "description": "The IP Address of the Peer Client"
          },
          "topic": {
            "type": "string",
            "description": "Message Topic"
          },
          "action": {
            "type": "string",
            "description": "Publish or Subscribe"
          },
          "authz_source": {
            "type": "string",
            "description": "Cache, Plugs or Default"
          },
          "result": {
            "type": "string",
            "description": "Allow or Deny"
          }
        },
        "type": "object"
      },
      "bridge_greptimedb.get_grpc_v1": {
        "required": [
          "dbname",
          "name",
          "type",
          "write_syntax"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to the GreptimeDB. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: If this Sink is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "write_syntax": {
            "type": "string",
            "format": "sql",
            "description": "Conf of GreptimeDB gRPC protocol to write data points. Write syntax is a text-based format that provides the measurement, tag set, field set, and timestamp of a data point, and placeholder supported, which is the same as InfluxDB line protocol.<br/>See also [InfluxDB 2.3 Line Protocol](https://docs.influxdata.com/influxdb/v2.3/reference/syntax/line-protocol/) and<br/>[GreptimeDB 1.8 Line Protocol](https://docs.influxdata.com/influxdb/v1.8/write_protocols/line_protocol_tutorial/) <br/><br/>TLDR:<br/><br/>```<br/><measurement>[,<tag_key>=<tag_value>[,<tag_key>=<tag_value>]] <field_key>=<field_value>[,<field_key>=<field_value>] [<timestamp>]<br/>```<br/>Please note that a placeholder for an integer value must be annotated with a suffix `i`. For example `${payload.int_value}i`."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "default": "127.0.0.1:4001",
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The GreptimeDB default port 8086 is used if `[:Port]` is not specified."
          },
          "precision": {
            "default": "ms",
            "type": "string",
            "enum": [
              "ns",
              "us",
              "ms",
              "s"
            ],
            "description": "GreptimeDB time precision."
          },
          "dbname": {
            "type": "string",
            "description": "GreptimeDB database."
          },
          "username": {
            "type": "string",
            "description": "GreptimeDB username."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "GreptimeDB password.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "type": {
            "type": "string",
            "enum": [
              "greptimedb"
            ],
            "description": "The type of the action."
          },
          "name": {
            "type": "string",
            "description": "The name of the action."
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          }
        },
        "type": "object"
      },
      "bridge_clickhouse.put_bridge_v2": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Action specific configs.",
            "$ref": "#/components/schemas/bridge_clickhouse.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_datalayers.post_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "datalayers"
            ]
          },
          "name": {
            "type": "string"
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Additional parameters specific to this action type",
            "$ref": "#/components/schemas/bridge_datalayers.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_kinesis.creation_opts": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "maximum": 1024,
            "type": "integer",
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 1
          },
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "start_after_created": {
            "default": true,
            "type": "boolean",
            "description": "Whether start the resource right after created."
          },
          "start_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "example": "32s"
          },
          "auto_restart_interval": {
            "default": "15s",
            "deprecated": true,
            "oneOf": [
              {
                "type": "string",
                "example": "32s"
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "query_mode": {
            "default": "async",
            "type": "string",
            "enum": [
              "sync",
              "async"
            ],
            "description": "Query mode. Optional 'sync/async', default 'async'."
          },
          "request_ttl": {
            "default": "45s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "string",
                "example": "32s"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "type": "integer",
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1
          },
          "batch_size": {
            "default": 1,
            "maximum": 500,
            "type": "integer",
            "description": "Maximum batch count. If equal to 1, there's effectively no batching.",
            "minimum": 1
          },
          "batch_time": {
            "default": "0ms",
            "type": "string",
            "description": "Maximum waiting interval when accumulating a batch at a low message rates for more efficient resource usage.",
            "example": "32s"
          },
          "enable_queue": {
            "default": false,
            "type": "boolean",
            "deprecated": true,
            "description": "Enable disk buffer queue (only applicable for egress bridges).<br/>When Enabled, messages will be buffered on disk when the bridge connection is down.<br/>When disabled the messages are buffered in RAM only."
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "type": "string",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB"
          }
        },
        "type": "object"
      },
      "rule_engine.ctx_unsub": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "type": "string",
            "enum": [
              "session_unsubscribed"
            ],
            "description": "Event Type"
          },
          "clientid": {
            "type": "string",
            "description": "The Client ID"
          },
          "username": {
            "type": "string",
            "description": "Username"
          },
          "payload": {
            "type": "string",
            "description": "The Message Payload"
          },
          "peerhost": {
            "type": "string",
            "description": "The IP Address of the Peer Client"
          },
          "topic": {
            "type": "string",
            "description": "Message Topic"
          },
          "publish_received_at": {
            "type": "integer",
            "description": "The Time that this Message is Received"
          },
          "qos": {
            "maximum": 2,
            "type": "integer",
            "description": "The Message QoS",
            "minimum": 0,
            "example": 0
          }
        },
        "type": "object"
      },
      "bridge_redis.creation_opts_redis_cluster": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "maximum": 1024,
            "type": "integer",
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 1
          },
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "start_after_created": {
            "default": true,
            "type": "boolean",
            "description": "Whether start the resource right after created."
          },
          "start_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "example": "32s"
          },
          "auto_restart_interval": {
            "default": "15s",
            "deprecated": true,
            "oneOf": [
              {
                "type": "string",
                "example": "32s"
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "query_mode": {
            "default": "async",
            "type": "string",
            "enum": [
              "sync",
              "async"
            ],
            "description": "Query mode. Optional 'sync/async', default 'async'."
          },
          "request_ttl": {
            "default": "45s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "string",
                "example": "32s"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "type": "integer",
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1
          },
          "enable_queue": {
            "default": false,
            "type": "boolean",
            "deprecated": true,
            "description": "Enable disk buffer queue (only applicable for egress bridges).<br/>When Enabled, messages will be buffered on disk when the bridge connection is down.<br/>When disabled the messages are buffered in RAM only."
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "type": "string",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB"
          }
        },
        "type": "object"
      },
      "bridge_elasticsearch.get_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "elasticsearch"
            ]
          },
          "name": {
            "type": "string"
          },
          "parameters": {
            "description": "ElasticSearch action parameters",
            "oneOf": [
              {
                "$ref": "#/components/schemas/bridge_elasticsearch.action_update"
              },
              {
                "$ref": "#/components/schemas/bridge_elasticsearch.action_delete"
              },
              {
                "$ref": "#/components/schemas/bridge_elasticsearch.action_create"
              }
            ]
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_elasticsearch.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_gcp_pubsub.get_producer": {
        "required": [
          "name",
          "pubsub_topic",
          "service_account_json",
          "type"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "gcp_pubsub"
            ],
            "description": "The action type."
          },
          "name": {
            "type": "string",
            "description": "Action name, used as a human-readable identifier."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "connect_timeout": {
            "default": "15s",
            "type": "string",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s"
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "The pool size.",
            "minimum": 1
          },
          "pipelining": {
            "default": 100,
            "type": "integer",
            "description": "A positive integer. Whether to send HTTP requests continuously, when set to 1, it means that after each HTTP request is sent, you need to wait for the server to return and then continue to send the next request.",
            "minimum": 1
          },
          "max_retries": {
            "default": 2,
            "type": "integer",
            "description": "Max retry times if an error occurs when sending a request.",
            "minimum": 0
          },
          "request_timeout": {
            "default": "15s",
            "type": "string",
            "deprecated": true,
            "example": "32s"
          },
          "service_account_json": {
            "type": "string",
            "description": "JSON containing the GCP Service Account credentials to be used with PubSub.<br/>When a GCP Service Account is created (as described in https://developers.google.com/identity/protocols/oauth2/service-account#creatinganaccount), you have the option of downloading the credentials in JSON form.  That's the file needed."
          },
          "attributes_template": {
            "default": [],
            "type": "array",
            "description": "The template for formatting the outgoing message attributes.  Undefined values will be rendered as empty string values.  Empty keys are removed from the attribute map.",
            "items": {
              "$ref": "#/components/schemas/bridge_gcp_pubsub.key_value_pair"
            }
          },
          "ordering_key_template": {
            "default": "",
            "type": "string",
            "description": "The template for formatting the outgoing message ordering key.  Undefined values will be rendered as empty string values.  This value will not be added to the message if it's empty."
          },
          "payload_template": {
            "default": "",
            "type": "string",
            "description": "The template for formatting the outgoing messages.  If undefined, will send all the available context in JSON format."
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to GCP PubSub. All MQTT 'PUBLISH' messages with the topic<br/>matching `local_topic` will be forwarded.<br/><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "pubsub_topic": {
            "type": "string",
            "description": "The GCP PubSub topic to publish messages to."
          }
        },
        "type": "object"
      },
      "bridge_matrix.post_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "matrix"
            ],
            "description": "The Bridge Type"
          },
          "name": {
            "type": "string",
            "description": "Bridge name."
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Configuration Parameters Specific to the PostgreSQL Action",
            "$ref": "#/components/schemas/bridge_pgsql.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_rabbitmq.action_parameters": {
        "required": [
          "exchange",
          "routing_key"
        ],
        "properties": {
          "wait_for_publish_confirmations": {
            "default": true,
            "type": "boolean",
            "description": "A boolean value that indicates whether to wait for RabbitMQ to confirm message publication when using publisher confirms."
          },
          "publish_confirmation_timeout": {
            "default": "30s",
            "type": "string",
            "description": "The timeout for waiting on the connection to be established.",
            "example": "32s"
          },
          "exchange": {
            "type": "string",
            "description": "The name of the RabbitMQ exchange where the messages will be sent."
          },
          "routing_key": {
            "type": "string",
            "description": "The routing key used to route messages to the correct queue in the RabbitMQ exchange."
          },
          "delivery_mode": {
            "default": "non_persistent",
            "type": "string",
            "enum": [
              "non_persistent",
              "persistent"
            ],
            "description": "The delivery mode for messages published to RabbitMQ. Delivery mode non_persistent (1) is suitable for messages that don't require persistence across RabbitMQ restarts, whereas delivery mode persistent (2) is designed for messages that must survive RabbitMQ restarts."
          },
          "payload_template": {
            "default": "",
            "type": "string",
            "description": "The template for formatting the payload of the message before sending it to RabbitMQ. Template placeholders, such as ${field1.sub_field}, will be substituted with the respective field's value. When left empty, the entire input message will be used as the payload, formatted as a JSON text. This behavior is equivalent to specifying ${.} as the payload template."
          }
        },
        "type": "object"
      },
      "bridge_http.action_resource_opts": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "maximum": 1024,
            "type": "integer",
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 1
          },
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "query_mode": {
            "default": "async",
            "type": "string",
            "enum": [
              "sync",
              "async"
            ],
            "description": "Query mode. Optional 'sync/async', default 'async'."
          },
          "request_ttl": {
            "default": "45s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "string",
                "example": "32s"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "type": "integer",
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "type": "string",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB"
          }
        },
        "type": "object"
      },
      "bridge_redis.get_single": {
        "required": [
          "command_template",
          "name",
          "server",
          "type"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to Redis. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: If this action is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "command_template": {
            "type": "array",
            "description": "Redis command template used to export messages. Each list element stands for a command name or its argument.<br/>For example, to push payloads in a Redis list by key `msgs`, the elements should be the following:<br/>`rpush`, `msgs`, `${payload}`.",
            "items": {
              "type": "string"
            }
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_redis.creation_opts_redis_single"
          },
          "server": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The Redis default port 6379 is used if `[:Port]` is not specified."
          },
          "redis_type": {
            "default": "single",
            "type": "string",
            "enum": [
              "single"
            ],
            "description": "Single mode. Must be set to 'single' when Redis server is running in single mode."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "database": {
            "default": 0,
            "type": "integer",
            "description": "Redis database ID.",
            "minimum": 0
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "type": {
            "type": "string",
            "enum": [
              "redis_single"
            ],
            "description": "The Action Type"
          },
          "name": {
            "type": "string",
            "description": "Action name, used as a human-readable identifier."
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          }
        },
        "type": "object"
      },
      "bridge_kafka.connector_resource_opts": {
        "properties": {
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "start_after_created": {
            "default": true,
            "type": "boolean",
            "description": "Whether start the resource right after created."
          },
          "start_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "example": "32s"
          }
        },
        "type": "object"
      },
      "bridge_sqlserver.put_bridge_v2": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Action specific configuration.",
            "$ref": "#/components/schemas/bridge_sqlserver.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "schema_validation.validation": {
        "required": [
          "checks",
          "failure_action",
          "name",
          "strategy",
          "topics"
        ],
        "properties": {
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "enable": {
            "default": true,
            "type": "boolean"
          },
          "name": {
            "type": "string",
            "description": "Name"
          },
          "topics": {
            "description": "A single topic filter or list of topic filters that this validation should validate.",
            "oneOf": [
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              {
                "type": "string"
              }
            ]
          },
          "strategy": {
            "type": "string",
            "enum": [
              "any_pass",
              "all_pass"
            ],
            "description": "Strategy"
          },
          "failure_action": {
            "type": "string",
            "enum": [
              "drop",
              "disconnect",
              "ignore"
            ],
            "description": "How to proceed if the validation fails.<br/><br/>  <code>drop</code>: The offending message is simply dropped without further processing.<br/>  <code>disconnect</code>: The message is not published, and the publishing client is disconnected.<br/>  <code>ignore</code>: Only the failure is logged and traced.  No other action is taken."
          },
          "log_failure": {
            "default": {},
            "description": "Log level at which failures will be logged.",
            "$ref": "#/components/schemas/schema_validation.log_failure"
          },
          "checks": {
            "type": "array",
            "description": "Checks that will be performed during validation.  They are evaluated in the same order as defined.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/schema_validation.check_protobuf"
                },
                {
                  "$ref": "#/components/schemas/schema_validation.check_avro"
                },
                {
                  "$ref": "#/components/schemas/schema_validation.check_json"
                },
                {
                  "$ref": "#/components/schemas/schema_validation.check_sql"
                }
              ]
            }
          }
        },
        "type": "object"
      },
      "bridge_mqtt_publisher.put_source": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "parameters": {
            "$ref": "#/components/schemas/bridge_mqtt_publisher.ingress_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_mqtt_publisher.source_resource_opts"
          }
        },
        "type": "object"
      },
      "node_eviction.stats": {
        "properties": {
          "connections": {
            "type": "integer"
          },
          "sessions": {
            "type": "integer"
          }
        },
        "type": "object"
      },
      "bridge_kafka.post_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "kafka_producer"
            ],
            "description": "The Action Type"
          },
          "name": {
            "type": "string",
            "description": "Action name, used as a human-readable identifier."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in Kafka."
          },
          "parameters": {
            "description": "Kafka producer configs.",
            "$ref": "#/components/schemas/bridge_kafka.producer_kafka_opts"
          },
          "resource_opts": {
            "default": {},
            "$ref": "#/components/schemas/bridge_kafka.resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_gcp_pubsub.post_producer": {
        "required": [
          "name",
          "pubsub_topic",
          "service_account_json",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "gcp_pubsub"
            ],
            "description": "The action type."
          },
          "name": {
            "type": "string",
            "description": "Action name, used as a human-readable identifier."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "connect_timeout": {
            "default": "15s",
            "type": "string",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s"
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "The pool size.",
            "minimum": 1
          },
          "pipelining": {
            "default": 100,
            "type": "integer",
            "description": "A positive integer. Whether to send HTTP requests continuously, when set to 1, it means that after each HTTP request is sent, you need to wait for the server to return and then continue to send the next request.",
            "minimum": 1
          },
          "max_retries": {
            "default": 2,
            "type": "integer",
            "description": "Max retry times if an error occurs when sending a request.",
            "minimum": 0
          },
          "request_timeout": {
            "default": "15s",
            "type": "string",
            "deprecated": true,
            "example": "32s"
          },
          "service_account_json": {
            "type": "string",
            "description": "JSON containing the GCP Service Account credentials to be used with PubSub.<br/>When a GCP Service Account is created (as described in https://developers.google.com/identity/protocols/oauth2/service-account#creatinganaccount), you have the option of downloading the credentials in JSON form.  That's the file needed."
          },
          "attributes_template": {
            "default": [],
            "type": "array",
            "description": "The template for formatting the outgoing message attributes.  Undefined values will be rendered as empty string values.  Empty keys are removed from the attribute map.",
            "items": {
              "$ref": "#/components/schemas/bridge_gcp_pubsub.key_value_pair"
            }
          },
          "ordering_key_template": {
            "default": "",
            "type": "string",
            "description": "The template for formatting the outgoing message ordering key.  Undefined values will be rendered as empty string values.  This value will not be added to the message if it's empty."
          },
          "payload_template": {
            "default": "",
            "type": "string",
            "description": "The template for formatting the outgoing messages.  If undefined, will send all the available context in JSON format."
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to GCP PubSub. All MQTT 'PUBLISH' messages with the topic<br/>matching `local_topic` will be forwarded.<br/><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "pubsub_topic": {
            "type": "string",
            "description": "The GCP PubSub topic to publish messages to."
          }
        },
        "type": "object"
      },
      "mongo.topology": {
        "properties": {
          "max_overflow": {
            "default": 0,
            "type": "integer",
            "description": "The maximum number of additional workers that can be created when all workers in the pool are busy. This helps to manage temporary spikes in workload by allowing more concurrent connections to the MongoDB server.",
            "minimum": 0
          },
          "overflow_ttl": {
            "type": "string",
            "description": "Period of time before workers that exceed the configured pool size (\"overflow\") to be terminated.",
            "example": "32s"
          },
          "overflow_check_period": {
            "type": "string",
            "description": "Period for checking if there are more workers than configured (\"overflow\").",
            "example": "32s"
          },
          "local_threshold_ms": {
            "type": "string",
            "description": "The size of the latency window for selecting among multiple suitable MongoDB instances.",
            "example": "32s"
          },
          "connect_timeout_ms": {
            "type": "string",
            "description": "The duration to attempt a connection before timing out.",
            "example": "32s"
          },
          "socket_timeout_ms": {
            "type": "string",
            "description": "The duration to attempt to send or to receive on a socket before the attempt times out.",
            "example": "32s"
          },
          "server_selection_timeout_ms": {
            "type": "string",
            "description": "Specifies how long to block for server selection before throwing an exception.",
            "example": "32s"
          },
          "wait_queue_timeout_ms": {
            "type": "string",
            "description": "The maximum duration that a worker can wait for a connection to become available.",
            "example": "32s"
          },
          "heartbeat_frequency_ms": {
            "default": "200s",
            "type": "string",
            "description": "Controls when the driver checks the state of the MongoDB deployment. Specify the interval between checks, counted from the end of the previous check until the beginning of the next one. If the number of connections is increased (which will happen, for example, if you increase the pool size), you may need to increase this period as well to avoid creating too many log entries in the MongoDB log file.",
            "example": "32s"
          },
          "min_heartbeat_frequency_ms": {
            "type": "string",
            "description": "Controls the minimum amount of time to wait between heartbeats.",
            "example": "32s"
          }
        },
        "type": "object"
      },
      "bridge_greptimedb.connector_resource_opts": {
        "properties": {
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "start_after_created": {
            "default": true,
            "type": "boolean",
            "description": "Whether start the resource right after created."
          },
          "start_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "example": "32s"
          }
        },
        "type": "object"
      },
      "bridge_http.get": {
        "required": [
          "name",
          "type",
          "url"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "webhook",
              "http"
            ],
            "description": "The action type."
          },
          "name": {
            "type": "string",
            "description": "Action name, used as a human-readable identifier."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this action."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "connect_timeout": {
            "default": "15s",
            "type": "string",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s"
          },
          "retry_interval": {
            "type": "string",
            "deprecated": true,
            "example": "12m"
          },
          "pool_type": {
            "default": "random",
            "type": "string",
            "enum": [
              "random",
              "hash"
            ],
            "description": "The type of the pool. Can be one of `random`, `hash`."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "The pool size.",
            "minimum": 1
          },
          "enable_pipelining": {
            "default": 100,
            "type": "integer",
            "description": "The maximum number of HTTP requests that can be sent before an HTTP response is received.<br/><br/>Setting this to 1 is equivalent to turning off HTTP pipelining, and the EMQX must receive a response to the previous HTTP request before sending the next HTTP request.",
            "minimum": 1
          },
          "request": {
            "type": "object",
            "deprecated": true,
            "description": "This field is never used, so we deprecated it since 5.3.2.",
            "example": {}
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "url": {
            "type": "string",
            "description": "The URL of the HTTP action.<br/><br/>Template with variables is allowed in the path, but variables cannot be used in the scheme, host,<br/>or port part.<br/><br/>For example, <code> http://localhost:9901/${topic} </code> is allowed, but<br/><code> http://${host}:9901/message </code> or <code> http://localhost:${port}/message </code><br/>is not allowed."
          },
          "direction": {
            "type": "string",
            "enum": [
              "egress"
            ],
            "deprecated": true
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to the HTTP server. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: If this action is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "method": {
            "default": "post",
            "type": "string",
            "enum": [
              "post",
              "put",
              "get",
              "delete"
            ],
            "description": "The method of the HTTP request. All the available methods are: post, put, get, delete.<br/><br/>Template with variables is allowed."
          },
          "headers": {
            "default": {
              "accept": "application/json",
              "cache-control": "no-cache",
              "connection": "keep-alive",
              "content-type": "application/json",
              "keep-alive": "timeout=5"
            },
            "type": "object",
            "description": "The headers of the HTTP request.<br/><br/>Template with variables is allowed.",
            "example": {},
            "is_template": true
          },
          "body": {
            "type": "string",
            "description": "The body of the HTTP request.<br/><br/>If not provided, the body will be a JSON object of all the available fields.<br/><br/>There, 'all the available fields' means the context of a MQTT message when<br/>this webhook is triggered by receiving a MQTT message (the `local_topic` is set),<br/>or the context of the event when this webhook is triggered by a rule (i.e. this<br/>webhook is used as an action of a rule).<br/><br/>Template with variables is allowed."
          },
          "max_retries": {
            "default": 2,
            "type": "integer",
            "description": "HTTP request max retry times if failed.",
            "minimum": 0
          },
          "request_timeout": {
            "default": "15s",
            "type": "string",
            "deprecated": true,
            "description": "HTTP request timeout.",
            "example": "32s"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_http.v1_resource_opts"
          }
        },
        "type": "object"
      },
      "rocketmq.post": {
        "required": [
          "name",
          "servers",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "rocketmq"
            ],
            "description": "The Bridge Type"
          },
          "name": {
            "type": "string",
            "description": "Bridge name."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "template": {
            "default": "",
            "type": "string",
            "description": "Template, the default value is empty. When this value is empty the whole message will be stored in the RocketMQ.<br><br/>            The template can be any valid string with placeholders, example:<br><br/>            - ${id}, ${username}, ${clientid}, ${timestamp}<br><br/>            - {\"id\" : ${id}, \"username\" : ${username}}"
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to RocketMQ. All MQTT `PUBLISH` messages with the topic<br/>matching the `local_topic` will be forwarded.<br/><br/>NOTE: if the bridge is used as a rule action, `local_topic` should be left empty otherwise the messages will be duplicated."
          },
          "strategy": {
            "default": "roundrobin",
            "description": "Producer key dispatch strategy, the default is `roundrobin`, also supports placeholders, such as: `clientid`, `messageid`, `username`.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "string",
                "enum": [
                  "roundrobin"
                ]
              }
            ]
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "servers": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The RocketMQ default port 9876 is used if `[:Port]` is not specified."
          },
          "namespace": {
            "type": "string",
            "description": "The namespace field MUST be set if you are using the RocketMQ service in<br/>aliyun cloud and also the namespace is enabled,<br/>or if you have configured a namespace in your RocketMQ server.<br/>For RocketMQ in aliyun cloud, the namespace is the instance ID."
          },
          "topic": {
            "default": "TopicTest",
            "type": "string",
            "description": "RocketMQ Topic"
          },
          "access_key": {
            "default": "",
            "type": "string",
            "description": "RocketMQ server `accessKey`."
          },
          "secret_key": {
            "default": "",
            "type": "string",
            "format": "password",
            "description": "RocketMQ server `secretKey`.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "security_token": {
            "default": "",
            "type": "string",
            "format": "password",
            "description": "RocketMQ Server Security Token",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "sync_timeout": {
            "default": "3s",
            "type": "string",
            "description": "Timeout of RocketMQ driver synchronous call.",
            "example": "12m"
          },
          "refresh_interval": {
            "default": "3s",
            "type": "string",
            "description": "RocketMQ Topic Route Refresh Interval.",
            "example": "12m"
          },
          "send_buffer": {
            "default": "1024KB",
            "type": "string",
            "description": "The socket send buffer size of the RocketMQ driver client.",
            "example": "32MB"
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "rule_engine.ctx_delivery_dropped": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "type": "string",
            "enum": [
              "delivery_dropped"
            ],
            "description": "Event Type"
          },
          "id": {
            "type": "string",
            "description": "Message ID"
          },
          "reason": {
            "type": "string",
            "description": "The Reason for Dropping"
          },
          "from_clientid": {
            "type": "string",
            "description": "The Client ID"
          },
          "from_username": {
            "type": "string",
            "description": "The User Name"
          },
          "clientid": {
            "type": "string",
            "description": "The Client ID"
          },
          "username": {
            "type": "string",
            "description": "Username"
          },
          "payload": {
            "type": "string",
            "description": "The Message Payload"
          },
          "peerhost": {
            "type": "string",
            "description": "The IP Address of the Peer Client"
          },
          "topic": {
            "type": "string",
            "description": "Message Topic"
          },
          "publish_received_at": {
            "type": "integer",
            "description": "The Time that this Message is Received"
          },
          "qos": {
            "maximum": 2,
            "type": "integer",
            "description": "The Message QoS",
            "minimum": 0,
            "example": 0
          }
        },
        "type": "object"
      },
      "cluster_link.link_metrics_response": {
        "properties": {
          "node_metrics": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster_link.node_metrics"
            }
          },
          "metrics": {
            "type": "object",
            "example": {}
          }
        },
        "type": "object"
      },
      "bridge_redis.get_cluster": {
        "required": [
          "command_template",
          "name",
          "servers",
          "type"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to Redis. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: If this action is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "command_template": {
            "type": "array",
            "description": "Redis command template used to export messages. Each list element stands for a command name or its argument.<br/>For example, to push payloads in a Redis list by key `msgs`, the elements should be the following:<br/>`rpush`, `msgs`, `${payload}`.",
            "items": {
              "type": "string"
            }
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_redis.creation_opts_redis_cluster"
          },
          "servers": {
            "type": "string",
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The Redis default port 6379 is used if `[:Port]` is not specified."
          },
          "redis_type": {
            "default": "cluster",
            "type": "string",
            "enum": [
              "cluster"
            ],
            "description": "Cluster mode. Must be set to 'cluster' when Redis server is running in clustered mode."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "type": {
            "type": "string",
            "enum": [
              "redis_cluster"
            ],
            "description": "The Action Type"
          },
          "name": {
            "type": "string",
            "description": "Action name, used as a human-readable identifier."
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          }
        },
        "type": "object"
      },
      "bridge_kinesis.post_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "kinesis"
            ]
          },
          "name": {
            "type": "string"
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Action specific configuration.",
            "$ref": "#/components/schemas/bridge_kinesis.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_kinesis.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_kafka.producer_kafka_ext_headers": {
        "required": [
          "kafka_ext_header_key",
          "kafka_ext_header_value"
        ],
        "properties": {
          "kafka_ext_header_key": {
            "type": "string",
            "description": "Key of the header. Placeholders in format of ${var} are supported."
          },
          "kafka_ext_header_value": {
            "type": "string",
            "description": "Value of the header. Placeholders in format of ${var} are supported."
          }
        },
        "type": "object"
      },
      "bridge_timescale.get": {
        "required": [
          "database",
          "name",
          "server",
          "type",
          "username"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "pgsql"
            ],
            "description": "The Bridge Type"
          },
          "name": {
            "type": "string",
            "description": "Bridge name."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "sql": {
            "default": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
            "type": "string",
            "format": "sql",
            "description": "SQL Template"
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to PostgreSQL. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The PostgreSQL default port 5432 is used if `[:Port]` is not specified."
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "rule_engine.rule_test": {
        "required": [
          "sql"
        ],
        "properties": {
          "context": {
            "default": {},
            "description": "The context of the event for testing",
            "oneOf": [
              {
                "$ref": "#/components/schemas/rule_engine.ctx_message_transformation_failed"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_schema_validation_failed"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_delivery_dropped"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_bridge_mqtt"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_check_authn_complete"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_check_authz_complete"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_connack"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_disconnected"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_connected"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_dropped"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_acked"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_delivered"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_unsub"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_sub"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_pub"
              }
            ]
          },
          "sql": {
            "type": "string",
            "description": "The SQL of the rule for testing"
          }
        },
        "type": "object"
      },
      "bridge_dynamo.put_connector": {
        "required": [
          "aws_access_key_id",
          "aws_secret_access_key",
          "region",
          "url"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this connector."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "url": {
            "type": "string",
            "description": "The url of DynamoDB endpoint."
          },
          "region": {
            "type": "string",
            "description": "Region of AWS Dynamo"
          },
          "aws_access_key_id": {
            "type": "string",
            "description": "Access Key ID for connecting to DynamoDB."
          },
          "aws_secret_access_key": {
            "type": "string",
            "format": "password",
            "description": "AWS Secret Access Key for connecting to DynamoDB.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_dynamo.connector_resource_opts"
          }
        },
        "type": "object"
      },
      "gcp_pubsub_consumer.put_source": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "parameters": {
            "description": "Source configs.",
            "$ref": "#/components/schemas/gcp_pubsub_consumer.source_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/gcp_pubsub_consumer.source_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_influxdb.put_bridge_v2": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Additional parameters specific to this action type",
            "$ref": "#/components/schemas/bridge_influxdb.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_azure_event_hub.put_bridge_v2": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in Azure Event Hubs."
          },
          "parameters": {
            "description": "Azure Event Hubs producer configs.",
            "$ref": "#/components/schemas/bridge_azure_event_hub.producer_kafka_opts"
          },
          "resource_opts": {
            "default": {},
            "$ref": "#/components/schemas/bridge_kafka.resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_datalayers.post_connector": {
        "required": [
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "datalayers"
            ],
            "description": "The type of the connector."
          },
          "name": {
            "type": "string",
            "description": "The name of the connector."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this connector."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "server": {
            "default": "127.0.0.1:8361",
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The Datalayers default port 8361 is used if `[:Port]` is not specified."
          },
          "parameters": {
            "description": "Set of parameters specific for the given type of this Datalayers connector.",
            "$ref": "#/components/schemas/connector_datalayers.datalayers_parameters"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_datalayers.connector_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_dynamo.creation_opts": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "maximum": 1024,
            "type": "integer",
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 1
          },
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "start_after_created": {
            "default": true,
            "type": "boolean",
            "description": "Whether start the resource right after created."
          },
          "start_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "example": "32s"
          },
          "auto_restart_interval": {
            "default": "15s",
            "deprecated": true,
            "oneOf": [
              {
                "type": "string",
                "example": "32s"
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "query_mode": {
            "default": "async",
            "type": "string",
            "enum": [
              "sync",
              "async"
            ],
            "description": "Query mode. Optional 'sync/async', default 'async'."
          },
          "request_ttl": {
            "default": "45s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "string",
                "example": "32s"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "type": "integer",
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1
          },
          "batch_size": {
            "default": 1,
            "type": "integer",
            "description": "Maximum batch count. If equal to 1, there's effectively no batching.",
            "minimum": 1
          },
          "batch_time": {
            "default": "0ms",
            "type": "string",
            "description": "Maximum waiting interval when accumulating a batch at a low message rates for more efficient resource usage.",
            "example": "32s"
          },
          "enable_queue": {
            "default": false,
            "type": "boolean",
            "deprecated": true,
            "description": "Enable disk buffer queue (only applicable for egress bridges).<br/>When Enabled, messages will be buffered on disk when the bridge connection is down.<br/>When disabled the messages are buffered in RAM only."
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "type": "string",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB"
          }
        },
        "type": "object"
      },
      "rule_engine.rule_apply_test": {
        "properties": {
          "context": {
            "default": {},
            "description": "The context of the event for testing",
            "oneOf": [
              {
                "$ref": "#/components/schemas/rule_engine.ctx_message_transformation_failed"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_schema_validation_failed"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_delivery_dropped"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_bridge_mqtt"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_check_authn_complete"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_check_authz_complete"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_connack"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_disconnected"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_connected"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_dropped"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_acked"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_delivered"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_unsub"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_sub"
              },
              {
                "$ref": "#/components/schemas/rule_engine.ctx_pub"
              }
            ]
          },
          "stop_action_after_template_rendering": {
            "default": true,
            "type": "boolean",
            "description": "Set this to true if the action should be stopped after its template has been rendered (default is true)."
          }
        },
        "type": "object"
      },
      "bridge_mysql.get": {
        "required": [
          "database",
          "name",
          "server",
          "type"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "mysql"
            ],
            "description": "The action type"
          },
          "name": {
            "type": "string",
            "description": "Action name, used as a human-readable identifier of the action."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this action"
          },
          "sql": {
            "default": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, FROM_UNIXTIME(${timestamp}/1000))",
            "type": "string",
            "format": "sql",
            "description": "SQL Template"
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to MySQL. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: If this action is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The MySQL default port 3306 is used if `[:Port]` is not specified."
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "default": "root",
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "action_azure_blob_storage.aggreg_parameters": {
        "required": [
          "aggregation",
          "blob",
          "container",
          "mode"
        ],
        "properties": {
          "mode": {
            "type": "string",
            "enum": [
              "aggregated"
            ],
            "description": "Enables time-based aggregation of incoming events and uploading them to the Azure Blob Storage service as a single object."
          },
          "aggregation": {
            "description": "Set of parameters governing the aggregation process.",
            "$ref": "#/components/schemas/action_azure_blob_storage.aggregation"
          },
          "container": {
            "type": "string",
            "description": "The Azure Blob Storage container name. Does not support templates."
          },
          "blob": {
            "type": "string",
            "description": "Template for the Azure Blob Storage blob name of an aggregated upload.<br/><br/>  Template may contain placeholders for the following variables:<br/>  <ul><br/>  <li><code>${action}</code>: name of the action (required).</li><br/>  <li><code>${node}</code>: name of the EMQX node conducting the upload (required).</li><br/>  <li><code>${datetime.{format}}</code>: date and time when aggregation started, formatted according to the <code>{format}</code> string (required):<br/>      <ul><br/>      <li><code>${datetime.rfc3339utc}</code>: RFC3339-formatted date and time in UTC,</li><br/>      <li><code>${datetime.rfc3339}</code>: RFC3339-formatted date and time in local timezone,</li><br/>      <li><code>${datetime.unix}</code>: Unix timestamp.</li><br/>      </ul><br/>  </li><br/>  <li><code>${datetime_until.{format}}</code>: date and time when aggregation ended, with the same formatting options.</li><br/>  <li><code>${sequence}</code>: sequence number of the aggregated upload within the same time interval (required).</li><br/>  </ul><br/>  All other placeholders are considered invalid. Note that placeholders marked as required will be added as a path suffix to the Azure Blob Storage blob name if they are missing from the template."
          }
        },
        "type": "object"
      },
      "cluster_link.node_metrics": {
        "properties": {
          "node": {
            "type": "string"
          },
          "metrics": {
            "type": "object",
            "example": {}
          }
        },
        "type": "object"
      },
      "bridge_dynamo.post_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "dynamo"
            ]
          },
          "name": {
            "type": "string"
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Action specific configuration.",
            "$ref": "#/components/schemas/bridge_dynamo.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "gcp_pubsub_producer.put_bridge_v2": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Action configs.",
            "$ref": "#/components/schemas/gcp_pubsub_producer.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_redis.post_cluster": {
        "required": [
          "command_template",
          "name",
          "servers",
          "type"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to Redis. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: If this action is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "command_template": {
            "type": "array",
            "description": "Redis command template used to export messages. Each list element stands for a command name or its argument.<br/>For example, to push payloads in a Redis list by key `msgs`, the elements should be the following:<br/>`rpush`, `msgs`, `${payload}`.",
            "items": {
              "type": "string"
            }
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_redis.creation_opts_redis_cluster"
          },
          "servers": {
            "type": "string",
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The Redis default port 6379 is used if `[:Port]` is not specified."
          },
          "redis_type": {
            "default": "cluster",
            "type": "string",
            "enum": [
              "cluster"
            ],
            "description": "Cluster mode. Must be set to 'cluster' when Redis server is running in clustered mode."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "type": {
            "type": "string",
            "enum": [
              "redis_cluster"
            ],
            "description": "The Action Type"
          },
          "name": {
            "type": "string",
            "description": "Action name, used as a human-readable identifier."
          }
        },
        "type": "object"
      },
      "message_transformation.transformation": {
        "required": [
          "failure_action",
          "name",
          "topics"
        ],
        "properties": {
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "enable": {
            "default": true,
            "type": "boolean"
          },
          "name": {
            "type": "string"
          },
          "topics": {
            "oneOf": [
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              {
                "type": "string"
              }
            ]
          },
          "failure_action": {
            "type": "string",
            "enum": [
              "drop",
              "disconnect",
              "ignore"
            ]
          },
          "log_failure": {
            "default": {},
            "$ref": "#/components/schemas/message_transformation.log_failure"
          },
          "payload_decoder": {
            "default": {
              "type": "none"
            },
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "payload_serde_protobuf"
                ]
              },
              {
                "type": "string",
                "enum": [
                  "payload_serde_avro"
                ]
              },
              {
                "type": "string",
                "enum": [
                  "payload_serde_json"
                ]
              },
              {
                "type": "string",
                "enum": [
                  "payload_serde_none"
                ]
              }
            ]
          },
          "payload_encoder": {
            "default": {
              "type": "none"
            },
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "payload_serde_protobuf"
                ]
              },
              {
                "type": "string",
                "enum": [
                  "payload_serde_avro"
                ]
              },
              {
                "type": "string",
                "enum": [
                  "payload_serde_json"
                ]
              },
              {
                "type": "string",
                "enum": [
                  "payload_serde_none"
                ]
              }
            ]
          },
          "operations": {
            "default": [],
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/message_transformation.operation"
            }
          }
        },
        "type": "object"
      },
      "bridge_pulsar.producer_resource_opts": {
        "properties": {
          "health_check_interval": {
            "default": "1s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "start_after_created": {
            "default": true,
            "type": "boolean",
            "description": "Whether start the resource right after created."
          },
          "start_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "example": "32s"
          }
        },
        "type": "object"
      },
      "confluent.post_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "confluent_producer"
            ],
            "description": "The type of the action."
          },
          "name": {
            "type": "string",
            "description": "Action name, used as a human-readable description of the action."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in Confluent."
          },
          "parameters": {
            "description": "Confluent producer configs.",
            "$ref": "#/components/schemas/confluent.producer_kafka_opts"
          },
          "resource_opts": {
            "default": {},
            "$ref": "#/components/schemas/bridge_kafka.resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_azure_event_hub.get_producer": {
        "required": [
          "bootstrap_hosts",
          "kafka",
          "name",
          "type"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "kafka",
              "kafka_producer",
              "kafka_consumer"
            ],
            "description": "The action type."
          },
          "name": {
            "type": "string",
            "description": "Bridge name, used as a human-readable description of the bridge."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this connector."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "bootstrap_hosts": {
            "type": "string",
            "description": "A comma separated list of Azure Event Hubs Kafka <code>host[:port]</code> namespace endpoints to bootstrap the client.  Default port number is 9093."
          },
          "connect_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Maximum wait time for TCP connection establishment (including authentication time if enabled).",
            "example": "32s"
          },
          "min_metadata_refresh_interval": {
            "default": "3s",
            "type": "string",
            "description": "Minimum time interval the client has to wait before refreshing Azure Event Hubs Kafka broker and topic metadata. Setting too small value may add extra load on Azure Event Hubs.",
            "example": "32s"
          },
          "metadata_request_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Maximum wait time when fetching metadata from Azure Event Hubs.",
            "example": "32s"
          },
          "authentication": {
            "default": "none",
            "description": "Authentication configs.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/bridge_kafka.auth_gssapi_kerberos"
              },
              {
                "$ref": "#/components/schemas/bridge_kafka.auth_username_password"
              },
              {
                "type": "string",
                "enum": [
                  "none"
                ]
              }
            ]
          },
          "socket_opts": {
            "description": "Extra socket options.",
            "$ref": "#/components/schemas/bridge_kafka.socket_opts"
          },
          "health_check_topic": {
            "type": "string",
            "description": "Topic name used exclusively for more accurate connector health checks."
          },
          "ssl": {
            "$ref": "#/components/schemas/bridge_kafka.ssl_client_opts"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_kafka.connector_resource_opts"
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in Azure Event Hubs."
          },
          "kafka": {
            "description": "Azure Event Hubs producer configs.",
            "$ref": "#/components/schemas/bridge_kafka.v1_producer_kafka_opts"
          }
        },
        "type": "object"
      },
      "bridge_s3.get_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "s3"
            ]
          },
          "name": {
            "type": "string"
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Action that takes incoming events and uploads them to the S3 API compatible service.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/bridge_s3.s3_direct_upload_parameters"
              },
              {
                "$ref": "#/components/schemas/bridge_s3.s3_aggregated_upload_parameters"
              }
            ]
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_s3.s3_upload_resource_opts"
          }
        },
        "type": "object"
      },
      "rocketmq.get_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "rocketmq"
            ]
          },
          "name": {
            "type": "string"
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Action specific configuration.",
            "$ref": "#/components/schemas/rocketmq.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "file_transfer.local_storage": {
        "properties": {
          "segments": {
            "default": {
              "gc": {}
            },
            "description": "Settings for local segments storage, which include uploaded transfer fragments and temporary data.",
            "$ref": "#/components/schemas/file_transfer.local_storage_segments"
          },
          "exporter": {
            "default": {
              "local": {}
            },
            "description": "Exporter for the local file system storage backend.<br/><br/>Exporter defines where and how fully transferred and assembled files are stored.",
            "$ref": "#/components/schemas/file_transfer.local_storage_exporter_backend"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Whether to enable this backend."
          }
        },
        "type": "object"
      },
      "rule_engine.rule_info": {
        "required": [
          "id",
          "sql"
        ],
        "properties": {
          "id": {
            "type": "string",
            "description": "The ID of the rule",
            "example": "293fb66f"
          },
          "from": {
            "type": "array",
            "description": "The topics of the rule",
            "items": {
              "type": "string"
            },
            "example": "t/#"
          },
          "created_at": {
            "type": "string",
            "description": "The created time of the rule",
            "example": "2021-12-01T15:00:43.153+08:00"
          },
          "name": {
            "default": "",
            "type": "string",
            "description": "The name of the rule",
            "example": "foo"
          },
          "sql": {
            "type": "string",
            "description": "SQL query to transform the messages.<br/>Example: <code>SELECT * FROM \"test/topic\" WHERE payload.x = 1</code>",
            "example": "SELECT * FROM \"test/topic\" WHERE payload.x = 1"
          },
          "actions": {
            "default": [],
            "type": "array",
            "description": "A list of actions of the rule.<br/>An action can be a string that refers to the channel ID of an EMQX bridge, or an object<br/>that refers to a function.<br/>There a some built-in functions like \"republish\" and \"console\", and we also support user<br/>provided functions in the format: \"{module}:{function}\".<br/>The actions in the list are executed sequentially.<br/>This means that if one of the action is executing slowly, all the following actions will not<br/>be executed until it returns.<br/>If one of the action crashed, all other actions come after it will still be executed, in the<br/>original order.<br/>If there's any error when running an action, there will be an error message, and the 'failure'<br/>counter of the function action or the bridge channel will increase.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/rule_engine.user_provided_function"
                },
                {
                  "$ref": "#/components/schemas/rule_engine.builtin_action_console"
                },
                {
                  "$ref": "#/components/schemas/rule_engine.builtin_action_republish"
                },
                {
                  "type": "string"
                }
              ]
            },
            "example": [
              "webhook:my_webhook",
              {
                "args": {
                  "payload": "${payload}",
                  "topic": "t/1"
                },
                "function": "republish"
              },
              {
                "function": "console"
              }
            ]
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable the rule"
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "The description of the rule",
            "example": "Some description"
          },
          "metadata": {
            "type": "object",
            "description": "Rule metadata, do not change manually",
            "example": {}
          }
        },
        "type": "object"
      },
      "rule_engine.ctx_acked": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "type": "string",
            "enum": [
              "message_acked"
            ],
            "description": "Event Type"
          },
          "id": {
            "type": "string",
            "description": "Message ID"
          },
          "from_clientid": {
            "type": "string",
            "description": "The Client ID"
          },
          "from_username": {
            "type": "string",
            "description": "The User Name"
          },
          "clientid": {
            "type": "string",
            "description": "The Client ID"
          },
          "username": {
            "type": "string",
            "description": "Username"
          },
          "payload": {
            "type": "string",
            "description": "The Message Payload"
          },
          "peerhost": {
            "type": "string",
            "description": "The IP Address of the Peer Client"
          },
          "topic": {
            "type": "string",
            "description": "Message Topic"
          },
          "publish_received_at": {
            "type": "integer",
            "description": "The Time that this Message is Received"
          },
          "qos": {
            "maximum": 2,
            "type": "integer",
            "description": "The Message QoS",
            "minimum": 0,
            "example": 0
          }
        },
        "type": "object"
      },
      "rocketmq.post_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "rocketmq"
            ]
          },
          "name": {
            "type": "string"
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Action specific configuration.",
            "$ref": "#/components/schemas/rocketmq.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_timescale.post_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "timescale"
            ],
            "description": "The Bridge Type"
          },
          "name": {
            "type": "string",
            "description": "Bridge name."
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Configuration Parameters Specific to the PostgreSQL Action",
            "$ref": "#/components/schemas/bridge_pgsql.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "kafka_consumer.source_parameters": {
        "required": [
          "topic"
        ],
        "properties": {
          "topic": {
            "type": "string",
            "description": "Kafka topic to consume from."
          },
          "group_id": {
            "type": "string",
            "description": "Consumer group identifier to be used for this source.  If omitted, one based off the source name will be automatically generated."
          },
          "max_batch_bytes": {
            "default": "896KB",
            "type": "string",
            "description": "Set how many bytes to pull from Kafka in each fetch request. Please note that if the configured value is smaller than the message size in Kafka, it may negatively impact the fetch performance.",
            "example": "32MB"
          },
          "offset_reset_policy": {
            "default": "latest",
            "type": "string",
            "enum": [
              "latest",
              "earliest"
            ],
            "description": "Defines from which offset a consumer should start fetching when there is no commit history or when the commit history becomes invalid."
          },
          "offset_commit_interval_seconds": {
            "default": "5s",
            "type": "string",
            "description": "Defines the time interval between two offset commit requests sent for each consumer group.",
            "example": "1h"
          },
          "key_encoding_mode": {
            "default": "none",
            "type": "string",
            "enum": [
              "none",
              "base64"
            ],
            "description": "Defines how the key from the Kafka message is encoded before being forwarded via MQTT.<br/><code>none</code> Uses the key from the Kafka message unchanged.  Note: in this case, the key must be a valid UTF-8 string.<br/><code>base64</code> Uses base-64 encoding on the received key."
          },
          "value_encoding_mode": {
            "default": "none",
            "type": "string",
            "enum": [
              "none",
              "base64"
            ],
            "description": "Defines how the value from the Kafka message is encoded before being forwarded via MQTT.<br/><code>none</code> Uses the value from the Kafka message unchanged.  Note: in this case, the value must be a valid UTF-8 string.<br/><code>base64</code> Uses base-64 encoding on the received value."
          }
        },
        "type": "object"
      },
      "bridge_kinesis.put_bridge_v2": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Action specific configuration.",
            "$ref": "#/components/schemas/bridge_kinesis.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_kinesis.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_s3.s3_aggregated_upload_parameters": {
        "required": [
          "aggregation",
          "bucket",
          "container",
          "key",
          "mode"
        ],
        "properties": {
          "mode": {
            "type": "string",
            "enum": [
              "aggregated"
            ],
            "description": "Enables time-based aggregation of incoming events and uploading them to the S3 service as a single object."
          },
          "container": {
            "default": {
              "type": "csv"
            },
            "description": "Settings governing the file format of an upload containing aggregated events.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/bridge_s3.s3_aggregated_container_csv"
              }
            ]
          },
          "aggregation": {
            "description": "Set of parameters governing the aggregation process.",
            "$ref": "#/components/schemas/bridge_s3.s3_aggregation"
          },
          "bucket": {
            "type": "string",
            "description": "The name of the S3 bucket."
          },
          "key": {
            "type": "string",
            "description": "Template for the S3 object key of an aggregated upload.<br/><br/>Template may contain placeholders for the following variables:<br/><ul><br/><li><code>${action}</code>: name of the action (required).</li><br/><li><code>${node}</code>: name of the EMQX node conducting the upload (required).</li><br/><li><code>${datetime.{format}}</code>: date and time when aggregation started, formatted according to the <code>{format}</code> string (required):<br/>    <ul><br/>    <li><code>${datetime.rfc3339utc}</code>: RFC3339-formatted date and time in UTC,</li><br/>    <li><code>${datetime.rfc3339}</code>: RFC3339-formatted date and time in local timezone,</li><br/>    <li><code>${datetime.unix}</code>: Unix timestamp.</li><br/>    </ul><br/></li><br/><li><code>${datetime_until.{format}}</code>: date and time when aggregation ended, with the same formatting options.</li><br/><li><code>${sequence}</code>: sequence number of the aggregated upload within the same time interval (required).</li><br/></ul><br/>All other placeholders are considered invalid. Note that placeholders marked as required will be added as a path suffix to the S3 object key if they are missing from the template."
          },
          "acl": {
            "type": "string",
            "enum": [
              "private",
              "public_read",
              "public_read_write",
              "authenticated_read",
              "bucket_owner_read",
              "bucket_owner_full_control"
            ],
            "description": "The ACL to use for the uploaded objects."
          },
          "headers": {
            "type": "object",
            "description": "HTTP headers to include in the S3 object upload request.<br/><br/>Useful to specify content type, content encoding, etc. of the S3 object.",
            "example": {}
          },
          "min_part_size": {
            "default": "5mb",
            "type": "string",
            "description": "The minimum part size for multipart uploads.<br/><br/>Uploaded data will be accumulated in memory until this size is reached.",
            "example": "32MB"
          },
          "max_part_size": {
            "default": "5gb",
            "type": "string",
            "description": "The maximum part size for multipart uploads.<br/><br/>S3 uploader won't try to upload parts larger than this size.",
            "example": "32MB"
          }
        },
        "type": "object"
      },
      "action_azure_blob_storage.get_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "azure_blob_storage"
            ]
          },
          "name": {
            "type": "string"
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Set of parameters for the action.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/action_azure_blob_storage.direct_parameters"
              },
              {
                "$ref": "#/components/schemas/action_azure_blob_storage.aggreg_parameters"
              }
            ]
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/action_azure_blob_storage.action_resource_opts"
          }
        },
        "type": "object"
      },
      "action_azure_blob_storage.put_bridge_v2": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Set of parameters for the action.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/action_azure_blob_storage.direct_parameters"
              },
              {
                "$ref": "#/components/schemas/action_azure_blob_storage.aggreg_parameters"
              }
            ]
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/action_azure_blob_storage.action_resource_opts"
          }
        },
        "type": "object"
      },
      "redis.post_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "redis"
            ],
            "description": "The Action Type"
          },
          "name": {
            "type": "string",
            "description": "Action name, used as a human-readable identifier."
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "The parameters of the action.",
            "$ref": "#/components/schemas/bridge_redis.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/redis.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_elasticsearch.post_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "elasticsearch"
            ]
          },
          "name": {
            "type": "string"
          },
          "parameters": {
            "description": "ElasticSearch action parameters",
            "oneOf": [
              {
                "$ref": "#/components/schemas/bridge_elasticsearch.action_update"
              },
              {
                "$ref": "#/components/schemas/bridge_elasticsearch.action_delete"
              },
              {
                "$ref": "#/components/schemas/bridge_elasticsearch.action_create"
              }
            ]
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_elasticsearch.action_resource_opts"
          }
        },
        "type": "object"
      },
      "rule_engine.builtin_action_console": {
        "properties": {
          "function": {
            "type": "string",
            "enum": [
              "console"
            ],
            "description": "Print the actions to the console"
          }
        },
        "type": "object"
      },
      "bridge_mqtt.put": {
        "required": [
          "server"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_mqtt.creation_opts"
          },
          "mode": {
            "default": "cluster_shareload",
            "type": "string",
            "enum": [
              "cluster_shareload"
            ],
            "deprecated": true,
            "description": "The mode of the MQTT Bridge.<br/><br/>- cluster_shareload: create an MQTT connection on each node in the emqx cluster.<br/><br/>In 'cluster_shareload' mode, the incoming load from the remote broker is shared by<br/>using shared subscription.<br/><br/>Note that the 'clientid' is suffixed by the node name, this is to avoid<br/>clientid conflicts between different nodes. And we can only use shared subscription<br/>topic filters for <code>remote.topic</code> of ingress connections."
          },
          "server": {
            "type": "string",
            "description": "The host and port of the remote MQTT broker"
          },
          "clientid_prefix": {
            "type": "string",
            "description": "Optional prefix to prepend to the clientid used by egress bridges."
          },
          "reconnect_interval": {
            "type": "string",
            "deprecated": true
          },
          "proto_ver": {
            "default": "v4",
            "type": "string",
            "enum": [
              "v3",
              "v4",
              "v5"
            ],
            "description": "The MQTT protocol version"
          },
          "bridge_mode": {
            "default": false,
            "type": "boolean",
            "description": "If enable bridge mode.<br/>NOTE: This setting is only for MQTT protocol version older than 5.0, and the remote MQTT<br/>broker MUST support this feature.<br/>If bridge_mode is set to true, the bridge will indicate to the remote broker that it is a bridge not an ordinary client.<br/>This means that loop detection will be more effective and that retained messages will be propagated correctly."
          },
          "username": {
            "type": "string",
            "description": "The username of the MQTT protocol"
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password of the MQTT protocol",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "clean_start": {
            "default": true,
            "type": "boolean",
            "description": "Whether to start a clean session when reconnecting a remote broker for ingress bridge"
          },
          "keepalive": {
            "default": "300s",
            "type": "string",
            "description": "MQTT Keepalive. Time interval is a string that contains a number followed by time unit:<br/>- `ms` for milliseconds,<br/>- `s` for seconds,<br/>- `m` for minutes,<br/>- `h` for hours;<br/><br/>or combination of whereof: `1h5m0s`"
          },
          "retry_interval": {
            "default": "15s",
            "type": "string",
            "description": "Message retry interval. Delay for the MQTT bridge to retry sending the QoS1/QoS2 messages in case of ACK not received. Time interval is a string that contains a number followed by time unit:<br/>- `ms` for milliseconds,<br/>- `s` for seconds,<br/>- `m` for minutes,<br/>- `h` for hours;<br/><br/>or combination of whereof: `1h5m0s`"
          },
          "max_inflight": {
            "default": 32,
            "type": "integer",
            "description": "Max inflight (sent, but un-acked) messages of the MQTT protocol",
            "minimum": 0
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "ingress": {
            "description": "The ingress config defines how this bridge receive messages from the remote MQTT broker, and then<br/>        send them to the local broker.<br/><br/>        Template with variables is allowed in 'remote.qos', 'local.topic', 'local.qos', 'local.retain', 'local.payload'.<br/><br/>        NOTE: if this bridge is used as the input of a rule, and also 'local.topic' is<br/>        configured, then messages got from the remote broker will be sent to both the 'local.topic' and<br/>        the rule.",
            "$ref": "#/components/schemas/connector_mqtt.ingress"
          },
          "egress": {
            "description": "The egress config defines how this bridge forwards messages from the local broker to the remote broker.<br/><br/>Template with variables is allowed in 'remote.topic', 'local.qos', 'local.retain', 'local.payload'.<br/><br/>NOTE: if this bridge is used as the action of a rule, and also 'local.topic'<br/>is configured, then both the data got from the rule and the MQTT messages that matches<br/>'local.topic' will be forwarded.",
            "$ref": "#/components/schemas/connector_mqtt.egress"
          }
        },
        "type": "object"
      },
      "bridge_rabbitmq.action_resource_opts": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "maximum": 1024,
            "type": "integer",
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 1
          },
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "query_mode": {
            "default": "async",
            "type": "string",
            "enum": [
              "sync",
              "async"
            ],
            "description": "Query mode. Optional 'sync/async', default 'async'."
          },
          "request_ttl": {
            "default": "45s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "string",
                "example": "32s"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "type": "integer",
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1
          },
          "batch_size": {
            "default": 1,
            "type": "integer",
            "description": "Maximum batch count. If equal to 1, there's effectively no batching.",
            "minimum": 1
          },
          "batch_time": {
            "default": "0ms",
            "type": "string",
            "description": "Maximum waiting interval when accumulating a batch at a low message rates for more efficient resource usage.",
            "example": "32s"
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "type": "string",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB"
          }
        },
        "type": "object"
      },
      "schema_validation.log_failure": {
        "properties": {
          "level": {
            "default": "info",
            "type": "string",
            "enum": [
              "error",
              "warning",
              "notice",
              "info",
              "debug",
              "none"
            ],
            "description": "Log level at which failures will be logged."
          }
        },
        "type": "object"
      },
      "rocketmq.put_bridge_v2": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Action specific configuration.",
            "$ref": "#/components/schemas/rocketmq.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_tdengine.action_parameters": {
        "required": [
          "database"
        ],
        "properties": {
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "sql": {
            "default": "insert into t_mqtt_msg(ts, msgid, mqtt_topic, qos, payload, arrived) values (${ts}, '${id}', '${topic}', ${qos}, '${payload}', ${timestamp})",
            "type": "string",
            "format": "sql",
            "description": "SQL Template"
          }
        },
        "type": "object"
      },
      "bridge_hstreamdb.get": {
        "required": [
          "name",
          "stream",
          "type",
          "url"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "direction": {
            "default": "egress",
            "type": "string",
            "enum": [
              "egress"
            ],
            "description": "The direction of this bridge, MUST be 'egress'"
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to the HStreamDB. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: If this action is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "record_template": {
            "default": "${payload}",
            "type": "string",
            "description": "The HStream Record template to be forwarded to the HStreamDB. Placeholders supported.<br><br/>NOTE: When you use `raw record` template (which means the data is not a valid JSON), you should use `read` or `subscription` in HStream to get the data."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "url": {
            "default": "http://127.0.0.1:6570",
            "type": "string",
            "description": "HStreamDB Server URL. This URL will be used as the gRPC HTTP server address."
          },
          "stream": {
            "type": "string",
            "description": "HStreamDB Stream Name."
          },
          "partition_key": {
            "type": "string",
            "description": "HStreamDB Partition Key. Placeholders supported."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "grpc_timeout": {
            "default": "30s",
            "type": "string",
            "description": "The timeout for HStreamDB gRPC requests.",
            "example": "32s"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "type": {
            "type": "string",
            "enum": [
              "hstreamdb"
            ],
            "description": "The type of the action."
          },
          "name": {
            "type": "string",
            "description": "Action name, a human-readable identifier."
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          }
        },
        "type": "object"
      },
      "pulsar.put_bridge_v2": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Action specific configs.",
            "$ref": "#/components/schemas/pulsar.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/pulsar.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_redis.creation_opts_redis_sentinel": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "maximum": 1024,
            "type": "integer",
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 1
          },
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "start_after_created": {
            "default": true,
            "type": "boolean",
            "description": "Whether start the resource right after created."
          },
          "start_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "example": "32s"
          },
          "auto_restart_interval": {
            "default": "15s",
            "deprecated": true,
            "oneOf": [
              {
                "type": "string",
                "example": "32s"
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "query_mode": {
            "default": "async",
            "type": "string",
            "enum": [
              "sync",
              "async"
            ],
            "description": "Query mode. Optional 'sync/async', default 'async'."
          },
          "request_ttl": {
            "default": "45s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "string",
                "example": "32s"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "type": "integer",
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1
          },
          "batch_size": {
            "default": 1,
            "type": "integer",
            "description": "Maximum batch count. If equal to 1, there's effectively no batching.",
            "minimum": 1
          },
          "batch_time": {
            "default": "0ms",
            "type": "string",
            "description": "Maximum waiting interval when accumulating a batch at a low message rates for more efficient resource usage.",
            "example": "32s"
          },
          "enable_queue": {
            "default": false,
            "type": "boolean",
            "deprecated": true,
            "description": "Enable disk buffer queue (only applicable for egress bridges).<br/>When Enabled, messages will be buffered on disk when the bridge connection is down.<br/>When disabled the messages are buffered in RAM only."
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "type": "string",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB"
          }
        },
        "type": "object"
      },
      "syskeeper.parameters": {
        "properties": {
          "target_topic": {
            "default": "${topic}",
            "type": "string",
            "description": "The topic for the forwarded message"
          },
          "target_qos": {
            "maximum": 2,
            "type": "integer",
            "description": "The QoS for the forwarded message. To preserve the original QoS of the forwarded message, the value can be omitted.",
            "minimum": 0
          },
          "template": {
            "default": "${payload}",
            "type": "string",
            "description": "Template"
          }
        },
        "type": "object"
      },
      "file_transfer.s3_exporter": {
        "required": [
          "bucket",
          "host",
          "port"
        ],
        "properties": {
          "access_key_id": {
            "type": "string",
            "description": "The access key ID of the S3 bucket."
          },
          "secret_access_key": {
            "type": "string",
            "format": "password",
            "description": "The secret access key of the S3 bucket.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "host": {
            "type": "string",
            "description": "The host of the S3 endpoint."
          },
          "port": {
            "type": "integer",
            "description": "The port of the S3 endpoint.",
            "minimum": 1
          },
          "transport_options": {
            "description": "Options for the HTTP transport layer used by the S3 client.",
            "$ref": "#/components/schemas/s3.transport_options"
          },
          "min_part_size": {
            "default": "5mb",
            "type": "string",
            "description": "The minimum part size for multipart uploads.<br/><br/>Uploaded data will be accumulated in memory until this size is reached.",
            "example": "32MB"
          },
          "max_part_size": {
            "default": "5gb",
            "type": "string",
            "description": "The maximum part size for multipart uploads.<br/><br/>S3 uploader won't try to upload parts larger than this size.",
            "example": "32MB"
          },
          "url_expire_time": {
            "default": "1h",
            "type": "string",
            "description": "The time in seconds for which the signed URLs to the S3 objects are valid.",
            "example": "1h"
          },
          "bucket": {
            "type": "string",
            "description": "The name of the S3 bucket."
          },
          "acl": {
            "type": "string",
            "enum": [
              "private",
              "public_read",
              "public_read_write",
              "authenticated_read",
              "bucket_owner_read",
              "bucket_owner_full_control"
            ],
            "description": "The ACL to use for the uploaded objects."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Whether to enable this backend."
          }
        },
        "type": "object"
      },
      "bridge_sqlserver.post": {
        "required": [
          "database",
          "name",
          "server",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "sqlserver"
            ],
            "description": "The Bridge Type"
          },
          "name": {
            "type": "string",
            "description": "Bridge name."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "sql": {
            "default": "insert into t_mqtt_msg(msgid, topic, qos, payload) values ( ${id}, ${topic}, ${qos}, ${payload} )",
            "type": "string",
            "format": "sql",
            "description": "SQL Template"
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to Microsoft SQL Server. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_sqlserver.creation_opts"
          },
          "driver": {
            "default": "ms-sql",
            "type": "string",
            "description": "SQL Server Driver Name"
          },
          "server": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The SQL Server default port 1433 is used if `[:Port]` is not specified."
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "default": "sa",
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          }
        },
        "type": "object"
      },
      "bridge_elasticsearch.action_resource_opts": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "maximum": 1024,
            "type": "integer",
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 1
          },
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "query_mode": {
            "default": "async",
            "type": "string",
            "enum": [
              "sync",
              "async"
            ],
            "description": "Query mode. Optional 'sync/async', default 'async'."
          },
          "request_ttl": {
            "default": "45s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "string",
                "example": "32s"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "type": "integer",
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "type": "string",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB"
          }
        },
        "type": "object"
      },
      "bridge_pgsql.get": {
        "required": [
          "database",
          "name",
          "server",
          "type",
          "username"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "pgsql"
            ],
            "description": "The Bridge Type"
          },
          "name": {
            "type": "string",
            "description": "Bridge name."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "sql": {
            "default": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
            "type": "string",
            "format": "sql",
            "description": "SQL Template"
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to PostgreSQL. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The PostgreSQL default port 5432 is used if `[:Port]` is not specified."
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "bridge_rabbitmq.get_source": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "rabbitmq"
            ]
          },
          "name": {
            "type": "string"
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "parameters": {
            "description": "The source config defines how this bridge receive messages from the remote RabbitMQ broker",
            "$ref": "#/components/schemas/bridge_rabbitmq.source_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.source_resource_opts"
          }
        },
        "type": "object"
      },
      "redis.action_resource_opts": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "maximum": 1024,
            "type": "integer",
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 1
          },
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "query_mode": {
            "default": "async",
            "type": "string",
            "enum": [
              "sync",
              "async"
            ],
            "description": "Query mode. Optional 'sync/async', default 'async'."
          },
          "request_ttl": {
            "default": "45s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "string",
                "example": "32s"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "type": "integer",
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1
          },
          "batch_size": {
            "default": 1,
            "type": "integer",
            "description": "This parameter defines the upper limit of the batch count.<br/>Setting this value to 1 effectively disables batching, as it indicates that only one item will be processed per batch.<br/>Note on Redis Cluster Mode:<br/>In the context of Redis Cluster Mode, it is important to note that batching is not supported.<br/>Consequently, the batch_size is always set to 1,<br/>reflecting the mode inherent limitation in handling batch operations.",
            "minimum": 1
          },
          "batch_time": {
            "default": "0ms",
            "type": "string",
            "description": "Maximum waiting interval when accumulating a batch at a low message rates for more efficient resource usage.",
            "example": "32s"
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "type": "string",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB"
          }
        },
        "type": "object"
      },
      "bridge_redis.action_parameters": {
        "required": [
          "command_template"
        ],
        "properties": {
          "command_template": {
            "type": "array",
            "description": "Redis command template used to export messages. Each list element stands for a command name or its argument.<br/>For example, to push payloads in a Redis list by key `msgs`, the elements should be the following:<br/>`rpush`, `msgs`, `${payload}`.",
            "items": {
              "type": "string"
            }
          }
        },
        "type": "object"
      },
      "bridge_iotdb.action_parameters": {
        "properties": {
          "is_aligned": {
            "default": false,
            "type": "boolean",
            "description": "Whether to align the timeseries"
          },
          "device_id": {
            "type": "string",
            "description": "The IoTDB device ID this data should be inserted for.<br/>If left empty, the MQTT message payload must contain a `device_id` field,<br/>or EMQX's rule-engine SQL must produce a `device_id` field."
          },
          "data": {
            "default": [],
            "type": "array",
            "description": "IoTDB action parameter data",
            "items": {
              "$ref": "#/components/schemas/bridge_iotdb.action_parameters_data"
            }
          },
          "max_retries": {
            "default": 2,
            "type": "integer",
            "description": "HTTP request max retry times if failed.",
            "minimum": 0
          }
        },
        "type": "object"
      },
      "cluster.creation_opts": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "maximum": 1024,
            "type": "integer",
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 1
          },
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "start_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "example": "32s"
          },
          "auto_restart_interval": {
            "default": "15s",
            "deprecated": true,
            "oneOf": [
              {
                "type": "string",
                "example": "32s"
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "request_ttl": {
            "default": "45s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "string",
                "example": "32s"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "type": "integer",
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1
          },
          "enable_queue": {
            "default": false,
            "type": "boolean",
            "deprecated": true,
            "description": "Enable disk buffer queue (only applicable for egress bridges).<br/>When Enabled, messages will be buffered on disk when the bridge connection is down.<br/>When disabled the messages are buffered in RAM only."
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "type": "string",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB"
          }
        },
        "type": "object"
      },
      "bridge_dynamo.get_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "dynamo"
            ]
          },
          "name": {
            "type": "string"
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Action specific configuration.",
            "$ref": "#/components/schemas/bridge_dynamo.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_kinesis.get_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "kinesis"
            ]
          },
          "name": {
            "type": "string"
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Action specific configuration.",
            "$ref": "#/components/schemas/bridge_kinesis.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_kinesis.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_matrix.get": {
        "required": [
          "database",
          "name",
          "server",
          "type",
          "username"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "pgsql"
            ],
            "description": "The Bridge Type"
          },
          "name": {
            "type": "string",
            "description": "Bridge name."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "sql": {
            "default": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
            "type": "string",
            "format": "sql",
            "description": "SQL Template"
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to PostgreSQL. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The PostgreSQL default port 5432 is used if `[:Port]` is not specified."
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "rule_engine.republish_mqtt_properties": {
        "properties": {
          "Payload-Format-Indicator": {
            "type": "string"
          },
          "Message-Expiry-Interval": {
            "type": "string"
          },
          "Content-Type": {
            "type": "string"
          },
          "Response-Topic": {
            "type": "string"
          },
          "Correlation-Data": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge_oracle.post_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "oracle"
            ]
          },
          "name": {
            "type": "string"
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Action specific configuration.",
            "$ref": "#/components/schemas/bridge_oracle.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_iotdb.creation_opts": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "maximum": 1024,
            "type": "integer",
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 1
          },
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "start_after_created": {
            "default": true,
            "type": "boolean",
            "description": "Whether start the resource right after created."
          },
          "start_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "example": "32s"
          },
          "auto_restart_interval": {
            "default": "15s",
            "deprecated": true,
            "oneOf": [
              {
                "type": "string",
                "example": "32s"
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "query_mode": {
            "default": "async",
            "type": "string",
            "enum": [
              "sync",
              "async"
            ],
            "description": "Query mode. Optional 'sync/async', default 'async'."
          },
          "request_ttl": {
            "default": "45s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "string",
                "example": "32s"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "type": "integer",
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1
          },
          "batch_size": {
            "default": 1,
            "type": "integer",
            "description": "Maximum batch count. If equal to 1, there's effectively no batching.",
            "minimum": 1
          },
          "batch_time": {
            "default": "0ms",
            "type": "string",
            "description": "Maximum waiting interval when accumulating a batch at a low message rates for more efficient resource usage.",
            "example": "32s"
          },
          "enable_queue": {
            "default": false,
            "type": "boolean",
            "deprecated": true,
            "description": "Enable disk buffer queue (only applicable for egress bridges).<br/>When Enabled, messages will be buffered on disk when the bridge connection is down.<br/>When disabled the messages are buffered in RAM only."
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "type": "string",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB"
          }
        },
        "type": "object"
      },
      "bridge_iotdb.get": {
        "required": [
          "base_url",
          "name",
          "type"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "iotdb"
            ]
          },
          "name": {
            "type": "string"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "authentication": {
            "default": "auth_basic",
            "description": "Authentication configuration",
            "oneOf": [
              {
                "$ref": "#/components/schemas/bridge_iotdb.auth_basic"
              }
            ]
          },
          "is_aligned": {
            "default": false,
            "type": "boolean",
            "description": "Whether to align the timeseries"
          },
          "device_id": {
            "type": "string",
            "description": "The IoTDB device ID this data should be inserted for.<br/>If left empty, the MQTT message payload must contain a `device_id` field,<br/>or EMQX's rule-engine SQL must produce a `device_id` field."
          },
          "iotdb_version": {
            "default": "v1.3.x",
            "type": "string",
            "enum": [
              "v1.3.x",
              "v1.1.x",
              "v1.0.x",
              "v0.13.x"
            ],
            "description": "The version of the IoTDB system to connect to."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_iotdb.creation_opts"
          },
          "connect_timeout": {
            "default": "15s",
            "type": "string",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s"
          },
          "retry_interval": {
            "type": "string",
            "deprecated": true,
            "example": "12m"
          },
          "pool_type": {
            "default": "random",
            "type": "string",
            "enum": [
              "random",
              "hash"
            ],
            "description": "The type of the pool. Can be one of `random`, `hash`."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "The pool size.",
            "minimum": 1
          },
          "enable_pipelining": {
            "default": 100,
            "type": "integer",
            "description": "The maximum number of HTTP requests that can be sent before an HTTP response is received.<br/><br/>Setting this to 1 is equivalent to turning off HTTP pipelining, and the EMQX must receive a response to the previous HTTP request before sending the next HTTP request.",
            "minimum": 1
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "base_url": {
            "type": "string",
            "description": "The base URL of the external IoTDB service's REST interface.",
            "example": "http://127.0.0.1"
          },
          "max_retries": {
            "default": 2,
            "type": "integer",
            "description": "HTTP request max retry times if failed.",
            "minimum": 0
          }
        },
        "type": "object"
      },
      "rule_engine.ctx_disconnected": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "type": "string",
            "enum": [
              "client_disconnected"
            ],
            "description": "Event Type"
          },
          "clientid": {
            "type": "string",
            "description": "The Client ID"
          },
          "username": {
            "type": "string",
            "description": "Username"
          },
          "reason": {
            "type": "string",
            "description": "The Reason for Disconnect"
          },
          "peername": {
            "type": "string",
            "description": "The IP Address and Port of the Peer Client"
          },
          "sockname": {
            "type": "string",
            "description": "The IP Address and Port of the Local Listener"
          },
          "disconnected_at": {
            "type": "integer",
            "description": "The Time that this Client is Disconnected"
          }
        },
        "type": "object"
      },
      "bridge_opents.get": {
        "required": [
          "name",
          "server",
          "type"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "opents"
            ],
            "description": "The Bridge Type"
          },
          "name": {
            "type": "string",
            "description": "Bridge name."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "type": "string",
            "description": "The URL of OpenTSDB endpoint."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "summary": {
            "default": true,
            "type": "boolean",
            "description": "Whether to return summary information."
          },
          "details": {
            "default": false,
            "type": "boolean",
            "description": "Whether to return detailed information."
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          }
        },
        "type": "object"
      },
      "gcp_pubsub_producer.get_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "gcp_pubsub_producer"
            ]
          },
          "name": {
            "type": "string"
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Action configs.",
            "$ref": "#/components/schemas/gcp_pubsub_producer.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_clickhouse.connector_resource_opts": {
        "properties": {
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "start_after_created": {
            "default": true,
            "type": "boolean",
            "description": "Whether start the resource right after created."
          },
          "start_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "example": "32s"
          }
        },
        "type": "object"
      },
      "rule_engine.rule_creation": {
        "required": [
          "sql"
        ],
        "properties": {
          "name": {
            "default": "",
            "type": "string",
            "description": "The name of the rule",
            "example": "foo"
          },
          "sql": {
            "type": "string",
            "description": "SQL query to transform the messages.<br/>Example: <code>SELECT * FROM \"test/topic\" WHERE payload.x = 1</code>",
            "example": "SELECT * FROM \"test/topic\" WHERE payload.x = 1"
          },
          "actions": {
            "default": [],
            "type": "array",
            "description": "A list of actions of the rule.<br/>An action can be a string that refers to the channel ID of an EMQX bridge, or an object<br/>that refers to a function.<br/>There a some built-in functions like \"republish\" and \"console\", and we also support user<br/>provided functions in the format: \"{module}:{function}\".<br/>The actions in the list are executed sequentially.<br/>This means that if one of the action is executing slowly, all the following actions will not<br/>be executed until it returns.<br/>If one of the action crashed, all other actions come after it will still be executed, in the<br/>original order.<br/>If there's any error when running an action, there will be an error message, and the 'failure'<br/>counter of the function action or the bridge channel will increase.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/rule_engine.user_provided_function"
                },
                {
                  "$ref": "#/components/schemas/rule_engine.builtin_action_console"
                },
                {
                  "$ref": "#/components/schemas/rule_engine.builtin_action_republish"
                },
                {
                  "type": "string"
                }
              ]
            },
            "example": [
              "webhook:my_webhook",
              {
                "args": {
                  "payload": "${payload}",
                  "topic": "t/1"
                },
                "function": "republish"
              },
              {
                "function": "console"
              }
            ]
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable the rule"
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "The description of the rule",
            "example": "Some description"
          },
          "metadata": {
            "type": "object",
            "description": "Rule metadata, do not change manually",
            "example": {}
          }
        },
        "type": "object"
      },
      "schema_validation_http_api.node_metrics": {
        "properties": {
          "node": {
            "type": "string"
          },
          "matched": {
            "type": "integer",
            "minimum": 0
          },
          "succeeded": {
            "type": "integer",
            "minimum": 0
          },
          "failed": {
            "type": "integer",
            "minimum": 0
          }
        },
        "type": "object"
      },
      "s3.transport_options": {
        "properties": {
          "ipv6_probe": {
            "default": false,
            "type": "boolean",
            "description": "Whether to probe for IPv6 support."
          },
          "connect_timeout": {
            "default": "15s",
            "type": "string",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s"
          },
          "pool_type": {
            "default": "random",
            "type": "string",
            "enum": [
              "random",
              "hash"
            ],
            "description": "The type of the pool. Can be one of `random`, `hash`."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "The pool size.",
            "minimum": 1
          },
          "enable_pipelining": {
            "default": 100,
            "type": "integer",
            "description": "The maximum number of HTTP requests that can be sent before an HTTP response is received.<br/><br/>Setting this to 1 is equivalent to turning off HTTP pipelining, and the EMQX must receive a response to the previous HTTP request before sending the next HTTP request.",
            "minimum": 1
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "headers": {
            "type": "object",
            "description": "List of HTTP headers.",
            "example": {},
            "is_template": true
          },
          "max_retries": {
            "type": "integer",
            "description": "Max retry times if error on sending request.",
            "minimum": 0
          },
          "request_timeout": {
            "type": "string",
            "description": "HTTP request timeout.",
            "example": "32s"
          }
        },
        "type": "object"
      },
      "bridge_clickhouse.get_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "clickhouse"
            ]
          },
          "name": {
            "type": "string"
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Action specific configs.",
            "$ref": "#/components/schemas/bridge_clickhouse.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_kafka.resource_opts": {
        "properties": {
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          }
        },
        "type": "object"
      },
      "bridge_mqtt.get": {
        "required": [
          "server"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_mqtt.creation_opts"
          },
          "mode": {
            "default": "cluster_shareload",
            "type": "string",
            "enum": [
              "cluster_shareload"
            ],
            "deprecated": true,
            "description": "The mode of the MQTT Bridge.<br/><br/>- cluster_shareload: create an MQTT connection on each node in the emqx cluster.<br/><br/>In 'cluster_shareload' mode, the incoming load from the remote broker is shared by<br/>using shared subscription.<br/><br/>Note that the 'clientid' is suffixed by the node name, this is to avoid<br/>clientid conflicts between different nodes. And we can only use shared subscription<br/>topic filters for <code>remote.topic</code> of ingress connections."
          },
          "server": {
            "type": "string",
            "description": "The host and port of the remote MQTT broker"
          },
          "clientid_prefix": {
            "type": "string",
            "description": "Optional prefix to prepend to the clientid used by egress bridges."
          },
          "reconnect_interval": {
            "type": "string",
            "deprecated": true
          },
          "proto_ver": {
            "default": "v4",
            "type": "string",
            "enum": [
              "v3",
              "v4",
              "v5"
            ],
            "description": "The MQTT protocol version"
          },
          "bridge_mode": {
            "default": false,
            "type": "boolean",
            "description": "If enable bridge mode.<br/>NOTE: This setting is only for MQTT protocol version older than 5.0, and the remote MQTT<br/>broker MUST support this feature.<br/>If bridge_mode is set to true, the bridge will indicate to the remote broker that it is a bridge not an ordinary client.<br/>This means that loop detection will be more effective and that retained messages will be propagated correctly."
          },
          "username": {
            "type": "string",
            "description": "The username of the MQTT protocol"
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password of the MQTT protocol",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "clean_start": {
            "default": true,
            "type": "boolean",
            "description": "Whether to start a clean session when reconnecting a remote broker for ingress bridge"
          },
          "keepalive": {
            "default": "300s",
            "type": "string",
            "description": "MQTT Keepalive. Time interval is a string that contains a number followed by time unit:<br/>- `ms` for milliseconds,<br/>- `s` for seconds,<br/>- `m` for minutes,<br/>- `h` for hours;<br/><br/>or combination of whereof: `1h5m0s`"
          },
          "retry_interval": {
            "default": "15s",
            "type": "string",
            "description": "Message retry interval. Delay for the MQTT bridge to retry sending the QoS1/QoS2 messages in case of ACK not received. Time interval is a string that contains a number followed by time unit:<br/>- `ms` for milliseconds,<br/>- `s` for seconds,<br/>- `m` for minutes,<br/>- `h` for hours;<br/><br/>or combination of whereof: `1h5m0s`"
          },
          "max_inflight": {
            "default": 32,
            "type": "integer",
            "description": "Max inflight (sent, but un-acked) messages of the MQTT protocol",
            "minimum": 0
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "ingress": {
            "description": "The ingress config defines how this bridge receive messages from the remote MQTT broker, and then<br/>        send them to the local broker.<br/><br/>        Template with variables is allowed in 'remote.qos', 'local.topic', 'local.qos', 'local.retain', 'local.payload'.<br/><br/>        NOTE: if this bridge is used as the input of a rule, and also 'local.topic' is<br/>        configured, then messages got from the remote broker will be sent to both the 'local.topic' and<br/>        the rule.",
            "$ref": "#/components/schemas/connector_mqtt.ingress"
          },
          "egress": {
            "description": "The egress config defines how this bridge forwards messages from the local broker to the remote broker.<br/><br/>Template with variables is allowed in 'remote.topic', 'local.qos', 'local.retain', 'local.payload'.<br/><br/>NOTE: if this bridge is used as the action of a rule, and also 'local.topic'<br/>is configured, then both the data got from the rule and the MQTT messages that matches<br/>'local.topic' will be forwarded.",
            "$ref": "#/components/schemas/connector_mqtt.egress"
          }
        },
        "type": "object"
      },
      "file_transfer.local_storage_exporter": {
        "properties": {
          "root": {
            "type": "string",
            "description": "Directory where the uploaded files are kept."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Whether to enable this backend."
          }
        },
        "type": "object"
      },
      "bridge_dynamo.put": {
        "required": [
          "aws_access_key_id",
          "aws_secret_access_key",
          "hash_key",
          "region",
          "table",
          "url"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "template": {
            "default": "",
            "type": "string",
            "description": "Template, the default value is empty. When this value is empty the whole message will be stored in the database.<br><br/>The template can be any valid JSON with placeholders and make sure all keys for table are here, example:<br><br/>  <code>{\"id\" : \"${id}\", \"clientid\" : \"${clientid}\", \"data\" : \"${payload.data}\"}</code>"
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to DynamoDB. All MQTT `PUBLISH` messages with the topic<br/>matching the `local_topic` will be forwarded.<br/><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also `local_topic` is<br/>configured, then both the data got from the rule and the MQTT messages that match `local_topic`<br/>will be forwarded."
          },
          "hash_key": {
            "type": "string",
            "description": "DynamoDB Hash Key"
          },
          "range_key": {
            "type": "string",
            "description": "DynamoDB Range Key"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_dynamo.creation_opts"
          },
          "url": {
            "type": "string",
            "description": "The url of DynamoDB endpoint."
          },
          "region": {
            "type": "string",
            "description": "Region of AWS Dynamo"
          },
          "table": {
            "type": "string",
            "description": "DynamoDB Table."
          },
          "aws_access_key_id": {
            "type": "string",
            "description": "Access Key ID for connecting to DynamoDB."
          },
          "aws_secret_access_key": {
            "type": "string",
            "format": "password",
            "description": "AWS Secret Access Key for connecting to DynamoDB.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          }
        },
        "type": "object"
      },
      "bridge_greptimedb.post_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "greptimedb"
            ]
          },
          "name": {
            "type": "string"
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Additional parameters specific to this action type",
            "$ref": "#/components/schemas/bridge_greptimedb.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_greptimedb.put_bridge_v2": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Additional parameters specific to this action type",
            "$ref": "#/components/schemas/bridge_greptimedb.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_sqlserver.get_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "sqlserver"
            ]
          },
          "name": {
            "type": "string"
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Action specific configuration.",
            "$ref": "#/components/schemas/bridge_sqlserver.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_redis.put_sentinel": {
        "required": [
          "command_template",
          "sentinel",
          "servers"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to Redis. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: If this action is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "command_template": {
            "type": "array",
            "description": "Redis command template used to export messages. Each list element stands for a command name or its argument.<br/>For example, to push payloads in a Redis list by key `msgs`, the elements should be the following:<br/>`rpush`, `msgs`, `${payload}`.",
            "items": {
              "type": "string"
            }
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_redis.creation_opts_redis_sentinel"
          },
          "servers": {
            "type": "string",
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The Redis default port 6379 is used if `[:Port]` is not specified."
          },
          "redis_type": {
            "default": "sentinel",
            "type": "string",
            "enum": [
              "sentinel"
            ],
            "description": "Sentinel mode. Must be set to 'sentinel' when Redis server is running in sentinel mode."
          },
          "sentinel": {
            "type": "string",
            "description": "The cluster name in Redis sentinel mode."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "database": {
            "default": 0,
            "type": "integer",
            "description": "Redis database ID.",
            "minimum": 0
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "bridge_datalayers.put_bridge_v2": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Additional parameters specific to this action type",
            "$ref": "#/components/schemas/bridge_datalayers.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "durable_queues.durable_queue_get": {
        "properties": {
          "id": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge_timescale.put_bridge_v2": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Configuration Parameters Specific to the PostgreSQL Action",
            "$ref": "#/components/schemas/bridge_pgsql.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_kafka.producer_kafka_opts": {
        "required": [
          "topic"
        ],
        "properties": {
          "topic": {
            "type": "string",
            "description": "Kafka topic name.  Supports templates (e.g.: `t-${payload.t}`)."
          },
          "message": {
            "description": "Template for rendering a message.",
            "$ref": "#/components/schemas/bridge_kafka.kafka_message"
          },
          "max_batch_bytes": {
            "default": "896KB",
            "type": "string",
            "description": "Maximum bytes to collect in a Kafka message batch. Most of the Kafka brokers default to a limit of 1 MB batch size. EMQX's default value is less than 1 MB in order to compensate Kafka message encoding overheads (especially when each individual message is very small). When a single message is over the limit, it is still sent (as a single element batch).",
            "example": "32MB"
          },
          "compression": {
            "default": "no_compression",
            "type": "string",
            "enum": [
              "no_compression",
              "snappy",
              "gzip"
            ],
            "description": "Specify the method of compression."
          },
          "partition_strategy": {
            "default": "random",
            "type": "string",
            "enum": [
              "random",
              "key_dispatch"
            ],
            "description": "Partition strategy is to tell the producer how to dispatch messages to partitions.<br/><br/><code>random</code>: Randomly pick a partition for each message.<br/><code>key_dispatch</code>: Assigns messages to partitions based on a hash of the message key,<br/>ensuring consistent partition for messages with the same key."
          },
          "required_acks": {
            "default": "all_isr",
            "type": "string",
            "enum": [
              "all_isr",
              "leader_only",
              "none"
            ],
            "description": "The acknowledgement criteria for the partition leader. It determines the level of confirmation required from partition replicas before sending an acknowledgement back to the producer.<br/><br/><code>all_isr</code>: Require all in-sync replicas to acknowledge.<br/><code>leader_only</code>: Require only the partition-leader's acknowledgement.<br/><code>none</code>: No need for Kafka to acknowledge at all."
          },
          "kafka_headers": {
            "type": "string",
            "description": "Provide a placeholder for message headers<br/><br/>e.g. <code>${pub_props}</code><br/><br/>Note that the value of the placeholder must be either an object:<br/><code>{\"foo\": \"bar\"}</code><br/>or an array of key-value pairs:<br/><code>[{\"key\": \"foo\", \"value\": \"bar\"}]</code>"
          },
          "kafka_ext_headers": {
            "type": "array",
            "description": "Provide more key-value pairs for message headers<br/><br/>The key-value pairs here will be combined with the<br/>value of <code>kafka_headers</code> field before sending producing.",
            "items": {
              "$ref": "#/components/schemas/bridge_kafka.producer_kafka_ext_headers"
            }
          },
          "kafka_header_value_encode_mode": {
            "default": "none",
            "type": "string",
            "enum": [
              "none",
              "json"
            ],
            "description": "The encoding mode for headers.<br/><br/> - `none`: Add only strings are added as header values<br/> - `json`: Encode header values as JSON string"
          },
          "partition_count_refresh_interval": {
            "default": "60s",
            "type": "string",
            "description": "The time interval for Kafka producer to discover increased number of partitions.<br/>After the number of partitions is increased in Kafka, EMQX will start taking the<br/>discovered partitions into account when dispatching messages per <code>partition_strategy</code>.",
            "example": "1h"
          },
          "partitions_limit": {
            "default": "all_partitions",
            "description": "Limit the number of partitions to produce data for the given topic.<br/>The special value `all_partitions` is to utilize all partitions for the topic.<br/>Setting this to a value which is greater than the total number of partitions in has no effect.",
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1
              },
              {
                "type": "string",
                "enum": [
                  "all_partitions"
                ]
              }
            ]
          },
          "max_inflight": {
            "default": 10,
            "type": "integer",
            "description": "The maximum number of message batches that the producer can send to each partition before it must wait for an acknowledgement.<br/>Setting a higher number can enhance throughput. However, value above 1 may lead to potential message reordering risks.",
            "minimum": 1
          },
          "buffer": {
            "description": "Configure producer message buffer.<br/><br/>Tell Kafka producer how to buffer messages when EMQX has more messages to send than Kafka can keep up, or when Kafka is down.",
            "$ref": "#/components/schemas/bridge_kafka.producer_buffer"
          },
          "query_mode": {
            "default": "async",
            "type": "string",
            "enum": [
              "async",
              "sync"
            ],
            "description": "Query mode. Optional 'sync/async', default 'async'."
          },
          "sync_query_timeout": {
            "default": "5s",
            "type": "string",
            "description": "This parameter defines the timeout limit for synchronous queries. It applies only when the query mode is configured to 'sync'.",
            "example": "32s"
          }
        },
        "type": "object"
      },
      "bridge_tdengine.put": {
        "required": [
          "database",
          "password",
          "server"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "sql": {
            "default": "insert into t_mqtt_msg(ts, msgid, mqtt_topic, qos, payload, arrived) values (${ts}, '${id}', '${topic}', ${qos}, '${payload}', ${timestamp})",
            "type": "string",
            "format": "sql",
            "description": "SQL Template"
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to TDengine. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The TDengine default port 6041 is used if `[:Port]` is not specified."
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "default": "root",
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          }
        },
        "type": "object"
      },
      "bridge_mqtt.post": {
        "required": [
          "name",
          "server",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "mqtt"
            ],
            "description": "The bridge type."
          },
          "name": {
            "type": "string",
            "description": "Bridge name, used as a human-readable identifier."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_mqtt.creation_opts"
          },
          "mode": {
            "default": "cluster_shareload",
            "type": "string",
            "enum": [
              "cluster_shareload"
            ],
            "deprecated": true,
            "description": "The mode of the MQTT Bridge.<br/><br/>- cluster_shareload: create an MQTT connection on each node in the emqx cluster.<br/><br/>In 'cluster_shareload' mode, the incoming load from the remote broker is shared by<br/>using shared subscription.<br/><br/>Note that the 'clientid' is suffixed by the node name, this is to avoid<br/>clientid conflicts between different nodes. And we can only use shared subscription<br/>topic filters for <code>remote.topic</code> of ingress connections."
          },
          "server": {
            "type": "string",
            "description": "The host and port of the remote MQTT broker"
          },
          "clientid_prefix": {
            "type": "string",
            "description": "Optional prefix to prepend to the clientid used by egress bridges."
          },
          "reconnect_interval": {
            "type": "string",
            "deprecated": true
          },
          "proto_ver": {
            "default": "v4",
            "type": "string",
            "enum": [
              "v3",
              "v4",
              "v5"
            ],
            "description": "The MQTT protocol version"
          },
          "bridge_mode": {
            "default": false,
            "type": "boolean",
            "description": "If enable bridge mode.<br/>NOTE: This setting is only for MQTT protocol version older than 5.0, and the remote MQTT<br/>broker MUST support this feature.<br/>If bridge_mode is set to true, the bridge will indicate to the remote broker that it is a bridge not an ordinary client.<br/>This means that loop detection will be more effective and that retained messages will be propagated correctly."
          },
          "username": {
            "type": "string",
            "description": "The username of the MQTT protocol"
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password of the MQTT protocol",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "clean_start": {
            "default": true,
            "type": "boolean",
            "description": "Whether to start a clean session when reconnecting a remote broker for ingress bridge"
          },
          "keepalive": {
            "default": "300s",
            "type": "string",
            "description": "MQTT Keepalive. Time interval is a string that contains a number followed by time unit:<br/>- `ms` for milliseconds,<br/>- `s` for seconds,<br/>- `m` for minutes,<br/>- `h` for hours;<br/><br/>or combination of whereof: `1h5m0s`"
          },
          "retry_interval": {
            "default": "15s",
            "type": "string",
            "description": "Message retry interval. Delay for the MQTT bridge to retry sending the QoS1/QoS2 messages in case of ACK not received. Time interval is a string that contains a number followed by time unit:<br/>- `ms` for milliseconds,<br/>- `s` for seconds,<br/>- `m` for minutes,<br/>- `h` for hours;<br/><br/>or combination of whereof: `1h5m0s`"
          },
          "max_inflight": {
            "default": 32,
            "type": "integer",
            "description": "Max inflight (sent, but un-acked) messages of the MQTT protocol",
            "minimum": 0
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "ingress": {
            "description": "The ingress config defines how this bridge receive messages from the remote MQTT broker, and then<br/>        send them to the local broker.<br/><br/>        Template with variables is allowed in 'remote.qos', 'local.topic', 'local.qos', 'local.retain', 'local.payload'.<br/><br/>        NOTE: if this bridge is used as the input of a rule, and also 'local.topic' is<br/>        configured, then messages got from the remote broker will be sent to both the 'local.topic' and<br/>        the rule.",
            "$ref": "#/components/schemas/connector_mqtt.ingress"
          },
          "egress": {
            "description": "The egress config defines how this bridge forwards messages from the local broker to the remote broker.<br/><br/>Template with variables is allowed in 'remote.topic', 'local.qos', 'local.retain', 'local.payload'.<br/><br/>NOTE: if this bridge is used as the action of a rule, and also 'local.topic'<br/>is configured, then both the data got from the rule and the MQTT messages that matches<br/>'local.topic' will be forwarded.",
            "$ref": "#/components/schemas/connector_mqtt.egress"
          }
        },
        "type": "object"
      },
      "bridge_cassa.post_connector": {
        "required": [
          "keyspace",
          "name",
          "servers",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "cassandra"
            ],
            "description": "The type of the connector."
          },
          "name": {
            "type": "string",
            "description": "The name of the connector."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this connector."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "servers": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port][,Host2:Port]`.<br/><br/>The Cassandra default port 9042 is used if `[:Port]` is not specified."
          },
          "keyspace": {
            "type": "string",
            "description": "Keyspace name to connect to."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_cassa.connector_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_kafka.kafka_message": {
        "properties": {
          "key": {
            "default": "${.clientid}",
            "type": "string",
            "description": "Template for rendering message key. If the template is rendered into a NULL value (i.e. there is no such data field in Rule Engine context) then <code>NULL</code> (but not empty string) is used."
          },
          "value": {
            "default": "${.}",
            "type": "string",
            "description": "Template for rendering Kafka message value. If the template is rendered into a NULL value (i.e. there is no such data field in Rule Engine context) then Kafka's <code>NULL</code> (but not empty string) is used."
          },
          "timestamp": {
            "default": "${.timestamp}",
            "type": "string",
            "description": "Which timestamp to use. The timestamp is expected to be a millisecond precision Unix epoch which can be in string format, e.g. <code>1661326462115</code> or <code>'1661326462115'</code>. When the desired data field for this template is not found, or if the found data is not a valid integer, the current system timestamp will be used."
          }
        },
        "type": "object"
      },
      "actions_and_sources.source_resource_opts": {
        "properties": {
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          }
        },
        "type": "object"
      },
      "bridge_oracle.put": {
        "required": [
          "server",
          "username"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "sql": {
            "default": "insert into t_mqtt_msgs(msgid, topic, qos, payload) values (${id}, ${topic}, ${qos}, ${payload})",
            "type": "string",
            "format": "sql",
            "description": "SQL Template. The template string can contain placeholders for message metadata and payload field. The placeholders are inserted without any checking and special formatting, so it is important to ensure that the inserted values are formatted and escaped correctly."
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to Oracle Database. All MQTT 'PUBLISH' messages with the topic matching the local_topic will be forwarded.<br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is configured, then both the data got from the rule and the MQTT messages that match local_topic will be forwarded."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The Oracle Database default port 1521 is used if `[:Port]` is not specified."
          },
          "sid": {
            "type": "string",
            "description": "Sid for Oracle Database."
          },
          "service_name": {
            "type": "string",
            "description": "Service Name for Oracle Database."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          }
        },
        "type": "object"
      },
      "rule_engine.metrics": {
        "properties": {
          "matched": {
            "type": "integer",
            "description": "How many times the FROM clause of the SQL is matched.",
            "minimum": 0
          },
          "matched.rate": {
            "type": "number",
            "description": "The rate of matched, times/second"
          },
          "matched.rate.max": {
            "type": "number",
            "description": "The max rate of matched, times/second"
          },
          "matched.rate.last5m": {
            "type": "number",
            "description": "The average rate of matched in last 5 minutes, times/second"
          },
          "passed": {
            "type": "integer",
            "description": "How many times the SQL is passed",
            "minimum": 0
          },
          "failed": {
            "type": "integer",
            "description": "How many times the SQL statement has failed",
            "minimum": 0
          },
          "failed.exception": {
            "type": "integer",
            "description": "How many times the SQL is failed due to exceptions. This may because of a crash when calling a SQL function, or trying to do arithmetic operation on undefined variables",
            "minimum": 0
          },
          "failed.unknown": {
            "type": "integer",
            "description": "How many times the SQL is failed due to an unknown error.",
            "minimum": 0
          },
          "actions.total": {
            "type": "integer",
            "description": "How many times the actions are called by the rule. This value may several times of 'matched', depending on the number of the actions of the rule.",
            "minimum": 0
          },
          "actions.success": {
            "type": "integer",
            "description": "How many times the rule successided to call the actions.",
            "minimum": 0
          },
          "actions.failed": {
            "type": "integer",
            "description": "How many times the rule failed to call the actions.",
            "minimum": 0
          },
          "actions.failed.out_of_service": {
            "type": "integer",
            "description": "How many times the rule has failed to call actions due to the action is out of service. For example, a bridge is disabled or stopped.",
            "minimum": 0
          },
          "actions.failed.unknown": {
            "type": "integer",
            "description": "The number of action failures that have occurred due to unanticipated reasons. For more information on these errors, please refer to the EMQX log file.",
            "minimum": 0
          }
        },
        "type": "object"
      },
      "bridge_timescale.put": {
        "required": [
          "database",
          "server",
          "username"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "sql": {
            "default": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
            "type": "string",
            "format": "sql",
            "description": "SQL Template"
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to PostgreSQL. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The PostgreSQL default port 5432 is used if `[:Port]` is not specified."
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "bridge_mongodb.get_single": {
        "required": [
          "database",
          "mongo_type",
          "name",
          "resource_opts",
          "server",
          "type"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "mongo_type": {
            "default": "single",
            "type": "string",
            "enum": [
              "single"
            ],
            "description": "Standalone instance. Must be set to 'single' when MongoDB server is running in standalone mode."
          },
          "server": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The MongoDB default port 27017 is used if `[:Port]` is not specified."
          },
          "w_mode": {
            "default": "unsafe",
            "type": "string",
            "enum": [
              "unsafe",
              "safe"
            ],
            "description": "Write mode."
          },
          "srv_record": {
            "default": false,
            "type": "boolean",
            "description": "Use DNS SRV record."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "use_legacy_protocol": {
            "default": "auto",
            "type": "string",
            "enum": [
              "auto",
              true,
              false
            ],
            "description": "Whether to use MongoDB's legacy protocol for communicating with the database.  The default is to attempt to automatically determine if the newer protocol is supported."
          },
          "auth_source": {
            "type": "string",
            "description": "Database name associated with the user's credentials."
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "topology": {
            "$ref": "#/components/schemas/mongo.topology"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this MongoDB Action"
          },
          "collection": {
            "default": "mqtt",
            "type": "string",
            "description": "The collection where data will be stored into"
          },
          "payload_template": {
            "type": "string",
            "description": "The template for formatting the outgoing messages.  If undefined, rule engine will use JSON format to serialize all visible inputs, such as clientid, topic, payload etc."
          },
          "resource_opts": {
            "description": "Creation options.",
            "$ref": "#/components/schemas/bridge_mongodb.creation_opts"
          },
          "type": {
            "type": "string",
            "enum": [
              "mongodb_single"
            ]
          },
          "name": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge_opents.post_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "opents"
            ]
          },
          "name": {
            "type": "string"
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "OpenTSDB action parameters",
            "$ref": "#/components/schemas/bridge_opents.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_greptimedb.post_grpc_v1": {
        "required": [
          "dbname",
          "name",
          "type",
          "write_syntax"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to the GreptimeDB. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: If this Sink is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "write_syntax": {
            "type": "string",
            "format": "sql",
            "description": "Conf of GreptimeDB gRPC protocol to write data points. Write syntax is a text-based format that provides the measurement, tag set, field set, and timestamp of a data point, and placeholder supported, which is the same as InfluxDB line protocol.<br/>See also [InfluxDB 2.3 Line Protocol](https://docs.influxdata.com/influxdb/v2.3/reference/syntax/line-protocol/) and<br/>[GreptimeDB 1.8 Line Protocol](https://docs.influxdata.com/influxdb/v1.8/write_protocols/line_protocol_tutorial/) <br/><br/>TLDR:<br/><br/>```<br/><measurement>[,<tag_key>=<tag_value>[,<tag_key>=<tag_value>]] <field_key>=<field_value>[,<field_key>=<field_value>] [<timestamp>]<br/>```<br/>Please note that a placeholder for an integer value must be annotated with a suffix `i`. For example `${payload.int_value}i`."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "default": "127.0.0.1:4001",
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The GreptimeDB default port 8086 is used if `[:Port]` is not specified."
          },
          "precision": {
            "default": "ms",
            "type": "string",
            "enum": [
              "ns",
              "us",
              "ms",
              "s"
            ],
            "description": "GreptimeDB time precision."
          },
          "dbname": {
            "type": "string",
            "description": "GreptimeDB database."
          },
          "username": {
            "type": "string",
            "description": "GreptimeDB username."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "GreptimeDB password.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "type": {
            "type": "string",
            "enum": [
              "greptimedb"
            ],
            "description": "The type of the action."
          },
          "name": {
            "type": "string",
            "description": "The name of the action."
          }
        },
        "type": "object"
      },
      "bridge_kafka.get_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "kafka_producer"
            ],
            "description": "The Action Type"
          },
          "name": {
            "type": "string",
            "description": "Action name, used as a human-readable identifier."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in Kafka."
          },
          "parameters": {
            "description": "Kafka producer configs.",
            "$ref": "#/components/schemas/bridge_kafka.producer_kafka_opts"
          },
          "resource_opts": {
            "default": {},
            "$ref": "#/components/schemas/bridge_kafka.resource_opts"
          }
        },
        "type": "object"
      },
      "connector_mqtt.ingress_remote": {
        "required": [
          "topic"
        ],
        "properties": {
          "topic": {
            "type": "string",
            "description": "Receive messages from which topic of the remote broker"
          },
          "qos": {
            "default": 1,
            "maximum": 2,
            "type": "integer",
            "description": "The QoS level to be used when subscribing to the remote broker",
            "minimum": 0,
            "example": 0
          }
        },
        "type": "object"
      },
      "bridge_rabbitmq.source_parameters": {
        "required": [
          "queue"
        ],
        "properties": {
          "queue": {
            "type": "string",
            "description": "The queue name of the RabbitMQ broker."
          },
          "wait_for_publish_confirmations": {
            "default": true,
            "type": "boolean",
            "description": "A boolean value that indicates whether to wait for RabbitMQ to confirm message publication when using publisher confirms."
          },
          "no_ack": {
            "default": true,
            "type": "boolean",
            "description": "Whether to use no_ack mode when consuming messages from the RabbitMQ broker."
          }
        },
        "type": "object"
      },
      "bridge_mqtt_publisher.post_source": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "mqtt"
            ]
          },
          "name": {
            "type": "string"
          },
          "parameters": {
            "$ref": "#/components/schemas/bridge_mqtt_publisher.ingress_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_mqtt_publisher.source_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_matrix.get_bridge_v2": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Configuration Parameters Specific to the PostgreSQL Action",
            "$ref": "#/components/schemas/bridge_pgsql.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "pulsar.producer_pulsar_message": {
        "properties": {
          "key": {
            "default": "${.clientid}",
            "type": "string",
            "description": "Template to render Pulsar message key."
          },
          "value": {
            "default": "${.}",
            "type": "string",
            "description": "Template to render Pulsar message value."
          }
        },
        "type": "object"
      },
      "bridge_kafka.socket_opts": {
        "properties": {
          "sndbuf": {
            "default": "1MB",
            "type": "string",
            "description": "Fine tune the socket send buffer. The default value is tuned for high throughput.",
            "example": "32MB"
          },
          "recbuf": {
            "default": "1MB",
            "type": "string",
            "description": "Fine tune the socket receive buffer. The default value is tuned for high throughput.",
            "example": "32MB"
          },
          "nodelay": {
            "default": true,
            "type": "boolean",
            "description": "When set to 'true', TCP buffer is sent as soon as possible. Otherwise, the OS kernel may buffer small TCP packets for a while (40 ms by default)."
          },
          "tcp_keepalive": {
            "default": "none",
            "type": "string",
            "description": "Enable TCP keepalive.<br/>The value is three comma separated numbers in the format of 'Idle,Interval,Probes'<br/> - Idle: The number of seconds a connection needs to be idle before the server begins to send out keep-alive probes (Linux default 7200).<br/> - Interval: The number of seconds between TCP keep-alive probes (Linux default 75).<br/> - Probes: The maximum number of TCP keep-alive probes to send before giving up and killing the connection if no response is obtained from the other end (Linux default 9).<br/>For example \"240,30,5\" means: TCP keepalive probes are sent after the connection is idle for 240 seconds, and the probes are sent every 30 seconds until a response is received, if it misses 5 consecutive responses, the connection should be closed.<br/>Default: 'none'"
          }
        },
        "type": "object"
      },
      "gcp_pubsub_consumer.source_parameters": {
        "required": [
          "topic"
        ],
        "properties": {
          "topic": {
            "type": "string",
            "description": "The GCP PubSub topic to publish messages to."
          },
          "pull_max_messages": {
            "default": 100,
            "type": "integer",
            "description": "The maximum number of messages to retrieve from GCP PubSub in a single pull request. The actual number may be less than the specified value.",
            "minimum": 1
          }
        },
        "type": "object"
      },
      "bridge_redis.post_single": {
        "required": [
          "command_template",
          "name",
          "server",
          "type"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to Redis. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: If this action is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "command_template": {
            "type": "array",
            "description": "Redis command template used to export messages. Each list element stands for a command name or its argument.<br/>For example, to push payloads in a Redis list by key `msgs`, the elements should be the following:<br/>`rpush`, `msgs`, `${payload}`.",
            "items": {
              "type": "string"
            }
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_redis.creation_opts_redis_single"
          },
          "server": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The Redis default port 6379 is used if `[:Port]` is not specified."
          },
          "redis_type": {
            "default": "single",
            "type": "string",
            "enum": [
              "single"
            ],
            "description": "Single mode. Must be set to 'single' when Redis server is running in single mode."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "database": {
            "default": 0,
            "type": "integer",
            "description": "Redis database ID.",
            "minimum": 0
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "type": {
            "type": "string",
            "enum": [
              "redis_single"
            ],
            "description": "The Action Type"
          },
          "name": {
            "type": "string",
            "description": "Action name, used as a human-readable identifier."
          }
        },
        "type": "object"
      },
      "audit.audit": {
        "properties": {
          "created_at": {
            "description": "The time when the log is created",
            "oneOf": [
              {
                "type": "integer",
                "description": "epoch-microsecond",
                "example": 1640995200000000
              },
              {
                "type": "string",
                "format": "date-time",
                "example": "2022-01-01T00:00:00.000000Z"
              }
            ]
          },
          "node": {
            "type": "string",
            "description": "The node name to which the log is created"
          },
          "from": {
            "type": "string",
            "enum": [
              "dashboard",
              "rest_api",
              "cli",
              "erlang_console"
            ],
            "description": "The source type of the log"
          },
          "source": {
            "type": "string",
            "description": "The source of the log"
          },
          "source_ip": {
            "type": "string",
            "description": "The source ip of the log"
          },
          "operation_id": {
            "type": "string",
            "description": "The operation id of the log"
          },
          "operation_type": {
            "type": "string",
            "description": "The operation type of the log"
          },
          "operation_result": {
            "type": "string",
            "enum": [
              "success",
              "failure"
            ],
            "description": "The operation result of the log"
          },
          "http_status_code": {
            "type": "integer",
            "description": "The http status code of the log"
          },
          "http_method": {
            "type": "string",
            "enum": [
              "post",
              "put",
              "delete"
            ],
            "description": "The http method of the log"
          },
          "duration_ms": {
            "type": "integer",
            "description": "The duration of the log"
          },
          "args": {
            "type": "array",
            "description": "The args of the log",
            "items": {
              "type": "string"
            }
          },
          "failure": {
            "type": "array",
            "description": "The failure of the log",
            "items": {
              "type": "string"
            }
          },
          "http_request": {
            "description": "The http request of the log",
            "$ref": "#/components/schemas/audit.http_request"
          }
        },
        "type": "object"
      },
      "bridge_opents.put": {
        "required": [
          "server"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "type": "string",
            "description": "The URL of OpenTSDB endpoint."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "summary": {
            "default": true,
            "type": "boolean",
            "description": "Whether to return summary information."
          },
          "details": {
            "default": false,
            "type": "boolean",
            "description": "Whether to return detailed information."
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          }
        },
        "type": "object"
      },
      "kafka_consumer.get_source": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "kafka_consumer"
            ]
          },
          "name": {
            "type": "string"
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "parameters": {
            "description": "Source configs.",
            "$ref": "#/components/schemas/kafka_consumer.source_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.source_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_datalayers.get_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "datalayers"
            ]
          },
          "name": {
            "type": "string"
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Additional parameters specific to this action type",
            "$ref": "#/components/schemas/bridge_datalayers.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "rule_engine.ctx_check_authn_complete": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "type": "string",
            "enum": [
              "client_check_authn_complete"
            ],
            "description": "Event Type"
          },
          "clientid": {
            "type": "string",
            "description": "The Client ID"
          },
          "username": {
            "type": "string",
            "description": "Username"
          },
          "reason_code": {
            "type": "string",
            "description": "The reason code"
          },
          "peername": {
            "type": "string",
            "description": "The IP Address and Port of the Peer Client"
          },
          "is_anonymous": {
            "type": "boolean",
            "description": "True if this user is anonymous."
          },
          "is_superuser": {
            "type": "boolean",
            "description": "True if this is a super user."
          }
        },
        "type": "object"
      },
      "action_azure_blob_storage.direct_parameters": {
        "required": [
          "blob",
          "container",
          "mode"
        ],
        "properties": {
          "mode": {
            "type": "string",
            "enum": [
              "direct"
            ],
            "description": "Enables uploading of events to the Azure Blob Storage service as separate objects."
          },
          "container": {
            "type": "string",
            "description": "The name of the Azure Blob Storage container name."
          },
          "blob": {
            "type": "string",
            "description": "The name of the Azure Blob Storage blob name."
          },
          "content": {
            "default": "${.}",
            "type": "string",
            "description": "Content of the Azure Blob Storage blob being uploaded. Supports templates."
          }
        },
        "type": "object"
      },
      "bridge_oracle.action_parameters": {
        "properties": {
          "sql": {
            "default": "insert into t_mqtt_msgs(msgid, topic, qos, payload) values (${id}, ${topic}, ${qos}, ${payload})",
            "type": "string",
            "format": "sql",
            "description": "SQL Template. The template string can contain placeholders for message metadata and payload field. The placeholders are inserted without any checking and special formatting, so it is important to ensure that the inserted values are formatted and escaped correctly."
          }
        },
        "type": "object"
      },
      "bridge_datalayers.put_connector": {
        "required": [
          "parameters"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this connector."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "server": {
            "default": "127.0.0.1:8361",
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The Datalayers default port 8361 is used if `[:Port]` is not specified."
          },
          "parameters": {
            "description": "Set of parameters specific for the given type of this Datalayers connector.",
            "$ref": "#/components/schemas/connector_datalayers.datalayers_parameters"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_datalayers.connector_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_datalayers.action_parameters": {
        "required": [
          "write_syntax"
        ],
        "properties": {
          "write_syntax": {
            "type": "string",
            "format": "sql",
            "description": "Conf of InfluxDB line protocol to write data points. It is a text-based format that provides the measurement, tag set, field set, and timestamp of a data point, and placeholder supported.<br/>See also [InfluxDB 1.8 Line Protocol](https://docs.influxdata.com/influxdb/v1.8/write_protocols/line_protocol_tutorial/) <br/><br/>TLDR:<br/><br/>```<br/><measurement>[,<tag_key>=<tag_value>[,<tag_key>=<tag_value>]] <field_key>=<field_value>[,<field_key>=<field_value>] [<timestamp>]<br/>```<br/>Please note that a placeholder for an integer value must be annotated with a suffix `i`. For example `${payload.int_value}i`."
          },
          "precision": {
            "default": "ms",
            "type": "string",
            "enum": [
              "ns",
              "us",
              "ms",
              "s"
            ],
            "description": "Datalayers time precision."
          }
        },
        "type": "object"
      },
      "syskeeper.get_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "syskeeper_forwarder"
            ],
            "description": "The action type."
          },
          "name": {
            "type": "string",
            "description": "Action name."
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Syskeeper action parameters",
            "$ref": "#/components/schemas/syskeeper.parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/syskeeper.creation_opts"
          }
        },
        "type": "object"
      },
      "message_transformation_http_api.get_metrics": {
        "properties": {
          "metrics": {
            "$ref": "#/components/schemas/message_transformation_http_api.metrics"
          },
          "node_metrics": {
            "$ref": "#/components/schemas/message_transformation_http_api.node_metrics"
          }
        },
        "type": "object"
      },
      "bridge_mysql.post": {
        "required": [
          "database",
          "name",
          "server",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "mysql"
            ],
            "description": "The action type"
          },
          "name": {
            "type": "string",
            "description": "Action name, used as a human-readable identifier of the action."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this action"
          },
          "sql": {
            "default": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, FROM_UNIXTIME(${timestamp}/1000))",
            "type": "string",
            "format": "sql",
            "description": "SQL Template"
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to MySQL. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: If this action is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The MySQL default port 3306 is used if `[:Port]` is not specified."
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "default": "root",
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "bridge_sqlserver.creation_opts": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "maximum": 1024,
            "type": "integer",
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 1
          },
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "start_after_created": {
            "default": true,
            "type": "boolean",
            "description": "Whether start the resource right after created."
          },
          "start_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "example": "32s"
          },
          "auto_restart_interval": {
            "default": "15s",
            "deprecated": true,
            "oneOf": [
              {
                "type": "string",
                "example": "32s"
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "query_mode": {
            "default": "async",
            "type": "string",
            "enum": [
              "sync",
              "async"
            ],
            "description": "Query mode. Optional 'sync/async', default 'async'."
          },
          "request_ttl": {
            "default": "45s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "string",
                "example": "32s"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "type": "integer",
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1
          },
          "batch_size": {
            "default": 1,
            "type": "integer",
            "description": "Maximum batch count. If equal to 1, there's effectively no batching.",
            "minimum": 1
          },
          "batch_time": {
            "default": "0ms",
            "type": "string",
            "description": "Maximum waiting interval when accumulating a batch at a low message rates for more efficient resource usage.",
            "example": "32s"
          },
          "enable_queue": {
            "default": false,
            "type": "boolean",
            "deprecated": true,
            "description": "Enable disk buffer queue (only applicable for egress bridges).<br/>When Enabled, messages will be buffered on disk when the bridge connection is down.<br/>When disabled the messages are buffered in RAM only."
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "type": "string",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB"
          }
        },
        "type": "object"
      },
      "bridge_kafka.auth_gssapi_kerberos": {
        "required": [
          "kerberos_keytab_file",
          "kerberos_principal"
        ],
        "properties": {
          "kerberos_principal": {
            "type": "string",
            "description": "SASL GSSAPI authentication Kerberos principal. For example <code>kafka/node1.example.com@EXAMPLE.COM</code>, NOTE: The realm in use has to be configured in /etc/krb5.conf in EMQX nodes."
          },
          "kerberos_keytab_file": {
            "type": "string",
            "description": "SASL GSSAPI authentication Kerberos keytab file path. NOTE: This file has to be placed in EMQX nodes, and the EMQX service runner user requires read permission."
          }
        },
        "type": "object"
      },
      "bridge_redis.put_single": {
        "required": [
          "command_template",
          "server"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to Redis. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: If this action is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "command_template": {
            "type": "array",
            "description": "Redis command template used to export messages. Each list element stands for a command name or its argument.<br/>For example, to push payloads in a Redis list by key `msgs`, the elements should be the following:<br/>`rpush`, `msgs`, `${payload}`.",
            "items": {
              "type": "string"
            }
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_redis.creation_opts_redis_single"
          },
          "server": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The Redis default port 6379 is used if `[:Port]` is not specified."
          },
          "redis_type": {
            "default": "single",
            "type": "string",
            "enum": [
              "single"
            ],
            "description": "Single mode. Must be set to 'single' when Redis server is running in single mode."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "database": {
            "default": 0,
            "type": "integer",
            "description": "Redis database ID.",
            "minimum": 0
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "bridge_azure_event_hub.put_producer": {
        "required": [
          "bootstrap_hosts",
          "kafka"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this connector."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "bootstrap_hosts": {
            "type": "string",
            "description": "A comma separated list of Azure Event Hubs Kafka <code>host[:port]</code> namespace endpoints to bootstrap the client.  Default port number is 9093."
          },
          "connect_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Maximum wait time for TCP connection establishment (including authentication time if enabled).",
            "example": "32s"
          },
          "min_metadata_refresh_interval": {
            "default": "3s",
            "type": "string",
            "description": "Minimum time interval the client has to wait before refreshing Azure Event Hubs Kafka broker and topic metadata. Setting too small value may add extra load on Azure Event Hubs.",
            "example": "32s"
          },
          "metadata_request_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Maximum wait time when fetching metadata from Azure Event Hubs.",
            "example": "32s"
          },
          "authentication": {
            "default": "none",
            "description": "Authentication configs.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/bridge_kafka.auth_gssapi_kerberos"
              },
              {
                "$ref": "#/components/schemas/bridge_kafka.auth_username_password"
              },
              {
                "type": "string",
                "enum": [
                  "none"
                ]
              }
            ]
          },
          "socket_opts": {
            "description": "Extra socket options.",
            "$ref": "#/components/schemas/bridge_kafka.socket_opts"
          },
          "health_check_topic": {
            "type": "string",
            "description": "Topic name used exclusively for more accurate connector health checks."
          },
          "ssl": {
            "$ref": "#/components/schemas/bridge_kafka.ssl_client_opts"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_kafka.connector_resource_opts"
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in Azure Event Hubs."
          },
          "kafka": {
            "description": "Azure Event Hubs producer configs.",
            "$ref": "#/components/schemas/bridge_kafka.v1_producer_kafka_opts"
          }
        },
        "type": "object"
      },
      "bridge_kafka.get_consumer": {
        "required": [
          "bootstrap_hosts",
          "name",
          "topic_mapping",
          "type"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "kafka",
              "kafka_producer",
              "kafka_consumer"
            ],
            "description": "The Action Type"
          },
          "name": {
            "type": "string",
            "description": "Action name, used as a human-readable identifier."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this connector."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "bootstrap_hosts": {
            "type": "string",
            "description": "A comma separated list of Kafka <code>host:port</code> endpoints to bootstrap the client."
          },
          "connect_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Maximum wait time for TCP connection establishment (including authentication time if enabled).",
            "example": "32s"
          },
          "min_metadata_refresh_interval": {
            "default": "3s",
            "type": "string",
            "description": "Minimum time interval the client has to wait before refreshing Kafka broker and topic metadata. Setting too small value may add extra load on Kafka.",
            "example": "32s"
          },
          "metadata_request_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Maximum wait time when fetching topic metadata.",
            "example": "32s"
          },
          "authentication": {
            "default": "none",
            "description": "Authentication configs.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/bridge_kafka.auth_gssapi_kerberos"
              },
              {
                "$ref": "#/components/schemas/bridge_kafka.auth_username_password"
              },
              {
                "type": "string",
                "enum": [
                  "none"
                ]
              }
            ]
          },
          "socket_opts": {
            "description": "Extra socket options.",
            "$ref": "#/components/schemas/bridge_kafka.socket_opts"
          },
          "health_check_topic": {
            "type": "string",
            "description": "Topic name used exclusively for more accurate connector health checks."
          },
          "ssl": {
            "$ref": "#/components/schemas/bridge_kafka.ssl_client_opts"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_kafka.connector_resource_opts"
          },
          "kafka": {
            "description": "Kafka consumer configs.",
            "$ref": "#/components/schemas/bridge_kafka.consumer_kafka_opts"
          },
          "topic_mapping": {
            "type": "array",
            "description": "Defines the mapping between Kafka topics and MQTT topics. Must contain at least one item.",
            "items": {
              "$ref": "#/components/schemas/bridge_kafka.consumer_topic_mapping"
            }
          },
          "key_encoding_mode": {
            "default": "none",
            "type": "string",
            "enum": [
              "none",
              "base64"
            ],
            "description": "Defines how the key from the Kafka message is encoded before being forwarded via MQTT.<br/><code>none</code> Uses the key from the Kafka message unchanged.  Note: in this case, the key must be a valid UTF-8 string.<br/><code>base64</code> Uses base-64 encoding on the received key."
          },
          "value_encoding_mode": {
            "default": "none",
            "type": "string",
            "enum": [
              "none",
              "base64"
            ],
            "description": "Defines how the value from the Kafka message is encoded before being forwarded via MQTT.<br/><code>none</code> Uses the value from the Kafka message unchanged.  Note: in this case, the value must be a valid UTF-8 string.<br/><code>base64</code> Uses base-64 encoding on the received value."
          }
        },
        "type": "object"
      },
      "bridge_mqtt_publisher.post_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "mqtt"
            ]
          },
          "name": {
            "type": "string"
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Action specific configs.",
            "$ref": "#/components/schemas/bridge_mqtt_publisher.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_mqtt_publisher.action_resource_opts"
          }
        },
        "type": "object"
      },
      "node_eviction.status_enabled": {
        "properties": {
          "status": {
            "default": "enabled",
            "type": "string",
            "enum": [
              "enabled"
            ]
          },
          "stats": {
            "$ref": "#/components/schemas/node_eviction.stats"
          }
        },
        "type": "object"
      },
      "rule_engine.ctx_schema_validation_failed": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "type": "string",
            "enum": [
              "schema_validation_failed"
            ],
            "description": "Event Type"
          },
          "validation": {
            "type": "string",
            "description": "Validation"
          },
          "clientid": {
            "type": "string",
            "description": "The Client ID"
          },
          "username": {
            "type": "string",
            "description": "Username"
          },
          "payload": {
            "type": "string",
            "description": "The Message Payload"
          },
          "peerhost": {
            "type": "string",
            "description": "The IP Address of the Peer Client"
          },
          "topic": {
            "type": "string",
            "description": "Message Topic"
          },
          "publish_received_at": {
            "type": "integer",
            "description": "The Time that this Message is Received"
          },
          "qos": {
            "maximum": 2,
            "type": "integer",
            "description": "The Message QoS",
            "minimum": 0,
            "example": 0
          }
        },
        "type": "object"
      },
      "bridge_kafka.consumer_kafka_opts": {
        "properties": {
          "max_batch_bytes": {
            "default": "896KB",
            "type": "string",
            "description": "Set how many bytes to pull from Kafka in each fetch request. Please note that if the configured value is smaller than the message size in Kafka, it may negatively impact the fetch performance.",
            "example": "32MB"
          },
          "offset_reset_policy": {
            "default": "latest",
            "type": "string",
            "enum": [
              "latest",
              "earliest"
            ],
            "description": "Defines from which offset a consumer should start fetching when there is no commit history or when the commit history becomes invalid."
          },
          "offset_commit_interval_seconds": {
            "default": "5s",
            "type": "string",
            "description": "Defines the time interval between two offset commit requests sent for each consumer group.",
            "example": "1h"
          }
        },
        "type": "object"
      },
      "bridge_pgsql.put_bridge_v2": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Configuration Parameters Specific to the PostgreSQL Action",
            "$ref": "#/components/schemas/bridge_pgsql.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "gcp_pubsub_consumer.post_source": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "gcp_pubsub_consumer"
            ]
          },
          "name": {
            "type": "string"
          },
          "parameters": {
            "description": "Source configs.",
            "$ref": "#/components/schemas/gcp_pubsub_consumer.source_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/gcp_pubsub_consumer.source_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_iotdb.put": {
        "required": [
          "base_url"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "authentication": {
            "default": "auth_basic",
            "description": "Authentication configuration",
            "oneOf": [
              {
                "$ref": "#/components/schemas/bridge_iotdb.auth_basic"
              }
            ]
          },
          "is_aligned": {
            "default": false,
            "type": "boolean",
            "description": "Whether to align the timeseries"
          },
          "device_id": {
            "type": "string",
            "description": "The IoTDB device ID this data should be inserted for.<br/>If left empty, the MQTT message payload must contain a `device_id` field,<br/>or EMQX's rule-engine SQL must produce a `device_id` field."
          },
          "iotdb_version": {
            "default": "v1.3.x",
            "type": "string",
            "enum": [
              "v1.3.x",
              "v1.1.x",
              "v1.0.x",
              "v0.13.x"
            ],
            "description": "The version of the IoTDB system to connect to."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_iotdb.creation_opts"
          },
          "connect_timeout": {
            "default": "15s",
            "type": "string",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s"
          },
          "retry_interval": {
            "type": "string",
            "deprecated": true,
            "example": "12m"
          },
          "pool_type": {
            "default": "random",
            "type": "string",
            "enum": [
              "random",
              "hash"
            ],
            "description": "The type of the pool. Can be one of `random`, `hash`."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "The pool size.",
            "minimum": 1
          },
          "enable_pipelining": {
            "default": 100,
            "type": "integer",
            "description": "The maximum number of HTTP requests that can be sent before an HTTP response is received.<br/><br/>Setting this to 1 is equivalent to turning off HTTP pipelining, and the EMQX must receive a response to the previous HTTP request before sending the next HTTP request.",
            "minimum": 1
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "base_url": {
            "type": "string",
            "description": "The base URL of the external IoTDB service's REST interface.",
            "example": "http://127.0.0.1"
          },
          "max_retries": {
            "default": 2,
            "type": "integer",
            "description": "HTTP request max retry times if failed.",
            "minimum": 0
          }
        },
        "type": "object"
      },
      "syskeeper.creation_opts": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "maximum": 1024,
            "type": "integer",
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 1
          },
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "start_after_created": {
            "default": true,
            "type": "boolean",
            "description": "Whether start the resource right after created."
          },
          "start_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "example": "32s"
          },
          "auto_restart_interval": {
            "default": "15s",
            "deprecated": true,
            "oneOf": [
              {
                "type": "string",
                "example": "32s"
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "query_mode": {
            "default": "async",
            "type": "string",
            "enum": [
              "sync",
              "async"
            ],
            "description": "Query mode. Optional 'sync/async', default 'async'."
          },
          "request_ttl": {
            "default": "infinity",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "string",
                "example": "32s"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "type": "integer",
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1
          },
          "batch_size": {
            "default": 1,
            "type": "integer",
            "description": "Maximum batch count. If equal to 1, there's effectively no batching.",
            "minimum": 1
          },
          "batch_time": {
            "default": "0ms",
            "type": "string",
            "description": "Maximum waiting interval when accumulating a batch at a low message rates for more efficient resource usage.",
            "example": "32s"
          },
          "enable_queue": {
            "default": false,
            "type": "boolean",
            "deprecated": true,
            "description": "Enable disk buffer queue (only applicable for egress bridges).<br/>When Enabled, messages will be buffered on disk when the bridge connection is down.<br/>When disabled the messages are buffered in RAM only."
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "type": "string",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB"
          }
        },
        "type": "object"
      },
      "rocketmq.put": {
        "required": [
          "servers"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "template": {
            "default": "",
            "type": "string",
            "description": "Template, the default value is empty. When this value is empty the whole message will be stored in the RocketMQ.<br><br/>            The template can be any valid string with placeholders, example:<br><br/>            - ${id}, ${username}, ${clientid}, ${timestamp}<br><br/>            - {\"id\" : ${id}, \"username\" : ${username}}"
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to RocketMQ. All MQTT `PUBLISH` messages with the topic<br/>matching the `local_topic` will be forwarded.<br/><br/>NOTE: if the bridge is used as a rule action, `local_topic` should be left empty otherwise the messages will be duplicated."
          },
          "strategy": {
            "default": "roundrobin",
            "description": "Producer key dispatch strategy, the default is `roundrobin`, also supports placeholders, such as: `clientid`, `messageid`, `username`.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "string",
                "enum": [
                  "roundrobin"
                ]
              }
            ]
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "servers": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The RocketMQ default port 9876 is used if `[:Port]` is not specified."
          },
          "namespace": {
            "type": "string",
            "description": "The namespace field MUST be set if you are using the RocketMQ service in<br/>aliyun cloud and also the namespace is enabled,<br/>or if you have configured a namespace in your RocketMQ server.<br/>For RocketMQ in aliyun cloud, the namespace is the instance ID."
          },
          "topic": {
            "default": "TopicTest",
            "type": "string",
            "description": "RocketMQ Topic"
          },
          "access_key": {
            "default": "",
            "type": "string",
            "description": "RocketMQ server `accessKey`."
          },
          "secret_key": {
            "default": "",
            "type": "string",
            "format": "password",
            "description": "RocketMQ server `secretKey`.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "security_token": {
            "default": "",
            "type": "string",
            "format": "password",
            "description": "RocketMQ Server Security Token",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "sync_timeout": {
            "default": "3s",
            "type": "string",
            "description": "Timeout of RocketMQ driver synchronous call.",
            "example": "12m"
          },
          "refresh_interval": {
            "default": "3s",
            "type": "string",
            "description": "RocketMQ Topic Route Refresh Interval.",
            "example": "12m"
          },
          "send_buffer": {
            "default": "1024KB",
            "type": "string",
            "description": "The socket send buffer size of the RocketMQ driver client.",
            "example": "32MB"
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "bridge_iotdb.action_parameters_data": {
        "required": [
          "data_type",
          "measurement",
          "value"
        ],
        "properties": {
          "timestamp": {
            "default": "now",
            "description": "Timestamp. Placeholders in format of ${var} is supported, the final value can be:<br/><br/>- now: use the `now_ms` which is contained in the payload as timestamp<br/>- now_ms: same as above<br/>- now_us: use the `now_us` which is contained in the payload as timestamp<br/>- now_ns: use the `now_ns` which is contained in the payload as timestamp<br/>- any other: use the value directly as the timestamp",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "string",
                "enum": [
                  "now",
                  "now_ms",
                  "now_ns",
                  "now_us"
                ]
              }
            ]
          },
          "measurement": {
            "type": "string",
            "description": "Measurement. Placeholders in format of ${var} is supported"
          },
          "data_type": {
            "description": "Data Type, an enumerated or a string.<br/>For string placeholders in format of ${var} is supported, the final value can be:<br/><br/>- TEXT<br/>- BOOLEAN<br/>- INT32<br/>- INT64<br/>- FLOAT<br/>- DOUBLE",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "string",
                "enum": [
                  "text",
                  "boolean",
                  "int32",
                  "int64",
                  "float",
                  "double"
                ]
              }
            ]
          },
          "value": {
            "type": "string",
            "description": "Value. Placeholders in format of ${var} is supported"
          }
        },
        "type": "object"
      },
      "bridge_cassa.post": {
        "required": [
          "keyspace",
          "name",
          "servers",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "cassandra"
            ],
            "description": "The Bridge Type"
          },
          "name": {
            "type": "string",
            "description": "Bridge name."
          },
          "cql": {
            "default": "insert into mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic},  ${qos}, ${payload}, ${timestamp})",
            "type": "string",
            "format": "sql",
            "description": "CQL Template"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to Cassandra. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "servers": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port][,Host2:Port]`.<br/><br/>The Cassandra default port 9042 is used if `[:Port]` is not specified."
          },
          "keyspace": {
            "type": "string",
            "description": "Keyspace name to connect to."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "rule_engine.user_provided_function": {
        "required": [
          "function"
        ],
        "properties": {
          "function": {
            "type": "string",
            "description": "The user provided function. Should be in the format: '{module}:{function}'.<br/>Where {module} is the Erlang callback module and {function} is the Erlang function.<br/><br/>To write your own function, checkout the function <code>console</code> and<br/><code>republish</code> in the source file:<br/><code>apps/emqx_rule_engine/src/emqx_rule_actions.erl</code> as an example.",
            "example": "module:function"
          },
          "args": {
            "default": {},
            "type": "object",
            "description": "The args will be passed as the 3rd argument to module:function/3,<br/>checkout the function <code>console</code> and <code>republish</code> in the source file:<br/><code>apps/emqx_rule_engine/src/emqx_rule_actions.erl</code> as an example.",
            "example": {}
          }
        },
        "type": "object"
      },
      "bridge_tdengine.get": {
        "required": [
          "database",
          "name",
          "password",
          "server",
          "type"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "tdengine"
            ],
            "description": "The Bridge Type"
          },
          "name": {
            "type": "string",
            "description": "Bridge name."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "sql": {
            "default": "insert into t_mqtt_msg(ts, msgid, mqtt_topic, qos, payload, arrived) values (${ts}, '${id}', '${topic}', ${qos}, '${payload}', ${timestamp})",
            "type": "string",
            "format": "sql",
            "description": "SQL Template"
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to TDengine. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The TDengine default port 6041 is used if `[:Port]` is not specified."
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "default": "root",
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          }
        },
        "type": "object"
      },
      "bridge_mqtt_publisher.action_resource_opts": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "maximum": 1024,
            "type": "integer",
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 1
          },
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "query_mode": {
            "default": "async",
            "type": "string",
            "enum": [
              "sync",
              "async"
            ],
            "description": "Query mode. Optional 'sync/async', default 'async'."
          },
          "request_ttl": {
            "default": "45s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "string",
                "example": "32s"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "type": "integer",
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "type": "string",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB"
          }
        },
        "type": "object"
      },
      "action_azure_blob_storage.aggregation": {
        "required": [
          "container"
        ],
        "properties": {
          "container": {
            "default": {
              "type": "csv"
            },
            "description": "Settings governing the file format of an upload containing aggregated events.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/connector_aggregator.container_csv"
              }
            ]
          },
          "time_interval": {
            "default": "1h",
            "type": "string",
            "description": "Amount of time events will be aggregated in a single object before uploading.",
            "example": "1h"
          },
          "max_records": {
            "default": 1000000,
            "type": "integer",
            "description": "Number of records (events) allowed per each aggregated object. Each aggregated upload will contain no more than that number of events, but may contain less.<br/><br/>  If event rate is high enough, there obviously may be more than one aggregated upload during the same time interval. These uploads will have different, but consecutive sequence numbers, which will be a part of Azure Blob Storage blob name.",
            "minimum": 1
          }
        },
        "type": "object"
      },
      "bridge_cassa.put_connector": {
        "required": [
          "keyspace",
          "servers"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this connector."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "servers": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port][,Host2:Port]`.<br/><br/>The Cassandra default port 9042 is used if `[:Port]` is not specified."
          },
          "keyspace": {
            "type": "string",
            "description": "Keyspace name to connect to."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_cassa.connector_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_kafka.put_producer": {
        "required": [
          "bootstrap_hosts",
          "kafka"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this connector."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "bootstrap_hosts": {
            "type": "string",
            "description": "A comma separated list of Kafka <code>host:port</code> endpoints to bootstrap the client."
          },
          "connect_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Maximum wait time for TCP connection establishment (including authentication time if enabled).",
            "example": "32s"
          },
          "min_metadata_refresh_interval": {
            "default": "3s",
            "type": "string",
            "description": "Minimum time interval the client has to wait before refreshing Kafka broker and topic metadata. Setting too small value may add extra load on Kafka.",
            "example": "32s"
          },
          "metadata_request_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Maximum wait time when fetching topic metadata.",
            "example": "32s"
          },
          "authentication": {
            "default": "none",
            "description": "Authentication configs.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/bridge_kafka.auth_gssapi_kerberos"
              },
              {
                "$ref": "#/components/schemas/bridge_kafka.auth_username_password"
              },
              {
                "type": "string",
                "enum": [
                  "none"
                ]
              }
            ]
          },
          "socket_opts": {
            "description": "Extra socket options.",
            "$ref": "#/components/schemas/bridge_kafka.socket_opts"
          },
          "health_check_topic": {
            "type": "string",
            "description": "Topic name used exclusively for more accurate connector health checks."
          },
          "ssl": {
            "$ref": "#/components/schemas/bridge_kafka.ssl_client_opts"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_kafka.connector_resource_opts"
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in Kafka."
          },
          "kafka": {
            "description": "Kafka producer configs.",
            "$ref": "#/components/schemas/bridge_kafka.v1_producer_kafka_opts"
          }
        },
        "type": "object"
      },
      "schema_validation.check_json": {
        "required": [
          "schema"
        ],
        "properties": {
          "type": {
            "default": "json",
            "type": "string",
            "enum": [
              "json"
            ],
            "description": "JSON schema check"
          },
          "schema": {
            "type": "string",
            "description": "JSON schema check"
          }
        },
        "type": "object"
      },
      "resource_schema.creation_opts": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "maximum": 1024,
            "type": "integer",
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 1
          },
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "start_after_created": {
            "default": true,
            "type": "boolean",
            "description": "Whether start the resource right after created."
          },
          "start_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "example": "32s"
          },
          "auto_restart_interval": {
            "default": "15s",
            "deprecated": true,
            "oneOf": [
              {
                "type": "string",
                "example": "32s"
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "query_mode": {
            "default": "async",
            "type": "string",
            "enum": [
              "sync",
              "async"
            ],
            "description": "Query mode. Optional 'sync/async', default 'async'."
          },
          "request_ttl": {
            "default": "45s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "string",
                "example": "32s"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "type": "integer",
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1
          },
          "batch_size": {
            "default": 1,
            "type": "integer",
            "description": "Maximum batch count. If equal to 1, there's effectively no batching.",
            "minimum": 1
          },
          "batch_time": {
            "default": "0ms",
            "type": "string",
            "description": "Maximum waiting interval when accumulating a batch at a low message rates for more efficient resource usage.",
            "example": "32s"
          },
          "enable_queue": {
            "default": false,
            "type": "boolean",
            "deprecated": true,
            "description": "Enable disk buffer queue (only applicable for egress bridges).<br/>When Enabled, messages will be buffered on disk when the bridge connection is down.<br/>When disabled the messages are buffered in RAM only."
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "type": "string",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB"
          }
        },
        "type": "object"
      },
      "bridge_timescale.post": {
        "required": [
          "database",
          "name",
          "server",
          "type",
          "username"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "timescale"
            ],
            "description": "The Bridge Type"
          },
          "name": {
            "type": "string",
            "description": "Bridge name."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "sql": {
            "default": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
            "type": "string",
            "format": "sql",
            "description": "SQL Template"
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to PostgreSQL. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The PostgreSQL default port 5432 is used if `[:Port]` is not specified."
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "confluent.get_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "confluent_producer"
            ],
            "description": "The type of the action."
          },
          "name": {
            "type": "string",
            "description": "Action name, used as a human-readable description of the action."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in Confluent."
          },
          "parameters": {
            "description": "Confluent producer configs.",
            "$ref": "#/components/schemas/confluent.producer_kafka_opts"
          },
          "resource_opts": {
            "default": {},
            "$ref": "#/components/schemas/bridge_kafka.resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_gcp_pubsub.consumer_topic_mapping": {
        "required": [
          "mqtt_topic",
          "pubsub_topic"
        ],
        "properties": {
          "pubsub_topic": {
            "type": "string",
            "description": "GCP PubSub topic to consume from."
          },
          "mqtt_topic": {
            "type": "string",
            "description": "Local topic to which consumed GCP PubSub messages should be published to."
          },
          "qos": {
            "default": 0,
            "maximum": 2,
            "type": "integer",
            "description": "MQTT QoS level applied when publishing messages that are consumed from GCP PubSub.",
            "minimum": 0,
            "example": 0
          },
          "payload_template": {
            "default": "${.}",
            "type": "string",
            "description": "The template for transforming the incoming GCP PubSub message.  By default, it will use JSON format to serialize inputs from the GCP PubSub message.  Available fields are:<br/><code>message_id</code>: the message ID assigned by GCP PubSub.<br/><code>publish_time</code>: message timestamp assigned by GCP PubSub.<br/><code>topic</code>: GCP PubSub topic.<br/><code>value</code>: the payload of the GCP PubSub message.  Omitted if there's no payload.<br/><code>attributes</code>: an object containing string key-value pairs.  Omitted if there are no attributes.<br/><code>ordering_key</code>: GCP PubSub message ordering key.  Omitted if there's none."
          }
        },
        "type": "object"
      },
      "bridge_s3.s3_upload_resource_opts": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "maximum": 1024,
            "type": "integer",
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 1
          },
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "query_mode": {
            "default": "async",
            "type": "string",
            "enum": [
              "sync",
              "async"
            ],
            "description": "Query mode. Optional 'sync/async', default 'async'."
          },
          "request_ttl": {
            "default": "45s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "string",
                "example": "32s"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "type": "integer",
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1
          },
          "batch_size": {
            "default": 100,
            "type": "integer",
            "description": "Maximum batch count. If equal to 1, there's effectively no batching.",
            "minimum": 1
          },
          "batch_time": {
            "default": "10ms",
            "type": "string",
            "description": "Maximum waiting interval when accumulating a batch at a low message rates for more efficient resource usage.",
            "example": "32s"
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "type": "string",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB"
          }
        },
        "type": "object"
      },
      "bridge_sqlserver.put": {
        "required": [
          "database",
          "server"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "sql": {
            "default": "insert into t_mqtt_msg(msgid, topic, qos, payload) values ( ${id}, ${topic}, ${qos}, ${payload} )",
            "type": "string",
            "format": "sql",
            "description": "SQL Template"
          },
          "local_topic": {
            "type": "string",
            "description": "The MQTT topic filter to be forwarded to Microsoft SQL Server. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_sqlserver.creation_opts"
          },
          "driver": {
            "default": "ms-sql",
            "type": "string",
            "description": "SQL Server Driver Name"
          },
          "server": {
            "type": "string",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The SQL Server default port 1433 is used if `[:Port]` is not specified."
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "default": "sa",
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "auto_reconnect": {
            "default": true,
            "type": "boolean",
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database."
          }
        },
        "type": "object"
      },
      "bridge_gcp_pubsub.get_consumer": {
        "required": [
          "consumer",
          "name",
          "resource_opts",
          "service_account_json",
          "type"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "gcp_pubsub_consumer"
            ],
            "description": "The action type."
          },
          "name": {
            "type": "string",
            "description": "Action name, used as a human-readable identifier."
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this bridge"
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "description": "Creation options.",
            "$ref": "#/components/schemas/bridge_gcp_pubsub.consumer_resource_opts"
          },
          "connect_timeout": {
            "default": "15s",
            "type": "string",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s"
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "The pool size.",
            "minimum": 1
          },
          "pipelining": {
            "default": 100,
            "type": "integer",
            "description": "A positive integer. Whether to send HTTP requests continuously, when set to 1, it means that after each HTTP request is sent, you need to wait for the server to return and then continue to send the next request.",
            "minimum": 1
          },
          "max_retries": {
            "default": 2,
            "type": "integer",
            "description": "Max retry times if an error occurs when sending a request.",
            "minimum": 0
          },
          "request_timeout": {
            "default": "15s",
            "type": "string",
            "deprecated": true,
            "example": "32s"
          },
          "service_account_json": {
            "type": "string",
            "description": "JSON containing the GCP Service Account credentials to be used with PubSub.<br/>When a GCP Service Account is created (as described in https://developers.google.com/identity/protocols/oauth2/service-account#creatinganaccount), you have the option of downloading the credentials in JSON form.  That's the file needed."
          },
          "consumer": {
            "description": "Local MQTT publish and GCP PubSub consumer configs.",
            "$ref": "#/components/schemas/bridge_gcp_pubsub.consumer"
          }
        },
        "type": "object"
      },
      "cluster_link.link_config_response": {
        "required": [
          "name",
          "server",
          "topics"
        ],
        "properties": {
          "node": {
            "type": "string"
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ]
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable a cluster link. The link is enabled by default, disabling it allows stopping the link without removing its configuration. The link must be enabled on both sides to be operational. Disabling the link should also be done on both clusters in order to free up all associated resources."
          },
          "name": {
            "type": "string",
            "description": "Linked (remote) cluster name. Must be exactly equal to the value of `cluster.name` configured at the remote cluster. Must not be equal to the local cluster.name. All configured cluster link names must be unique."
          },
          "server": {
            "type": "string",
            "description": "MQTT host and port of the remote EMQX broker."
          },
          "clientid": {
            "type": "string",
            "description": "Optional Base MQTT client ID for connecting to the remote EMQX cluster. If omitted, local `cluster.name` is used. EMQX maintains several connections between linked clusters, so distinct suffixes are automatically appended to the base client ID."
          },
          "username": {
            "type": "string",
            "description": "Optional MQTT username for connecting to the remote EMQX cluster."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "Optional MQTT username for connecting to the remote EMQX cluster.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL configuration for connecting to the remote EMQX cluster.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "topics": {
            "type": "array",
            "description": "MQTT topics to be forwarded by the linked remote EMQX broker to the local broker. Messages are only forwarded if the local EMQX broker has matching subscriber(s).<br/>Wildcards are supported. Setting empty topics list on one side of the link can be used to establish unidirectional links: the side with the empty topics won't receive remote messages, but it can forward relevant messages to its linked counterpart (according to the topics configured on that side of the link).",
            "items": {
              "type": "string"
            }
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the pool of MQTT clients that will publish messages to the linked EMQX broker.",
            "minimum": 1
          },
          "retry_interval": {
            "default": "15s",
            "type": "string",
            "description": "MQTT Message retry interval. Delay for the link to retry sending the QoS1/QoS2 messages in case of ACK not received. Time interval is a string that contains a number followed by time unit:<br/>- `ms` for milliseconds,<br/>- `s` for seconds,<br/>- `m` for minutes,<br/>- `h` for hours;<br/><br/>or combination of whereof: `1h5m0s`"
          },
          "max_inflight": {
            "default": 32,
            "type": "integer",
            "description": "Max inflight (sent, but un-acked) messages of the MQTT protocol",
            "minimum": 0
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/cluster.creation_opts"
          }
        },
        "type": "object"
      },
      "bridge_influxdb.get_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "influxdb"
            ]
          },
          "name": {
            "type": "string"
          },
          "status": {
            "type": "string",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason": {
            "type": "string",
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused"
          },
          "node_status": {
            "type": "array",
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            }
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Additional parameters specific to this action type",
            "$ref": "#/components/schemas/bridge_influxdb.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/actions_and_sources.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_clickhouse.action_parameters": {
        "properties": {
          "sql": {
            "default": "INSERT INTO messages(data, arrived) VALUES ('${payload}', ${timestamp})",
            "type": "string",
            "format": "sql",
            "description": "The template string can contain ${field} placeholders for message metadata and payload field. Make sure that the inserted values are formatted and escaped correctly. [Prepared Statement](https://docs.emqx.com/en/enterprise/v5.0/data-integration/data-bridges.html#Prepared-Statement) is not supported."
          },
          "batch_value_separator": {
            "default": ", ",
            "type": "string",
            "description": "The default value ',' works for the VALUES format. You can also use other separator if other format is specified. See [INSERT INTO Statement](https://clickhouse.com/docs/en/sql-reference/statements/insert-into)."
          }
        },
        "type": "object"
      },
      "rule_engine.rule_events": {
        "required": [
          "event"
        ],
        "properties": {
          "event": {
            "type": "string",
            "enum": [
              "$events/client_connected",
              "$events/client_disconnected",
              "$events/client_connack",
              "$events/client_check_authz_complete",
              "$events/session_subscribed",
              "$events/session_unsubscribed",
              "$events/message_delivered",
              "$events/message_acked",
              "$events/message_dropped",
              "$events/message_transformation_failed",
              "$events/schema_validation_failed",
              "$events/delivery_dropped"
            ],
            "description": "The event topics"
          },
          "title": {
            "type": "string",
            "description": "The title",
            "example": "some title"
          },
          "description": {
            "type": "string",
            "description": "The description",
            "example": "some desc"
          },
          "columns": {
            "type": "object",
            "description": "The columns",
            "example": {}
          },
          "test_columns": {
            "type": "object",
            "description": "The test columns",
            "example": {}
          },
          "sql_example": {
            "type": "string",
            "description": "The sql_example"
          }
        },
        "type": "object"
      },
      "bridge_mqtt_publisher.put_bridge_v2": {
        "required": [
          "connector",
          "parameters"
        ],
        "properties": {
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Action specific configs.",
            "$ref": "#/components/schemas/bridge_mqtt_publisher.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_mqtt_publisher.action_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_pulsar.put_producer": {
        "required": [
          "pulsar_topic",
          "servers"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this Pulsar bridge."
          },
          "servers": {
            "type": "string",
            "description": "A comma separated list of Pulsar URLs in the form <code>scheme://host[:port]</code><br/> for the client to connect to. The supported schemes are <code>pulsar://</code> (default)<br/> and <code>pulsar+ssl://</code>. The default port is 6650."
          },
          "authentication": {
            "default": "none",
            "description": "Authentication configs.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/bridge_pulsar.auth_token"
              },
              {
                "$ref": "#/components/schemas/bridge_pulsar.auth_basic"
              },
              {
                "type": "string",
                "enum": [
                  "none"
                ]
              }
            ]
          },
          "connect_timeout": {
            "default": "5s",
            "type": "string",
            "description": "Maximum wait time for TCP connection establishment (including authentication time if enabled).",
            "example": "32s"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "message": {
            "description": "Template to render a Pulsar message.",
            "$ref": "#/components/schemas/pulsar.producer_pulsar_message"
          },
          "sync_timeout": {
            "default": "3s",
            "type": "string",
            "description": "Maximum wait time for receiving a receipt from Pulsar when publishing synchronously.",
            "example": "32s"
          },
          "pulsar_topic": {
            "type": "string",
            "description": "Pulsar topic name"
          },
          "batch_size": {
            "default": 100,
            "type": "integer",
            "description": "Maximum number of individual requests to batch in a Pulsar message.",
            "minimum": 1
          },
          "compression": {
            "default": "no_compression",
            "type": "string",
            "enum": [
              "no_compression",
              "snappy",
              "zlib"
            ],
            "description": "Compression method."
          },
          "send_buffer": {
            "default": "1MB",
            "type": "string",
            "description": "Fine tune the socket send buffer. The default value is tuned for high throughput.",
            "example": "32MB"
          },
          "retention_period": {
            "default": "infinity",
            "description": "The amount of time messages will be buffered while there is no connection to<br/> the Pulsar broker.  Longer times mean that more memory/disk will be used",
            "oneOf": [
              {
                "type": "string",
                "example": "32s"
              },
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              }
            ]
          },
          "max_batch_bytes": {
            "default": "900KB",
            "type": "string",
            "description": "Maximum bytes to collect in a Pulsar message batch. Most of the Pulsar brokers<br/> default to a limit of 5 MB batch size. EMQX's default value is less than 5 MB in<br/> order to compensate Pulsar message encoding overheads (especially when each individual<br/> message is very small). When a single message is over the limit, it is still<br/> sent (as a single element batch).",
            "example": "32MB"
          },
          "strategy": {
            "default": "random",
            "type": "string",
            "enum": [
              "random",
              "roundrobin",
              "key_dispatch"
            ],
            "description": "Partition strategy is to tell the producer how to dispatch messages to Pulsar partitions.<br/><br/><code>random</code>: Randomly pick a partition for each message.<br/><code>roundrobin</code>: Pick each available producer in turn for each message.<br/><code>key_dispatch</code>: Hash Pulsar message key of the first message in a batch<br/> to a partition number."
          },
          "buffer": {
            "description": "Configure producer message buffer.\"<br/>Tell Pulsar producer how to buffer messages when EMQX has more messages to\"<br/> send than Pulsar can keep up, or when Pulsar is down.",
            "$ref": "#/components/schemas/bridge_pulsar.producer_buffer"
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (bridge input)<br/> If rule action is used as data source, this config should be left empty,<br/> otherwise messages will be duplicated in Pulsar."
          },
          "resource_opts": {
            "description": "Creation options.",
            "$ref": "#/components/schemas/bridge_pulsar.producer_resource_opts"
          }
        },
        "type": "object"
      },
      "bridge_mongodb.put_sharded": {
        "required": [
          "database",
          "mongo_type",
          "resource_opts",
          "servers"
        ],
        "properties": {
          "mongo_type": {
            "default": "sharded",
            "type": "string",
            "enum": [
              "sharded"
            ],
            "description": "Sharded cluster. Must be set to 'sharded' when MongoDB server is running in 'sharded' mode."
          },
          "servers": {
            "type": "string",
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The MongoDB default port 27017 is used if `[:Port]` is not specified."
          },
          "w_mode": {
            "default": "unsafe",
            "type": "string",
            "enum": [
              "unsafe",
              "safe"
            ],
            "description": "Write mode."
          },
          "srv_record": {
            "default": false,
            "type": "boolean",
            "description": "Use DNS SRV record."
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1
          },
          "username": {
            "type": "string",
            "description": "The username associated with the bridge in the external database used for authentication or identification purposes."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "The password associated with the bridge, used for authentication with the external database.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "use_legacy_protocol": {
            "default": "auto",
            "type": "string",
            "enum": [
              "auto",
              true,
              false
            ],
            "description": "Whether to use MongoDB's legacy protocol for communicating with the database.  The default is to attempt to automatically determine if the newer protocol is supported."
          },
          "auth_source": {
            "type": "string",
            "description": "Database name associated with the user's credentials."
          },
          "database": {
            "type": "string",
            "description": "Database name."
          },
          "topology": {
            "$ref": "#/components/schemas/mongo.topology"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable this MongoDB Action"
          },
          "collection": {
            "default": "mqtt",
            "type": "string",
            "description": "The collection where data will be stored into"
          },
          "payload_template": {
            "type": "string",
            "description": "The template for formatting the outgoing messages.  If undefined, rule engine will use JSON format to serialize all visible inputs, such as clientid, topic, payload etc."
          },
          "resource_opts": {
            "description": "Creation options.",
            "$ref": "#/components/schemas/bridge_mongodb.creation_opts"
          }
        },
        "type": "object"
      },
      "bridge_iotdb.action_resource_opts": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "maximum": 1024,
            "type": "integer",
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 1
          },
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "query_mode": {
            "default": "async",
            "type": "string",
            "enum": [
              "sync",
              "async"
            ],
            "description": "Query mode. Optional 'sync/async', default 'async'."
          },
          "request_ttl": {
            "default": "45s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "string",
                "example": "32s"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "type": "integer",
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1
          },
          "batch_size": {
            "default": 1,
            "type": "integer",
            "description": "Maximum batch count. If equal to 1, there's effectively no batching.",
            "minimum": 1
          },
          "batch_time": {
            "default": "0ms",
            "type": "string",
            "description": "Maximum waiting interval when accumulating a batch at a low message rates for more efficient resource usage.",
            "example": "32s"
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "type": "string",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB"
          }
        },
        "type": "object"
      },
      "bridge_http.parameters_opts": {
        "properties": {
          "path": {
            "type": "string",
            "description": "The URL path for this Action.<br/><br/>This path will be appended to the Connector's <code>url</code> configuration to form the full<br/>URL address.<br/>Template with variables is allowed in this option. For example, <code>/room/{$room_no}</code>"
          },
          "method": {
            "default": "post",
            "type": "string",
            "enum": [
              "post",
              "put",
              "get",
              "delete"
            ],
            "description": "The method of the HTTP request. All the available methods are: post, put, get, delete.<br/><br/>Template with variables is allowed."
          },
          "headers": {
            "default": {
              "accept": "application/json",
              "cache-control": "no-cache",
              "connection": "keep-alive",
              "content-type": "application/json",
              "keep-alive": "timeout=5"
            },
            "type": "object",
            "description": "The headers of the HTTP request.<br/><br/>Template with variables is allowed.",
            "example": {},
            "is_template": true
          },
          "body": {
            "type": "string",
            "description": "The body of the HTTP request.<br/><br/>If not provided, the body will be a JSON object of all the available fields.<br/><br/>There, 'all the available fields' means the context of a MQTT message when<br/>this webhook is triggered by receiving a MQTT message (the `local_topic` is set),<br/>or the context of the event when this webhook is triggered by a rule (i.e. this<br/>webhook is used as an action of a rule).<br/><br/>Template with variables is allowed."
          },
          "max_retries": {
            "default": 2,
            "type": "integer",
            "description": "HTTP request max retry times if failed.",
            "minimum": 0
          },
          "request_timeout": {
            "default": "15s",
            "type": "string",
            "deprecated": true,
            "description": "HTTP request timeout.",
            "example": "32s"
          }
        },
        "type": "object"
      },
      "bridge_mongodb.post_bridge_v2": {
        "required": [
          "connector",
          "name",
          "parameters",
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "mongodb"
            ]
          },
          "name": {
            "type": "string"
          },
          "local_topic": {
            "type": "string",
            "description": "MQTT topic or topic filter as data source (action input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in the remote system."
          },
          "parameters": {
            "description": "Additional parameters specific to this action type",
            "$ref": "#/components/schemas/bridge_mongodb.action_parameters"
          },
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable (true) or disable (false) this action."
          },
          "connector": {
            "type": "string",
            "description": "Name of the connector specified by the action, used for external resource selection."
          },
          "tags": {
            "type": "array",
            "description": "Tags to annotate this config entry.",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "default": "",
            "type": "string",
            "description": "Descriptive text."
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/bridge_mongodb.action_resource_opts"
          }
        },
        "type": "object"
      },
      "rocketmq.action_parameters": {
        "properties": {
          "template": {
            "default": "",
            "type": "string",
            "description": "Template, the default value is empty. When this value is empty the whole message will be stored in the RocketMQ.<br><br/>            The template can be any valid string with placeholders, example:<br><br/>            - ${id}, ${username}, ${clientid}, ${timestamp}<br><br/>            - {\"id\" : ${id}, \"username\" : ${username}}"
          },
          "strategy": {
            "default": "roundrobin",
            "description": "Producer key dispatch strategy, the default is `roundrobin`, also supports placeholders, such as: `clientid`, `messageid`, `username`.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "string",
                "enum": [
                  "roundrobin"
                ]
              }
            ]
          },
          "topic": {
            "default": "TopicTest",
            "type": "string",
            "description": "RocketMQ Topic"
          },
          "sync_timeout": {
            "default": "3s",
            "type": "string",
            "description": "Timeout of RocketMQ driver synchronous call.",
            "example": "12m"
          },
          "refresh_interval": {
            "default": "3s",
            "type": "string",
            "description": "RocketMQ Topic Route Refresh Interval.",
            "example": "12m"
          },
          "send_buffer": {
            "default": "1024KB",
            "type": "string",
            "description": "The socket send buffer size of the RocketMQ driver client.",
            "example": "32MB"
          }
        },
        "type": "object"
      },
      "cluster.link": {
        "required": [
          "name",
          "server",
          "topics"
        ],
        "properties": {
          "enable": {
            "default": true,
            "type": "boolean",
            "description": "Enable or disable a cluster link. The link is enabled by default, disabling it allows stopping the link without removing its configuration. The link must be enabled on both sides to be operational. Disabling the link should also be done on both clusters in order to free up all associated resources."
          },
          "name": {
            "type": "string",
            "description": "Linked (remote) cluster name. Must be exactly equal to the value of `cluster.name` configured at the remote cluster. Must not be equal to the local cluster.name. All configured cluster link names must be unique."
          },
          "server": {
            "type": "string",
            "description": "MQTT host and port of the remote EMQX broker."
          },
          "clientid": {
            "type": "string",
            "description": "Optional Base MQTT client ID for connecting to the remote EMQX cluster. If omitted, local `cluster.name` is used. EMQX maintains several connections between linked clusters, so distinct suffixes are automatically appended to the base client ID."
          },
          "username": {
            "type": "string",
            "description": "Optional MQTT username for connecting to the remote EMQX cluster."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "Optional MQTT username for connecting to the remote EMQX cluster.",
            "example": "R4ND0M/S∃CЯ∃T"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL configuration for connecting to the remote EMQX cluster.",
            "$ref": "#/components/schemas/emqx.ssl_client_opts"
          },
          "topics": {
            "type": "array",
            "description": "MQTT topics to be forwarded by the linked remote EMQX broker to the local broker. Messages are only forwarded if the local EMQX broker has matching subscriber(s).<br/>Wildcards are supported. Setting empty topics list on one side of the link can be used to establish unidirectional links: the side with the empty topics won't receive remote messages, but it can forward relevant messages to its linked counterpart (according to the topics configured on that side of the link).",
            "items": {
              "type": "string"
            }
          },
          "pool_size": {
            "default": 8,
            "type": "integer",
            "description": "Size of the pool of MQTT clients that will publish messages to the linked EMQX broker.",
            "minimum": 1
          },
          "retry_interval": {
            "default": "15s",
            "type": "string",
            "description": "MQTT Message retry interval. Delay for the link to retry sending the QoS1/QoS2 messages in case of ACK not received. Time interval is a string that contains a number followed by time unit:<br/>- `ms` for milliseconds,<br/>- `s` for seconds,<br/>- `m` for minutes,<br/>- `h` for hours;<br/><br/>or combination of whereof: `1h5m0s`"
          },
          "max_inflight": {
            "default": 32,
            "type": "integer",
            "description": "Max inflight (sent, but un-acked) messages of the MQTT protocol",
            "minimum": 0
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "$ref": "#/components/schemas/cluster.creation_opts"
          }
        },
        "type": "object"
      },
      "bridge_pulsar.auth_basic": {
        "required": [
          "password",
          "username"
        ],
        "properties": {
          "username": {
            "type": "string",
            "description": "Basic authentication username. The `username` part of the `username:password` authentication string."
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "Basic authentication password. The `password` part of the `username:password` authentication string.",
            "example": "R4ND0M/S∃CЯ∃T"
          }
        },
        "type": "object"
      },
      "actions_and_sources.action_resource_opts": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "maximum": 1024,
            "type": "integer",
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 1
          },
          "health_check_interval": {
            "default": "15s",
            "type": "string",
            "description": "Health check interval.",
            "example": "32s"
          },
          "query_mode": {
            "default": "async",
            "type": "string",
            "enum": [
              "sync",
              "async"
            ],
            "description": "Query mode. Optional 'sync/async', default 'async'."
          },
          "request_ttl": {
            "default": "45s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "infinity"
                ]
              },
              {
                "type": "string",
                "example": "32s"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "type": "integer",
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1
          },
          "batch_size": {
            "default": 1,
            "type": "integer",
            "description": "Maximum batch count. If equal to 1, there's effectively no batching.",
            "minimum": 1
          },
          "batch_time": {
            "default": "0ms",
            "type": "string",
            "description": "Maximum waiting interval when accumulating a batch at a low message rates for more efficient resource usage.",
            "example": "32s"
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "type": "string",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB"
          }
        },
        "type": "object"
      }
    },
    "securitySchemes": {
      "bearerAuth": {
        "scheme": "bearer",
        "type": "http",
        "description": "Authorize with Bearer Token"
      },
      "basicAuth": {
        "scheme": "basic",
        "type": "http",
        "description": "Authorize with [API Keys](https://www.emqx.io/docs/en/v5.0/admin/api.html#api-keys)"
      }
    }
  },
  "paths": {
    "/plugins/{name}/schema": {
      "get": {
        "description": "Get plugin's config AVRO schema.",
        "tags": [
          "Plugins"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/plugins.name"
          }
        ],
        "summary": "Get installed plugin's AVRO schema",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "FILE_NOT_EXISTED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Plugin Not Found or Plugin not given a schema file"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/authentication/{id}/position/{position}": {
      "put": {
        "description": "Move authenticator in global authentication chain.",
        "tags": [
          "Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Authenticator ID.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "position",
            "description": "Position of authenticator in chain. Possible values are 'front', 'rear', 'before:{other_authenticator}', 'after:{other_authenticator}'.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "before:password_based:built_in_database"
          }
        ],
        "responses": {
          "204": {
            "description": "Authenticator moved"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/actions/{id}/metrics/reset": {
      "put": {
        "description": "Reset a bridge metrics by id.",
        "tags": [
          "Actions"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_action"
          }
        ],
        "summary": "Reset action metrics",
        "responses": {
          "204": {
            "description": "Reset success"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Action not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/metrics": {
      "get": {
        "description": "EMQX metrics",
        "tags": [
          "Metrics"
        ],
        "parameters": [
          {
            "in": "query",
            "name": "aggregate",
            "description": "Whether to aggregate all nodes Metrics",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/emqx_mgmt_api_metrics.node_metrics"
                      }
                    },
                    {
                      "$ref": "#/components/schemas/emqx_mgmt_api_metrics.aggregated_metrics"
                    }
                  ]
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/authentication/{id}/users/{user_id}": {
      "get": {
        "description": "Get user from authenticator in global authentication chain.",
        "tags": [
          "Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Authenticator ID.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "user_id",
            "description": "User ID.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "regular_user": {
                    "value": {
                      "user_id": "user1"
                    },
                    "summary": "Regular user"
                  },
                  "super_user": {
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    },
                    "summary": "Superuser"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update user in authenticator in global authentication chain.",
        "tags": [
          "Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Authenticator ID.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "user_id",
            "description": "User ID.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "regular_user": {
                    "value": {
                      "user_id": "user1"
                    },
                    "summary": "Regular user"
                  },
                  "super_user": {
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    },
                    "summary": "Superuser"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "regular_user": {
                  "value": {
                    "password": "******"
                  },
                  "summary": "Update regular user"
                },
                "super_user": {
                  "value": {
                    "password": "******",
                    "is_superuser": true
                  },
                  "summary": "Update user and promote to superuser"
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authn_api.request_user_update"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete user in authenticator in global authentication chain.",
        "tags": [
          "Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Authenticator ID.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "user_id",
            "description": "User ID.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "User deleted"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/authentication/{id}/import_users": {
      "post": {
        "description": "Import users into authenticator in global authentication chain.",
        "tags": [
          "Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Authenticator ID.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "type",
            "description": "The import file template type, enum with `plain`,`hash`",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "plain",
                "hash"
              ]
            },
            "example": "hash"
          }
        ],
        "responses": {
          "204": {
            "description": "Users imported"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "description": "Import body",
          "content": {
            "multipart/form-data": {
              "schema": {
                "type": "object",
                "properties": {
                  "filename": {
                    "type": "string",
                    "format": "binary"
                  }
                }
              }
            },
            "application/json": {
              "schema": {
                "type": "object",
                "example": [
                  {
                    "is_superuser": true,
                    "password": "password1",
                    "user_id": "user1"
                  },
                  {
                    "is_superuser": false,
                    "password": "password2",
                    "user_id": "user2"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/actions/{id}/{operation}": {
      "post": {
        "description": "Start bridge on all nodes in the cluster.",
        "tags": [
          "Actions"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_action"
          },
          {
            "in": "path",
            "name": "operation",
            "description": "Operation can be one of: 'start'.",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "start"
              ]
            },
            "example": "start"
          }
        ],
        "summary": "Manually start a bridge",
        "responses": {
          "204": {
            "description": "Operation success"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Problem with configuration of external service"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bridge not found or invalid operation"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "501": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_IMPLEMENTED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Implemented"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Service unavailable"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/mqtt/delayed": {
      "get": {
        "description": "Get delayed status",
        "tags": [
          "MQTT"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/modules.delayed"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Enable or disable delayed, set max delayed messages",
        "tags": [
          "MQTT"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Enable or disable delayed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/modules.delayed"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Max limit illegality"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/modules.delayed"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/lwm2m/clients/{clientid}/observe": {
      "post": {
        "description": "Observe or Cancel observe a resource",
        "tags": [
          "LwM2M Gateways"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "urn:oma:lwm2m:oma:2"
          },
          {
            "in": "query",
            "name": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "/3/0/7"
          },
          {
            "in": "query",
            "name": "enable",
            "required": true,
            "schema": {
              "type": "boolean"
            },
            "example": true
          }
        ],
        "summary": "Observe a Resource",
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "CLIENT_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Clientid not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/schema_validations/validation/{name}/metrics": {
      "get": {
        "description": "Get metrics for a particular validation",
        "tags": [
          "Schema Validation"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Validation name",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "my_validation"
          }
        ],
        "summary": "Get validation metrics",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "metrics": {
                    "value": {
                      "metrics": {
                        "matched": 2,
                        "failed": 1,
                        "succeeded": 1,
                        "rate": 1.23,
                        "rate_last5m": 0.88,
                        "rate_max": 1.87
                      },
                      "node_metrics": [
                        {
                          "node": "emqx@127.0.0.1",
                          "metrics": {
                            "matched": 2,
                            "failed": 1,
                            "succeeded": 1,
                            "rate": 1.23,
                            "rate_last5m": 0.88,
                            "rate_max": 1.87
                          }
                        }
                      ]
                    },
                    "summary": "Metrics"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/schema_validation_http_api.get_metrics"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Validation not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/plugins/{name}": {
      "get": {
        "description": "Describe a plugin according to its `release.json` and `README.md`.",
        "tags": [
          "Plugins"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/plugins.name"
          }
        ],
        "summary": "Get a plugin description",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/plugins.plugin"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Plugin Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Uninstalls a previously uploaded plugin package.",
        "tags": [
          "Plugins"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/plugins.name"
          }
        ],
        "summary": "Delete a plugin",
        "responses": {
          "204": {
            "description": "Uninstall successfully"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "PARAM_ERROR"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad parameter"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Plugin Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/bridges/{id}/metrics/reset": {
      "put": {
        "description": "Reset a bridge metrics by Id",
        "tags": [
          "Bridges"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge Id. Must be of format {type}:{name}",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:http_example"
          }
        ],
        "summary": "Reset bridge metrics",
        "responses": {
          "204": {
            "description": "Reset success"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bridge not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/cluster/links/link/{name}/metrics": {
      "get": {
        "description": "Get a cluster link metrics",
        "tags": [
          "Cluster"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "my_link"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "metrics": {
                    "routes": 10240
                  },
                  "node_metrics": [
                    {
                      "metrics": {
                        "routes": 10240
                      },
                      "node": "emqx1@emqx.net"
                    }
                  ]
                },
                "schema": {
                  "$ref": "#/components/schemas/cluster_link.link_metrics_response"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Cluster link not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/status": {
      "get": {
        "description": "Serves as a health check for the node.<br/>Returns response to describe the status of the node and the application.<br/><br/>This endpoint requires no authentication.<br/><br/>Returns status code 200 if the EMQX application is up and running, 503 otherwise.<br/>This API was introduced in v5.0.10.<br/>The GET `/status` endpoint (without the `/api/...` prefix) is also an alias to this endpoint and works in the same way.<br/>This alias has been available since v5.0.0.<br/><br/>Starting from v5.0.25 or e5.0.4, you can also use 'format' parameter to get JSON format information.",
        "tags": [
          "Status"
        ],
        "parameters": [
          {
            "in": "query",
            "name": "format",
            "description": "Specify the response format, 'text' (default) to return the HTTP body in free text,<br/>or 'json' to return the HTTP body with a JSON object.",
            "schema": {
              "default": "text",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "If 'format' parameter is 'json', then it returns a JSON like below:<br/><br/>{<br/>  \"rel_vsn\": \"v5.0.23\",<br/>  \"node_name\": \"emqx@127.0.0.1\",<br/>  \"broker_status\": \"started\",<br/>  \"app_status\": \"running\"<br/>}<br/><br/><br/>Otherwise it returns free text strings as below:<br/><br/>Node emqx@127.0.0.1 is started<br/>emqx is running"
          },
          "503": {
            "description": "When EMQX application is temporary not running or being restarted, it may return 'emqx is not_running'.<br/>If the 'format' parameter is provided 'json', then the 'app_status' field in the JSON object will be 'not_running'."
          }
        },
        "security": []
      }
    },
    "/topics/{topic}": {
      "get": {
        "description": "Lookup topic info by name",
        "tags": [
          "Topics"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "topic",
            "description": "Topic Name",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": ""
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/emqx_mgmt_api_topics.topic"
                  }
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "TOPIC_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Topic not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/message_transformations": {
      "get": {
        "description": "List transformations",
        "tags": [
          "Message Transformation"
        ],
        "parameters": [],
        "summary": "List transformations",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "list": {
                    "value": [
                      {
                        "name": "my_transformation",
                        "description": "my transformation",
                        "tags": [
                          "transformation"
                        ],
                        "enable": true,
                        "topics": [
                          "t/+"
                        ],
                        "operations": [
                          {
                            "value": "concat([topic, '/', payload.t])",
                            "key": "topic"
                          }
                        ],
                        "failure_action": "drop",
                        "log_failure": {
                          "level": "info"
                        },
                        "payload_encoder": {
                          "type": "json"
                        },
                        "payload_decoder": {
                          "type": "json"
                        }
                      },
                      {
                        "name": "other_transformation",
                        "description": "my transformation",
                        "tags": [
                          "transformation"
                        ],
                        "enable": true,
                        "topics": [
                          "t/+"
                        ],
                        "operations": [
                          {
                            "value": "concat([topic, '/', payload.t])",
                            "key": "topic"
                          }
                        ],
                        "failure_action": "drop",
                        "log_failure": {
                          "level": "info"
                        },
                        "payload_encoder": {
                          "type": "json"
                        },
                        "payload_decoder": {
                          "type": "json"
                        }
                      }
                    ],
                    "summary": "List"
                  }
                },
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/message_transformation.transformation"
                    }
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update a transformation",
        "tags": [
          "Message Transformation"
        ],
        "parameters": [],
        "summary": "Update a transformation",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "update": {
                    "value": {
                      "name": "my_transformation",
                      "description": "my transformation",
                      "tags": [
                        "transformation"
                      ],
                      "enable": true,
                      "topics": [
                        "t/+"
                      ],
                      "operations": [
                        {
                          "value": "concat([topic, '/', payload.t])",
                          "key": "topic"
                        }
                      ],
                      "failure_action": "drop",
                      "log_failure": {
                        "level": "info"
                      },
                      "payload_encoder": {
                        "type": "json"
                      },
                      "payload_decoder": {
                        "type": "json"
                      }
                    },
                    "summary": "Update"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/message_transformation.transformation"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad params"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Transformation not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "update": {
                  "value": {
                    "name": "my_transformation",
                    "description": "my transformation",
                    "tags": [
                      "transformation"
                    ],
                    "enable": true,
                    "topics": [
                      "t/+"
                    ],
                    "operations": [
                      {
                        "value": "concat([topic, '/', payload.t])",
                        "key": "topic"
                      }
                    ],
                    "failure_action": "drop",
                    "log_failure": {
                      "level": "info"
                    },
                    "payload_encoder": {
                      "type": "json"
                    },
                    "payload_decoder": {
                      "type": "json"
                    }
                  },
                  "summary": "Update"
                }
              },
              "schema": {
                "$ref": "#/components/schemas/message_transformation.transformation"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Append a new transformation to the list of transformations",
        "tags": [
          "Message Transformation"
        ],
        "parameters": [],
        "summary": "Append a new transformation",
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "message_transformation": {
                    "value": {
                      "name": "my_transformation",
                      "description": "my transformation",
                      "tags": [
                        "transformation"
                      ],
                      "enable": true,
                      "topics": [
                        "t/+"
                      ],
                      "operations": [
                        {
                          "value": "concat([topic, '/', payload.t])",
                          "key": "topic"
                        }
                      ],
                      "failure_action": "drop",
                      "log_failure": {
                        "level": "info"
                      },
                      "payload_encoder": {
                        "type": "json"
                      },
                      "payload_decoder": {
                        "type": "json"
                      }
                    },
                    "summary": "Simple message transformation"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/message_transformation.transformation"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "ALREADY_EXISTS"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Transformation already exists"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "message_transformation": {
                  "value": {
                    "name": "my_transformation",
                    "description": "my transformation",
                    "tags": [
                      "transformation"
                    ],
                    "enable": true,
                    "topics": [
                      "t/+"
                    ],
                    "operations": [
                      {
                        "value": "concat([topic, '/', payload.t])",
                        "key": "topic"
                      }
                    ],
                    "failure_action": "drop",
                    "log_failure": {
                      "level": "info"
                    },
                    "payload_encoder": {
                      "type": "json"
                    },
                    "payload_decoder": {
                      "type": "json"
                    }
                  },
                  "summary": "Simple message transformation"
                }
              },
              "schema": {
                "$ref": "#/components/schemas/message_transformation.transformation"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/message_transformations/dryrun": {
      "post": {
        "description": "Test an input against a transformation",
        "tags": [
          "Message Transformation"
        ],
        "parameters": [],
        "summary": "Test an input against a configuration",
        "responses": {
          "200": {
            "description": "TODO"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "test": {
                  "value": {
                    "message": {
                      "retain": true,
                      "user_property": {},
                      "payload": "{}",
                      "client_attrs": {},
                      "topic": "t/u/v",
                      "qos": 2
                    },
                    "transformation": {
                      "name": "my_transformation",
                      "description": "my transformation",
                      "tags": [
                        "transformation"
                      ],
                      "enable": true,
                      "topics": [
                        "t/+"
                      ],
                      "operations": [
                        {
                          "value": "concat([topic, '/', payload.t])",
                          "key": "topic"
                        }
                      ],
                      "failure_action": "drop",
                      "log_failure": {
                        "level": "info"
                      },
                      "payload_encoder": {
                        "type": "json"
                      },
                      "payload_decoder": {
                        "type": "json"
                      }
                    }
                  },
                  "summary": "Test an input against a configuration"
                }
              },
              "schema": {
                "$ref": "#/components/schemas/message_transformation_http_api.dryrun_transformation"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/file_transfer/file": {
      "get": {
        "description": "Get a file by its id.",
        "tags": [
          "File Transfer"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/file_transfer.file_node"
          },
          {
            "$ref": "#/components/parameters/file_transfer.file_ref"
          }
        ],
        "summary": "Download a particular file",
        "responses": {
          "200": {
            "description": "Operation success"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Service unavailable"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/stats": {
      "get": {
        "description": "EMQX stats",
        "tags": [
          "Metrics"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_mgmt_api_stats.aggregate"
          }
        ],
        "responses": {
          "200": {
            "description": "List stats ok",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/emqx_mgmt_api_stats.aggregated_data"
                    },
                    {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/emqx_mgmt_api_stats.per_node_data"
                      }
                    }
                  ]
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/monitor_current": {
      "get": {
        "description": "Current monitor (statistics) data, e.g. number of connections and connection rate in the whole cluster.",
        "tags": [
          "Metrics"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_dashboard_monitor_api.sampler_current"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/authorization/sources/built_in_database/rules/users": {
      "get": {
        "description": "Show the list of rules for users",
        "tags": [
          "Authorization"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          },
          {
            "in": "query",
            "name": "like_username",
            "description": "Fuzzy search `username` as substring",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "password_based:built_in_database": {
                    "value": {
                      "data": [
                        {
                          "rules": [
                            {
                              "action": "publish",
                              "permission": "allow",
                              "topic": "test/topic/1"
                            },
                            {
                              "action": "subscribe",
                              "permission": "allow",
                              "topic": "test/topic/2"
                            },
                            {
                              "action": "all",
                              "permission": "deny",
                              "topic": "eq test/#"
                            },
                            {
                              "action": "publish",
                              "retain": "true",
                              "permission": "allow",
                              "topic": "test/topic/3",
                              "qos": [
                                "1"
                              ]
                            },
                            {
                              "action": "publish",
                              "retain": "all",
                              "permission": "allow",
                              "topic": "test/topic/4",
                              "qos": [
                                "0",
                                "1",
                                "2"
                              ]
                            }
                          ],
                          "username": "user1"
                        }
                      ],
                      "meta": {
                        "count": 1,
                        "limit": 100,
                        "page": 1
                      }
                    },
                    "summary": "Username"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authz_api_mnesia.username_response_data"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Add new rule for 'username'",
        "tags": [
          "Authorization"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": "Created"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad username or bad rule schema"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "409": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "ALREADY_EXISTS"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "ALREADY_EXISTS"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "password_based:built_in_database": {
                  "value": [
                    {
                      "rules": [
                        {
                          "action": "publish",
                          "permission": "allow",
                          "topic": "test/topic/1"
                        },
                        {
                          "action": "subscribe",
                          "permission": "allow",
                          "topic": "test/topic/2"
                        },
                        {
                          "action": "all",
                          "permission": "deny",
                          "topic": "eq test/#"
                        },
                        {
                          "action": "publish",
                          "retain": "true",
                          "permission": "allow",
                          "topic": "test/topic/3",
                          "qos": [
                            "1"
                          ]
                        },
                        {
                          "action": "publish",
                          "retain": "all",
                          "permission": "allow",
                          "topic": "test/topic/4",
                          "qos": [
                            "0",
                            "1",
                            "2"
                          ]
                        }
                      ],
                      "username": "user1"
                    }
                  ],
                  "summary": "Username"
                }
              },
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/emqx_authz_api_mnesia.rules_for_username"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/message_transformations/transformation/{name}/metrics": {
      "get": {
        "description": "Get metrics for a particular transformation",
        "tags": [
          "Message Transformation"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Transformation name",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "my_transformation"
          }
        ],
        "summary": "Get transformation metrics",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "metrics": {
                    "value": {
                      "metrics": {
                        "matched": 2,
                        "failed": 1,
                        "succeeded": 1,
                        "rate": 1.23,
                        "rate_last5m": 0.88,
                        "rate_max": 1.87
                      },
                      "node_metrics": [
                        {
                          "node": "emqx@127.0.0.1",
                          "metrics": {
                            "matched": 2,
                            "failed": 1,
                            "succeeded": 1,
                            "rate": 1.23,
                            "rate_last5m": 0.88,
                            "rate_max": 1.87
                          }
                        }
                      ]
                    },
                    "summary": "Metrics"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/message_transformation_http_api.get_metrics"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Transformation not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/nodes/{node}/stats": {
      "get": {
        "description": "Get node run-time stats. Such as the number of topics, connections, etc.",
        "tags": [
          "Nodes"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_mgmt_api_nodes.node_name"
          }
        ],
        "responses": {
          "200": {
            "description": "Get node stats successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_stats.aggregated_data"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Node not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/exhooks/{name}": {
      "get": {
        "description": "Get the detail information of Exhook server",
        "tags": [
          "ExHook"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "The Exhook server name",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "default"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/exhook.detail_server_info"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Server not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update the server",
        "tags": [
          "ExHook"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "The Exhook server name",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "default"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/exhook.detail_server_info"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Server not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "500": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_RPC"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad RPC"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "example": {
                "name": "default",
                "ssl": {
                  "cacertfile": "/etc/emqx/certs/cacert.pem",
                  "certfile": "/etc/emqx/certs/cert.pem",
                  "keyfile": "/etc/emqx/certs/key.pem",
                  "enable": false
                },
                "pool_size": 8,
                "enable": true,
                "url": "http://127.0.0.1:8081",
                "request_timeout": "5s",
                "auto_reconnect": "60s",
                "failed_action": "deny"
              },
              "schema": {
                "$ref": "#/components/schemas/exhook.server_config"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete the server",
        "tags": [
          "ExHook"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "The Exhook server name",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "default"
          }
        ],
        "responses": {
          "204": {
            "description": ""
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Server not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "500": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_RPC"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad RPC"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/prometheus": {
      "get": {
        "description": "Get Prometheus config info",
        "tags": [
          "Monitor"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "collectors": {
                    "mnesia": "disabled",
                    "vm_dist": "disabled",
                    "vm_memory": "disabled",
                    "vm_msacc": "disabled",
                    "vm_statistics": "disabled",
                    "vm_system_info": "disabled"
                  },
                  "enable_basic_auth": false,
                  "push_gateway": {
                    "interval": "15s",
                    "headers": {
                      "Authorization": "Basic YWRtaW46Y2JraG55eWd5QDE="
                    },
                    "url": "http://127.0.0.1:9091",
                    "job_name": "${name}/instance/${name}~${host}"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/prometheus.recommend_setting"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update Prometheus config",
        "tags": [
          "Monitor"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "collectors": {
                    "mnesia": "disabled",
                    "vm_dist": "disabled",
                    "vm_memory": "disabled",
                    "vm_msacc": "disabled",
                    "vm_statistics": "disabled",
                    "vm_system_info": "disabled"
                  },
                  "enable_basic_auth": false,
                  "push_gateway": {
                    "interval": "15s",
                    "headers": {
                      "Authorization": "Basic YWRtaW46Y2JraG55eWd5QDE="
                    },
                    "url": "http://127.0.0.1:9091",
                    "job_name": "${name}/instance/${name}~${host}"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/prometheus.recommend_setting"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "recommend_setting": {
                  "value": {
                    "collectors": {
                      "mnesia": "disabled",
                      "vm_dist": "disabled",
                      "vm_memory": "disabled",
                      "vm_msacc": "disabled",
                      "vm_statistics": "disabled",
                      "vm_system_info": "disabled"
                    },
                    "enable_basic_auth": false,
                    "push_gateway": {
                      "interval": "15s",
                      "headers": {
                        "Authorization": "Basic YWRtaW46Y2JraG55eWd5QDE="
                      },
                      "url": "http://127.0.0.1:9091",
                      "job_name": "${name}/instance/${name}~${host}"
                    }
                  },
                  "summary": "recommend_setting"
                },
                "legacy_deprecated_setting": {
                  "value": {
                    "enable": true,
                    "interval": "15s",
                    "headers": {
                      "Authorization": "Basic YWRtaW46Y2JraG55eWd5QDE="
                    },
                    "push_gateway_server": "http://127.0.0.1:9091",
                    "job_name": "${name}/instance/${name}~${host}",
                    "mnesia_collector": "disabled",
                    "vm_dist_collector": "disabled",
                    "vm_memory_collector": "disabled",
                    "vm_msacc_collector": "disabled",
                    "vm_statistics_collector": "disabled",
                    "vm_system_info_collector": "disabled"
                  },
                  "summary": "legacy_deprecated_setting"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/prometheus.legacy_deprecated_setting"
                  },
                  {
                    "$ref": "#/components/schemas/prometheus.recommend_setting"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/mqtt/auto_subscribe": {
      "get": {
        "description": "Get auto subscribe topic list",
        "tags": [
          "Auto Subscribe"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "After the device logs in successfully, the subscription is automatically completed for the device through the pre-defined subscription representation. Supports the use of placeholders.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/auto_subscribe.topic"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update auto subscribe topic list",
        "tags": [
          "Auto Subscribe"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "After the device logs in successfully, the subscription is automatically completed for the device through the pre-defined subscription representation. Supports the use of placeholders.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/auto_subscribe.topic"
                  }
                }
              }
            }
          },
          "409": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "EXCEED_LIMIT"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Auto Subscribe topics max limit"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/auto_subscribe.topic"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/load_rebalance/{node}/evacuation/start": {
      "post": {
        "description": "Start evacuation process",
        "tags": [
          "Load Rebalance"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "node",
            "description": "Node name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "summary": "Start evacuation on a node",
        "responses": {
          "200": {
            "description": "The response is empty",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "example": {}
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "evacuation": {
                  "wait_takeover": "10s",
                  "sess_evict_rate": 100,
                  "conn_evict_rate": 100,
                  "migrate_to": [
                    "othernode@127.0.0.1"
                  ],
                  "wait_health_check": "10s",
                  "redirect_to": "othernode:1883"
                }
              },
              "schema": {
                "$ref": "#/components/schemas/load_rebalance.rebalance_evacuation_start"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/{name}/listeners/{id}/authentication": {
      "get": {
        "description": "Get the listener's authenticator configs.",
        "tags": [
          "Gateway Listeners"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "gbt32960",
                "jt808",
                "lwm2m",
                "mqttsn",
                "ocpp",
                "stomp"
              ]
            },
            "example": "stomp"
          },
          {
            "in": "path",
            "name": "id",
            "description": "Listener ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": ""
          }
        ],
        "summary": "Get the listener's authenticator",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "jwt": {
                    "value": {
                      "mechanism": "jwt",
                      "secret": "mysecret",
                      "algorithm": "hmac-based",
                      "secret_base64_encoded": false,
                      "use_jwks": false,
                      "verify_claims": {
                        "username": "${username}"
                      }
                    },
                    "summary": "JWT authentication"
                  },
                  "password_based:built_in_database": {
                    "value": {
                      "mechanism": "password_based",
                      "backend": "built_in_database",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "user_id_type": "username"
                    },
                    "summary": "Built-in password_based authentication"
                  },
                  "password_based:http": {
                    "value": {
                      "ssl": {
                        "enable": false
                      },
                      "connect_timeout": "5s",
                      "mechanism": "password_based",
                      "pool_size": 8,
                      "body": {
                        "password": "${password}",
                        "username": "${username}"
                      },
                      "headers": {
                        "content-type": "application/json"
                      },
                      "url": "http://127.0.0.1:18083",
                      "method": "post",
                      "backend": "http",
                      "request_timeout": "5s",
                      "enable_pipelining": 100
                    },
                    "summary": "password_based authentication through external HTTP API"
                  },
                  "password_based:mongodb": {
                    "value": {
                      "mechanism": "password_based",
                      "filter": {
                        "username": "${username}"
                      },
                      "server": "127.0.0.1:27017",
                      "database": "example",
                      "backend": "mongodb",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "collection": "users",
                      "is_superuser_field": "is_superuser",
                      "password_hash_field": "password_hash",
                      "salt_field": "salt"
                    },
                    "summary": "password_based authentication with MongoDB backend"
                  },
                  "password_based:redis": {
                    "value": {
                      "mechanism": "password_based",
                      "cmd": "HMGET ${username} password_hash salt",
                      "server": "127.0.0.1:6379",
                      "database": 0,
                      "backend": "redis",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "redis_type": "single"
                    },
                    "summary": "password_based authentication with Redis backend"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authn.kerberos"
                    },
                    {
                      "$ref": "#/components/schemas/authn.gcp_device"
                    },
                    {
                      "$ref": "#/components/schemas/authn.ldap_deprecated"
                    },
                    {
                      "$ref": "#/components/schemas/authn.ldap"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_jwks"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_public_key"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_hmac"
                    },
                    {
                      "$ref": "#/components/schemas/authn.http_post"
                    },
                    {
                      "$ref": "#/components/schemas/authn.http_get"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_single"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_sharded"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_rs"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_single"
                    },
                    {
                      "$ref": "#/components/schemas/authn.postgresql"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mysql"
                    },
                    {
                      "$ref": "#/components/schemas/authn.builtin_db"
                    }
                  ]
                }
              }
            }
          },
          "204": {
            "description": "Authentication or listener does not existed"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update authenticator configs for the listener, or disable/enable it.",
        "tags": [
          "Gateway Listeners"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "gbt32960",
                "jt808",
                "lwm2m",
                "mqttsn",
                "ocpp",
                "stomp"
              ]
            },
            "example": "stomp"
          },
          {
            "in": "path",
            "name": "id",
            "description": "Listener ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": ""
          }
        ],
        "summary": "Update config of authenticator for listener",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "jwt": {
                    "value": {
                      "mechanism": "jwt",
                      "secret": "mysecret",
                      "algorithm": "hmac-based",
                      "secret_base64_encoded": false,
                      "use_jwks": false,
                      "verify_claims": {
                        "username": "${username}"
                      }
                    },
                    "summary": "JWT authentication"
                  },
                  "password_based:built_in_database": {
                    "value": {
                      "mechanism": "password_based",
                      "backend": "built_in_database",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "user_id_type": "username"
                    },
                    "summary": "Built-in password_based authentication"
                  },
                  "password_based:http": {
                    "value": {
                      "ssl": {
                        "enable": false
                      },
                      "connect_timeout": "5s",
                      "mechanism": "password_based",
                      "pool_size": 8,
                      "body": {
                        "password": "${password}",
                        "username": "${username}"
                      },
                      "headers": {
                        "content-type": "application/json"
                      },
                      "url": "http://127.0.0.1:18083",
                      "method": "post",
                      "backend": "http",
                      "request_timeout": "5s",
                      "enable_pipelining": 100
                    },
                    "summary": "password_based authentication through external HTTP API"
                  },
                  "password_based:mongodb": {
                    "value": {
                      "mechanism": "password_based",
                      "filter": {
                        "username": "${username}"
                      },
                      "server": "127.0.0.1:27017",
                      "database": "example",
                      "backend": "mongodb",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "collection": "users",
                      "is_superuser_field": "is_superuser",
                      "password_hash_field": "password_hash",
                      "salt_field": "salt"
                    },
                    "summary": "password_based authentication with MongoDB backend"
                  },
                  "password_based:redis": {
                    "value": {
                      "mechanism": "password_based",
                      "cmd": "HMGET ${username} password_hash salt",
                      "server": "127.0.0.1:6379",
                      "database": 0,
                      "backend": "redis",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "redis_type": "single"
                    },
                    "summary": "password_based authentication with Redis backend"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authn.kerberos"
                    },
                    {
                      "$ref": "#/components/schemas/authn.gcp_device"
                    },
                    {
                      "$ref": "#/components/schemas/authn.ldap_deprecated"
                    },
                    {
                      "$ref": "#/components/schemas/authn.ldap"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_jwks"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_public_key"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_hmac"
                    },
                    {
                      "$ref": "#/components/schemas/authn.http_post"
                    },
                    {
                      "$ref": "#/components/schemas/authn.http_get"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_single"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_sharded"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_rs"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_single"
                    },
                    {
                      "$ref": "#/components/schemas/authn.postgresql"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mysql"
                    },
                    {
                      "$ref": "#/components/schemas/authn.builtin_db"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "jwt": {
                  "value": {
                    "mechanism": "jwt",
                    "secret": "mysecret",
                    "algorithm": "hmac-based",
                    "secret_base64_encoded": false,
                    "use_jwks": false,
                    "verify_claims": {
                      "username": "${username}"
                    }
                  },
                  "summary": "JWT authentication"
                },
                "password_based:built_in_database": {
                  "value": {
                    "mechanism": "password_based",
                    "backend": "built_in_database",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "user_id_type": "username"
                  },
                  "summary": "Built-in password_based authentication"
                },
                "password_based:http": {
                  "value": {
                    "ssl": {
                      "enable": false
                    },
                    "connect_timeout": "5s",
                    "mechanism": "password_based",
                    "pool_size": 8,
                    "body": {
                      "password": "${password}",
                      "username": "${username}"
                    },
                    "headers": {
                      "content-type": "application/json"
                    },
                    "url": "http://127.0.0.1:18083",
                    "method": "post",
                    "backend": "http",
                    "request_timeout": "5s",
                    "enable_pipelining": 100
                  },
                  "summary": "password_based authentication through external HTTP API"
                },
                "password_based:mongodb": {
                  "value": {
                    "mechanism": "password_based",
                    "filter": {
                      "username": "${username}"
                    },
                    "server": "127.0.0.1:27017",
                    "database": "example",
                    "backend": "mongodb",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "collection": "users",
                    "is_superuser_field": "is_superuser",
                    "password_hash_field": "password_hash",
                    "salt_field": "salt"
                  },
                  "summary": "password_based authentication with MongoDB backend"
                },
                "password_based:redis": {
                  "value": {
                    "mechanism": "password_based",
                    "cmd": "HMGET ${username} password_hash salt",
                    "server": "127.0.0.1:6379",
                    "database": 0,
                    "backend": "redis",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "redis_type": "single"
                  },
                  "summary": "password_based authentication with Redis backend"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/authn.kerberos"
                  },
                  {
                    "$ref": "#/components/schemas/authn.gcp_device"
                  },
                  {
                    "$ref": "#/components/schemas/authn.ldap_deprecated"
                  },
                  {
                    "$ref": "#/components/schemas/authn.ldap"
                  },
                  {
                    "$ref": "#/components/schemas/authn.jwt_jwks"
                  },
                  {
                    "$ref": "#/components/schemas/authn.jwt_public_key"
                  },
                  {
                    "$ref": "#/components/schemas/authn.jwt_hmac"
                  },
                  {
                    "$ref": "#/components/schemas/authn.http_post"
                  },
                  {
                    "$ref": "#/components/schemas/authn.http_get"
                  },
                  {
                    "$ref": "#/components/schemas/authn.redis_sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/authn.redis_cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn.redis_single"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mongo_sharded"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mongo_rs"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mongo_single"
                  },
                  {
                    "$ref": "#/components/schemas/authn.postgresql"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mysql"
                  },
                  {
                    "$ref": "#/components/schemas/authn.builtin_db"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Remove authenticator for the listener.",
        "tags": [
          "Gateway Listeners"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "gbt32960",
                "jt808",
                "lwm2m",
                "mqttsn",
                "ocpp",
                "stomp"
              ]
            },
            "example": "stomp"
          },
          {
            "in": "path",
            "name": "id",
            "description": "Listener ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": ""
          }
        ],
        "summary": "Delete the listener's authenticator",
        "responses": {
          "200": {
            "description": "Deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Enable authenticator for specified listener for client authentication.<br/><br/>When authenticator is enabled for a listener, all clients connecting to that listener will use that authenticator for authentication.",
        "tags": [
          "Gateway Listeners"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "gbt32960",
                "jt808",
                "lwm2m",
                "mqttsn",
                "ocpp",
                "stomp"
              ]
            },
            "example": "stomp"
          },
          {
            "in": "path",
            "name": "id",
            "description": "Listener ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": ""
          }
        ],
        "summary": "Create authenticator for listener",
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "jwt": {
                    "value": {
                      "mechanism": "jwt",
                      "secret": "mysecret",
                      "algorithm": "hmac-based",
                      "secret_base64_encoded": false,
                      "use_jwks": false,
                      "verify_claims": {
                        "username": "${username}"
                      }
                    },
                    "summary": "JWT authentication"
                  },
                  "password_based:built_in_database": {
                    "value": {
                      "mechanism": "password_based",
                      "backend": "built_in_database",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "user_id_type": "username"
                    },
                    "summary": "Built-in password_based authentication"
                  },
                  "password_based:http": {
                    "value": {
                      "ssl": {
                        "enable": false
                      },
                      "connect_timeout": "5s",
                      "mechanism": "password_based",
                      "pool_size": 8,
                      "body": {
                        "password": "${password}",
                        "username": "${username}"
                      },
                      "headers": {
                        "content-type": "application/json"
                      },
                      "url": "http://127.0.0.1:18083",
                      "method": "post",
                      "backend": "http",
                      "request_timeout": "5s",
                      "enable_pipelining": 100
                    },
                    "summary": "password_based authentication through external HTTP API"
                  },
                  "password_based:mongodb": {
                    "value": {
                      "mechanism": "password_based",
                      "filter": {
                        "username": "${username}"
                      },
                      "server": "127.0.0.1:27017",
                      "database": "example",
                      "backend": "mongodb",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "collection": "users",
                      "is_superuser_field": "is_superuser",
                      "password_hash_field": "password_hash",
                      "salt_field": "salt"
                    },
                    "summary": "password_based authentication with MongoDB backend"
                  },
                  "password_based:redis": {
                    "value": {
                      "mechanism": "password_based",
                      "cmd": "HMGET ${username} password_hash salt",
                      "server": "127.0.0.1:6379",
                      "database": 0,
                      "backend": "redis",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "redis_type": "single"
                    },
                    "summary": "password_based authentication with Redis backend"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authn.kerberos"
                    },
                    {
                      "$ref": "#/components/schemas/authn.gcp_device"
                    },
                    {
                      "$ref": "#/components/schemas/authn.ldap_deprecated"
                    },
                    {
                      "$ref": "#/components/schemas/authn.ldap"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_jwks"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_public_key"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_hmac"
                    },
                    {
                      "$ref": "#/components/schemas/authn.http_post"
                    },
                    {
                      "$ref": "#/components/schemas/authn.http_get"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_single"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_sharded"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_rs"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_single"
                    },
                    {
                      "$ref": "#/components/schemas/authn.postgresql"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mysql"
                    },
                    {
                      "$ref": "#/components/schemas/authn.builtin_db"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "jwt": {
                  "value": {
                    "mechanism": "jwt",
                    "secret": "mysecret",
                    "algorithm": "hmac-based",
                    "secret_base64_encoded": false,
                    "use_jwks": false,
                    "verify_claims": {
                      "username": "${username}"
                    }
                  },
                  "summary": "JWT authentication"
                },
                "password_based:built_in_database": {
                  "value": {
                    "mechanism": "password_based",
                    "backend": "built_in_database",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "user_id_type": "username"
                  },
                  "summary": "Built-in password_based authentication"
                },
                "password_based:http": {
                  "value": {
                    "ssl": {
                      "enable": false
                    },
                    "connect_timeout": "5s",
                    "mechanism": "password_based",
                    "pool_size": 8,
                    "body": {
                      "password": "${password}",
                      "username": "${username}"
                    },
                    "headers": {
                      "content-type": "application/json"
                    },
                    "url": "http://127.0.0.1:18083",
                    "method": "post",
                    "backend": "http",
                    "request_timeout": "5s",
                    "enable_pipelining": 100
                  },
                  "summary": "password_based authentication through external HTTP API"
                },
                "password_based:mongodb": {
                  "value": {
                    "mechanism": "password_based",
                    "filter": {
                      "username": "${username}"
                    },
                    "server": "127.0.0.1:27017",
                    "database": "example",
                    "backend": "mongodb",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "collection": "users",
                    "is_superuser_field": "is_superuser",
                    "password_hash_field": "password_hash",
                    "salt_field": "salt"
                  },
                  "summary": "password_based authentication with MongoDB backend"
                },
                "password_based:redis": {
                  "value": {
                    "mechanism": "password_based",
                    "cmd": "HMGET ${username} password_hash salt",
                    "server": "127.0.0.1:6379",
                    "database": 0,
                    "backend": "redis",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "redis_type": "single"
                  },
                  "summary": "password_based authentication with Redis backend"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/authn.kerberos"
                  },
                  {
                    "$ref": "#/components/schemas/authn.gcp_device"
                  },
                  {
                    "$ref": "#/components/schemas/authn.ldap_deprecated"
                  },
                  {
                    "$ref": "#/components/schemas/authn.ldap"
                  },
                  {
                    "$ref": "#/components/schemas/authn.jwt_jwks"
                  },
                  {
                    "$ref": "#/components/schemas/authn.jwt_public_key"
                  },
                  {
                    "$ref": "#/components/schemas/authn.jwt_hmac"
                  },
                  {
                    "$ref": "#/components/schemas/authn.http_post"
                  },
                  {
                    "$ref": "#/components/schemas/authn.http_get"
                  },
                  {
                    "$ref": "#/components/schemas/authn.redis_sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/authn.redis_cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn.redis_single"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mongo_sharded"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mongo_rs"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mongo_single"
                  },
                  {
                    "$ref": "#/components/schemas/authn.postgresql"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mysql"
                  },
                  {
                    "$ref": "#/components/schemas/authn.builtin_db"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/{name}/listeners": {
      "get": {
        "description": "Gets a list of gateway listeners. This interface returns all the configs of the listener (including the authenticator on that listener), as well as the status of that listener running in the cluster.",
        "tags": [
          "Gateway Listeners"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "gbt32960",
                "jt808",
                "lwm2m",
                "mqttsn",
                "ocpp",
                "stomp"
              ]
            },
            "example": "stomp"
          }
        ],
        "summary": "List all listeners",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": [
                  {
                    "name": "udp-def",
                    "status": {
                      "running": true,
                      "max_connections": 1024000,
                      "current_connections": 10
                    },
                    "type": "udp",
                    "bind": "22212",
                    "udp_options": {
                      "buffer": "10KB",
                      "recbuf": "10KB",
                      "reuseaddr": true,
                      "sndbuf": "10KB",
                      "active_n": 100
                    },
                    "node_status": [
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "running": true,
                          "max_connections": 1024000,
                          "current_connections": 10
                        }
                      }
                    ]
                  },
                  {
                    "name": "dtls-def",
                    "status": {
                      "running": true,
                      "max_connections": 1024000,
                      "current_connections": 10
                    },
                    "type": "dtls",
                    "bind": "22213",
                    "udp_options": {
                      "backlog": 1024,
                      "active_n": 100
                    },
                    "max_connections": 1024000,
                    "node_status": [
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "running": true,
                          "max_connections": 1024000,
                          "current_connections": 10
                        }
                      }
                    ],
                    "acceptors": 16,
                    "dtls_options": {
                      "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem",
                      "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                      "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                      "verify": "verify_none",
                      "versions": [
                        "dtlsv1.2",
                        "dtlsv1"
                      ],
                      "fail_if_no_peer_cert": false
                    },
                    "access_rules": [
                      "allow all"
                    ],
                    "max_conn_rate": 1000
                  },
                  {
                    "name": "ssl-def",
                    "status": {
                      "running": true,
                      "max_connections": 1024000,
                      "current_connections": 10
                    },
                    "type": "ssl",
                    "bind": "22211",
                    "tcp_options": {
                      "backlog": 1024,
                      "active_n": 100
                    },
                    "max_connections": 1024000,
                    "ssl_options": {
                      "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem",
                      "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                      "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                      "verify": "verify_none",
                      "versions": [
                        "tlsv1.3",
                        "tlsv1.2",
                        "tlsv1.1",
                        "tlsv1"
                      ],
                      "fail_if_no_peer_cert": false
                    },
                    "node_status": [
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "running": true,
                          "max_connections": 1024000,
                          "current_connections": 10
                        }
                      }
                    ],
                    "acceptors": 16,
                    "access_rules": [
                      "allow all"
                    ],
                    "max_conn_rate": 1000
                  },
                  {
                    "name": "tcp-def",
                    "status": {
                      "running": true,
                      "max_connections": 1024000,
                      "current_connections": 10
                    },
                    "type": "tcp",
                    "bind": "22210",
                    "tcp_options": {
                      "buffer": "10KB",
                      "high_watermark": "1MB",
                      "keepalive": "none",
                      "nodelay": false,
                      "recbuf": "10KB",
                      "reuseaddr": true,
                      "send_timeout": "15s",
                      "send_timeout_close": true,
                      "sndbuf": "10KB",
                      "backlog": 1024,
                      "active_n": 100
                    },
                    "max_connections": 1024000,
                    "node_status": [
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "running": true,
                          "max_connections": 1024000,
                          "current_connections": 10
                        }
                      }
                    ],
                    "acceptors": 16,
                    "max_conn_rate": 1000
                  },
                  {
                    "name": "ws-def",
                    "status": {
                      "running": true,
                      "max_connections": 1024000,
                      "current_connections": 10
                    },
                    "type": "ws",
                    "bind": "33043",
                    "tcp_options": {
                      "buffer": "10KB",
                      "high_watermark": "1MB",
                      "keepalive": "none",
                      "nodelay": false,
                      "recbuf": "10KB",
                      "reuseaddr": true,
                      "send_timeout": "15s",
                      "send_timeout_close": true,
                      "sndbuf": "10KB",
                      "backlog": 1024,
                      "active_n": 100
                    },
                    "max_connections": 1024000,
                    "node_status": [
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "running": true,
                          "max_connections": 1024000,
                          "current_connections": 10
                        }
                      }
                    ],
                    "websocket": {
                      "path": "/ocpp",
                      "compress": false,
                      "fail_if_no_subprotocol": true,
                      "supported_subprotocols": "ocpp1.6",
                      "check_origins": "http://localhost:18083, http://127.0.0.1:18083",
                      "check_origin_enable": false,
                      "piggyback": "single"
                    },
                    "acceptors": 16,
                    "max_conn_rate": 1000
                  },
                  {
                    "name": "ws-ssl-def",
                    "status": {
                      "running": true,
                      "max_connections": 1024000,
                      "current_connections": 10
                    },
                    "type": "wss",
                    "bind": "33053",
                    "tcp_options": {
                      "buffer": "10KB",
                      "high_watermark": "1MB",
                      "keepalive": "none",
                      "nodelay": false,
                      "recbuf": "10KB",
                      "reuseaddr": true,
                      "send_timeout": "15s",
                      "send_timeout_close": true,
                      "sndbuf": "10KB",
                      "backlog": 1024,
                      "active_n": 100
                    },
                    "max_connections": 1024000,
                    "ssl_options": {
                      "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem",
                      "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                      "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                      "verify": "verify_none",
                      "versions": [
                        "tlsv1.3",
                        "tlsv1.2",
                        "tlsv1.1",
                        "tlsv1"
                      ],
                      "fail_if_no_peer_cert": false
                    },
                    "node_status": [
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "running": true,
                          "max_connections": 1024000,
                          "current_connections": 10
                        }
                      }
                    ],
                    "websocket": {
                      "path": "/ocpp",
                      "compress": false,
                      "fail_if_no_subprotocol": true,
                      "supported_subprotocols": "ocpp1.6",
                      "check_origins": "http://localhost:18083, http://127.0.0.1:18083",
                      "check_origin_enable": false,
                      "piggyback": "single"
                    },
                    "acceptors": 16,
                    "max_conn_rate": 1000
                  },
                  {
                    "name": "dtls-psk",
                    "status": {
                      "running": true,
                      "max_connections": 1024000,
                      "current_connections": 10
                    },
                    "type": "dtls",
                    "bind": "22214",
                    "max_connections": 1024000,
                    "node_status": [
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "running": true,
                          "max_connections": 1024000,
                          "current_connections": 10
                        }
                      }
                    ],
                    "acceptors": 16,
                    "dtls_options": {
                      "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem",
                      "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                      "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                      "verify": "verify_none",
                      "ciphers": "RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA",
                      "versions": [
                        "dtlsv1.2",
                        "dtlsv1"
                      ],
                      "fail_if_no_peer_cert": false,
                      "user_lookup_fun": "emqx_tls_psk:lookup"
                    },
                    "max_conn_rate": 1000
                  },
                  {
                    "name": "tcp-with-authn",
                    "status": {
                      "running": true,
                      "max_connections": 1024000,
                      "current_connections": 10
                    },
                    "type": "tcp",
                    "bind": "22215",
                    "authentication": {
                      "mechanism": "password_based",
                      "backend": "built_in_database",
                      "password_hash_algorithm": {
                        "name": "sha256"
                      },
                      "user_id_type": "username"
                    },
                    "max_connections": 1024000,
                    "node_status": [
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "running": true,
                          "max_connections": 1024000,
                          "current_connections": 10
                        }
                      }
                    ],
                    "acceptors": 16,
                    "max_conn_rate": 1000
                  }
                ],
                "schema": {
                  "type": "array",
                  "items": {
                    "oneOf": [
                      {
                        "$ref": "#/components/schemas/emqx_gateway_api_listeners.dtls_listener"
                      },
                      {
                        "$ref": "#/components/schemas/emqx_gateway_api_listeners.udp_listener"
                      },
                      {
                        "$ref": "#/components/schemas/emqx_gateway_api_listeners.ssl_listener"
                      },
                      {
                        "$ref": "#/components/schemas/emqx_gateway_api_listeners.tcp_listener"
                      }
                    ]
                  }
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Create the gateway listener.<br/><br/>Note: For listener types not supported by a gateway, this API returns `400: BAD_REQUEST`.",
        "tags": [
          "Gateway Listeners"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "gbt32960",
                "jt808",
                "lwm2m",
                "mqttsn",
                "ocpp",
                "stomp"
              ]
            },
            "example": "stomp"
          }
        ],
        "summary": "Add listener",
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "udp_listener": {
                    "value": {
                      "name": "udp-def",
                      "type": "udp",
                      "bind": "22212",
                      "udp_options": {
                        "buffer": "10KB",
                        "recbuf": "10KB",
                        "reuseaddr": true,
                        "sndbuf": "10KB",
                        "active_n": 100
                      }
                    },
                    "summary": "A simple UDP listener example"
                  },
                  "dtls_listener": {
                    "value": {
                      "name": "dtls-def",
                      "type": "dtls",
                      "bind": "22213",
                      "udp_options": {
                        "backlog": 1024,
                        "active_n": 100
                      },
                      "max_connections": 1024000,
                      "acceptors": 16,
                      "dtls_options": {
                        "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem",
                        "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                        "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                        "verify": "verify_none",
                        "versions": [
                          "dtlsv1.2",
                          "dtlsv1"
                        ],
                        "fail_if_no_peer_cert": false
                      },
                      "access_rules": [
                        "allow all"
                      ],
                      "max_conn_rate": 1000
                    },
                    "summary": "A simple DTLS listener example"
                  },
                  "ssl_listener": {
                    "value": {
                      "name": "ssl-def",
                      "type": "ssl",
                      "bind": "22211",
                      "tcp_options": {
                        "backlog": 1024,
                        "active_n": 100
                      },
                      "max_connections": 1024000,
                      "ssl_options": {
                        "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem",
                        "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                        "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                        "verify": "verify_none",
                        "versions": [
                          "tlsv1.3",
                          "tlsv1.2",
                          "tlsv1.1",
                          "tlsv1"
                        ],
                        "fail_if_no_peer_cert": false
                      },
                      "acceptors": 16,
                      "access_rules": [
                        "allow all"
                      ],
                      "max_conn_rate": 1000
                    },
                    "summary": "A simple SSL listener example"
                  },
                  "tcp_listener": {
                    "value": {
                      "name": "tcp-def",
                      "type": "tcp",
                      "bind": "22210",
                      "tcp_options": {
                        "buffer": "10KB",
                        "high_watermark": "1MB",
                        "keepalive": "none",
                        "nodelay": false,
                        "recbuf": "10KB",
                        "reuseaddr": true,
                        "send_timeout": "15s",
                        "send_timeout_close": true,
                        "sndbuf": "10KB",
                        "backlog": 1024,
                        "active_n": 100
                      },
                      "max_connections": 1024000,
                      "acceptors": 16,
                      "max_conn_rate": 1000
                    },
                    "summary": "A simple TCP listener example"
                  },
                  "ws_listener": {
                    "value": {
                      "name": "ws-def",
                      "type": "ws",
                      "bind": "33043",
                      "tcp_options": {
                        "buffer": "10KB",
                        "high_watermark": "1MB",
                        "keepalive": "none",
                        "nodelay": false,
                        "recbuf": "10KB",
                        "reuseaddr": true,
                        "send_timeout": "15s",
                        "send_timeout_close": true,
                        "sndbuf": "10KB",
                        "backlog": 1024,
                        "active_n": 100
                      },
                      "max_connections": 1024000,
                      "websocket": {
                        "path": "/ocpp",
                        "compress": false,
                        "fail_if_no_subprotocol": true,
                        "supported_subprotocols": "ocpp1.6",
                        "check_origins": "http://localhost:18083, http://127.0.0.1:18083",
                        "check_origin_enable": false,
                        "piggyback": "single"
                      },
                      "acceptors": 16,
                      "max_conn_rate": 1000
                    },
                    "summary": "A simple WebSocket listener example"
                  },
                  "wss_listener": {
                    "value": {
                      "name": "ws-ssl-def",
                      "type": "wss",
                      "bind": "33053",
                      "tcp_options": {
                        "buffer": "10KB",
                        "high_watermark": "1MB",
                        "keepalive": "none",
                        "nodelay": false,
                        "recbuf": "10KB",
                        "reuseaddr": true,
                        "send_timeout": "15s",
                        "send_timeout_close": true,
                        "sndbuf": "10KB",
                        "backlog": 1024,
                        "active_n": 100
                      },
                      "max_connections": 1024000,
                      "ssl_options": {
                        "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem",
                        "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                        "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                        "verify": "verify_none",
                        "versions": [
                          "tlsv1.3",
                          "tlsv1.2",
                          "tlsv1.1",
                          "tlsv1"
                        ],
                        "fail_if_no_peer_cert": false
                      },
                      "websocket": {
                        "path": "/ocpp",
                        "compress": false,
                        "fail_if_no_subprotocol": true,
                        "supported_subprotocols": "ocpp1.6",
                        "check_origins": "http://localhost:18083, http://127.0.0.1:18083",
                        "check_origin_enable": false,
                        "piggyback": "single"
                      },
                      "acceptors": 16,
                      "max_conn_rate": 1000
                    },
                    "summary": "A simple WebSocket/TLS listener example"
                  },
                  "dtls_listener_with_psk_ciphers": {
                    "value": {
                      "name": "dtls-psk",
                      "type": "dtls",
                      "bind": "22214",
                      "max_connections": 1024000,
                      "acceptors": 16,
                      "dtls_options": {
                        "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem",
                        "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                        "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                        "verify": "verify_none",
                        "ciphers": "RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA",
                        "versions": [
                          "dtlsv1.2",
                          "dtlsv1"
                        ],
                        "fail_if_no_peer_cert": false,
                        "user_lookup_fun": "emqx_tls_psk:lookup"
                      },
                      "max_conn_rate": 1000
                    },
                    "summary": "A DTLS listener with PSK example"
                  },
                  "lisetner_with_authn": {
                    "value": {
                      "name": "tcp-with-authn",
                      "type": "tcp",
                      "bind": "22215",
                      "authentication": {
                        "mechanism": "password_based",
                        "backend": "built_in_database",
                        "password_hash_algorithm": {
                          "name": "sha256"
                        },
                        "user_id_type": "username"
                      },
                      "max_connections": 1024000,
                      "acceptors": 16,
                      "max_conn_rate": 1000
                    },
                    "summary": "A TCP listener with authentication example"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.wss_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.ws_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.dtls_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.udp_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.ssl_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.tcp_listener"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "udp_listener": {
                  "value": {
                    "name": "udp-def",
                    "type": "udp",
                    "bind": "22212",
                    "udp_options": {
                      "buffer": "10KB",
                      "recbuf": "10KB",
                      "reuseaddr": true,
                      "sndbuf": "10KB",
                      "active_n": 100
                    }
                  },
                  "summary": "A simple UDP listener example"
                },
                "dtls_listener": {
                  "value": {
                    "name": "dtls-def",
                    "type": "dtls",
                    "bind": "22213",
                    "udp_options": {
                      "backlog": 1024,
                      "active_n": 100
                    },
                    "max_connections": 1024000,
                    "acceptors": 16,
                    "dtls_options": {
                      "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem",
                      "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                      "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                      "verify": "verify_none",
                      "versions": [
                        "dtlsv1.2",
                        "dtlsv1"
                      ],
                      "fail_if_no_peer_cert": false
                    },
                    "access_rules": [
                      "allow all"
                    ],
                    "max_conn_rate": 1000
                  },
                  "summary": "A simple DTLS listener example"
                },
                "ssl_listener": {
                  "value": {
                    "name": "ssl-def",
                    "type": "ssl",
                    "bind": "22211",
                    "tcp_options": {
                      "backlog": 1024,
                      "active_n": 100
                    },
                    "max_connections": 1024000,
                    "ssl_options": {
                      "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem",
                      "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                      "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                      "verify": "verify_none",
                      "versions": [
                        "tlsv1.3",
                        "tlsv1.2",
                        "tlsv1.1",
                        "tlsv1"
                      ],
                      "fail_if_no_peer_cert": false
                    },
                    "acceptors": 16,
                    "access_rules": [
                      "allow all"
                    ],
                    "max_conn_rate": 1000
                  },
                  "summary": "A simple SSL listener example"
                },
                "tcp_listener": {
                  "value": {
                    "name": "tcp-def",
                    "type": "tcp",
                    "bind": "22210",
                    "tcp_options": {
                      "buffer": "10KB",
                      "high_watermark": "1MB",
                      "keepalive": "none",
                      "nodelay": false,
                      "recbuf": "10KB",
                      "reuseaddr": true,
                      "send_timeout": "15s",
                      "send_timeout_close": true,
                      "sndbuf": "10KB",
                      "backlog": 1024,
                      "active_n": 100
                    },
                    "max_connections": 1024000,
                    "acceptors": 16,
                    "max_conn_rate": 1000
                  },
                  "summary": "A simple TCP listener example"
                },
                "ws_listener": {
                  "value": {
                    "name": "ws-def",
                    "type": "ws",
                    "bind": "33043",
                    "tcp_options": {
                      "buffer": "10KB",
                      "high_watermark": "1MB",
                      "keepalive": "none",
                      "nodelay": false,
                      "recbuf": "10KB",
                      "reuseaddr": true,
                      "send_timeout": "15s",
                      "send_timeout_close": true,
                      "sndbuf": "10KB",
                      "backlog": 1024,
                      "active_n": 100
                    },
                    "max_connections": 1024000,
                    "websocket": {
                      "path": "/ocpp",
                      "compress": false,
                      "fail_if_no_subprotocol": true,
                      "supported_subprotocols": "ocpp1.6",
                      "check_origins": "http://localhost:18083, http://127.0.0.1:18083",
                      "check_origin_enable": false,
                      "piggyback": "single"
                    },
                    "acceptors": 16,
                    "max_conn_rate": 1000
                  },
                  "summary": "A simple WebSocket listener example"
                },
                "wss_listener": {
                  "value": {
                    "name": "ws-ssl-def",
                    "type": "wss",
                    "bind": "33053",
                    "tcp_options": {
                      "buffer": "10KB",
                      "high_watermark": "1MB",
                      "keepalive": "none",
                      "nodelay": false,
                      "recbuf": "10KB",
                      "reuseaddr": true,
                      "send_timeout": "15s",
                      "send_timeout_close": true,
                      "sndbuf": "10KB",
                      "backlog": 1024,
                      "active_n": 100
                    },
                    "max_connections": 1024000,
                    "ssl_options": {
                      "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem",
                      "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                      "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                      "verify": "verify_none",
                      "versions": [
                        "tlsv1.3",
                        "tlsv1.2",
                        "tlsv1.1",
                        "tlsv1"
                      ],
                      "fail_if_no_peer_cert": false
                    },
                    "websocket": {
                      "path": "/ocpp",
                      "compress": false,
                      "fail_if_no_subprotocol": true,
                      "supported_subprotocols": "ocpp1.6",
                      "check_origins": "http://localhost:18083, http://127.0.0.1:18083",
                      "check_origin_enable": false,
                      "piggyback": "single"
                    },
                    "acceptors": 16,
                    "max_conn_rate": 1000
                  },
                  "summary": "A simple WebSocket/TLS listener example"
                },
                "dtls_listener_with_psk_ciphers": {
                  "value": {
                    "name": "dtls-psk",
                    "type": "dtls",
                    "bind": "22214",
                    "max_connections": 1024000,
                    "acceptors": 16,
                    "dtls_options": {
                      "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem",
                      "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                      "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                      "verify": "verify_none",
                      "ciphers": "RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA",
                      "versions": [
                        "dtlsv1.2",
                        "dtlsv1"
                      ],
                      "fail_if_no_peer_cert": false,
                      "user_lookup_fun": "emqx_tls_psk:lookup"
                    },
                    "max_conn_rate": 1000
                  },
                  "summary": "A DTLS listener with PSK example"
                },
                "lisetner_with_authn": {
                  "value": {
                    "name": "tcp-with-authn",
                    "type": "tcp",
                    "bind": "22215",
                    "authentication": {
                      "mechanism": "password_based",
                      "backend": "built_in_database",
                      "password_hash_algorithm": {
                        "name": "sha256"
                      },
                      "user_id_type": "username"
                    },
                    "max_connections": 1024000,
                    "acceptors": 16,
                    "max_conn_rate": 1000
                  },
                  "summary": "A TCP listener with authentication example"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.wss_listener"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.ws_listener"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.dtls_listener"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.udp_listener"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.ssl_listener"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.tcp_listener"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/plugins/{name}/config": {
      "get": {
        "description": "Get plugin config. Config schema is defined by user's schema.avsc file.<br/>",
        "tags": [
          "Plugins"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/plugins.name"
          }
        ],
        "summary": "Get plugin config",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_CONFIG"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Plugin Config Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Plugin Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update plugin config. Config schema defined by user's schema.avsc file.<br/>",
        "tags": [
          "Plugins"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/plugins.name"
          }
        ],
        "summary": "Update plugin config",
        "responses": {
          "204": {
            "description": "Config updated successfully"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_CONFIG",
                        "UNEXPECTED_ERROR"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Update plugin config failed"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Plugin Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/configs/sys_topics": {
      "get": {
        "description": "Get the sub-configurations under *sys_topics*",
        "tags": [
          "Configs"
        ],
        "parameters": [],
        "summary": "Get the sub-configurations under *sys_topics*",
        "responses": {
          "200": {
            "description": "System topics configuration.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx.sys_topics"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "config not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update the sub-configurations under *sys_topics*",
        "tags": [
          "Configs"
        ],
        "parameters": [],
        "summary": "Update the sub-configurations under *sys_topics*",
        "responses": {
          "200": {
            "description": "System topics configuration.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx.sys_topics"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UPDATE_FAILED",
                        "INVALID_CONFIG"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "403": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UPDATE_FAILED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx.sys_topics"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/clients/kickout/bulk": {
      "post": {
        "description": "Kick out a batch of client by client IDs",
        "tags": [
          "Clients"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": "Kick out clients successfully"
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "example": [
                "emqx_clientid_985bb09d",
                "emqx_clientid_211cc01c"
              ],
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/connectors_probe": {
      "post": {
        "description": "Test creating a new connector.",
        "tags": [
          "Connectors"
        ],
        "parameters": [],
        "summary": "Test creating connector",
        "responses": {
          "204": {
            "description": "Test connector OK"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "TEST_FAILED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "connector test failed"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "influxdb_api_v2": {
                  "value": {
                    "name": "influxdb_connector",
                    "type": "influxdb",
                    "ssl": {
                      "enable": false
                    },
                    "description": "My example influxdb connector",
                    "server": "127.0.0.1:8086",
                    "enable": true,
                    "parameters": {
                      "org": "examlpe_org",
                      "token": "example_token",
                      "bucket": "example_bucket",
                      "influxdb_type": "influxdb_api_v2"
                    }
                  },
                  "summary": "InfluxDB HTTP API V2 Connector"
                },
                "http": {
                  "value": {
                    "name": "my_http_connector",
                    "type": "http",
                    "connect_timeout": "15s",
                    "pool_size": 1,
                    "enable": true,
                    "headers": {
                      "content-type": "application/json"
                    },
                    "url": "http://localhost:8080/api/v1",
                    "pool_type": "hash",
                    "enable_pipelining": 100
                  },
                  "summary": "HTTP Connector"
                },
                "confluent_producer": {
                  "value": {
                    "name": "my_confluent_producer_connector",
                    "type": "confluent_producer",
                    "ssl": {
                      "verify": "verify_none",
                      "enable": true,
                      "versions": [
                        "tlsv1.3",
                        "tlsv1.2"
                      ],
                      "server_name_indication": "auto"
                    },
                    "authentication": {
                      "password": "******"
                    },
                    "connect_timeout": "5s",
                    "enable": true,
                    "socket_opts": {
                      "nodelay": true,
                      "recbuf": "1024KB",
                      "sndbuf": "1024KB",
                      "tcp_keepalive": "none"
                    },
                    "min_metadata_refresh_interval": "3s",
                    "bootstrap_hosts": "xyz.sa-east1.gcp.confluent.cloud:9092",
                    "metadata_request_timeout": "4s"
                  },
                  "summary": "Confluent Connector"
                },
                "iotdb": {
                  "value": {
                    "name": "iotdb_connector",
                    "type": "iotdb",
                    "ssl": {
                      "enable": false
                    },
                    "authentication": {
                      "password": "******",
                      "username": "root"
                    },
                    "description": "My example iotdb connector",
                    "connect_timeout": "15s",
                    "pool_size": 8,
                    "enable": true,
                    "base_url": "http://iotdb.local:18080/",
                    "pool_type": "random",
                    "enable_pipelining": 100,
                    "iotdb_version": "v1.3.x"
                  },
                  "summary": "Apache IoTDB Connector"
                },
                "couchbase": {
                  "value": {
                    "name": "my_connector",
                    "type": "couchbase",
                    "ssl": {
                      "enable": true
                    },
                    "description": "My connector",
                    "server": "couchbase:8093",
                    "enable": true,
                    "password": "******",
                    "username": "admin",
                    "resource_opts": {
                      "start_timeout": "5s",
                      "start_after_created": true,
                      "health_check_interval": "45s"
                    }
                  },
                  "summary": "Couchbase Connector"
                },
                "datalayers": {
                  "value": {
                    "name": "datalayers_connector",
                    "type": "datalayers",
                    "ssl": {
                      "enable": false
                    },
                    "description": "My example datalayers connector",
                    "server": "127.0.0.1:8361",
                    "enable": true,
                    "parameters": {
                      "password": "******",
                      "username": "example_username",
                      "database": "example_database"
                    }
                  },
                  "summary": "Datalayers Connector"
                },
                "azure_event_hub_producer": {
                  "value": {
                    "name": "my_azure_event_hub_producer_connector",
                    "type": "azure_event_hub_producer",
                    "ssl": {
                      "verify": "verify_none",
                      "enable": true,
                      "versions": [
                        "tlsv1.3",
                        "tlsv1.2"
                      ],
                      "server_name_indication": "auto"
                    },
                    "authentication": {
                      "password": "******"
                    },
                    "connect_timeout": "5s",
                    "enable": true,
                    "socket_opts": {
                      "nodelay": true,
                      "recbuf": "1024KB",
                      "sndbuf": "1024KB",
                      "tcp_keepalive": "none"
                    },
                    "min_metadata_refresh_interval": "3s",
                    "bootstrap_hosts": "namespace.servicebus.windows.net:9093",
                    "metadata_request_timeout": "4s"
                  },
                  "summary": "Azure Event Hub Connector"
                },
                "kafka_producer": {
                  "value": {
                    "name": "my_kafka_producer_connector",
                    "type": "kafka_producer",
                    "authentication": {
                      "mechanism": "plain",
                      "password": "******",
                      "username": "username"
                    },
                    "connect_timeout": "5s",
                    "enable": true,
                    "socket_opts": {
                      "nodelay": true,
                      "recbuf": "1024KB",
                      "sndbuf": "1024KB",
                      "tcp_keepalive": "none"
                    },
                    "min_metadata_refresh_interval": "3s",
                    "bootstrap_hosts": "localhost:9092",
                    "metadata_request_timeout": "4s"
                  },
                  "summary": "Kafka Producer Connector"
                },
                "kinesis": {
                  "value": {
                    "name": "kinesis_connector",
                    "type": "kinesis",
                    "description": "My example kinesis connector",
                    "aws_access_key_id": "your_access_key",
                    "aws_secret_access_key": "aws_secret_key",
                    "endpoint": "http://localhost:4566",
                    "max_retries": 2,
                    "pool_size": 8
                  },
                  "summary": "Kinesis Connector"
                },
                "syskeeper_proxy": {
                  "value": {
                    "name": "syskeeper_proxy",
                    "type": "syskeeper_proxy",
                    "listen": "127.0.0.1:9092",
                    "enable": true,
                    "acceptors": 16,
                    "handshake_timeout": "16s"
                  },
                  "summary": "Syskeeper Proxy Connector"
                },
                "pgsql": {
                  "value": {
                    "name": "my_pgsql_connector",
                    "type": "pgsql",
                    "database": "emqx_data",
                    "enable": true,
                    "password": "public",
                    "pool_size": 8,
                    "server": "127.0.0.1:5432",
                    "ssl": {
                      "ciphers": [],
                      "depth": 10,
                      "enable": false,
                      "hibernate_after": "5s",
                      "log_level": "notice",
                      "reuse_sessions": true,
                      "secure_renegotiate": true,
                      "verify": "verify_peer",
                      "versions": [
                        "tlsv1.3",
                        "tlsv1.2"
                      ]
                    },
                    "username": "postgres"
                  },
                  "summary": "PostgreSQL Connector"
                },
                "mysql": {
                  "value": {
                    "name": "mysql_connector",
                    "type": "mysql",
                    "description": "My example mysql connector",
                    "pool_size": 8,
                    "server": "127.0.0.1:3306",
                    "password": "******",
                    "username": "root",
                    "database": "test",
                    "resource_opts": {
                      "health_check_interval": "20s"
                    }
                  },
                  "summary": "MySQL Connector"
                },
                "rabbitmq": {
                  "value": {
                    "timeout": "5s",
                    "name": "rabbitmq_connector",
                    "port": 5672,
                    "type": "rabbitmq",
                    "ssl": {
                      "enable": false
                    },
                    "description": "My example rabbitmq connector",
                    "pool_size": 8,
                    "server": "127.0.0.1",
                    "enable": true,
                    "password": "******",
                    "username": "guest",
                    "heartbeat": "30s",
                    "virtual_host": "/"
                  },
                  "summary": "Rabbitmq Connector"
                },
                "dynamo": {
                  "value": {
                    "name": "dynamo_connector",
                    "type": "dynamo",
                    "description": "My example dynamo connector",
                    "aws_access_key_id": "root",
                    "aws_secret_access_key": "******",
                    "enable": true,
                    "pool_size": 8,
                    "region": "us-west-2",
                    "resource_opts": {
                      "health_check_interval": "15s",
                      "start_timeout": "5s"
                    },
                    "url": "http://127.0.0.1:8000"
                  },
                  "summary": "DynamoDB Connector"
                },
                "tdengine": {
                  "value": {
                    "name": "tdengine_connector",
                    "type": "tdengine",
                    "description": "My example tdengine connector",
                    "pool_size": 8,
                    "server": "127.0.0.1:6041",
                    "enable": true,
                    "password": "******",
                    "username": "root"
                  },
                  "summary": "TDengine Connector"
                },
                "mongodb_single": {
                  "value": {
                    "name": "mongodb_single_connector",
                    "type": "mongodb_single",
                    "description": "My example mongodb_single connector",
                    "parameters": {
                      "pool_size": 8,
                      "enable": true,
                      "password": "******",
                      "username": "myuser",
                      "database": "mqtt",
                      "srv_record": false
                    }
                  },
                  "summary": "MongoDB Standalone Connector"
                },
                "greptimedb": {
                  "value": {
                    "name": "demo",
                    "type": "greptimedb",
                    "ssl": {
                      "enable": false
                    },
                    "description": "My example greptimedb connector",
                    "server": "127.0.0.1:4001",
                    "enable": true,
                    "password": "******",
                    "username": "example_username",
                    "resource_opts": {
                      "batch_size": 100,
                      "batch_time": "20ms"
                    },
                    "local_topic": "local/topic/#",
                    "dbname": "example_db"
                  },
                  "summary": "GreptimeDB Connector"
                },
                "opents": {
                  "value": {
                    "name": "opents_connector",
                    "type": "opents",
                    "description": "My example opents connector",
                    "pool_size": 8,
                    "server": "http://localhost:4242/",
                    "enable": true
                  },
                  "summary": "OpenTSDB Connector"
                },
                "abs": {
                  "value": {
                    "name": "my_connector",
                    "type": "azure_blob_storage",
                    "description": "My connector",
                    "enable": true,
                    "resource_opts": {
                      "start_timeout": "5s",
                      "start_after_created": true,
                      "health_check_interval": "45s"
                    },
                    "account_key": "******",
                    "account_name": "my_account_name"
                  },
                  "summary": "Azure Blob Storage Connector"
                },
                "mongodb_sharded": {
                  "value": {
                    "name": "mongodb_sharded_connector",
                    "type": "mongodb_sharded",
                    "description": "My example mongodb_sharded connector",
                    "parameters": {
                      "pool_size": 8,
                      "enable": true,
                      "password": "******",
                      "username": "myuser",
                      "database": "mqtt",
                      "srv_record": false
                    }
                  },
                  "summary": "MongoDB Sharded Connector"
                },
                "mongodb_rs": {
                  "value": {
                    "name": "mongodb_rs_connector",
                    "type": "mongodb_rs",
                    "description": "My example mongodb_rs connector",
                    "parameters": {
                      "pool_size": 8,
                      "enable": true,
                      "password": "******",
                      "username": "myuser",
                      "database": "mqtt",
                      "srv_record": false
                    }
                  },
                  "summary": "MongoDB Replica Set Connector"
                },
                "redis_single_producer": {
                  "value": {
                    "name": "my_connector",
                    "type": "redis",
                    "ssl": {
                      "enable": false
                    },
                    "description": "My redis single connector",
                    "enable": true,
                    "parameters": {
                      "pool_size": 8,
                      "server": "127.0.0.1:6379",
                      "password": "******",
                      "username": "test",
                      "database": 1,
                      "redis_type": "single"
                    }
                  },
                  "summary": "Redis Single Producer Connector"
                },
                "oracle": {
                  "value": {
                    "name": "oracle_connector",
                    "type": "oracle",
                    "description": "My example oracle connector",
                    "password": "oracle",
                    "pool_size": 8,
                    "resource_opts": {
                      "health_check_interval": "15s",
                      "start_timeout": "5s"
                    },
                    "server": "127.0.0.1:1521",
                    "service_name": "XE",
                    "sid": "XE",
                    "username": "system"
                  },
                  "summary": "Oracle Connector"
                },
                "hstreamdb": {
                  "value": {
                    "name": "hstreamdb_connector",
                    "type": "hstreamdb",
                    "description": "My example hstreamdb connector",
                    "grpc_timeout": "30s",
                    "resource_opts": {
                      "health_check_interval": "15s",
                      "start_timeout": "5s"
                    },
                    "ssl": {
                      "enable": false,
                      "verify": "verify_peer"
                    },
                    "url": "http://127.0.0.1:6570"
                  },
                  "summary": "HStreamDB Connector"
                },
                "influxdb_api_v1": {
                  "value": {
                    "name": "influxdb_connector",
                    "type": "influxdb",
                    "ssl": {
                      "enable": false
                    },
                    "description": "My example influxdb connector",
                    "server": "127.0.0.1:8086",
                    "enable": true,
                    "parameters": {
                      "password": "******",
                      "username": "example_username",
                      "database": "example_database",
                      "influxdb_type": "influxdb_api_v1"
                    }
                  },
                  "summary": "InfluxDB HTTP API V1 Connector"
                },
                "s3_aws": {
                  "value": {
                    "name": "my_s3_connector",
                    "port": 443,
                    "type": "s3",
                    "host": "s3.eu-east-1.amazonaws.com",
                    "description": "My S3 connector",
                    "enable": true,
                    "transport_options": {
                      "ssl": {
                        "verify": "verify_peer",
                        "enable": true
                      },
                      "connect_timeout": "1s",
                      "pool_size": 4,
                      "max_retries": 1,
                      "request_timeout": "60s",
                      "enable_pipelining": 1
                    },
                    "secret_access_key": "SECRET",
                    "access_key_id": "ACCESS"
                  },
                  "summary": "S3 Connector"
                },
                "cassandra": {
                  "value": {
                    "name": "cassandra_connector",
                    "type": "cassandra",
                    "description": "My example cassandra connector",
                    "pool_size": 8,
                    "password": "******",
                    "username": "root",
                    "servers": "127.0.0.1:9042",
                    "keyspace": "mqtt"
                  },
                  "summary": "Cassandra Connector"
                },
                "gcp_pubsub_consumer": {
                  "value": {
                    "name": "my_connector",
                    "type": "gcp_pubsub_producer",
                    "description": "my connector",
                    "connect_timeout": "15s",
                    "pool_size": 8,
                    "enable": true,
                    "max_retries": 2,
                    "resource_opts": {
                      "start_timeout": "5s",
                      "start_after_created": true,
                      "health_check_interval": "30s"
                    },
                    "service_account_json": {
                      "type": "service_account",
                      "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQI...",
                      "client_id": "123812831923812319190",
                      "project_id": "myproject",
                      "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                      "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                      "client_email": "test@myproject.iam.gserviceaccount.com",
                      "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/test%40myproject.iam.gserviceaccount.com",
                      "private_key_id": "kid",
                      "token_uri": "https://oauth2.googleapis.com/token"
                    },
                    "pipelining": 100
                  },
                  "summary": "GCP PubSub Consumer Connector"
                },
                "clickhouse": {
                  "value": {
                    "name": "clickhouse_connector",
                    "type": "clickhouse",
                    "description": "My example clickhouse connector",
                    "pool_size": 8,
                    "password": "******",
                    "url": "http://localhost:8123",
                    "username": "default",
                    "database": "mqtt"
                  },
                  "summary": "ClickHouse Connector"
                },
                "sqlserver": {
                  "value": {
                    "driver": "ms-sql",
                    "name": "sqlserver_connector",
                    "type": "sqlserver",
                    "description": "My example sqlserver connector",
                    "pool_size": 8,
                    "server": "127.0.0.1:1433",
                    "password": "******",
                    "username": "sa",
                    "database": "test",
                    "resource_opts": {
                      "health_check_interval": "20s"
                    }
                  },
                  "summary": "Microsoft SQL Server Connector"
                },
                "redis_cluster_producer": {
                  "value": {
                    "name": "my_connector",
                    "type": "redis",
                    "ssl": {
                      "enable": false
                    },
                    "description": "My redis cluster connector",
                    "enable": true,
                    "parameters": {
                      "pool_size": 8,
                      "password": "******",
                      "username": "test",
                      "servers": "127.0.0.1:6379,127.0.0.2:6379",
                      "redis_type": "cluster"
                    }
                  },
                  "summary": "Redis Cluster Producer Connector"
                },
                "matrix": {
                  "value": {
                    "name": "my_matrix_connector",
                    "type": "matrix",
                    "database": "emqx_data",
                    "enable": true,
                    "password": "public",
                    "pool_size": 8,
                    "server": "127.0.0.1:5432",
                    "ssl": {
                      "ciphers": [],
                      "depth": 10,
                      "enable": false,
                      "hibernate_after": "5s",
                      "log_level": "notice",
                      "reuse_sessions": true,
                      "secure_renegotiate": true,
                      "verify": "verify_peer",
                      "versions": [
                        "tlsv1.3",
                        "tlsv1.2"
                      ]
                    },
                    "username": "postgres"
                  },
                  "summary": "Matrix Connector"
                },
                "kafka_consumer": {
                  "value": {
                    "name": "my_connector",
                    "type": "kafka_consumer",
                    "resource_opts": {
                      "start_timeout": "5s",
                      "start_after_created": true,
                      "health_check_interval": "30s"
                    },
                    "bootstrap_hosts": "kafka.emqx.net:9092"
                  },
                  "summary": "Kafka Consumer Connector"
                },
                "rocketmq": {
                  "value": {
                    "name": "rocketmq_connector",
                    "type": "rocketmq",
                    "description": "My example rocketmq connector",
                    "enable": true,
                    "pool_size": 8,
                    "resource_opts": {
                      "health_check_interval": "15s",
                      "start_after_created": true,
                      "start_timeout": "5s"
                    },
                    "servers": "127.0.0.1:9876"
                  },
                  "summary": "RocketMQ Connector"
                },
                "pulsar": {
                  "value": {
                    "name": "pulsar_connector",
                    "type": "pulsar",
                    "ssl": {
                      "enable": false
                    },
                    "authentication": "none",
                    "description": "My example pulsar connector",
                    "connect_timeout": "5s",
                    "enable": true,
                    "servers": "pulsar://127.0.0.1:6650"
                  },
                  "summary": "Pulsar Connector"
                },
                "syskeeper_forwarder": {
                  "value": {
                    "name": "syskeeper_forwarder",
                    "type": "syskeeper_forwarder",
                    "pool_size": 16,
                    "server": "127.0.0.1:9092",
                    "enable": true,
                    "ack_timeout": "10s",
                    "ack_mode": "no_ack"
                  },
                  "summary": "Syskeeper Forwarder Connector"
                },
                "elasticsearch": {
                  "value": {
                    "name": "elasticsearch_connector",
                    "type": "elasticsearch",
                    "ssl": {
                      "enable": false
                    },
                    "authentication": {
                      "password": "******",
                      "username": "root"
                    },
                    "description": "My example elasticsearch connector",
                    "connect_timeout": "15s",
                    "pool_size": 8,
                    "server": "127.0.0.1:9200",
                    "enable": true,
                    "pool_type": "random",
                    "enable_pipelining": 100
                  },
                  "summary": "Elastic Search Connector"
                },
                "gcp_pubsub_producer": {
                  "value": {
                    "name": "my_connector",
                    "type": "gcp_pubsub_producer",
                    "connect_timeout": "10s",
                    "pool_size": 8,
                    "enable": true,
                    "max_retries": 2,
                    "resource_opts": {
                      "request_ttl": "60s"
                    },
                    "service_account_json": {
                      "type": "service_account",
                      "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQI...",
                      "client_id": "123812831923812319190",
                      "project_id": "myproject",
                      "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                      "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                      "client_email": "test@myproject.iam.gserviceaccount.com",
                      "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/test%40myproject.iam.gserviceaccount.com",
                      "private_key_id": "kid",
                      "token_uri": "https://oauth2.googleapis.com/token"
                    },
                    "pipelining": 100
                  },
                  "summary": "GCP PubSub Producer Connector"
                },
                "timescale": {
                  "value": {
                    "name": "my_timescale_connector",
                    "type": "timescale",
                    "database": "emqx_data",
                    "enable": true,
                    "password": "public",
                    "pool_size": 8,
                    "server": "127.0.0.1:5432",
                    "ssl": {
                      "ciphers": [],
                      "depth": 10,
                      "enable": false,
                      "hibernate_after": "5s",
                      "log_level": "notice",
                      "reuse_sessions": true,
                      "secure_renegotiate": true,
                      "verify": "verify_peer",
                      "versions": [
                        "tlsv1.3",
                        "tlsv1.2"
                      ]
                    },
                    "username": "postgres"
                  },
                  "summary": "Timescale Connector"
                },
                "redis_sentinel_producer": {
                  "value": {
                    "name": "my_connector",
                    "type": "redis",
                    "ssl": {
                      "enable": false
                    },
                    "description": "My redis sentinel connector",
                    "enable": true,
                    "parameters": {
                      "pool_size": 8,
                      "password": "******",
                      "username": "test",
                      "database": 1,
                      "servers": "127.0.0.1:6379,127.0.0.2:6379",
                      "sentinel": "myredismaster",
                      "redis_type": "sentinel"
                    }
                  },
                  "summary": "Redis Sentinel Producer Connector"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/bridge_timescale.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mongodb.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/gcp_pubsub_producer.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/elasticsearch.post"
                  },
                  {
                    "$ref": "#/components/schemas/connector_azure_blob_storage.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/syskeeper_forwarder.post"
                  },
                  {
                    "$ref": "#/components/schemas/pulsar.post"
                  },
                  {
                    "$ref": "#/components/schemas/rocketmq.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/kafka_consumer.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_matrix.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_sqlserver.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_influxdb.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_clickhouse.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/gcp_pubsub_consumer.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_cassa.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_hstreamdb.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_oracle.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/opents_connector.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_greptimedb.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_s3.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/tdengine_connector.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_dynamo.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/redis.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/rabbitmq.post"
                  },
                  {
                    "$ref": "#/components/schemas/connector_mqtt.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mysql.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/connector_postgres.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/connector_syskeeper_proxy.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_kinesis.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_kafka.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_azure_event_hub.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_datalayers.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/connector_couchbase.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/iotdb.post"
                  },
                  {
                    "$ref": "#/components/schemas/confluent.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_http.post_connector"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/schema_validations/reorder": {
      "post": {
        "description": "Reorder of all validations",
        "tags": [
          "Schema Validation"
        ],
        "parameters": [],
        "summary": "Reorder all validations",
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "not_found": {
                      "type": "array",
                      "description": "Validations not found",
                      "items": {
                        "type": "string"
                      }
                    },
                    "not_reordered": {
                      "type": "array",
                      "description": "Validations not referenced in input",
                      "items": {
                        "type": "string"
                      }
                    },
                    "duplicated": {
                      "type": "array",
                      "description": "Duplicated validations in input",
                      "items": {
                        "type": "string"
                      }
                    },
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "reorder": {
                  "value": {
                    "order": [
                      "bar",
                      "foo",
                      "baz"
                    ]
                  },
                  "summary": "Update"
                }
              },
              "schema": {
                "$ref": "#/components/schemas/schema_validation_http_api.reorder"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/nodes/{node}/sources/{id}/{operation}": {
      "post": {
        "description": "Start bridge on a specific node.",
        "tags": [
          "Sources"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "node",
            "description": "The node name, e.g. 'emqx@127.0.0.1'.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "emqx@127.0.0.1"
          },
          {
            "in": "path",
            "name": "id",
            "description": "The bridge id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_action"
          },
          {
            "in": "path",
            "name": "operation",
            "description": "Operation can be one of: 'start'.",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "start"
              ]
            },
            "example": "start"
          }
        ],
        "summary": "Manually start a bridge on a given node",
        "responses": {
          "204": {
            "description": "Operation success"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Problem with configuration of external service or bridge not enabled"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bridge or node not found or invalid operation"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "501": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_IMPLEMENTED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Implemented"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Service unavailable"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/authorization/sources/built_in_database/rules/clients": {
      "get": {
        "description": "Show the list of rules for clients",
        "tags": [
          "Authorization"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          },
          {
            "in": "query",
            "name": "like_clientid",
            "description": "Fuzzy search `clientid` as substring",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "password_based:built_in_database": {
                    "value": {
                      "data": [
                        {
                          "rules": [
                            {
                              "action": "publish",
                              "permission": "allow",
                              "topic": "test/topic/1"
                            },
                            {
                              "action": "subscribe",
                              "permission": "allow",
                              "topic": "test/topic/2"
                            },
                            {
                              "action": "all",
                              "permission": "deny",
                              "topic": "eq test/#"
                            },
                            {
                              "action": "publish",
                              "retain": "true",
                              "permission": "allow",
                              "topic": "test/topic/3",
                              "qos": [
                                "1"
                              ]
                            },
                            {
                              "action": "publish",
                              "retain": "all",
                              "permission": "allow",
                              "topic": "test/topic/4",
                              "qos": [
                                "0",
                                "1",
                                "2"
                              ]
                            }
                          ],
                          "clientid": "client1"
                        }
                      ],
                      "meta": {
                        "count": 1,
                        "limit": 100,
                        "page": 1
                      }
                    },
                    "summary": "ClientID"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authz_api_mnesia.clientid_response_data"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Add new rule for 'clientid'",
        "tags": [
          "Authorization"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": "Created"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad clientid or bad rule schema"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "password_based:built_in_database": {
                  "value": [
                    {
                      "rules": [
                        {
                          "action": "publish",
                          "permission": "allow",
                          "topic": "test/topic/1"
                        },
                        {
                          "action": "subscribe",
                          "permission": "allow",
                          "topic": "test/topic/2"
                        },
                        {
                          "action": "all",
                          "permission": "deny",
                          "topic": "eq test/#"
                        },
                        {
                          "action": "publish",
                          "retain": "true",
                          "permission": "allow",
                          "topic": "test/topic/3",
                          "qos": [
                            "1"
                          ]
                        },
                        {
                          "action": "publish",
                          "retain": "all",
                          "permission": "allow",
                          "topic": "test/topic/4",
                          "qos": [
                            "0",
                            "1",
                            "2"
                          ]
                        }
                      ],
                      "clientid": "client1"
                    }
                  ],
                  "summary": "ClientID"
                }
              },
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/emqx_authz_api_mnesia.rules_for_clientid"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/schema_registry": {
      "get": {
        "description": "List all registered schemas",
        "tags": [
          "Schema Registry"
        ],
        "parameters": [],
        "summary": "List registered schemas",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "sample": {
                    "value": [
                      {
                        "name": "my_avro_schema",
                        "type": "avro",
                        "description": "My Avro Schema",
                        "source": "{\"type\":\"record\",\"fields\":[{\"type\":\"int\",\"name\":\"i\"},{\"type\":\"string\",\"name\":\"s\"}]}"
                      }
                    ]
                  }
                },
                "schema": {
                  "type": "array",
                  "items": {
                    "oneOf": [
                      {
                        "$ref": "#/components/schemas/schema_registry.get_json"
                      },
                      {
                        "$ref": "#/components/schemas/schema_registry.get_protobuf"
                      },
                      {
                        "$ref": "#/components/schemas/schema_registry.get_avro"
                      }
                    ]
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Register a new schema",
        "tags": [
          "Schema Registry"
        ],
        "parameters": [],
        "summary": "Register a new schema",
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "avro_schema": {
                    "value": {
                      "name": "my_avro_schema",
                      "type": "avro",
                      "description": "My Avro Schema",
                      "source": "{\"type\":\"record\",\"fields\":[{\"type\":\"int\",\"name\":\"i\"},{\"type\":\"string\",\"name\":\"s\"}]}"
                    },
                    "summary": "Avro"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/schema_registry.get_json"
                    },
                    {
                      "$ref": "#/components/schemas/schema_registry.get_protobuf"
                    },
                    {
                      "$ref": "#/components/schemas/schema_registry.get_avro"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "ALREADY_EXISTS"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Schema already exists"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "avro_schema": {
                  "value": {
                    "name": "my_avro_schema",
                    "type": "avro",
                    "description": "My Avro Schema",
                    "source": "{\"type\":\"record\",\"fields\":[{\"type\":\"int\",\"name\":\"i\"},{\"type\":\"string\",\"name\":\"s\"}]}"
                  },
                  "summary": "Avro"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/schema_registry.get_json"
                  },
                  {
                    "$ref": "#/components/schemas/schema_registry.get_protobuf"
                  },
                  {
                    "$ref": "#/components/schemas/schema_registry.get_avro"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/sso": {
      "get": {
        "tags": [
          "Dashboard Single Sign-On"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/dashboard_sso.backend_status"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/mqtt/delayed/messages/{node}/{msgid}": {
      "get": {
        "description": "View delayed message",
        "tags": [
          "MQTT"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "node",
            "description": "The node where message from",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "msgid",
            "description": "Delayed Message ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_delayed_api.message_without_payload"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "MESSAGE_ID_SCHEMA_ERROR",
                        "INVALID_NODE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Message ID format"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "MESSAGE_ID_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Message ID not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete delayed message",
        "tags": [
          "MQTT"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "node",
            "description": "The node where message from",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "msgid",
            "description": "Delayed Message ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Delete delayed message success"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "MESSAGE_ID_SCHEMA_ERROR",
                        "INVALID_NODE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Message ID format"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "MESSAGE_ID_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Message ID not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/monitor_current/nodes/{node}": {
      "get": {
        "description": "Node monitor (statistics) data, e.g. number of connections and connection rate on the specified node.",
        "tags": [
          "Metrics"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "node",
            "description": "EMQX node name.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "emqx@127.0.0.1"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_dashboard_monitor_api.sampler_current_node"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Node not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/authentication/{id}/users": {
      "get": {
        "description": "List users in authenticator in global authentication chain.",
        "tags": [
          "Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Authenticator ID.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          },
          {
            "in": "query",
            "name": "like_user_id",
            "description": "Fuzzy search user_id (username or clientid).",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "is_superuser",
            "description": "Is superuser",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "data": [
                    {
                      "user_id": "user1"
                    },
                    {
                      "is_superuser": true,
                      "user_id": "user2"
                    }
                  ],
                  "meta": {
                    "count": 300,
                    "limit": 20,
                    "page": 0
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_users"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Create users for authenticator in global authentication chain.",
        "tags": [
          "Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Authenticator ID.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "regular_user": {
                    "value": {
                      "user_id": "user1"
                    },
                    "summary": "Regular user"
                  },
                  "super_user": {
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    },
                    "summary": "Superuser"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "regular_user": {
                  "value": {
                    "password": "******",
                    "user_id": "user1"
                  },
                  "summary": "Regular user"
                },
                "super_user": {
                  "value": {
                    "password": "******",
                    "is_superuser": true,
                    "user_id": "user2"
                  },
                  "summary": "Superuser"
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authn_api.request_user_create"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/sessions_count": {
      "get": {
        "description": "Get the total number of sessions in the cluster.<br/>By default, it includes only those sessions that have not expired.<br/>If the `broker.session_history_retain` config is set to a duration greater than 0s,<br/>this count will also include sessions that expired within the specified retain time.<br/>By specifying the `since` parameter, it can return the number of sessions that have expired within the specified time.",
        "tags": [
          "Clients"
        ],
        "parameters": [
          {
            "in": "query",
            "name": "since",
            "description": "Include sessions expired after this time (UNIX Epoch in seconds precision)",
            "required": false,
            "schema": {
              "default": 0,
              "type": "integer",
              "minimum": 0
            },
            "example": 1705391625
          }
        ],
        "responses": {
          "200": {
            "description": "Number of sessions",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Node {name} cannot handle this request."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/sso/oidc/callback": {
      "get": {
        "description": "The callback path for the OIDC authorization server..",
        "tags": [
          "Dashboard Single Sign-On"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "token": {
                      "type": "string",
                      "description": "Dashboard Auth Token"
                    },
                    "version": {
                      "type": "string",
                      "description": "EMQX Version",
                      "example": "5.0.0"
                    },
                    "license": {
                      "properties": {
                        "edition": {
                          "type": "string",
                          "enum": [
                            "opensource",
                            "enterprise"
                          ],
                          "description": "EMQX License. opensource or enterprise",
                          "example": "opensource"
                        }
                      },
                      "type": "object"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "401": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_USERNAME_OR_PWD"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Login failed. Bad username or password"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BACKEND_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Backend not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": []
      }
    },
    "/sources": {
      "get": {
        "description": "List all created bridges.",
        "tags": [
          "Sources"
        ],
        "parameters": [],
        "summary": "List sources",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": [
                  {
                    "status": "connected",
                    "description": "my source",
                    "enable": true,
                    "parameters": {
                      "topic": "my-topic",
                      "pull_max_messages": 100
                    },
                    "connector": "my_connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "request_ttl": "45s",
                      "health_check_interval": "30s"
                    }
                  },
                  {
                    "status": "connected",
                    "parameters": {
                      "topic": "mytopic"
                    },
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  {
                    "name": "mqtt_source",
                    "status": "connected",
                    "type": "mqtt",
                    "description": "My example mqtt source",
                    "enable": true,
                    "parameters": {
                      "topic": "remote/topic",
                      "qos": 1
                    },
                    "connector": "mqtt_connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  {
                    "name": "rabbitmq_source",
                    "status": "connected",
                    "type": "rabbitmq",
                    "description": "My example rabbitmq source",
                    "enable": true,
                    "parameters": {
                      "queue": "test_queue",
                      "no_ack": true
                    },
                    "connector": "rabbitmq_connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  }
                ],
                "schema": {
                  "type": "array",
                  "items": {
                    "oneOf": [
                      {
                        "$ref": "#/components/schemas/bridge_rabbitmq.get_source"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_mqtt_publisher.get_source"
                      },
                      {
                        "$ref": "#/components/schemas/kafka_consumer.get_source"
                      },
                      {
                        "$ref": "#/components/schemas/gcp_pubsub_consumer.get_source"
                      }
                    ]
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Create a new bridge by type and name.",
        "tags": [
          "Sources"
        ],
        "parameters": [],
        "summary": "Create source",
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "gcp_pubsub_consumer": {
                    "value": {
                      "status": "connected",
                      "description": "my source",
                      "enable": true,
                      "parameters": {
                        "topic": "my-topic",
                        "pull_max_messages": 100
                      },
                      "connector": "my_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "request_ttl": "45s",
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "GCP PubSub Consumer Source"
                  },
                  "kafka_consumer": {
                    "value": {
                      "status": "connected",
                      "parameters": {
                        "topic": "mytopic"
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "Kafka Consumer Source"
                  },
                  "mqtt": {
                    "value": {
                      "name": "mqtt_source",
                      "status": "connected",
                      "type": "mqtt",
                      "description": "My example mqtt source",
                      "enable": true,
                      "parameters": {
                        "topic": "remote/topic",
                        "qos": 1
                      },
                      "connector": "mqtt_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "MQTT Subscriber Source"
                  },
                  "rabbitmq": {
                    "value": {
                      "name": "rabbitmq_source",
                      "status": "connected",
                      "type": "rabbitmq",
                      "description": "My example rabbitmq source",
                      "enable": true,
                      "parameters": {
                        "queue": "test_queue",
                        "no_ack": true
                      },
                      "connector": "rabbitmq_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "RabbitMQ Subscriber Source"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/bridge_rabbitmq.get_source"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mqtt_publisher.get_source"
                    },
                    {
                      "$ref": "#/components/schemas/kafka_consumer.get_source"
                    },
                    {
                      "$ref": "#/components/schemas/gcp_pubsub_consumer.get_source"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "ALREADY_EXISTS"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Source already exists"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "gcp_pubsub_consumer": {
                  "value": {
                    "name": "my_action",
                    "type": "gcp_pubsub_consumer",
                    "description": "my source",
                    "enable": true,
                    "parameters": {
                      "topic": "my-topic",
                      "pull_max_messages": 100
                    },
                    "connector": "my_connector",
                    "resource_opts": {
                      "request_ttl": "45s",
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "GCP PubSub Consumer Source"
                },
                "kafka_consumer": {
                  "value": {
                    "name": "my_source",
                    "type": "kafka_consumer",
                    "parameters": {
                      "topic": "mytopic"
                    },
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "Kafka Consumer Source"
                },
                "mqtt": {
                  "value": {
                    "name": "mqtt_source",
                    "type": "mqtt",
                    "description": "My example mqtt source",
                    "enable": true,
                    "parameters": {
                      "topic": "remote/topic",
                      "qos": 1
                    },
                    "connector": "mqtt_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "MQTT Subscriber Source"
                },
                "rabbitmq": {
                  "value": {
                    "name": "rabbitmq_source",
                    "type": "rabbitmq",
                    "description": "My example rabbitmq source",
                    "enable": true,
                    "parameters": {
                      "queue": "test_queue",
                      "no_ack": true
                    },
                    "connector": "rabbitmq_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "RabbitMQ Subscriber Source"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/bridge_rabbitmq.post_source"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mqtt_publisher.post_source"
                  },
                  {
                    "$ref": "#/components/schemas/kafka_consumer.post_source"
                  },
                  {
                    "$ref": "#/components/schemas/gcp_pubsub_consumer.post_source"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/actions/{id}/enable/{enable}": {
      "put": {
        "description": "Enable or Disable bridge on all nodes in the cluster.",
        "tags": [
          "Actions"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_action"
          },
          {
            "in": "path",
            "name": "enable",
            "description": "Whether to enable this bridge.",
            "required": true,
            "schema": {
              "type": "boolean"
            },
            "example": true
          }
        ],
        "summary": "Enable or disable bridge",
        "responses": {
          "204": {
            "description": "Success"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bridge not found or invalid operation"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Service unavailable"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/prometheus/data_integration": {
      "get": {
        "description": "Get Prometheus Metrics for Data Integration",
        "tags": [
          "Monitor"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_prometheus_api.mode"
          }
        ],
        "responses": {
          "200": {
            "description": "Get Prometheus Data.",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          }
        },
        "security": []
      }
    },
    "/data/files/{filename}": {
      "get": {
        "description": "Download a data backup file",
        "tags": [
          "Data Backup"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "filename",
            "description": "Data backup file name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "node",
            "description": "Node name",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "enum": [
                    "binary"
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Backup file not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete a data backup file",
        "tags": [
          "Data Backup"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "filename",
            "description": "Data backup file name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "node",
            "description": "Node name",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Backup file not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/cluster": {
      "get": {
        "description": "Get cluster info",
        "tags": [
          "Cluster"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "name": {
                      "type": "string",
                      "description": "Cluster name"
                    },
                    "nodes": {
                      "type": "array",
                      "description": "Node name",
                      "items": {
                        "type": "string"
                      }
                    },
                    "self": {
                      "type": "string",
                      "description": "Self node name"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/plugins/{name}/{action}": {
      "put": {
        "description": "start/stop a installed plugin.<br/>- **start**: start the plugin.<br/>- **stop**: stop the plugin.<br/>",
        "tags": [
          "Plugins"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/plugins.name"
          },
          {
            "in": "path",
            "name": "action",
            "description": "Action",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "start",
                "stop"
              ]
            }
          }
        ],
        "summary": "Trigger action on an installed plugin",
        "responses": {
          "204": {
            "description": "Trigger action successfully"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Plugin Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/sources/{id}": {
      "get": {
        "description": "Get a bridge by id.",
        "tags": [
          "Sources"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_action"
          }
        ],
        "summary": "Get source",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "gcp_pubsub_consumer": {
                    "value": {
                      "status": "connected",
                      "description": "my source",
                      "enable": true,
                      "parameters": {
                        "topic": "my-topic",
                        "pull_max_messages": 100
                      },
                      "connector": "my_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "request_ttl": "45s",
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "GCP PubSub Consumer Source"
                  },
                  "kafka_consumer": {
                    "value": {
                      "status": "connected",
                      "parameters": {
                        "topic": "mytopic"
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "Kafka Consumer Source"
                  },
                  "mqtt": {
                    "value": {
                      "name": "mqtt_source",
                      "status": "connected",
                      "type": "mqtt",
                      "description": "My example mqtt source",
                      "enable": true,
                      "parameters": {
                        "topic": "remote/topic",
                        "qos": 1
                      },
                      "connector": "mqtt_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "MQTT Subscriber Source"
                  },
                  "rabbitmq": {
                    "value": {
                      "name": "rabbitmq_source",
                      "status": "connected",
                      "type": "rabbitmq",
                      "description": "My example rabbitmq source",
                      "enable": true,
                      "parameters": {
                        "queue": "test_queue",
                        "no_ack": true
                      },
                      "connector": "rabbitmq_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "RabbitMQ Subscriber Source"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/bridge_rabbitmq.get_source"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mqtt_publisher.get_source"
                    },
                    {
                      "$ref": "#/components/schemas/kafka_consumer.get_source"
                    },
                    {
                      "$ref": "#/components/schemas/gcp_pubsub_consumer.get_source"
                    }
                  ]
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Source not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update a bridge by id.",
        "tags": [
          "Sources"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_action"
          }
        ],
        "summary": "Update source",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "gcp_pubsub_consumer": {
                    "value": {
                      "status": "connected",
                      "description": "my source",
                      "enable": true,
                      "parameters": {
                        "topic": "my-topic",
                        "pull_max_messages": 100
                      },
                      "connector": "my_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "request_ttl": "45s",
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "GCP PubSub Consumer Source"
                  },
                  "kafka_consumer": {
                    "value": {
                      "status": "connected",
                      "parameters": {
                        "topic": "mytopic"
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "Kafka Consumer Source"
                  },
                  "mqtt": {
                    "value": {
                      "name": "mqtt_source",
                      "status": "connected",
                      "type": "mqtt",
                      "description": "My example mqtt source",
                      "enable": true,
                      "parameters": {
                        "topic": "remote/topic",
                        "qos": 1
                      },
                      "connector": "mqtt_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "MQTT Subscriber Source"
                  },
                  "rabbitmq": {
                    "value": {
                      "name": "rabbitmq_source",
                      "status": "connected",
                      "type": "rabbitmq",
                      "description": "My example rabbitmq source",
                      "enable": true,
                      "parameters": {
                        "queue": "test_queue",
                        "no_ack": true
                      },
                      "connector": "rabbitmq_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "RabbitMQ Subscriber Source"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/bridge_rabbitmq.get_source"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mqtt_publisher.get_source"
                    },
                    {
                      "$ref": "#/components/schemas/kafka_consumer.get_source"
                    },
                    {
                      "$ref": "#/components/schemas/gcp_pubsub_consumer.get_source"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Update source failed"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Source not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "gcp_pubsub_consumer": {
                  "value": {
                    "description": "my source",
                    "enable": true,
                    "parameters": {
                      "topic": "my-topic",
                      "pull_max_messages": 100
                    },
                    "connector": "my_connector",
                    "resource_opts": {
                      "request_ttl": "45s",
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "GCP PubSub Consumer Source"
                },
                "kafka_consumer": {
                  "value": {
                    "parameters": {
                      "topic": "mytopic"
                    },
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "Kafka Consumer Source"
                },
                "mqtt": {
                  "value": {
                    "description": "My example mqtt source",
                    "enable": true,
                    "parameters": {
                      "topic": "remote/topic",
                      "qos": 1
                    },
                    "connector": "mqtt_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "MQTT Subscriber Source"
                },
                "rabbitmq": {
                  "value": {
                    "description": "My example rabbitmq source",
                    "enable": true,
                    "parameters": {
                      "queue": "test_queue",
                      "no_ack": true
                    },
                    "connector": "rabbitmq_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "RabbitMQ Subscriber Source"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/bridge_rabbitmq.put_source"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mqtt_publisher.put_source"
                  },
                  {
                    "$ref": "#/components/schemas/kafka_consumer.put_source"
                  },
                  {
                    "$ref": "#/components/schemas/gcp_pubsub_consumer.put_source"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete a bridge by id.",
        "tags": [
          "Sources"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_action"
          },
          {
            "in": "query",
            "name": "also_delete_dep_actions",
            "description": "Whether to cascade delete dependent actions.",
            "required": false,
            "schema": {
              "default": false,
              "type": "boolean"
            }
          }
        ],
        "summary": "Delete source",
        "responses": {
          "204": {
            "description": "Source deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "rules": {
                      "type": "array",
                      "description": "Dependent Rule IDs",
                      "items": {
                        "type": "string"
                      }
                    },
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Cannot delete bridge while active rules are defined for this source"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Source not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Service unavailable"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/data/export": {
      "post": {
        "description": "Export a data backup file",
        "tags": [
          "Data Backup"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "node": "emqx@127.0.0.1",
                  "size": 22740,
                  "filename": "emqx-export-2023-11-23-19-13-19.043.tar.gz",
                  "created_at": "2023-11-23T19:13:19+02:00",
                  "created_at_sec": 1700759599
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_data_backup.backup_file_info"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/source_types": {
      "get": {
        "description": "Lists the available source types.",
        "tags": [
          "Sources"
        ],
        "parameters": [],
        "summary": "List available source types",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "types": {
                    "value": [
                      "rabbitmq",
                      "kafka_consumer",
                      "gcp_pubsub_consumer",
                      "mqtt"
                    ],
                    "summary": "Source types"
                  }
                },
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "enum": [
                      "rabbitmq",
                      "kafka_consumer",
                      "gcp_pubsub_consumer",
                      "mqtt"
                    ]
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gcp_devices": {
      "get": {
        "description": "List all devices imported from GCP IoT Core",
        "tags": [
          "GCP Devices"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "data": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/emqx_gcp_device_api.gcp_device_all_info"
                      }
                    },
                    "meta": {
                      "$ref": "#/components/schemas/public.meta"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Import authentication and config data for devices from GCP IoT Core",
        "tags": [
          "GCP Devices"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_gcp_device_api.import_result"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/emqx_gcp_device_api.gcp_exported_device"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/{name}/clients/{clientid}": {
      "get": {
        "description": "Get the gateway client information",
        "tags": [
          "Gateway Clients"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "description": "Client ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "gbt32960",
                "jt808",
                "lwm2m",
                "mqttsn",
                "ocpp",
                "stomp"
              ]
            }
          }
        ],
        "summary": "Get client info",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "lwm2m_client": {
                    "value": {
                      "recv_oct": 56,
                      "mailbox_len": 0,
                      "is_bridge": false,
                      "send_pkt": 1,
                      "lifetime": 86400,
                      "awaiting_rel_max": "infinity",
                      "mqueue_dropped": 0,
                      "keepalive": 0,
                      "node": "emqx@127.0.0.1",
                      "send_cnt": 1,
                      "created_at": "2021-12-07T10:44:02.721+08:00",
                      "proto_ver": "1.0",
                      "connected_at": "2021-12-07T10:44:02.721+08:00",
                      "proto_name": "LwM2M",
                      "inflight_max": "infinity",
                      "subscriptions_cnt": 0,
                      "send_oct": 61,
                      "endpoint_name": "urn:imei:154928475237123",
                      "heap_size": 4185,
                      "recv_msg": 0,
                      "port": 50675,
                      "mqueue_max": "infinity",
                      "disconnected_at": null,
                      "clean_start": true,
                      "clientid": "MzAyMzEzNTUwNzk1NDA1MzYyMzIwNzUxNjQwMTY1NzQ0NjE",
                      "awaiting_rel_cnt": 0,
                      "subscriptions_max": "infinity",
                      "ip_address": "127.0.0.1",
                      "username": "guest",
                      "mqueue_len": 0,
                      "inflight_cnt": 0,
                      "expiry_interval": 0,
                      "connected": true,
                      "reductions": 72022,
                      "send_msg": 0,
                      "recv_pkt": 1,
                      "recv_cnt": 1
                    },
                    "summary": "LwM2M client info"
                  },
                  "general_client": {
                    "value": {
                      "recv_oct": 56,
                      "mailbox_len": 0,
                      "is_bridge": false,
                      "send_pkt": 1,
                      "awaiting_rel_max": "infinity",
                      "mqueue_dropped": 0,
                      "keepalive": 0,
                      "node": "emqx@127.0.0.1",
                      "send_cnt": 1,
                      "created_at": "2021-12-07T10:44:02.721+08:00",
                      "proto_ver": "1.0",
                      "connected_at": "2021-12-07T10:44:02.721+08:00",
                      "proto_name": "STOMP",
                      "inflight_max": "infinity",
                      "subscriptions_cnt": 0,
                      "send_oct": 61,
                      "heap_size": 4185,
                      "recv_msg": 0,
                      "port": 50675,
                      "mqueue_max": "infinity",
                      "disconnected_at": null,
                      "clean_start": true,
                      "clientid": "MzAyMzEzNTUwNzk1NDA1MzYyMzIwNzUxNjQwMTY1NzQ0NjE",
                      "awaiting_rel_cnt": 0,
                      "subscriptions_max": "infinity",
                      "ip_address": "127.0.0.1",
                      "username": "guest",
                      "mqueue_len": 0,
                      "inflight_cnt": 0,
                      "expiry_interval": 0,
                      "connected": true,
                      "reductions": 72022,
                      "send_msg": 0,
                      "recv_pkt": 1,
                      "recv_cnt": 1
                    },
                    "summary": "General client info"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api_clients.exproto_client"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api_clients.lwm2m_client"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api_clients.coap_client"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api_clients.mqttsn_client"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api_clients.stomp_client"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Kick out the gateway client",
        "tags": [
          "Gateway Clients"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "description": "Client ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "gbt32960",
                "jt808",
                "lwm2m",
                "mqttsn",
                "ocpp",
                "stomp"
              ]
            }
          }
        ],
        "summary": "Kick out client",
        "responses": {
          "204": {
            "description": "Kicked"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/publish/bulk": {
      "post": {
        "description": "Possible HTTP response status code are:<br/><br/>200: All messages are delivered to at least one subscriber;<br/><br/>202: At least one message was not delivered to any subscriber;<br/><br/>400: At least one message is invalid. For example bad topic name, or QoS is out of range;<br/><br/>503: Failed to deliver at least one of the messages;<br/><br/><br/>In case there is at lest one invalid message in the batch, the HTTP response body<br/>is the same as for <code>/publish</code> API.<br/><br/>Otherwise the HTTP response body is an array of JSON objects indicating the publish<br/>result of each individual message in the batch.",
        "tags": [
          "Publish"
        ],
        "parameters": [],
        "summary": "Publish a batch of messages",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/emqx_mgmt_api_publish.publish_ok"
                  }
                }
              }
            }
          },
          "202": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/emqx_mgmt_api_publish.publish_error"
                  }
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/emqx_mgmt_api_publish.publish_error"
                      }
                    },
                    {
                      "$ref": "#/components/schemas/emqx_mgmt_api_publish.bad_request"
                    }
                  ]
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/emqx_mgmt_api_publish.publish_error"
                  }
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_publish.publish_message"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/nodes/{node}/bridges/{id}/{operation}": {
      "post": {
        "description": "Stop/Restart bridges on a specific node.",
        "tags": [
          "Bridges"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "node",
            "description": "The node name, e.g. emqx@127.0.0.1",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "emqx@127.0.0.1"
          },
          {
            "in": "path",
            "name": "id",
            "description": "The bridge Id. Must be of format {type}:{name}",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:http_example"
          },
          {
            "in": "path",
            "name": "operation",
            "description": "Operations can be one of: stop, restart",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "start",
                "stop",
                "restart"
              ]
            },
            "example": "start"
          }
        ],
        "summary": "Stop/restart bridge",
        "responses": {
          "204": {
            "description": "Operation success"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Problem with configuration of external service or bridge not enabled"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bridge or node not found or invalid operation"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "501": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_IMPLEMENTED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Implemented"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Service unavailable"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/rule_test": {
      "post": {
        "description": "Test a rule",
        "tags": [
          "Rules"
        ],
        "parameters": [],
        "summary": "Test a rule",
        "responses": {
          "200": {
            "description": "Rule Test Pass"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Invalid Parameters"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "412": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_MATCH"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "SQL Not Match"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/rule_engine.rule_test"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/authorization/sources/built_in_database/rules/clients/{clientid}": {
      "get": {
        "description": "Get rule for 'clientid'",
        "tags": [
          "Authorization"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_authz_api_mnesia.clientid"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "password_based:built_in_database": {
                    "value": {
                      "rules": [
                        {
                          "action": "publish",
                          "permission": "allow",
                          "topic": "test/topic/1"
                        },
                        {
                          "action": "subscribe",
                          "permission": "allow",
                          "topic": "test/topic/2"
                        },
                        {
                          "action": "all",
                          "permission": "deny",
                          "topic": "eq test/#"
                        },
                        {
                          "action": "publish",
                          "retain": "true",
                          "permission": "allow",
                          "topic": "test/topic/3",
                          "qos": [
                            "1"
                          ]
                        },
                        {
                          "action": "publish",
                          "retain": "all",
                          "permission": "allow",
                          "topic": "test/topic/4",
                          "qos": [
                            "0",
                            "1",
                            "2"
                          ]
                        }
                      ],
                      "clientid": "client1"
                    },
                    "summary": "ClientID"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authz_api_mnesia.rules_for_clientid"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Set rule for 'clientid'",
        "tags": [
          "Authorization"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_authz_api_mnesia.clientid"
          }
        ],
        "responses": {
          "204": {
            "description": "Updated"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad clientid or bad rule schema"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "password_based:built_in_database": {
                  "value": {
                    "rules": [
                      {
                        "action": "publish",
                        "permission": "allow",
                        "topic": "test/topic/1"
                      },
                      {
                        "action": "subscribe",
                        "permission": "allow",
                        "topic": "test/topic/2"
                      },
                      {
                        "action": "all",
                        "permission": "deny",
                        "topic": "eq test/#"
                      },
                      {
                        "action": "publish",
                        "retain": "true",
                        "permission": "allow",
                        "topic": "test/topic/3",
                        "qos": [
                          "1"
                        ]
                      },
                      {
                        "action": "publish",
                        "retain": "all",
                        "permission": "allow",
                        "topic": "test/topic/4",
                        "qos": [
                          "0",
                          "1",
                          "2"
                        ]
                      }
                    ],
                    "clientid": "client1"
                  },
                  "summary": "ClientID"
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authz_api_mnesia.rules_for_clientid"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete rule for 'clientid'",
        "tags": [
          "Authorization"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_authz_api_mnesia.clientid"
          }
        ],
        "responses": {
          "204": {
            "description": "Deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad clientid"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "ClientID Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/configs/sysmon": {
      "get": {
        "description": "Get the sub-configurations under *sysmon*",
        "tags": [
          "Configs"
        ],
        "parameters": [],
        "summary": "Get the sub-configurations under *sysmon*",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx.sysmon"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "config not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update the sub-configurations under *sysmon*",
        "tags": [
          "Configs"
        ],
        "parameters": [],
        "summary": "Update the sub-configurations under *sysmon*",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx.sysmon"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UPDATE_FAILED",
                        "INVALID_CONFIG"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "403": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UPDATE_FAILED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx.sysmon"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/connectors/{id}": {
      "get": {
        "description": "Get a connector by id.",
        "tags": [
          "Connectors"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The connector id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_connector"
          }
        ],
        "summary": "Get connector",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "influxdb_api_v2": {
                    "value": {
                      "name": "influxdb_connector",
                      "status": "connected",
                      "type": "influxdb",
                      "ssl": {
                        "enable": false
                      },
                      "description": "My example influxdb connector",
                      "server": "127.0.0.1:8086",
                      "enable": true,
                      "parameters": {
                        "org": "examlpe_org",
                        "token": "example_token",
                        "bucket": "example_bucket",
                        "influxdb_type": "influxdb_api_v2"
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ]
                    },
                    "summary": "InfluxDB HTTP API V2 Connector"
                  },
                  "http": {
                    "value": {
                      "name": "my_http_connector",
                      "status": "connected",
                      "type": "http",
                      "connect_timeout": "15s",
                      "pool_size": 1,
                      "enable": true,
                      "headers": {
                        "content-type": "application/json"
                      },
                      "url": "http://localhost:8080/api/v1",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "pool_type": "hash",
                      "enable_pipelining": 100
                    },
                    "summary": "HTTP Connector"
                  },
                  "confluent_producer": {
                    "value": {
                      "name": "my_confluent_producer_connector",
                      "status": "connected",
                      "type": "confluent_producer",
                      "ssl": {
                        "verify": "verify_none",
                        "enable": true,
                        "versions": [
                          "tlsv1.3",
                          "tlsv1.2"
                        ],
                        "server_name_indication": "auto"
                      },
                      "authentication": {
                        "password": "******"
                      },
                      "connect_timeout": "5s",
                      "enable": true,
                      "socket_opts": {
                        "nodelay": true,
                        "recbuf": "1024KB",
                        "sndbuf": "1024KB",
                        "tcp_keepalive": "none"
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "min_metadata_refresh_interval": "3s",
                      "bootstrap_hosts": "xyz.sa-east1.gcp.confluent.cloud:9092",
                      "metadata_request_timeout": "4s"
                    },
                    "summary": "Confluent Connector"
                  },
                  "iotdb": {
                    "value": {
                      "name": "iotdb_connector",
                      "status": "connected",
                      "type": "iotdb",
                      "ssl": {
                        "enable": false
                      },
                      "authentication": {
                        "password": "******",
                        "username": "root"
                      },
                      "description": "My example iotdb connector",
                      "connect_timeout": "15s",
                      "pool_size": 8,
                      "enable": true,
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "base_url": "http://iotdb.local:18080/",
                      "actions": [
                        "my_action"
                      ],
                      "pool_type": "random",
                      "enable_pipelining": 100,
                      "iotdb_version": "v1.3.x"
                    },
                    "summary": "Apache IoTDB Connector"
                  },
                  "couchbase": {
                    "value": {
                      "status": "connected",
                      "ssl": {
                        "enable": true
                      },
                      "description": "My connector",
                      "server": "couchbase:8093",
                      "enable": true,
                      "password": "******",
                      "username": "admin",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "start_timeout": "5s",
                        "start_after_created": true,
                        "health_check_interval": "45s"
                      }
                    },
                    "summary": "Couchbase Connector"
                  },
                  "datalayers": {
                    "value": {
                      "name": "datalayers_connector",
                      "status": "connected",
                      "type": "datalayers",
                      "ssl": {
                        "enable": false
                      },
                      "description": "My example datalayers connector",
                      "server": "127.0.0.1:8361",
                      "enable": true,
                      "parameters": {
                        "password": "******",
                        "username": "example_username",
                        "database": "example_database"
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ]
                    },
                    "summary": "Datalayers Connector"
                  },
                  "azure_event_hub_producer": {
                    "value": {
                      "name": "my_azure_event_hub_producer_connector",
                      "status": "connected",
                      "type": "azure_event_hub_producer",
                      "ssl": {
                        "verify": "verify_none",
                        "enable": true,
                        "versions": [
                          "tlsv1.3",
                          "tlsv1.2"
                        ],
                        "server_name_indication": "auto"
                      },
                      "authentication": {
                        "password": "******"
                      },
                      "connect_timeout": "5s",
                      "enable": true,
                      "socket_opts": {
                        "nodelay": true,
                        "recbuf": "1024KB",
                        "sndbuf": "1024KB",
                        "tcp_keepalive": "none"
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "min_metadata_refresh_interval": "3s",
                      "bootstrap_hosts": "namespace.servicebus.windows.net:9093",
                      "metadata_request_timeout": "4s"
                    },
                    "summary": "Azure Event Hub Connector"
                  },
                  "kafka_producer": {
                    "value": {
                      "name": "my_kafka_producer_connector",
                      "status": "connected",
                      "type": "kafka_producer",
                      "authentication": {
                        "mechanism": "plain",
                        "password": "******",
                        "username": "username"
                      },
                      "connect_timeout": "5s",
                      "enable": true,
                      "socket_opts": {
                        "nodelay": true,
                        "recbuf": "1024KB",
                        "sndbuf": "1024KB",
                        "tcp_keepalive": "none"
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "min_metadata_refresh_interval": "3s",
                      "bootstrap_hosts": "localhost:9092",
                      "metadata_request_timeout": "4s"
                    },
                    "summary": "Kafka Producer Connector"
                  },
                  "kinesis": {
                    "value": {
                      "name": "kinesis_connector",
                      "status": "connected",
                      "type": "kinesis",
                      "description": "My example kinesis connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "aws_access_key_id": "your_access_key",
                      "aws_secret_access_key": "aws_secret_key",
                      "endpoint": "http://localhost:4566",
                      "max_retries": 2,
                      "pool_size": 8
                    },
                    "summary": "Kinesis Connector"
                  },
                  "syskeeper_proxy": {
                    "value": {
                      "name": "syskeeper_proxy",
                      "status": "connected",
                      "type": "syskeeper_proxy",
                      "listen": "127.0.0.1:9092",
                      "enable": true,
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "acceptors": 16,
                      "handshake_timeout": "16s",
                      "actions": [
                        "my_action"
                      ]
                    },
                    "summary": "Syskeeper Proxy Connector"
                  },
                  "pgsql": {
                    "value": {
                      "name": "my_pgsql_connector",
                      "status": "connected",
                      "type": "pgsql",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "database": "emqx_data",
                      "enable": true,
                      "password": "public",
                      "pool_size": 8,
                      "server": "127.0.0.1:5432",
                      "ssl": {
                        "ciphers": [],
                        "depth": 10,
                        "enable": false,
                        "hibernate_after": "5s",
                        "log_level": "notice",
                        "reuse_sessions": true,
                        "secure_renegotiate": true,
                        "verify": "verify_peer",
                        "versions": [
                          "tlsv1.3",
                          "tlsv1.2"
                        ]
                      },
                      "username": "postgres"
                    },
                    "summary": "PostgreSQL Connector"
                  },
                  "mysql": {
                    "value": {
                      "name": "mysql_connector",
                      "status": "connected",
                      "type": "mysql",
                      "description": "My example mysql connector",
                      "pool_size": 8,
                      "server": "127.0.0.1:3306",
                      "password": "******",
                      "username": "root",
                      "database": "test",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "resource_opts": {
                        "health_check_interval": "20s"
                      }
                    },
                    "summary": "MySQL Connector"
                  },
                  "rabbitmq": {
                    "value": {
                      "timeout": "5s",
                      "name": "rabbitmq_connector",
                      "port": 5672,
                      "status": "connected",
                      "type": "rabbitmq",
                      "ssl": {
                        "enable": false
                      },
                      "description": "My example rabbitmq connector",
                      "pool_size": 8,
                      "server": "127.0.0.1",
                      "enable": true,
                      "password": "******",
                      "username": "guest",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "heartbeat": "30s",
                      "actions": [
                        "my_action"
                      ],
                      "virtual_host": "/"
                    },
                    "summary": "Rabbitmq Connector"
                  },
                  "dynamo": {
                    "value": {
                      "name": "dynamo_connector",
                      "status": "connected",
                      "type": "dynamo",
                      "description": "My example dynamo connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "aws_access_key_id": "root",
                      "aws_secret_access_key": "******",
                      "enable": true,
                      "pool_size": 8,
                      "region": "us-west-2",
                      "resource_opts": {
                        "health_check_interval": "15s",
                        "start_timeout": "5s"
                      },
                      "url": "http://127.0.0.1:8000"
                    },
                    "summary": "DynamoDB Connector"
                  },
                  "tdengine": {
                    "value": {
                      "name": "tdengine_connector",
                      "status": "connected",
                      "type": "tdengine",
                      "description": "My example tdengine connector",
                      "pool_size": 8,
                      "server": "127.0.0.1:6041",
                      "enable": true,
                      "password": "******",
                      "username": "root",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ]
                    },
                    "summary": "TDengine Connector"
                  },
                  "mongodb_single": {
                    "value": {
                      "name": "mongodb_single_connector",
                      "status": "connected",
                      "type": "mongodb_single",
                      "description": "My example mongodb_single connector",
                      "parameters": {
                        "pool_size": 8,
                        "enable": true,
                        "password": "******",
                        "username": "myuser",
                        "database": "mqtt",
                        "srv_record": false
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ]
                    },
                    "summary": "MongoDB Standalone Connector"
                  },
                  "greptimedb": {
                    "value": {
                      "name": "demo",
                      "status": "connected",
                      "type": "greptimedb",
                      "ssl": {
                        "enable": false
                      },
                      "description": "My example greptimedb connector",
                      "server": "127.0.0.1:4001",
                      "enable": true,
                      "password": "******",
                      "username": "example_username",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "resource_opts": {
                        "batch_size": 100,
                        "batch_time": "20ms"
                      },
                      "local_topic": "local/topic/#",
                      "dbname": "example_db"
                    },
                    "summary": "GreptimeDB Connector"
                  },
                  "opents": {
                    "value": {
                      "name": "opents_connector",
                      "status": "connected",
                      "type": "opents",
                      "description": "My example opents connector",
                      "pool_size": 8,
                      "server": "http://localhost:4242/",
                      "enable": true,
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ]
                    },
                    "summary": "OpenTSDB Connector"
                  },
                  "abs": {
                    "value": {
                      "status": "connected",
                      "description": "My connector",
                      "enable": true,
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "start_timeout": "5s",
                        "start_after_created": true,
                        "health_check_interval": "45s"
                      },
                      "account_key": "******",
                      "account_name": "my_account_name"
                    },
                    "summary": "Azure Blob Storage Connector"
                  },
                  "mongodb_sharded": {
                    "value": {
                      "name": "mongodb_sharded_connector",
                      "status": "connected",
                      "type": "mongodb_sharded",
                      "description": "My example mongodb_sharded connector",
                      "parameters": {
                        "pool_size": 8,
                        "enable": true,
                        "password": "******",
                        "username": "myuser",
                        "database": "mqtt",
                        "srv_record": false
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ]
                    },
                    "summary": "MongoDB Sharded Connector"
                  },
                  "mongodb_rs": {
                    "value": {
                      "name": "mongodb_rs_connector",
                      "status": "connected",
                      "type": "mongodb_rs",
                      "description": "My example mongodb_rs connector",
                      "parameters": {
                        "pool_size": 8,
                        "enable": true,
                        "password": "******",
                        "username": "myuser",
                        "database": "mqtt",
                        "srv_record": false
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ]
                    },
                    "summary": "MongoDB Replica Set Connector"
                  },
                  "redis_single_producer": {
                    "value": {
                      "status": "connected",
                      "ssl": {
                        "enable": false
                      },
                      "description": "My redis single connector",
                      "enable": true,
                      "parameters": {
                        "pool_size": 8,
                        "server": "127.0.0.1:6379",
                        "password": "******",
                        "username": "test",
                        "database": 1,
                        "redis_type": "single"
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ]
                    },
                    "summary": "Redis Single Producer Connector"
                  },
                  "oracle": {
                    "value": {
                      "name": "oracle_connector",
                      "status": "connected",
                      "type": "oracle",
                      "description": "My example oracle connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "password": "oracle",
                      "pool_size": 8,
                      "resource_opts": {
                        "health_check_interval": "15s",
                        "start_timeout": "5s"
                      },
                      "server": "127.0.0.1:1521",
                      "service_name": "XE",
                      "sid": "XE",
                      "username": "system"
                    },
                    "summary": "Oracle Connector"
                  },
                  "hstreamdb": {
                    "value": {
                      "name": "hstreamdb_connector",
                      "status": "connected",
                      "type": "hstreamdb",
                      "description": "My example hstreamdb connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "grpc_timeout": "30s",
                      "resource_opts": {
                        "health_check_interval": "15s",
                        "start_timeout": "5s"
                      },
                      "ssl": {
                        "enable": false,
                        "verify": "verify_peer"
                      },
                      "url": "http://127.0.0.1:6570"
                    },
                    "summary": "HStreamDB Connector"
                  },
                  "influxdb_api_v1": {
                    "value": {
                      "name": "influxdb_connector",
                      "status": "connected",
                      "type": "influxdb",
                      "ssl": {
                        "enable": false
                      },
                      "description": "My example influxdb connector",
                      "server": "127.0.0.1:8086",
                      "enable": true,
                      "parameters": {
                        "password": "******",
                        "username": "example_username",
                        "database": "example_database",
                        "influxdb_type": "influxdb_api_v1"
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ]
                    },
                    "summary": "InfluxDB HTTP API V1 Connector"
                  },
                  "s3_aws": {
                    "value": {
                      "port": 443,
                      "status": "connected",
                      "host": "s3.eu-east-1.amazonaws.com",
                      "description": "My S3 connector",
                      "enable": true,
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "transport_options": {
                        "ssl": {
                          "verify": "verify_peer",
                          "enable": true
                        },
                        "connect_timeout": "1s",
                        "pool_size": 4,
                        "max_retries": 1,
                        "request_timeout": "60s",
                        "enable_pipelining": 1
                      },
                      "secret_access_key": "SECRET",
                      "access_key_id": "ACCESS"
                    },
                    "summary": "S3 Connector"
                  },
                  "cassandra": {
                    "value": {
                      "name": "cassandra_connector",
                      "status": "connected",
                      "type": "cassandra",
                      "description": "My example cassandra connector",
                      "pool_size": 8,
                      "password": "******",
                      "username": "root",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "servers": "127.0.0.1:9042",
                      "actions": [
                        "my_action"
                      ],
                      "keyspace": "mqtt"
                    },
                    "summary": "Cassandra Connector"
                  },
                  "gcp_pubsub_consumer": {
                    "value": {
                      "name": "my_connector",
                      "status": "connected",
                      "type": "gcp_pubsub_producer",
                      "description": "my connector",
                      "connect_timeout": "15s",
                      "pool_size": 8,
                      "enable": true,
                      "max_retries": 2,
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "resource_opts": {
                        "start_timeout": "5s",
                        "start_after_created": true,
                        "health_check_interval": "30s"
                      },
                      "service_account_json": {
                        "type": "service_account",
                        "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQI...",
                        "client_id": "123812831923812319190",
                        "project_id": "myproject",
                        "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                        "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                        "client_email": "test@myproject.iam.gserviceaccount.com",
                        "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/test%40myproject.iam.gserviceaccount.com",
                        "private_key_id": "kid",
                        "token_uri": "https://oauth2.googleapis.com/token"
                      },
                      "pipelining": 100
                    },
                    "summary": "GCP PubSub Consumer Connector"
                  },
                  "clickhouse": {
                    "value": {
                      "name": "clickhouse_connector",
                      "status": "connected",
                      "type": "clickhouse",
                      "description": "My example clickhouse connector",
                      "pool_size": 8,
                      "password": "******",
                      "url": "http://localhost:8123",
                      "username": "default",
                      "database": "mqtt",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ]
                    },
                    "summary": "ClickHouse Connector"
                  },
                  "sqlserver": {
                    "value": {
                      "driver": "ms-sql",
                      "name": "sqlserver_connector",
                      "status": "connected",
                      "type": "sqlserver",
                      "description": "My example sqlserver connector",
                      "pool_size": 8,
                      "server": "127.0.0.1:1433",
                      "password": "******",
                      "username": "sa",
                      "database": "test",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "resource_opts": {
                        "health_check_interval": "20s"
                      }
                    },
                    "summary": "Microsoft SQL Server Connector"
                  },
                  "redis_cluster_producer": {
                    "value": {
                      "status": "connected",
                      "ssl": {
                        "enable": false
                      },
                      "description": "My redis cluster connector",
                      "enable": true,
                      "parameters": {
                        "pool_size": 8,
                        "password": "******",
                        "username": "test",
                        "servers": "127.0.0.1:6379,127.0.0.2:6379",
                        "redis_type": "cluster"
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ]
                    },
                    "summary": "Redis Cluster Producer Connector"
                  },
                  "matrix": {
                    "value": {
                      "name": "my_matrix_connector",
                      "status": "connected",
                      "type": "matrix",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "database": "emqx_data",
                      "enable": true,
                      "password": "public",
                      "pool_size": 8,
                      "server": "127.0.0.1:5432",
                      "ssl": {
                        "ciphers": [],
                        "depth": 10,
                        "enable": false,
                        "hibernate_after": "5s",
                        "log_level": "notice",
                        "reuse_sessions": true,
                        "secure_renegotiate": true,
                        "verify": "verify_peer",
                        "versions": [
                          "tlsv1.3",
                          "tlsv1.2"
                        ]
                      },
                      "username": "postgres"
                    },
                    "summary": "Matrix Connector"
                  },
                  "kafka_consumer": {
                    "value": {
                      "name": "my_connector",
                      "status": "connected",
                      "type": "kafka_consumer",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "start_timeout": "5s",
                        "start_after_created": true,
                        "health_check_interval": "30s"
                      },
                      "bootstrap_hosts": "kafka.emqx.net:9092"
                    },
                    "summary": "Kafka Consumer Connector"
                  },
                  "rocketmq": {
                    "value": {
                      "name": "rocketmq_connector",
                      "status": "connected",
                      "type": "rocketmq",
                      "description": "My example rocketmq connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "enable": true,
                      "pool_size": 8,
                      "resource_opts": {
                        "health_check_interval": "15s",
                        "start_after_created": true,
                        "start_timeout": "5s"
                      },
                      "servers": "127.0.0.1:9876"
                    },
                    "summary": "RocketMQ Connector"
                  },
                  "pulsar": {
                    "value": {
                      "name": "pulsar_connector",
                      "status": "connected",
                      "type": "pulsar",
                      "ssl": {
                        "enable": false
                      },
                      "authentication": "none",
                      "description": "My example pulsar connector",
                      "connect_timeout": "5s",
                      "enable": true,
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "servers": "pulsar://127.0.0.1:6650",
                      "actions": [
                        "my_action"
                      ]
                    },
                    "summary": "Pulsar Connector"
                  },
                  "syskeeper_forwarder": {
                    "value": {
                      "name": "syskeeper_forwarder",
                      "status": "connected",
                      "type": "syskeeper_forwarder",
                      "pool_size": 16,
                      "server": "127.0.0.1:9092",
                      "enable": true,
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "ack_timeout": "10s",
                      "actions": [
                        "my_action"
                      ],
                      "ack_mode": "no_ack"
                    },
                    "summary": "Syskeeper Forwarder Connector"
                  },
                  "elasticsearch": {
                    "value": {
                      "name": "elasticsearch_connector",
                      "status": "connected",
                      "type": "elasticsearch",
                      "ssl": {
                        "enable": false
                      },
                      "authentication": {
                        "password": "******",
                        "username": "root"
                      },
                      "description": "My example elasticsearch connector",
                      "connect_timeout": "15s",
                      "pool_size": 8,
                      "server": "127.0.0.1:9200",
                      "enable": true,
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "pool_type": "random",
                      "enable_pipelining": 100
                    },
                    "summary": "Elastic Search Connector"
                  },
                  "gcp_pubsub_producer": {
                    "value": {
                      "name": "my_connector",
                      "status": "connected",
                      "type": "gcp_pubsub_producer",
                      "connect_timeout": "10s",
                      "pool_size": 8,
                      "enable": true,
                      "max_retries": 2,
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "resource_opts": {
                        "request_ttl": "60s"
                      },
                      "service_account_json": {
                        "type": "service_account",
                        "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQI...",
                        "client_id": "123812831923812319190",
                        "project_id": "myproject",
                        "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                        "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                        "client_email": "test@myproject.iam.gserviceaccount.com",
                        "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/test%40myproject.iam.gserviceaccount.com",
                        "private_key_id": "kid",
                        "token_uri": "https://oauth2.googleapis.com/token"
                      },
                      "pipelining": 100
                    },
                    "summary": "GCP PubSub Producer Connector"
                  },
                  "timescale": {
                    "value": {
                      "name": "my_timescale_connector",
                      "status": "connected",
                      "type": "timescale",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "database": "emqx_data",
                      "enable": true,
                      "password": "public",
                      "pool_size": 8,
                      "server": "127.0.0.1:5432",
                      "ssl": {
                        "ciphers": [],
                        "depth": 10,
                        "enable": false,
                        "hibernate_after": "5s",
                        "log_level": "notice",
                        "reuse_sessions": true,
                        "secure_renegotiate": true,
                        "verify": "verify_peer",
                        "versions": [
                          "tlsv1.3",
                          "tlsv1.2"
                        ]
                      },
                      "username": "postgres"
                    },
                    "summary": "Timescale Connector"
                  },
                  "redis_sentinel_producer": {
                    "value": {
                      "status": "connected",
                      "ssl": {
                        "enable": false
                      },
                      "description": "My redis sentinel connector",
                      "enable": true,
                      "parameters": {
                        "pool_size": 8,
                        "password": "******",
                        "username": "test",
                        "database": 1,
                        "servers": "127.0.0.1:6379,127.0.0.2:6379",
                        "sentinel": "myredismaster",
                        "redis_type": "sentinel"
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ]
                    },
                    "summary": "Redis Sentinel Producer Connector"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/bridge_timescale.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mongodb.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/gcp_pubsub_producer.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/elasticsearch.get"
                    },
                    {
                      "$ref": "#/components/schemas/connector_azure_blob_storage.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/syskeeper_forwarder.get"
                    },
                    {
                      "$ref": "#/components/schemas/pulsar.get"
                    },
                    {
                      "$ref": "#/components/schemas/rocketmq.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/kafka_consumer.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_matrix.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_sqlserver.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_influxdb.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_clickhouse.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/gcp_pubsub_consumer.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_cassa.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_hstreamdb.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_oracle.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/opents_connector.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_greptimedb.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_s3.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/tdengine_connector.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_dynamo.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/redis.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/rabbitmq.get"
                    },
                    {
                      "$ref": "#/components/schemas/connector_mqtt.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mysql.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/connector_postgres.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/connector_syskeeper_proxy.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_kinesis.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_kafka.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_azure_event_hub.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_datalayers.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/connector_couchbase.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/iotdb.get"
                    },
                    {
                      "$ref": "#/components/schemas/confluent.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_http.get_connector"
                    }
                  ]
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Connector not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update a connector by id.",
        "tags": [
          "Connectors"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The connector id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_connector"
          }
        ],
        "summary": "Update connector",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "influxdb_api_v2": {
                    "value": {
                      "name": "influxdb_connector",
                      "status": "connected",
                      "type": "influxdb",
                      "ssl": {
                        "enable": false
                      },
                      "description": "My example influxdb connector",
                      "server": "127.0.0.1:8086",
                      "enable": true,
                      "parameters": {
                        "org": "examlpe_org",
                        "token": "example_token",
                        "bucket": "example_bucket",
                        "influxdb_type": "influxdb_api_v2"
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ]
                    },
                    "summary": "InfluxDB HTTP API V2 Connector"
                  },
                  "http": {
                    "value": {
                      "name": "my_http_connector",
                      "status": "connected",
                      "type": "http",
                      "connect_timeout": "15s",
                      "pool_size": 1,
                      "enable": true,
                      "headers": {
                        "content-type": "application/json"
                      },
                      "url": "http://localhost:8080/api/v1",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "pool_type": "hash",
                      "enable_pipelining": 100
                    },
                    "summary": "HTTP Connector"
                  },
                  "confluent_producer": {
                    "value": {
                      "name": "my_confluent_producer_connector",
                      "status": "connected",
                      "type": "confluent_producer",
                      "ssl": {
                        "verify": "verify_none",
                        "enable": true,
                        "versions": [
                          "tlsv1.3",
                          "tlsv1.2"
                        ],
                        "server_name_indication": "auto"
                      },
                      "authentication": {
                        "password": "******"
                      },
                      "connect_timeout": "5s",
                      "enable": true,
                      "socket_opts": {
                        "nodelay": true,
                        "recbuf": "1024KB",
                        "sndbuf": "1024KB",
                        "tcp_keepalive": "none"
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "min_metadata_refresh_interval": "3s",
                      "bootstrap_hosts": "xyz.sa-east1.gcp.confluent.cloud:9092",
                      "metadata_request_timeout": "4s"
                    },
                    "summary": "Confluent Connector"
                  },
                  "iotdb": {
                    "value": {
                      "name": "iotdb_connector",
                      "status": "connected",
                      "type": "iotdb",
                      "ssl": {
                        "enable": false
                      },
                      "authentication": {
                        "password": "******",
                        "username": "root"
                      },
                      "description": "My example iotdb connector",
                      "connect_timeout": "15s",
                      "pool_size": 8,
                      "enable": true,
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "base_url": "http://iotdb.local:18080/",
                      "actions": [
                        "my_action"
                      ],
                      "pool_type": "random",
                      "enable_pipelining": 100,
                      "iotdb_version": "v1.3.x"
                    },
                    "summary": "Apache IoTDB Connector"
                  },
                  "couchbase": {
                    "value": {
                      "status": "connected",
                      "ssl": {
                        "enable": true
                      },
                      "description": "My connector",
                      "server": "couchbase:8093",
                      "enable": true,
                      "password": "******",
                      "username": "admin",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "start_timeout": "5s",
                        "start_after_created": true,
                        "health_check_interval": "45s"
                      }
                    },
                    "summary": "Couchbase Connector"
                  },
                  "datalayers": {
                    "value": {
                      "name": "datalayers_connector",
                      "status": "connected",
                      "type": "datalayers",
                      "ssl": {
                        "enable": false
                      },
                      "description": "My example datalayers connector",
                      "server": "127.0.0.1:8361",
                      "enable": true,
                      "parameters": {
                        "password": "******",
                        "username": "example_username",
                        "database": "example_database"
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ]
                    },
                    "summary": "Datalayers Connector"
                  },
                  "azure_event_hub_producer": {
                    "value": {
                      "name": "my_azure_event_hub_producer_connector",
                      "status": "connected",
                      "type": "azure_event_hub_producer",
                      "ssl": {
                        "verify": "verify_none",
                        "enable": true,
                        "versions": [
                          "tlsv1.3",
                          "tlsv1.2"
                        ],
                        "server_name_indication": "auto"
                      },
                      "authentication": {
                        "password": "******"
                      },
                      "connect_timeout": "5s",
                      "enable": true,
                      "socket_opts": {
                        "nodelay": true,
                        "recbuf": "1024KB",
                        "sndbuf": "1024KB",
                        "tcp_keepalive": "none"
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "min_metadata_refresh_interval": "3s",
                      "bootstrap_hosts": "namespace.servicebus.windows.net:9093",
                      "metadata_request_timeout": "4s"
                    },
                    "summary": "Azure Event Hub Connector"
                  },
                  "kafka_producer": {
                    "value": {
                      "name": "my_kafka_producer_connector",
                      "status": "connected",
                      "type": "kafka_producer",
                      "authentication": {
                        "mechanism": "plain",
                        "password": "******",
                        "username": "username"
                      },
                      "connect_timeout": "5s",
                      "enable": true,
                      "socket_opts": {
                        "nodelay": true,
                        "recbuf": "1024KB",
                        "sndbuf": "1024KB",
                        "tcp_keepalive": "none"
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "min_metadata_refresh_interval": "3s",
                      "bootstrap_hosts": "localhost:9092",
                      "metadata_request_timeout": "4s"
                    },
                    "summary": "Kafka Producer Connector"
                  },
                  "kinesis": {
                    "value": {
                      "name": "kinesis_connector",
                      "status": "connected",
                      "type": "kinesis",
                      "description": "My example kinesis connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "aws_access_key_id": "your_access_key",
                      "aws_secret_access_key": "aws_secret_key",
                      "endpoint": "http://localhost:4566",
                      "max_retries": 2,
                      "pool_size": 8
                    },
                    "summary": "Kinesis Connector"
                  },
                  "syskeeper_proxy": {
                    "value": {
                      "name": "syskeeper_proxy",
                      "status": "connected",
                      "type": "syskeeper_proxy",
                      "listen": "127.0.0.1:9092",
                      "enable": true,
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "acceptors": 16,
                      "handshake_timeout": "16s",
                      "actions": [
                        "my_action"
                      ]
                    },
                    "summary": "Syskeeper Proxy Connector"
                  },
                  "pgsql": {
                    "value": {
                      "name": "my_pgsql_connector",
                      "status": "connected",
                      "type": "pgsql",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "database": "emqx_data",
                      "enable": true,
                      "password": "public",
                      "pool_size": 8,
                      "server": "127.0.0.1:5432",
                      "ssl": {
                        "ciphers": [],
                        "depth": 10,
                        "enable": false,
                        "hibernate_after": "5s",
                        "log_level": "notice",
                        "reuse_sessions": true,
                        "secure_renegotiate": true,
                        "verify": "verify_peer",
                        "versions": [
                          "tlsv1.3",
                          "tlsv1.2"
                        ]
                      },
                      "username": "postgres"
                    },
                    "summary": "PostgreSQL Connector"
                  },
                  "mysql": {
                    "value": {
                      "name": "mysql_connector",
                      "status": "connected",
                      "type": "mysql",
                      "description": "My example mysql connector",
                      "pool_size": 8,
                      "server": "127.0.0.1:3306",
                      "password": "******",
                      "username": "root",
                      "database": "test",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "resource_opts": {
                        "health_check_interval": "20s"
                      }
                    },
                    "summary": "MySQL Connector"
                  },
                  "rabbitmq": {
                    "value": {
                      "timeout": "5s",
                      "name": "rabbitmq_connector",
                      "port": 5672,
                      "status": "connected",
                      "type": "rabbitmq",
                      "ssl": {
                        "enable": false
                      },
                      "description": "My example rabbitmq connector",
                      "pool_size": 8,
                      "server": "127.0.0.1",
                      "enable": true,
                      "password": "******",
                      "username": "guest",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "heartbeat": "30s",
                      "actions": [
                        "my_action"
                      ],
                      "virtual_host": "/"
                    },
                    "summary": "Rabbitmq Connector"
                  },
                  "dynamo": {
                    "value": {
                      "name": "dynamo_connector",
                      "status": "connected",
                      "type": "dynamo",
                      "description": "My example dynamo connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "aws_access_key_id": "root",
                      "aws_secret_access_key": "******",
                      "enable": true,
                      "pool_size": 8,
                      "region": "us-west-2",
                      "resource_opts": {
                        "health_check_interval": "15s",
                        "start_timeout": "5s"
                      },
                      "url": "http://127.0.0.1:8000"
                    },
                    "summary": "DynamoDB Connector"
                  },
                  "tdengine": {
                    "value": {
                      "name": "tdengine_connector",
                      "status": "connected",
                      "type": "tdengine",
                      "description": "My example tdengine connector",
                      "pool_size": 8,
                      "server": "127.0.0.1:6041",
                      "enable": true,
                      "password": "******",
                      "username": "root",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ]
                    },
                    "summary": "TDengine Connector"
                  },
                  "mongodb_single": {
                    "value": {
                      "name": "mongodb_single_connector",
                      "status": "connected",
                      "type": "mongodb_single",
                      "description": "My example mongodb_single connector",
                      "parameters": {
                        "pool_size": 8,
                        "enable": true,
                        "password": "******",
                        "username": "myuser",
                        "database": "mqtt",
                        "srv_record": false
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ]
                    },
                    "summary": "MongoDB Standalone Connector"
                  },
                  "greptimedb": {
                    "value": {
                      "name": "demo",
                      "status": "connected",
                      "type": "greptimedb",
                      "ssl": {
                        "enable": false
                      },
                      "description": "My example greptimedb connector",
                      "server": "127.0.0.1:4001",
                      "enable": true,
                      "password": "******",
                      "username": "example_username",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "resource_opts": {
                        "batch_size": 100,
                        "batch_time": "20ms"
                      },
                      "local_topic": "local/topic/#",
                      "dbname": "example_db"
                    },
                    "summary": "GreptimeDB Connector"
                  },
                  "opents": {
                    "value": {
                      "name": "opents_connector",
                      "status": "connected",
                      "type": "opents",
                      "description": "My example opents connector",
                      "pool_size": 8,
                      "server": "http://localhost:4242/",
                      "enable": true,
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ]
                    },
                    "summary": "OpenTSDB Connector"
                  },
                  "abs": {
                    "value": {
                      "status": "connected",
                      "description": "My connector",
                      "enable": true,
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "start_timeout": "5s",
                        "start_after_created": true,
                        "health_check_interval": "45s"
                      },
                      "account_key": "******",
                      "account_name": "my_account_name"
                    },
                    "summary": "Azure Blob Storage Connector"
                  },
                  "mongodb_sharded": {
                    "value": {
                      "name": "mongodb_sharded_connector",
                      "status": "connected",
                      "type": "mongodb_sharded",
                      "description": "My example mongodb_sharded connector",
                      "parameters": {
                        "pool_size": 8,
                        "enable": true,
                        "password": "******",
                        "username": "myuser",
                        "database": "mqtt",
                        "srv_record": false
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ]
                    },
                    "summary": "MongoDB Sharded Connector"
                  },
                  "mongodb_rs": {
                    "value": {
                      "name": "mongodb_rs_connector",
                      "status": "connected",
                      "type": "mongodb_rs",
                      "description": "My example mongodb_rs connector",
                      "parameters": {
                        "pool_size": 8,
                        "enable": true,
                        "password": "******",
                        "username": "myuser",
                        "database": "mqtt",
                        "srv_record": false
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ]
                    },
                    "summary": "MongoDB Replica Set Connector"
                  },
                  "redis_single_producer": {
                    "value": {
                      "status": "connected",
                      "ssl": {
                        "enable": false
                      },
                      "description": "My redis single connector",
                      "enable": true,
                      "parameters": {
                        "pool_size": 8,
                        "server": "127.0.0.1:6379",
                        "password": "******",
                        "username": "test",
                        "database": 1,
                        "redis_type": "single"
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ]
                    },
                    "summary": "Redis Single Producer Connector"
                  },
                  "oracle": {
                    "value": {
                      "name": "oracle_connector",
                      "status": "connected",
                      "type": "oracle",
                      "description": "My example oracle connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "password": "oracle",
                      "pool_size": 8,
                      "resource_opts": {
                        "health_check_interval": "15s",
                        "start_timeout": "5s"
                      },
                      "server": "127.0.0.1:1521",
                      "service_name": "XE",
                      "sid": "XE",
                      "username": "system"
                    },
                    "summary": "Oracle Connector"
                  },
                  "hstreamdb": {
                    "value": {
                      "name": "hstreamdb_connector",
                      "status": "connected",
                      "type": "hstreamdb",
                      "description": "My example hstreamdb connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "grpc_timeout": "30s",
                      "resource_opts": {
                        "health_check_interval": "15s",
                        "start_timeout": "5s"
                      },
                      "ssl": {
                        "enable": false,
                        "verify": "verify_peer"
                      },
                      "url": "http://127.0.0.1:6570"
                    },
                    "summary": "HStreamDB Connector"
                  },
                  "influxdb_api_v1": {
                    "value": {
                      "name": "influxdb_connector",
                      "status": "connected",
                      "type": "influxdb",
                      "ssl": {
                        "enable": false
                      },
                      "description": "My example influxdb connector",
                      "server": "127.0.0.1:8086",
                      "enable": true,
                      "parameters": {
                        "password": "******",
                        "username": "example_username",
                        "database": "example_database",
                        "influxdb_type": "influxdb_api_v1"
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ]
                    },
                    "summary": "InfluxDB HTTP API V1 Connector"
                  },
                  "s3_aws": {
                    "value": {
                      "port": 443,
                      "status": "connected",
                      "host": "s3.eu-east-1.amazonaws.com",
                      "description": "My S3 connector",
                      "enable": true,
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "transport_options": {
                        "ssl": {
                          "verify": "verify_peer",
                          "enable": true
                        },
                        "connect_timeout": "1s",
                        "pool_size": 4,
                        "max_retries": 1,
                        "request_timeout": "60s",
                        "enable_pipelining": 1
                      },
                      "secret_access_key": "SECRET",
                      "access_key_id": "ACCESS"
                    },
                    "summary": "S3 Connector"
                  },
                  "cassandra": {
                    "value": {
                      "name": "cassandra_connector",
                      "status": "connected",
                      "type": "cassandra",
                      "description": "My example cassandra connector",
                      "pool_size": 8,
                      "password": "******",
                      "username": "root",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "servers": "127.0.0.1:9042",
                      "actions": [
                        "my_action"
                      ],
                      "keyspace": "mqtt"
                    },
                    "summary": "Cassandra Connector"
                  },
                  "gcp_pubsub_consumer": {
                    "value": {
                      "name": "my_connector",
                      "status": "connected",
                      "type": "gcp_pubsub_producer",
                      "description": "my connector",
                      "connect_timeout": "15s",
                      "pool_size": 8,
                      "enable": true,
                      "max_retries": 2,
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "resource_opts": {
                        "start_timeout": "5s",
                        "start_after_created": true,
                        "health_check_interval": "30s"
                      },
                      "service_account_json": {
                        "type": "service_account",
                        "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQI...",
                        "client_id": "123812831923812319190",
                        "project_id": "myproject",
                        "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                        "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                        "client_email": "test@myproject.iam.gserviceaccount.com",
                        "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/test%40myproject.iam.gserviceaccount.com",
                        "private_key_id": "kid",
                        "token_uri": "https://oauth2.googleapis.com/token"
                      },
                      "pipelining": 100
                    },
                    "summary": "GCP PubSub Consumer Connector"
                  },
                  "clickhouse": {
                    "value": {
                      "name": "clickhouse_connector",
                      "status": "connected",
                      "type": "clickhouse",
                      "description": "My example clickhouse connector",
                      "pool_size": 8,
                      "password": "******",
                      "url": "http://localhost:8123",
                      "username": "default",
                      "database": "mqtt",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ]
                    },
                    "summary": "ClickHouse Connector"
                  },
                  "sqlserver": {
                    "value": {
                      "driver": "ms-sql",
                      "name": "sqlserver_connector",
                      "status": "connected",
                      "type": "sqlserver",
                      "description": "My example sqlserver connector",
                      "pool_size": 8,
                      "server": "127.0.0.1:1433",
                      "password": "******",
                      "username": "sa",
                      "database": "test",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "resource_opts": {
                        "health_check_interval": "20s"
                      }
                    },
                    "summary": "Microsoft SQL Server Connector"
                  },
                  "redis_cluster_producer": {
                    "value": {
                      "status": "connected",
                      "ssl": {
                        "enable": false
                      },
                      "description": "My redis cluster connector",
                      "enable": true,
                      "parameters": {
                        "pool_size": 8,
                        "password": "******",
                        "username": "test",
                        "servers": "127.0.0.1:6379,127.0.0.2:6379",
                        "redis_type": "cluster"
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ]
                    },
                    "summary": "Redis Cluster Producer Connector"
                  },
                  "matrix": {
                    "value": {
                      "name": "my_matrix_connector",
                      "status": "connected",
                      "type": "matrix",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "database": "emqx_data",
                      "enable": true,
                      "password": "public",
                      "pool_size": 8,
                      "server": "127.0.0.1:5432",
                      "ssl": {
                        "ciphers": [],
                        "depth": 10,
                        "enable": false,
                        "hibernate_after": "5s",
                        "log_level": "notice",
                        "reuse_sessions": true,
                        "secure_renegotiate": true,
                        "verify": "verify_peer",
                        "versions": [
                          "tlsv1.3",
                          "tlsv1.2"
                        ]
                      },
                      "username": "postgres"
                    },
                    "summary": "Matrix Connector"
                  },
                  "kafka_consumer": {
                    "value": {
                      "name": "my_connector",
                      "status": "connected",
                      "type": "kafka_consumer",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "start_timeout": "5s",
                        "start_after_created": true,
                        "health_check_interval": "30s"
                      },
                      "bootstrap_hosts": "kafka.emqx.net:9092"
                    },
                    "summary": "Kafka Consumer Connector"
                  },
                  "rocketmq": {
                    "value": {
                      "name": "rocketmq_connector",
                      "status": "connected",
                      "type": "rocketmq",
                      "description": "My example rocketmq connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "enable": true,
                      "pool_size": 8,
                      "resource_opts": {
                        "health_check_interval": "15s",
                        "start_after_created": true,
                        "start_timeout": "5s"
                      },
                      "servers": "127.0.0.1:9876"
                    },
                    "summary": "RocketMQ Connector"
                  },
                  "pulsar": {
                    "value": {
                      "name": "pulsar_connector",
                      "status": "connected",
                      "type": "pulsar",
                      "ssl": {
                        "enable": false
                      },
                      "authentication": "none",
                      "description": "My example pulsar connector",
                      "connect_timeout": "5s",
                      "enable": true,
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "servers": "pulsar://127.0.0.1:6650",
                      "actions": [
                        "my_action"
                      ]
                    },
                    "summary": "Pulsar Connector"
                  },
                  "syskeeper_forwarder": {
                    "value": {
                      "name": "syskeeper_forwarder",
                      "status": "connected",
                      "type": "syskeeper_forwarder",
                      "pool_size": 16,
                      "server": "127.0.0.1:9092",
                      "enable": true,
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "ack_timeout": "10s",
                      "actions": [
                        "my_action"
                      ],
                      "ack_mode": "no_ack"
                    },
                    "summary": "Syskeeper Forwarder Connector"
                  },
                  "elasticsearch": {
                    "value": {
                      "name": "elasticsearch_connector",
                      "status": "connected",
                      "type": "elasticsearch",
                      "ssl": {
                        "enable": false
                      },
                      "authentication": {
                        "password": "******",
                        "username": "root"
                      },
                      "description": "My example elasticsearch connector",
                      "connect_timeout": "15s",
                      "pool_size": 8,
                      "server": "127.0.0.1:9200",
                      "enable": true,
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "pool_type": "random",
                      "enable_pipelining": 100
                    },
                    "summary": "Elastic Search Connector"
                  },
                  "gcp_pubsub_producer": {
                    "value": {
                      "name": "my_connector",
                      "status": "connected",
                      "type": "gcp_pubsub_producer",
                      "connect_timeout": "10s",
                      "pool_size": 8,
                      "enable": true,
                      "max_retries": 2,
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "resource_opts": {
                        "request_ttl": "60s"
                      },
                      "service_account_json": {
                        "type": "service_account",
                        "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQI...",
                        "client_id": "123812831923812319190",
                        "project_id": "myproject",
                        "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                        "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                        "client_email": "test@myproject.iam.gserviceaccount.com",
                        "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/test%40myproject.iam.gserviceaccount.com",
                        "private_key_id": "kid",
                        "token_uri": "https://oauth2.googleapis.com/token"
                      },
                      "pipelining": 100
                    },
                    "summary": "GCP PubSub Producer Connector"
                  },
                  "timescale": {
                    "value": {
                      "name": "my_timescale_connector",
                      "status": "connected",
                      "type": "timescale",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "database": "emqx_data",
                      "enable": true,
                      "password": "public",
                      "pool_size": 8,
                      "server": "127.0.0.1:5432",
                      "ssl": {
                        "ciphers": [],
                        "depth": 10,
                        "enable": false,
                        "hibernate_after": "5s",
                        "log_level": "notice",
                        "reuse_sessions": true,
                        "secure_renegotiate": true,
                        "verify": "verify_peer",
                        "versions": [
                          "tlsv1.3",
                          "tlsv1.2"
                        ]
                      },
                      "username": "postgres"
                    },
                    "summary": "Timescale Connector"
                  },
                  "redis_sentinel_producer": {
                    "value": {
                      "status": "connected",
                      "ssl": {
                        "enable": false
                      },
                      "description": "My redis sentinel connector",
                      "enable": true,
                      "parameters": {
                        "pool_size": 8,
                        "password": "******",
                        "username": "test",
                        "database": 1,
                        "servers": "127.0.0.1:6379,127.0.0.2:6379",
                        "sentinel": "myredismaster",
                        "redis_type": "sentinel"
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ]
                    },
                    "summary": "Redis Sentinel Producer Connector"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/bridge_timescale.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mongodb.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/gcp_pubsub_producer.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/elasticsearch.get"
                    },
                    {
                      "$ref": "#/components/schemas/connector_azure_blob_storage.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/syskeeper_forwarder.get"
                    },
                    {
                      "$ref": "#/components/schemas/pulsar.get"
                    },
                    {
                      "$ref": "#/components/schemas/rocketmq.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/kafka_consumer.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_matrix.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_sqlserver.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_influxdb.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_clickhouse.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/gcp_pubsub_consumer.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_cassa.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_hstreamdb.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_oracle.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/opents_connector.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_greptimedb.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_s3.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/tdengine_connector.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_dynamo.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/redis.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/rabbitmq.get"
                    },
                    {
                      "$ref": "#/components/schemas/connector_mqtt.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mysql.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/connector_postgres.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/connector_syskeeper_proxy.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_kinesis.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_kafka.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_azure_event_hub.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_datalayers.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/connector_couchbase.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/iotdb.get"
                    },
                    {
                      "$ref": "#/components/schemas/confluent.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_http.get_connector"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Update connector failed"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Connector not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "influxdb_api_v2": {
                  "value": {
                    "ssl": {
                      "enable": false
                    },
                    "description": "My example influxdb connector",
                    "server": "127.0.0.1:8086",
                    "enable": true,
                    "parameters": {
                      "org": "examlpe_org",
                      "token": "example_token",
                      "bucket": "example_bucket",
                      "influxdb_type": "influxdb_api_v2"
                    }
                  },
                  "summary": "InfluxDB HTTP API V2 Connector"
                },
                "http": {
                  "value": {
                    "connect_timeout": "15s",
                    "pool_size": 1,
                    "enable": true,
                    "headers": {
                      "content-type": "application/json"
                    },
                    "url": "http://localhost:8080/api/v1",
                    "pool_type": "hash",
                    "enable_pipelining": 100
                  },
                  "summary": "HTTP Connector"
                },
                "confluent_producer": {
                  "value": {
                    "authentication": {
                      "password": "******"
                    },
                    "connect_timeout": "5s",
                    "enable": true,
                    "socket_opts": {
                      "nodelay": true,
                      "recbuf": "1024KB",
                      "sndbuf": "1024KB",
                      "tcp_keepalive": "none"
                    },
                    "min_metadata_refresh_interval": "3s",
                    "bootstrap_hosts": "xyz.sa-east1.gcp.confluent.cloud:9092",
                    "metadata_request_timeout": "4s"
                  },
                  "summary": "Confluent Connector"
                },
                "iotdb": {
                  "value": {
                    "name": "iotdb_connector",
                    "type": "iotdb",
                    "ssl": {
                      "enable": false
                    },
                    "authentication": {
                      "password": "******",
                      "username": "root"
                    },
                    "description": "My example iotdb connector",
                    "connect_timeout": "15s",
                    "pool_size": 8,
                    "enable": true,
                    "base_url": "http://iotdb.local:18080/",
                    "pool_type": "random",
                    "enable_pipelining": 100,
                    "iotdb_version": "v1.3.x"
                  },
                  "summary": "Apache IoTDB Connector"
                },
                "couchbase": {
                  "value": {
                    "ssl": {
                      "enable": true
                    },
                    "description": "My connector",
                    "server": "couchbase:8093",
                    "enable": true,
                    "password": "******",
                    "username": "admin",
                    "resource_opts": {
                      "start_timeout": "5s",
                      "start_after_created": true,
                      "health_check_interval": "45s"
                    }
                  },
                  "summary": "Couchbase Connector"
                },
                "datalayers": {
                  "value": {
                    "ssl": {
                      "enable": false
                    },
                    "description": "My example datalayers connector",
                    "server": "127.0.0.1:8361",
                    "enable": true,
                    "parameters": {
                      "password": "******",
                      "username": "example_username",
                      "database": "example_database"
                    }
                  },
                  "summary": "Datalayers Connector"
                },
                "azure_event_hub_producer": {
                  "value": {
                    "authentication": {
                      "password": "******"
                    },
                    "connect_timeout": "5s",
                    "enable": true,
                    "socket_opts": {
                      "nodelay": true,
                      "recbuf": "1024KB",
                      "sndbuf": "1024KB",
                      "tcp_keepalive": "none"
                    },
                    "min_metadata_refresh_interval": "3s",
                    "bootstrap_hosts": "namespace.servicebus.windows.net:9093",
                    "metadata_request_timeout": "4s"
                  },
                  "summary": "Azure Event Hub Connector"
                },
                "kafka_producer": {
                  "value": {
                    "authentication": {
                      "mechanism": "plain",
                      "password": "******",
                      "username": "username"
                    },
                    "connect_timeout": "5s",
                    "enable": true,
                    "socket_opts": {
                      "nodelay": true,
                      "recbuf": "1024KB",
                      "sndbuf": "1024KB",
                      "tcp_keepalive": "none"
                    },
                    "min_metadata_refresh_interval": "3s",
                    "bootstrap_hosts": "localhost:9092",
                    "metadata_request_timeout": "4s"
                  },
                  "summary": "Kafka Producer Connector"
                },
                "kinesis": {
                  "value": {
                    "description": "My example kinesis connector",
                    "aws_access_key_id": "your_access_key",
                    "aws_secret_access_key": "aws_secret_key",
                    "endpoint": "http://localhost:4566",
                    "max_retries": 2,
                    "pool_size": 8
                  },
                  "summary": "Kinesis Connector"
                },
                "syskeeper_proxy": {
                  "value": {
                    "listen": "127.0.0.1:9092",
                    "enable": true,
                    "acceptors": 16,
                    "handshake_timeout": "16s"
                  },
                  "summary": "Syskeeper Proxy Connector"
                },
                "pgsql": {
                  "value": {
                    "database": "emqx_data",
                    "enable": true,
                    "password": "public",
                    "pool_size": 8,
                    "server": "127.0.0.1:5432",
                    "ssl": {
                      "ciphers": [],
                      "depth": 10,
                      "enable": false,
                      "hibernate_after": "5s",
                      "log_level": "notice",
                      "reuse_sessions": true,
                      "secure_renegotiate": true,
                      "verify": "verify_peer",
                      "versions": [
                        "tlsv1.3",
                        "tlsv1.2"
                      ]
                    },
                    "username": "postgres"
                  },
                  "summary": "PostgreSQL Connector"
                },
                "mysql": {
                  "value": {
                    "description": "My example mysql connector",
                    "pool_size": 8,
                    "server": "127.0.0.1:3306",
                    "password": "******",
                    "username": "root",
                    "database": "test",
                    "resource_opts": {
                      "health_check_interval": "20s"
                    }
                  },
                  "summary": "MySQL Connector"
                },
                "rabbitmq": {
                  "value": {
                    "timeout": "5s",
                    "name": "rabbitmq_connector",
                    "port": 5672,
                    "type": "rabbitmq",
                    "ssl": {
                      "enable": false
                    },
                    "description": "My example rabbitmq connector",
                    "pool_size": 8,
                    "server": "127.0.0.1",
                    "enable": true,
                    "password": "******",
                    "username": "guest",
                    "heartbeat": "30s",
                    "virtual_host": "/"
                  },
                  "summary": "Rabbitmq Connector"
                },
                "dynamo": {
                  "value": {
                    "description": "My example dynamo connector",
                    "aws_access_key_id": "root",
                    "aws_secret_access_key": "******",
                    "enable": true,
                    "pool_size": 8,
                    "region": "us-west-2",
                    "resource_opts": {
                      "health_check_interval": "15s",
                      "start_timeout": "5s"
                    },
                    "url": "http://127.0.0.1:8000"
                  },
                  "summary": "DynamoDB Connector"
                },
                "tdengine": {
                  "value": {
                    "name": "tdengine_connector",
                    "type": "tdengine",
                    "description": "My example tdengine connector",
                    "pool_size": 8,
                    "server": "127.0.0.1:6041",
                    "enable": true,
                    "password": "******",
                    "username": "root"
                  },
                  "summary": "TDengine Connector"
                },
                "mongodb_single": {
                  "value": {
                    "description": "My example mongodb_single connector",
                    "parameters": {
                      "pool_size": 8,
                      "enable": true,
                      "password": "******",
                      "username": "myuser",
                      "database": "mqtt",
                      "srv_record": false
                    }
                  },
                  "summary": "MongoDB Standalone Connector"
                },
                "greptimedb": {
                  "value": {
                    "name": "demo",
                    "type": "greptimedb",
                    "ssl": {
                      "enable": false
                    },
                    "description": "My example greptimedb connector",
                    "server": "127.0.0.1:4001",
                    "enable": true,
                    "password": "******",
                    "username": "example_username",
                    "resource_opts": {
                      "batch_size": 100,
                      "batch_time": "20ms"
                    },
                    "local_topic": "local/topic/#",
                    "dbname": "example_db"
                  },
                  "summary": "GreptimeDB Connector"
                },
                "opents": {
                  "value": {
                    "name": "opents_connector",
                    "type": "opents",
                    "description": "My example opents connector",
                    "pool_size": 8,
                    "server": "http://localhost:4242/",
                    "enable": true
                  },
                  "summary": "OpenTSDB Connector"
                },
                "abs": {
                  "value": {
                    "description": "My connector",
                    "enable": true,
                    "resource_opts": {
                      "start_timeout": "5s",
                      "start_after_created": true,
                      "health_check_interval": "45s"
                    },
                    "account_key": "******",
                    "account_name": "my_account_name"
                  },
                  "summary": "Azure Blob Storage Connector"
                },
                "mongodb_sharded": {
                  "value": {
                    "description": "My example mongodb_sharded connector",
                    "parameters": {
                      "pool_size": 8,
                      "enable": true,
                      "password": "******",
                      "username": "myuser",
                      "database": "mqtt",
                      "srv_record": false
                    }
                  },
                  "summary": "MongoDB Sharded Connector"
                },
                "mongodb_rs": {
                  "value": {
                    "description": "My example mongodb_rs connector",
                    "parameters": {
                      "pool_size": 8,
                      "enable": true,
                      "password": "******",
                      "username": "myuser",
                      "database": "mqtt",
                      "srv_record": false
                    }
                  },
                  "summary": "MongoDB Replica Set Connector"
                },
                "redis_single_producer": {
                  "value": {
                    "ssl": {
                      "enable": false
                    },
                    "description": "My redis single connector",
                    "enable": true,
                    "parameters": {
                      "pool_size": 8,
                      "server": "127.0.0.1:6379",
                      "password": "******",
                      "username": "test",
                      "database": 1,
                      "redis_type": "single"
                    }
                  },
                  "summary": "Redis Single Producer Connector"
                },
                "oracle": {
                  "value": {
                    "description": "My example oracle connector",
                    "password": "oracle",
                    "pool_size": 8,
                    "resource_opts": {
                      "health_check_interval": "15s",
                      "start_timeout": "5s"
                    },
                    "server": "127.0.0.1:1521",
                    "service_name": "XE",
                    "sid": "XE",
                    "username": "system"
                  },
                  "summary": "Oracle Connector"
                },
                "hstreamdb": {
                  "value": {
                    "description": "My example hstreamdb connector",
                    "grpc_timeout": "30s",
                    "resource_opts": {
                      "health_check_interval": "15s",
                      "start_timeout": "5s"
                    },
                    "ssl": {
                      "enable": false,
                      "verify": "verify_peer"
                    },
                    "url": "http://127.0.0.1:6570"
                  },
                  "summary": "HStreamDB Connector"
                },
                "influxdb_api_v1": {
                  "value": {
                    "ssl": {
                      "enable": false
                    },
                    "description": "My example influxdb connector",
                    "server": "127.0.0.1:8086",
                    "enable": true,
                    "parameters": {
                      "password": "******",
                      "username": "example_username",
                      "database": "example_database",
                      "influxdb_type": "influxdb_api_v1"
                    }
                  },
                  "summary": "InfluxDB HTTP API V1 Connector"
                },
                "s3_aws": {
                  "value": {
                    "port": 443,
                    "host": "s3.eu-east-1.amazonaws.com",
                    "description": "My S3 connector",
                    "enable": true,
                    "transport_options": {
                      "ssl": {
                        "verify": "verify_peer",
                        "enable": true
                      },
                      "connect_timeout": "1s",
                      "pool_size": 4,
                      "max_retries": 1,
                      "request_timeout": "60s",
                      "enable_pipelining": 1
                    },
                    "secret_access_key": "SECRET",
                    "access_key_id": "ACCESS"
                  },
                  "summary": "S3 Connector"
                },
                "cassandra": {
                  "value": {
                    "description": "My example cassandra connector",
                    "pool_size": 8,
                    "password": "******",
                    "username": "root",
                    "servers": "127.0.0.1:9042",
                    "keyspace": "mqtt"
                  },
                  "summary": "Cassandra Connector"
                },
                "gcp_pubsub_consumer": {
                  "value": {
                    "description": "my connector",
                    "connect_timeout": "15s",
                    "pool_size": 8,
                    "enable": true,
                    "max_retries": 2,
                    "resource_opts": {
                      "start_timeout": "5s",
                      "start_after_created": true,
                      "health_check_interval": "30s"
                    },
                    "service_account_json": {
                      "type": "service_account",
                      "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQI...",
                      "client_id": "123812831923812319190",
                      "project_id": "myproject",
                      "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                      "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                      "client_email": "test@myproject.iam.gserviceaccount.com",
                      "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/test%40myproject.iam.gserviceaccount.com",
                      "private_key_id": "kid",
                      "token_uri": "https://oauth2.googleapis.com/token"
                    },
                    "pipelining": 100
                  },
                  "summary": "GCP PubSub Consumer Connector"
                },
                "clickhouse": {
                  "value": {
                    "description": "My example clickhouse connector",
                    "pool_size": 8,
                    "password": "******",
                    "url": "http://localhost:8123",
                    "username": "default",
                    "database": "mqtt"
                  },
                  "summary": "ClickHouse Connector"
                },
                "sqlserver": {
                  "value": {
                    "driver": "ms-sql",
                    "description": "My example sqlserver connector",
                    "pool_size": 8,
                    "server": "127.0.0.1:1433",
                    "password": "******",
                    "username": "sa",
                    "database": "test",
                    "resource_opts": {
                      "health_check_interval": "20s"
                    }
                  },
                  "summary": "Microsoft SQL Server Connector"
                },
                "redis_cluster_producer": {
                  "value": {
                    "ssl": {
                      "enable": false
                    },
                    "description": "My redis cluster connector",
                    "enable": true,
                    "parameters": {
                      "pool_size": 8,
                      "password": "******",
                      "username": "test",
                      "servers": "127.0.0.1:6379,127.0.0.2:6379",
                      "redis_type": "cluster"
                    }
                  },
                  "summary": "Redis Cluster Producer Connector"
                },
                "matrix": {
                  "value": {
                    "database": "emqx_data",
                    "enable": true,
                    "password": "public",
                    "pool_size": 8,
                    "server": "127.0.0.1:5432",
                    "ssl": {
                      "ciphers": [],
                      "depth": 10,
                      "enable": false,
                      "hibernate_after": "5s",
                      "log_level": "notice",
                      "reuse_sessions": true,
                      "secure_renegotiate": true,
                      "verify": "verify_peer",
                      "versions": [
                        "tlsv1.3",
                        "tlsv1.2"
                      ]
                    },
                    "username": "postgres"
                  },
                  "summary": "Matrix Connector"
                },
                "kafka_consumer": {
                  "value": {
                    "resource_opts": {
                      "start_timeout": "5s",
                      "start_after_created": true,
                      "health_check_interval": "30s"
                    },
                    "bootstrap_hosts": "kafka.emqx.net:9092"
                  },
                  "summary": "Kafka Consumer Connector"
                },
                "rocketmq": {
                  "value": {
                    "description": "My example rocketmq connector",
                    "enable": true,
                    "pool_size": 8,
                    "resource_opts": {
                      "health_check_interval": "15s",
                      "start_after_created": true,
                      "start_timeout": "5s"
                    },
                    "servers": "127.0.0.1:9876"
                  },
                  "summary": "RocketMQ Connector"
                },
                "pulsar": {
                  "value": {
                    "name": "pulsar_connector",
                    "type": "pulsar",
                    "ssl": {
                      "enable": false
                    },
                    "authentication": "none",
                    "description": "My example pulsar connector",
                    "connect_timeout": "5s",
                    "enable": true,
                    "servers": "pulsar://127.0.0.1:6650"
                  },
                  "summary": "Pulsar Connector"
                },
                "syskeeper_forwarder": {
                  "value": {
                    "pool_size": 16,
                    "server": "127.0.0.1:9092",
                    "enable": true,
                    "ack_timeout": "10s",
                    "ack_mode": "no_ack"
                  },
                  "summary": "Syskeeper Forwarder Connector"
                },
                "elasticsearch": {
                  "value": {
                    "name": "elasticsearch_connector",
                    "type": "elasticsearch",
                    "ssl": {
                      "enable": false
                    },
                    "authentication": {
                      "password": "******",
                      "username": "root"
                    },
                    "description": "My example elasticsearch connector",
                    "connect_timeout": "15s",
                    "pool_size": 8,
                    "server": "127.0.0.1:9200",
                    "enable": true,
                    "pool_type": "random",
                    "enable_pipelining": 100
                  },
                  "summary": "Elastic Search Connector"
                },
                "gcp_pubsub_producer": {
                  "value": {
                    "connect_timeout": "10s",
                    "pool_size": 8,
                    "enable": true,
                    "max_retries": 2,
                    "resource_opts": {
                      "request_ttl": "60s"
                    },
                    "service_account_json": {
                      "type": "service_account",
                      "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQI...",
                      "client_id": "123812831923812319190",
                      "project_id": "myproject",
                      "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                      "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                      "client_email": "test@myproject.iam.gserviceaccount.com",
                      "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/test%40myproject.iam.gserviceaccount.com",
                      "private_key_id": "kid",
                      "token_uri": "https://oauth2.googleapis.com/token"
                    },
                    "pipelining": 100
                  },
                  "summary": "GCP PubSub Producer Connector"
                },
                "timescale": {
                  "value": {
                    "database": "emqx_data",
                    "enable": true,
                    "password": "public",
                    "pool_size": 8,
                    "server": "127.0.0.1:5432",
                    "ssl": {
                      "ciphers": [],
                      "depth": 10,
                      "enable": false,
                      "hibernate_after": "5s",
                      "log_level": "notice",
                      "reuse_sessions": true,
                      "secure_renegotiate": true,
                      "verify": "verify_peer",
                      "versions": [
                        "tlsv1.3",
                        "tlsv1.2"
                      ]
                    },
                    "username": "postgres"
                  },
                  "summary": "Timescale Connector"
                },
                "redis_sentinel_producer": {
                  "value": {
                    "ssl": {
                      "enable": false
                    },
                    "description": "My redis sentinel connector",
                    "enable": true,
                    "parameters": {
                      "pool_size": 8,
                      "password": "******",
                      "username": "test",
                      "database": 1,
                      "servers": "127.0.0.1:6379,127.0.0.2:6379",
                      "sentinel": "myredismaster",
                      "redis_type": "sentinel"
                    }
                  },
                  "summary": "Redis Sentinel Producer Connector"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/bridge_timescale.put_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mongodb.put_connector"
                  },
                  {
                    "$ref": "#/components/schemas/gcp_pubsub_producer.put_connector"
                  },
                  {
                    "$ref": "#/components/schemas/elasticsearch.put"
                  },
                  {
                    "$ref": "#/components/schemas/connector_azure_blob_storage.put_connector"
                  },
                  {
                    "$ref": "#/components/schemas/syskeeper_forwarder.put"
                  },
                  {
                    "$ref": "#/components/schemas/pulsar.put"
                  },
                  {
                    "$ref": "#/components/schemas/rocketmq.put_connector"
                  },
                  {
                    "$ref": "#/components/schemas/kafka_consumer.put_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_matrix.put_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_sqlserver.put_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_influxdb.put_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_clickhouse.put_connector"
                  },
                  {
                    "$ref": "#/components/schemas/gcp_pubsub_consumer.put_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_cassa.put_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_hstreamdb.put_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_oracle.put_connector"
                  },
                  {
                    "$ref": "#/components/schemas/opents_connector.put"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_greptimedb.put_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_s3.put_connector"
                  },
                  {
                    "$ref": "#/components/schemas/tdengine_connector.put"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_dynamo.put_connector"
                  },
                  {
                    "$ref": "#/components/schemas/redis.put_connector"
                  },
                  {
                    "$ref": "#/components/schemas/rabbitmq.put"
                  },
                  {
                    "$ref": "#/components/schemas/connector_mqtt.put_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mysql.put_connector"
                  },
                  {
                    "$ref": "#/components/schemas/connector_postgres.put_connector"
                  },
                  {
                    "$ref": "#/components/schemas/connector_syskeeper_proxy.put"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_kinesis.put_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_kafka.put_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_azure_event_hub.put_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_datalayers.put_connector"
                  },
                  {
                    "$ref": "#/components/schemas/connector_couchbase.put_connector"
                  },
                  {
                    "$ref": "#/components/schemas/iotdb.put"
                  },
                  {
                    "$ref": "#/components/schemas/confluent.put_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_http.put_connector"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete a connector by id.",
        "tags": [
          "Connectors"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The connector id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_connector"
          }
        ],
        "summary": "Delete connector",
        "responses": {
          "204": {
            "description": "Connector deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Cannot delete connector while active rules are defined for this connector"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Connector not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Service unavailable"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/clients/{clientid}/authorization/cache": {
      "get": {
        "description": "Get client authz cache in the cluster.",
        "tags": [
          "Clients"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_clients.authz_cache"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "CLIENTID_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Client ID not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Clean client authz cache in the cluster.",
        "tags": [
          "Clients"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Clean client authz cache successfully"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "CLIENTID_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Client ID not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/data/import": {
      "post": {
        "description": "Import a data backup file",
        "tags": [
          "Data Backup"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Backup file import failed"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "example": {
                "node": "emqx@127.0.0.1",
                "filename": "emqx-export-2023-11-23-19-13-19.043.tar.gz"
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_mgmt_api_data_backup.import_request_body"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/cluster/{node}/force_leave": {
      "delete": {
        "description": "Force leave node from cluster",
        "tags": [
          "Cluster"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/cluster.node"
          }
        ],
        "responses": {
          "204": {
            "description": "Delete successfully"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/prometheus/schema_validation": {
      "get": {
        "description": "Get Prometheus Metrics for Schema Validation",
        "tags": [
          "Monitor"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_prometheus_api.mode"
          }
        ],
        "responses": {
          "200": {
            "description": "Get Prometheus Data.",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          }
        },
        "security": []
      }
    },
    "/gateways/{name}/listeners/{id}": {
      "get": {
        "description": "Get the gateway listener configs",
        "tags": [
          "Gateway Listeners"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "gbt32960",
                "jt808",
                "lwm2m",
                "mqttsn",
                "ocpp",
                "stomp"
              ]
            },
            "example": "stomp"
          },
          {
            "in": "path",
            "name": "id",
            "description": "Listener ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": ""
          }
        ],
        "summary": "Get listener config",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "udp_listener": {
                    "value": {
                      "name": "udp-def",
                      "type": "udp",
                      "bind": "22212",
                      "udp_options": {
                        "buffer": "10KB",
                        "recbuf": "10KB",
                        "reuseaddr": true,
                        "sndbuf": "10KB",
                        "active_n": 100
                      }
                    },
                    "summary": "A simple UDP listener example"
                  },
                  "dtls_listener": {
                    "value": {
                      "name": "dtls-def",
                      "type": "dtls",
                      "bind": "22213",
                      "udp_options": {
                        "backlog": 1024,
                        "active_n": 100
                      },
                      "max_connections": 1024000,
                      "acceptors": 16,
                      "dtls_options": {
                        "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem",
                        "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                        "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                        "verify": "verify_none",
                        "versions": [
                          "dtlsv1.2",
                          "dtlsv1"
                        ],
                        "fail_if_no_peer_cert": false
                      },
                      "access_rules": [
                        "allow all"
                      ],
                      "max_conn_rate": 1000
                    },
                    "summary": "A simple DTLS listener example"
                  },
                  "ssl_listener": {
                    "value": {
                      "name": "ssl-def",
                      "type": "ssl",
                      "bind": "22211",
                      "tcp_options": {
                        "backlog": 1024,
                        "active_n": 100
                      },
                      "max_connections": 1024000,
                      "ssl_options": {
                        "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem",
                        "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                        "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                        "verify": "verify_none",
                        "versions": [
                          "tlsv1.3",
                          "tlsv1.2",
                          "tlsv1.1",
                          "tlsv1"
                        ],
                        "fail_if_no_peer_cert": false
                      },
                      "acceptors": 16,
                      "access_rules": [
                        "allow all"
                      ],
                      "max_conn_rate": 1000
                    },
                    "summary": "A simple SSL listener example"
                  },
                  "tcp_listener": {
                    "value": {
                      "name": "tcp-def",
                      "type": "tcp",
                      "bind": "22210",
                      "tcp_options": {
                        "buffer": "10KB",
                        "high_watermark": "1MB",
                        "keepalive": "none",
                        "nodelay": false,
                        "recbuf": "10KB",
                        "reuseaddr": true,
                        "send_timeout": "15s",
                        "send_timeout_close": true,
                        "sndbuf": "10KB",
                        "backlog": 1024,
                        "active_n": 100
                      },
                      "max_connections": 1024000,
                      "acceptors": 16,
                      "max_conn_rate": 1000
                    },
                    "summary": "A simple TCP listener example"
                  },
                  "ws_listener": {
                    "value": {
                      "name": "ws-def",
                      "type": "ws",
                      "bind": "33043",
                      "tcp_options": {
                        "buffer": "10KB",
                        "high_watermark": "1MB",
                        "keepalive": "none",
                        "nodelay": false,
                        "recbuf": "10KB",
                        "reuseaddr": true,
                        "send_timeout": "15s",
                        "send_timeout_close": true,
                        "sndbuf": "10KB",
                        "backlog": 1024,
                        "active_n": 100
                      },
                      "max_connections": 1024000,
                      "websocket": {
                        "path": "/ocpp",
                        "compress": false,
                        "fail_if_no_subprotocol": true,
                        "supported_subprotocols": "ocpp1.6",
                        "check_origins": "http://localhost:18083, http://127.0.0.1:18083",
                        "check_origin_enable": false,
                        "piggyback": "single"
                      },
                      "acceptors": 16,
                      "max_conn_rate": 1000
                    },
                    "summary": "A simple WebSocket listener example"
                  },
                  "wss_listener": {
                    "value": {
                      "name": "ws-ssl-def",
                      "type": "wss",
                      "bind": "33053",
                      "tcp_options": {
                        "buffer": "10KB",
                        "high_watermark": "1MB",
                        "keepalive": "none",
                        "nodelay": false,
                        "recbuf": "10KB",
                        "reuseaddr": true,
                        "send_timeout": "15s",
                        "send_timeout_close": true,
                        "sndbuf": "10KB",
                        "backlog": 1024,
                        "active_n": 100
                      },
                      "max_connections": 1024000,
                      "ssl_options": {
                        "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem",
                        "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                        "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                        "verify": "verify_none",
                        "versions": [
                          "tlsv1.3",
                          "tlsv1.2",
                          "tlsv1.1",
                          "tlsv1"
                        ],
                        "fail_if_no_peer_cert": false
                      },
                      "websocket": {
                        "path": "/ocpp",
                        "compress": false,
                        "fail_if_no_subprotocol": true,
                        "supported_subprotocols": "ocpp1.6",
                        "check_origins": "http://localhost:18083, http://127.0.0.1:18083",
                        "check_origin_enable": false,
                        "piggyback": "single"
                      },
                      "acceptors": 16,
                      "max_conn_rate": 1000
                    },
                    "summary": "A simple WebSocket/TLS listener example"
                  },
                  "dtls_listener_with_psk_ciphers": {
                    "value": {
                      "name": "dtls-psk",
                      "type": "dtls",
                      "bind": "22214",
                      "max_connections": 1024000,
                      "acceptors": 16,
                      "dtls_options": {
                        "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem",
                        "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                        "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                        "verify": "verify_none",
                        "ciphers": "RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA",
                        "versions": [
                          "dtlsv1.2",
                          "dtlsv1"
                        ],
                        "fail_if_no_peer_cert": false,
                        "user_lookup_fun": "emqx_tls_psk:lookup"
                      },
                      "max_conn_rate": 1000
                    },
                    "summary": "A DTLS listener with PSK example"
                  },
                  "lisetner_with_authn": {
                    "value": {
                      "name": "tcp-with-authn",
                      "type": "tcp",
                      "bind": "22215",
                      "authentication": {
                        "mechanism": "password_based",
                        "backend": "built_in_database",
                        "password_hash_algorithm": {
                          "name": "sha256"
                        },
                        "user_id_type": "username"
                      },
                      "max_connections": 1024000,
                      "acceptors": 16,
                      "max_conn_rate": 1000
                    },
                    "summary": "A TCP listener with authentication example"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.wss_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.ws_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.dtls_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.udp_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.ssl_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.tcp_listener"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update the gateway listener. The listener being updated performs a restart and all clients connected to that listener will be disconnected.",
        "tags": [
          "Gateway Listeners"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "gbt32960",
                "jt808",
                "lwm2m",
                "mqttsn",
                "ocpp",
                "stomp"
              ]
            },
            "example": "stomp"
          },
          {
            "in": "path",
            "name": "id",
            "description": "Listener ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": ""
          }
        ],
        "summary": "Update listener config",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "udp_listener": {
                    "value": {
                      "name": "udp-def",
                      "type": "udp",
                      "bind": "22212",
                      "udp_options": {
                        "buffer": "10KB",
                        "recbuf": "10KB",
                        "reuseaddr": true,
                        "sndbuf": "10KB",
                        "active_n": 100
                      }
                    },
                    "summary": "A simple UDP listener example"
                  },
                  "dtls_listener": {
                    "value": {
                      "name": "dtls-def",
                      "type": "dtls",
                      "bind": "22213",
                      "udp_options": {
                        "backlog": 1024,
                        "active_n": 100
                      },
                      "max_connections": 1024000,
                      "acceptors": 16,
                      "dtls_options": {
                        "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem",
                        "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                        "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                        "verify": "verify_none",
                        "versions": [
                          "dtlsv1.2",
                          "dtlsv1"
                        ],
                        "fail_if_no_peer_cert": false
                      },
                      "access_rules": [
                        "allow all"
                      ],
                      "max_conn_rate": 1000
                    },
                    "summary": "A simple DTLS listener example"
                  },
                  "ssl_listener": {
                    "value": {
                      "name": "ssl-def",
                      "type": "ssl",
                      "bind": "22211",
                      "tcp_options": {
                        "backlog": 1024,
                        "active_n": 100
                      },
                      "max_connections": 1024000,
                      "ssl_options": {
                        "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem",
                        "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                        "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                        "verify": "verify_none",
                        "versions": [
                          "tlsv1.3",
                          "tlsv1.2",
                          "tlsv1.1",
                          "tlsv1"
                        ],
                        "fail_if_no_peer_cert": false
                      },
                      "acceptors": 16,
                      "access_rules": [
                        "allow all"
                      ],
                      "max_conn_rate": 1000
                    },
                    "summary": "A simple SSL listener example"
                  },
                  "tcp_listener": {
                    "value": {
                      "name": "tcp-def",
                      "type": "tcp",
                      "bind": "22210",
                      "tcp_options": {
                        "buffer": "10KB",
                        "high_watermark": "1MB",
                        "keepalive": "none",
                        "nodelay": false,
                        "recbuf": "10KB",
                        "reuseaddr": true,
                        "send_timeout": "15s",
                        "send_timeout_close": true,
                        "sndbuf": "10KB",
                        "backlog": 1024,
                        "active_n": 100
                      },
                      "max_connections": 1024000,
                      "acceptors": 16,
                      "max_conn_rate": 1000
                    },
                    "summary": "A simple TCP listener example"
                  },
                  "ws_listener": {
                    "value": {
                      "name": "ws-def",
                      "type": "ws",
                      "bind": "33043",
                      "tcp_options": {
                        "buffer": "10KB",
                        "high_watermark": "1MB",
                        "keepalive": "none",
                        "nodelay": false,
                        "recbuf": "10KB",
                        "reuseaddr": true,
                        "send_timeout": "15s",
                        "send_timeout_close": true,
                        "sndbuf": "10KB",
                        "backlog": 1024,
                        "active_n": 100
                      },
                      "max_connections": 1024000,
                      "websocket": {
                        "path": "/ocpp",
                        "compress": false,
                        "fail_if_no_subprotocol": true,
                        "supported_subprotocols": "ocpp1.6",
                        "check_origins": "http://localhost:18083, http://127.0.0.1:18083",
                        "check_origin_enable": false,
                        "piggyback": "single"
                      },
                      "acceptors": 16,
                      "max_conn_rate": 1000
                    },
                    "summary": "A simple WebSocket listener example"
                  },
                  "wss_listener": {
                    "value": {
                      "name": "ws-ssl-def",
                      "type": "wss",
                      "bind": "33053",
                      "tcp_options": {
                        "buffer": "10KB",
                        "high_watermark": "1MB",
                        "keepalive": "none",
                        "nodelay": false,
                        "recbuf": "10KB",
                        "reuseaddr": true,
                        "send_timeout": "15s",
                        "send_timeout_close": true,
                        "sndbuf": "10KB",
                        "backlog": 1024,
                        "active_n": 100
                      },
                      "max_connections": 1024000,
                      "ssl_options": {
                        "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem",
                        "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                        "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                        "verify": "verify_none",
                        "versions": [
                          "tlsv1.3",
                          "tlsv1.2",
                          "tlsv1.1",
                          "tlsv1"
                        ],
                        "fail_if_no_peer_cert": false
                      },
                      "websocket": {
                        "path": "/ocpp",
                        "compress": false,
                        "fail_if_no_subprotocol": true,
                        "supported_subprotocols": "ocpp1.6",
                        "check_origins": "http://localhost:18083, http://127.0.0.1:18083",
                        "check_origin_enable": false,
                        "piggyback": "single"
                      },
                      "acceptors": 16,
                      "max_conn_rate": 1000
                    },
                    "summary": "A simple WebSocket/TLS listener example"
                  },
                  "dtls_listener_with_psk_ciphers": {
                    "value": {
                      "name": "dtls-psk",
                      "type": "dtls",
                      "bind": "22214",
                      "max_connections": 1024000,
                      "acceptors": 16,
                      "dtls_options": {
                        "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem",
                        "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                        "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                        "verify": "verify_none",
                        "ciphers": "RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA",
                        "versions": [
                          "dtlsv1.2",
                          "dtlsv1"
                        ],
                        "fail_if_no_peer_cert": false,
                        "user_lookup_fun": "emqx_tls_psk:lookup"
                      },
                      "max_conn_rate": 1000
                    },
                    "summary": "A DTLS listener with PSK example"
                  },
                  "lisetner_with_authn": {
                    "value": {
                      "name": "tcp-with-authn",
                      "type": "tcp",
                      "bind": "22215",
                      "authentication": {
                        "mechanism": "password_based",
                        "backend": "built_in_database",
                        "password_hash_algorithm": {
                          "name": "sha256"
                        },
                        "user_id_type": "username"
                      },
                      "max_connections": 1024000,
                      "acceptors": 16,
                      "max_conn_rate": 1000
                    },
                    "summary": "A TCP listener with authentication example"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.wss_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.ws_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.dtls_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.udp_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.ssl_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.tcp_listener"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "udp_listener": {
                  "value": {
                    "name": "udp-def",
                    "type": "udp",
                    "bind": "22212",
                    "udp_options": {
                      "buffer": "10KB",
                      "recbuf": "10KB",
                      "reuseaddr": true,
                      "sndbuf": "10KB",
                      "active_n": 100
                    }
                  },
                  "summary": "A simple UDP listener example"
                },
                "dtls_listener": {
                  "value": {
                    "name": "dtls-def",
                    "type": "dtls",
                    "bind": "22213",
                    "udp_options": {
                      "backlog": 1024,
                      "active_n": 100
                    },
                    "max_connections": 1024000,
                    "acceptors": 16,
                    "dtls_options": {
                      "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem",
                      "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                      "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                      "verify": "verify_none",
                      "versions": [
                        "dtlsv1.2",
                        "dtlsv1"
                      ],
                      "fail_if_no_peer_cert": false
                    },
                    "access_rules": [
                      "allow all"
                    ],
                    "max_conn_rate": 1000
                  },
                  "summary": "A simple DTLS listener example"
                },
                "ssl_listener": {
                  "value": {
                    "name": "ssl-def",
                    "type": "ssl",
                    "bind": "22211",
                    "tcp_options": {
                      "backlog": 1024,
                      "active_n": 100
                    },
                    "max_connections": 1024000,
                    "ssl_options": {
                      "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem",
                      "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                      "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                      "verify": "verify_none",
                      "versions": [
                        "tlsv1.3",
                        "tlsv1.2",
                        "tlsv1.1",
                        "tlsv1"
                      ],
                      "fail_if_no_peer_cert": false
                    },
                    "acceptors": 16,
                    "access_rules": [
                      "allow all"
                    ],
                    "max_conn_rate": 1000
                  },
                  "summary": "A simple SSL listener example"
                },
                "tcp_listener": {
                  "value": {
                    "name": "tcp-def",
                    "type": "tcp",
                    "bind": "22210",
                    "tcp_options": {
                      "buffer": "10KB",
                      "high_watermark": "1MB",
                      "keepalive": "none",
                      "nodelay": false,
                      "recbuf": "10KB",
                      "reuseaddr": true,
                      "send_timeout": "15s",
                      "send_timeout_close": true,
                      "sndbuf": "10KB",
                      "backlog": 1024,
                      "active_n": 100
                    },
                    "max_connections": 1024000,
                    "acceptors": 16,
                    "max_conn_rate": 1000
                  },
                  "summary": "A simple TCP listener example"
                },
                "ws_listener": {
                  "value": {
                    "name": "ws-def",
                    "type": "ws",
                    "bind": "33043",
                    "tcp_options": {
                      "buffer": "10KB",
                      "high_watermark": "1MB",
                      "keepalive": "none",
                      "nodelay": false,
                      "recbuf": "10KB",
                      "reuseaddr": true,
                      "send_timeout": "15s",
                      "send_timeout_close": true,
                      "sndbuf": "10KB",
                      "backlog": 1024,
                      "active_n": 100
                    },
                    "max_connections": 1024000,
                    "websocket": {
                      "path": "/ocpp",
                      "compress": false,
                      "fail_if_no_subprotocol": true,
                      "supported_subprotocols": "ocpp1.6",
                      "check_origins": "http://localhost:18083, http://127.0.0.1:18083",
                      "check_origin_enable": false,
                      "piggyback": "single"
                    },
                    "acceptors": 16,
                    "max_conn_rate": 1000
                  },
                  "summary": "A simple WebSocket listener example"
                },
                "wss_listener": {
                  "value": {
                    "name": "ws-ssl-def",
                    "type": "wss",
                    "bind": "33053",
                    "tcp_options": {
                      "buffer": "10KB",
                      "high_watermark": "1MB",
                      "keepalive": "none",
                      "nodelay": false,
                      "recbuf": "10KB",
                      "reuseaddr": true,
                      "send_timeout": "15s",
                      "send_timeout_close": true,
                      "sndbuf": "10KB",
                      "backlog": 1024,
                      "active_n": 100
                    },
                    "max_connections": 1024000,
                    "ssl_options": {
                      "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem",
                      "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                      "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                      "verify": "verify_none",
                      "versions": [
                        "tlsv1.3",
                        "tlsv1.2",
                        "tlsv1.1",
                        "tlsv1"
                      ],
                      "fail_if_no_peer_cert": false
                    },
                    "websocket": {
                      "path": "/ocpp",
                      "compress": false,
                      "fail_if_no_subprotocol": true,
                      "supported_subprotocols": "ocpp1.6",
                      "check_origins": "http://localhost:18083, http://127.0.0.1:18083",
                      "check_origin_enable": false,
                      "piggyback": "single"
                    },
                    "acceptors": 16,
                    "max_conn_rate": 1000
                  },
                  "summary": "A simple WebSocket/TLS listener example"
                },
                "dtls_listener_with_psk_ciphers": {
                  "value": {
                    "name": "dtls-psk",
                    "type": "dtls",
                    "bind": "22214",
                    "max_connections": 1024000,
                    "acceptors": 16,
                    "dtls_options": {
                      "cacertfile": "${EMQX_ETC_DIR}/certs/cacert.pem",
                      "certfile": "${EMQX_ETC_DIR}/certs/cert.pem",
                      "keyfile": "${EMQX_ETC_DIR}/certs/key.pem",
                      "verify": "verify_none",
                      "ciphers": "RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA",
                      "versions": [
                        "dtlsv1.2",
                        "dtlsv1"
                      ],
                      "fail_if_no_peer_cert": false,
                      "user_lookup_fun": "emqx_tls_psk:lookup"
                    },
                    "max_conn_rate": 1000
                  },
                  "summary": "A DTLS listener with PSK example"
                },
                "lisetner_with_authn": {
                  "value": {
                    "name": "tcp-with-authn",
                    "type": "tcp",
                    "bind": "22215",
                    "authentication": {
                      "mechanism": "password_based",
                      "backend": "built_in_database",
                      "password_hash_algorithm": {
                        "name": "sha256"
                      },
                      "user_id_type": "username"
                    },
                    "max_connections": 1024000,
                    "acceptors": 16,
                    "max_conn_rate": 1000
                  },
                  "summary": "A TCP listener with authentication example"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.wss_listener"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.ws_listener"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.dtls_listener"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.udp_listener"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.ssl_listener"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.tcp_listener"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete the gateway listener. All connected clients under the deleted listener will be disconnected.",
        "tags": [
          "Gateway Listeners"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "gbt32960",
                "jt808",
                "lwm2m",
                "mqttsn",
                "ocpp",
                "stomp"
              ]
            },
            "example": "stomp"
          },
          {
            "in": "path",
            "name": "id",
            "description": "Listener ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": ""
          }
        ],
        "summary": "Delete listener",
        "responses": {
          "204": {
            "description": "Deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/relup/upgrade/{node}": {
      "post": {
        "description": "Upgrade a specified node to the target version with the installed package.",
        "tags": [
          "Relup"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/relup.node_name"
          }
        ],
        "summary": "Upgrade a specified node",
        "responses": {
          "204": {
            "description": "Upgrade is started successfully"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UNEXPECTED_ERROR"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Upgrade failed because of invalid input or environment"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Node not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "500": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "INTERNAL_ERROR"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Upgrade failed because of internal errors"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/sources/{id}/metrics/reset": {
      "put": {
        "description": "Reset a bridge metrics by id.",
        "tags": [
          "Sources"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_action"
          }
        ],
        "summary": "Reset source metrics",
        "responses": {
          "204": {
            "description": "Reset success"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Source not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/rules/{id}/test": {
      "post": {
        "description": "Apply a rule with the given message and environment",
        "tags": [
          "Rules"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "my_rule_id"
          }
        ],
        "summary": "Apply a rule for testing",
        "responses": {
          "200": {
            "description": "Rule Applied"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Invalid Parameters"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "RULE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "The rule could not be found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "412": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_MATCH"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "SQL Not Match"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/rule_engine.rule_apply_test"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/relup/upgrade": {
      "post": {
        "description": "Upgrade all nodes to the target version with the installed package.",
        "tags": [
          "Relup"
        ],
        "parameters": [],
        "summary": "Upgrade all nodes",
        "responses": {
          "204": {
            "description": "Upgrade is started successfully"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UNEXPECTED_ERROR"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Upgrade failed because of invalid input or environment"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "500": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "INTERNAL_ERROR"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Upgrade failed because of internal errors"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/{name}/enable/{enable}": {
      "put": {
        "description": "Update the gateway basic configurations and running status.<br/><br/>Note: The Authentication and Listener configurations should be updated by other special APIs.",
        "tags": [
          "Gateways"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "gbt32960",
                "jt808",
                "lwm2m",
                "mqttsn",
                "ocpp",
                "stomp"
              ]
            },
            "example": "stomp"
          },
          {
            "in": "path",
            "name": "enable",
            "description": "Whether to enable this gateway",
            "required": true,
            "schema": {
              "type": "boolean"
            },
            "example": true
          }
        ],
        "summary": "Enable or disable gateway",
        "responses": {
          "204": {
            "description": "Gateway configuration updated"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/relup/package/upload": {
      "post": {
        "description": "Upload a hot upgrade package (emqx_relup-vsn.tar.gz).<br/>Note that only one package is alllowed to be installed at a time.",
        "tags": [
          "Relup"
        ],
        "parameters": [],
        "summary": "Upload a hot upgrade package",
        "responses": {
          "204": {
            "description": "Package is uploaded successfully"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UNEXPECTED_ERROR",
                        "ALREADY_INSTALLED",
                        "BAD_PLUGIN_INFO"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "multipart/form-data": {
              "encoding": {
                "plugin": {
                  "contentType": "application/gzip"
                }
              },
              "schema": {
                "type": "object",
                "properties": {
                  "plugin": {
                    "type": "string",
                    "format": "binary"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/rules": {
      "get": {
        "description": "List all rules",
        "tags": [
          "Rules"
        ],
        "parameters": [
          {
            "in": "query",
            "name": "enable",
            "description": "Filter enable/disable rules",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "in": "query",
            "name": "from",
            "description": "Filter rules by from(topic), exact match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "like_id",
            "description": "Filter rules by id, Substring matching",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "like_from",
            "description": "Filter rules by from(topic), Substring matching",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "like_description",
            "description": "Filter rules by description, Substring matching",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "match_from",
            "description": "Filter rules by from(topic), Mqtt topic matching",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "action",
            "description": "Filters rules that contain any of the given action id(s).  When used in conjunction with source id filtering, the rules must contain sources *and* actions that match some of the criteria.",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "in": "query",
            "name": "source",
            "description": "Filters rules that contain any of the given source id(s).  When used in conjunction with action id filtering, the rules must contain sources *and* actions that match some of the criteria.",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          }
        ],
        "summary": "List rules",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "data": {
                      "type": "array",
                      "description": "List of rules",
                      "items": {
                        "$ref": "#/components/schemas/rule_engine.rule_info"
                      }
                    },
                    "meta": {
                      "$ref": "#/components/schemas/public.meta"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Invalid Parameters"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Create a new rule using given Id",
        "tags": [
          "Rules"
        ],
        "parameters": [],
        "summary": "Create a rule",
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/rule_engine.rule_info"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Invalid Parameters"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/rule_engine.rule_creation"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/authentication/{id}/status": {
      "get": {
        "description": "Get authenticator status from global authentication chain.",
        "tags": [
          "Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Authenticator ID.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "status_metrics": {
                    "value": {
                      "status": "connected",
                      "metrics": {
                        "nomatch": 0,
                        "total": 0,
                        "success": 0,
                        "failed": 0,
                        "rate": 0,
                        "rate_last5m": 0,
                        "rate_max": 0
                      },
                      "node_status": [
                        {
                          "node": "emqx@127.0.0.1",
                          "status": "connected"
                        }
                      ],
                      "resource_metrics": {
                        "success": 0,
                        "matched": 0,
                        "failed": 0,
                        "rate": 0,
                        "rate_last5m": 0,
                        "rate_max": 0
                      },
                      "node_error": [],
                      "node_metrics": [
                        {
                          "node": "emqx@127.0.0.1",
                          "metrics": {
                            "nomatch": 0,
                            "total": 0,
                            "matched": 0,
                            "failed": 0,
                            "rate": 0,
                            "rate_last5m": 0,
                            "rate_max": 0
                          }
                        }
                      ],
                      "node_resource_metrics": [
                        {
                          "node": "emqx@127.0.0.1",
                          "metrics": {
                            "success": 0,
                            "matched": 0,
                            "failed": 0,
                            "rate": 0,
                            "rate_last5m": 0,
                            "rate_max": 0
                          }
                        }
                      ]
                    },
                    "summary": "Authn status metrics"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/authn.metrics_status_fields"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "500": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "INTERNAL_ERROR"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Internal Service Error"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/mqtt/topic_rewrite": {
      "get": {
        "description": "List all rewrite rules",
        "tags": [
          "MQTT"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "List all rewrite rules",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/modules.rewrite"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update all rewrite rules",
        "tags": [
          "MQTT"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Update all rewrite rules",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/modules.rewrite"
                  }
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "413": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "EXCEED_LIMIT"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Rules count exceed max limit"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/modules.rewrite"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways": {
      "get": {
        "description": "This API returns an overview info for the specified or all gateways.<br/>including current running status, number of connections, listener status, etc.",
        "tags": [
          "Gateways"
        ],
        "parameters": [
          {
            "in": "query",
            "name": "status",
            "description": "Filter gateways by status.<br/><br/>It is enum with `running`, `stopped`, `unloaded`",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "running",
                "stopped",
                "unloaded"
              ]
            },
            "example": "running"
          }
        ],
        "summary": "List all gateways",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": [
                  {
                    "name": "coap",
                    "status": "unloaded"
                  },
                  {
                    "name": "exproto",
                    "status": "unloaded"
                  },
                  {
                    "name": "lwm2m",
                    "status": "running",
                    "max_connections": 1024000,
                    "started_at": "2021-12-08T14:41:26.202+08:00",
                    "node_status": [
                      {
                        "node": "node@127.0.0.1",
                        "status": "running",
                        "max_connections": 1024000,
                        "current_connections": 0
                      }
                    ],
                    "listeners": [
                      {
                        "id": "lwm2m:udp:default",
                        "name": "default",
                        "running": true,
                        "type": "udp"
                      }
                    ],
                    "created_at": "2021-12-08T14:41:26.171+08:00",
                    "current_connections": 0
                  },
                  {
                    "name": "mqttsn",
                    "status": "stopped",
                    "max_connections": 1024000,
                    "node_status": [
                      {
                        "node": "node@127.0.0.1",
                        "status": "running",
                        "max_connections": 1024000,
                        "current_connections": 0
                      }
                    ],
                    "listeners": [
                      {
                        "id": "mqttsn:udp:default",
                        "name": "default",
                        "running": false,
                        "type": "udp"
                      }
                    ],
                    "created_at": "2021-12-08T14:41:45.071+08:00",
                    "current_connections": 0,
                    "stopped_at": "2021-12-08T14:56:35.576+08:00"
                  },
                  {
                    "name": "stomp",
                    "status": "running",
                    "max_connections": 1024000,
                    "started_at": "2021-12-08T14:42:15.274+08:00",
                    "node_status": [
                      {
                        "node": "node@127.0.0.1",
                        "status": "running",
                        "max_connections": 1024000,
                        "current_connections": 0
                      }
                    ],
                    "listeners": [
                      {
                        "id": "stomp:tcp:default",
                        "name": "default",
                        "running": true,
                        "type": "tcp"
                      }
                    ],
                    "created_at": "2021-12-08T14:42:15.272+08:00",
                    "current_connections": 0
                  }
                ],
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/emqx_gateway_api.gateway_overview"
                  }
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/mqtt/topic_metrics/{topic}": {
      "get": {
        "description": "Get topic metrics",
        "tags": [
          "MQTT"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "topic",
            "description": "Topic string. Notice: Topic string in url path must be encoded",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "testtopic/1"
          }
        ],
        "responses": {
          "200": {
            "description": "Topic",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_topic_metrics_api.topic_metrics"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "TOPIC_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found. Topic metrics not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete topic metrics",
        "tags": [
          "MQTT"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "topic",
            "description": "Topic string. Notice: Topic string in url path must be encoded",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "testtopic/1"
          }
        ],
        "responses": {
          "204": {
            "description": "Delete topic metrics"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "TOPIC_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found. Topic metrics not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/bridges_probe": {
      "post": {
        "description": "Test creating a new bridge by given ID <br/><br/>The ID must be of format '{type}:{name}'",
        "tags": [
          "Bridges"
        ],
        "parameters": [],
        "summary": "Test creating bridge",
        "responses": {
          "204": {
            "description": "Test bridge OK"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "TEST_FAILED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "bridge test failed"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "influxdb_api_v2": {
                  "value": {
                    "name": "demo",
                    "type": "influxdb_api_v2",
                    "ssl": {
                      "enable": false
                    },
                    "server": "127.0.0.1:8086",
                    "enable": true,
                    "precision": "ms",
                    "org": "examlpe_org",
                    "token": "example_token",
                    "bucket": "example_bucket",
                    "resource_opts": {
                      "batch_size": 100,
                      "batch_time": "20ms"
                    },
                    "local_topic": "local/topic/#",
                    "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,uint_value=${payload.uint_key}u,bool=${payload.bool}",
                    "influxdb_type": "influxdb_api_v2"
                  },
                  "summary": "InfluxDB HTTP API V2 Bridge"
                },
                "iotdb": {
                  "value": {
                    "name": "My IoTDB Bridge",
                    "type": "iotdb",
                    "ssl": {
                      "enable": false
                    },
                    "authentication": {
                      "password": "*****",
                      "username": "root"
                    },
                    "connect_timeout": "15s",
                    "pool_size": 8,
                    "enable": true,
                    "base_url": "http://iotdb.local:18080/",
                    "pool_type": "random",
                    "resource_opts": {
                      "worker_pool_size": 8,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "health_check_interval": "15s"
                    },
                    "enable_pipelining": 100,
                    "iotdb_version": "v1.1.x",
                    "device_id": "my_device",
                    "is_aligned": false
                  },
                  "summary": "Apache IoTDB Bridge"
                },
                "azure_event_hub_producer": {
                  "value": {
                    "name": "my_azure_event_hub_producer",
                    "type": "azure_event_hub_producer",
                    "authentication": {
                      "password": "******"
                    },
                    "connect_timeout": "5s",
                    "enable": true,
                    "parameters": {
                      "message": {
                        "value": "${.}",
                        "key": "${.clientid}"
                      },
                      "buffer": {
                        "mode": "hybrid",
                        "memory_overload_protection": true,
                        "segment_bytes": "100MB",
                        "per_partition_limit": "2GB"
                      },
                      "topic": "topic",
                      "max_inflight": 10,
                      "required_acks": "all_isr",
                      "max_batch_bytes": "896KB",
                      "partition_count_refresh_interval": "60s",
                      "kafka_header_value_encode_mode": "none",
                      "kafka_ext_headers": [
                        {
                          "kafka_ext_header_value": "${clientid}",
                          "kafka_ext_header_key": "clientid"
                        },
                        {
                          "kafka_ext_header_value": "${topic}",
                          "kafka_ext_header_key": "topic"
                        }
                      ],
                      "kafka_headers": "${.pub_props}",
                      "partition_strategy": "random"
                    },
                    "socket_opts": {
                      "nodelay": true,
                      "recbuf": "1024KB",
                      "sndbuf": "1024KB",
                      "tcp_keepalive": "none"
                    },
                    "local_topic": "mqtt/local/topic",
                    "min_metadata_refresh_interval": "3s",
                    "bootstrap_hosts": "namespace.servicebus.windows.net:9093",
                    "metadata_request_timeout": "4s"
                  },
                  "summary": "Azure Event Hub Producer Bridge"
                },
                "kafka_producer": {
                  "value": {
                    "name": "my_kafka_producer_action",
                    "type": "kafka_producer",
                    "authentication": {
                      "mechanism": "plain",
                      "password": "******",
                      "username": "username"
                    },
                    "connect_timeout": "5s",
                    "enable": true,
                    "socket_opts": {
                      "nodelay": true,
                      "recbuf": "1024KB",
                      "sndbuf": "1024KB",
                      "tcp_keepalive": "none"
                    },
                    "local_topic": "mqtt/local/topic",
                    "kafka": {
                      "message": {
                        "timestamp": "${.timestamp}",
                        "value": "${.}",
                        "key": "${.clientid}"
                      },
                      "buffer": {
                        "mode": "hybrid",
                        "memory_overload_protection": true,
                        "segment_bytes": "100MB",
                        "per_partition_limit": "2GB"
                      },
                      "compression": "no_compression",
                      "topic": "kafka-topic",
                      "max_inflight": 10,
                      "required_acks": "all_isr",
                      "max_batch_bytes": "896KB",
                      "partitions_limit": "all_partitions",
                      "partition_count_refresh_interval": "60s",
                      "kafka_header_value_encode_mode": "none",
                      "kafka_ext_headers": [
                        {
                          "kafka_ext_header_value": "${clientid}",
                          "kafka_ext_header_key": "clientid"
                        },
                        {
                          "kafka_ext_header_value": "${topic}",
                          "kafka_ext_header_key": "topic"
                        }
                      ],
                      "kafka_headers": "${pub_props}",
                      "partition_strategy": "random"
                    },
                    "min_metadata_refresh_interval": "3s",
                    "bootstrap_hosts": "localhost:9092",
                    "metadata_request_timeout": "4s"
                  },
                  "summary": "Kafka Producer Bridge"
                },
                "redis_sentinel": {
                  "value": {
                    "name": "redis_bridge",
                    "type": "redis_sentinel",
                    "ssl": {
                      "enable": false
                    },
                    "pool_size": 8,
                    "enable": true,
                    "password": "******",
                    "database": 1,
                    "servers": [
                      "127.0.0.1:26379"
                    ],
                    "resource_opts": {
                      "batch_size": 1,
                      "batch_time": "20ms"
                    },
                    "sentinel": "mymaster",
                    "redis_type": "sentinel",
                    "local_topic": "local/topic/#",
                    "command_template": [
                      "LPUSH",
                      "MSGS",
                      "${payload}"
                    ]
                  },
                  "summary": "Redis Sentinel Bridge"
                },
                "pulsar_producer": {
                  "value": {
                    "authentication": "none",
                    "batch_size": 1,
                    "buffer": {
                      "memory_overload_protection": true,
                      "mode": "memory",
                      "per_partition_limit": "10MB",
                      "segment_bytes": "5MB"
                    },
                    "compression": "no_compression",
                    "enable": true,
                    "local_topic": "mqtt/topic/-576460752303423482",
                    "max_batch_bytes": "900KB",
                    "message": {
                      "key": "${.clientid}",
                      "value": "${.}"
                    },
                    "name": "pulsar_example_name",
                    "pulsar_topic": "pulsar_example_topic",
                    "retention_period": "infinity",
                    "send_buffer": "1MB",
                    "servers": "pulsar://127.0.0.1:6650",
                    "ssl": {
                      "enable": false,
                      "server_name_indication": "auto",
                      "verify": "verify_none"
                    },
                    "strategy": "key_dispatch",
                    "sync_timeout": "5s",
                    "type": "pulsar_producer"
                  },
                  "summary": "Pulsar Producer Bridge"
                },
                "pgsql": {
                  "value": {
                    "name": "foo",
                    "type": "pgsql",
                    "pool_size": 8,
                    "server": "127.0.0.1:5432",
                    "enable": true,
                    "password": "******",
                    "username": "root",
                    "database": "mqtt",
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 8,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#"
                  },
                  "summary": "PostgreSQL Bridge"
                },
                "redis_cluster": {
                  "value": {
                    "name": "redis_bridge",
                    "type": "redis_cluster",
                    "ssl": {
                      "enable": false
                    },
                    "pool_size": 8,
                    "enable": true,
                    "password": "******",
                    "servers": [
                      "127.0.0.1:6379"
                    ],
                    "resource_opts": {},
                    "redis_type": "cluster",
                    "local_topic": "local/topic/#",
                    "command_template": [
                      "LPUSH",
                      "MSGS",
                      "${payload}"
                    ]
                  },
                  "summary": "Redis Cluster Bridge"
                },
                "mysql": {
                  "value": {
                    "name": "foo",
                    "type": "mysql",
                    "pool_size": 8,
                    "server": "127.0.0.1:3306",
                    "enable": true,
                    "password": "******",
                    "username": "root",
                    "database": "test",
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, FROM_UNIXTIME(${timestamp}/1000))",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 1,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#"
                  },
                  "summary": "MySQL Bridge"
                },
                "kinesis_producer": {
                  "value": {
                    "name": "foo",
                    "type": "kinesis_producer",
                    "enable": true,
                    "max_retries": 3,
                    "aws_secret_access_key": "******",
                    "resource_opts": {
                      "worker_pool_size": 1,
                      "query_mode": "async",
                      "max_buffer_bytes": 104857600,
                      "inflight_window": 100,
                      "health_check_interval": 15000
                    },
                    "endpoint": "https://kinesis.us-east-1.amazonaws.com",
                    "partition_key": "key",
                    "aws_access_key_id": "aws_access_key_id",
                    "stream_name": "stream_name"
                  },
                  "summary": "Amazon Kinesis Producer Bridge"
                },
                "http_example": {
                  "value": {
                    "name": "http_example",
                    "type": "http",
                    "ssl": {
                      "enable": false
                    },
                    "connect_timeout": "15s",
                    "pool_size": 4,
                    "enable": true,
                    "body": "${payload}",
                    "url": "http://localhost:9901/messages/${topic}",
                    "method": "post",
                    "max_retries": 3,
                    "request_timeout": "15s",
                    "pool_type": "random",
                    "resource_opts": {
                      "worker_pool_size": 1,
                      "query_mode": "async",
                      "max_buffer_bytes": 104857600,
                      "inflight_window": 100,
                      "health_check_interval": 15000
                    },
                    "enable_pipelining": 100,
                    "local_topic": "emqx_http/#"
                  },
                  "summary": "HTTP"
                },
                "rabbitmq": {
                  "value": {
                    "timeout": 5,
                    "name": "foo",
                    "port": 5672,
                    "type": "rabbitmq",
                    "exchange": "messages",
                    "pool_size": 8,
                    "server": "localhost",
                    "enable": true,
                    "password": "******",
                    "username": "guest",
                    "heartbeat": "30s",
                    "durable": false,
                    "auto_reconnect": "2s",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 8,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "payload_template": "",
                    "routing_key": "my_routing_key",
                    "virtual_host": "/",
                    "exchange_type": "topic"
                  },
                  "summary": "RabbitMQ Bridge"
                },
                "dynamo": {
                  "value": {
                    "name": "foo",
                    "table": "mqtt",
                    "type": "dynamo",
                    "pool_size": 8,
                    "template": "",
                    "enable": true,
                    "url": "http://127.0.0.1:8000",
                    "aws_secret_access_key": "******",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 8,
                      "query_mode": "sync",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#",
                    "aws_access_key_id": "root"
                  },
                  "summary": "DynamoDB Bridge"
                },
                "tdengine": {
                  "value": {
                    "name": "foo",
                    "type": "tdengine",
                    "pool_size": 8,
                    "server": "127.0.0.1:6041",
                    "enable": true,
                    "password": "******",
                    "username": "root",
                    "database": "mqtt",
                    "sql": "insert into t_mqtt_msg(ts, msgid, mqtt_topic, qos, payload, arrived) values (${ts}, '${id}', '${topic}', ${qos}, '${payload}', ${timestamp})",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 8,
                      "query_mode": "sync",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#"
                  },
                  "summary": "TDengine Bridge"
                },
                "mongodb_single": {
                  "value": {
                    "name": "mongodb_single_demo",
                    "type": "mongodb_single",
                    "pool_size": 8,
                    "server": "localhost:27017",
                    "enable": true,
                    "password": "******",
                    "username": "myuser",
                    "database": "mqtt",
                    "collection": "mycol",
                    "w_mode": "safe",
                    "srv_record": false,
                    "mongo_type": "single"
                  },
                  "summary": "MongoDB (Standalone) Bridge"
                },
                "greptimedb": {
                  "value": {
                    "name": "demo",
                    "type": "greptimedb",
                    "ssl": {
                      "enable": false
                    },
                    "server": "127.0.0.1:4001",
                    "enable": true,
                    "precision": "ms",
                    "password": "******",
                    "username": "example_username",
                    "resource_opts": {
                      "batch_size": 100,
                      "batch_time": "20ms"
                    },
                    "local_topic": "local/topic/#",
                    "dbname": "example_db",
                    "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,uint_value=${payload.uint_key}u,bool=${payload.bool}"
                  },
                  "summary": "Greptimedb HTTP API V2 Bridge"
                },
                "opents": {
                  "value": {
                    "name": "foo",
                    "type": "opents",
                    "pool_size": 8,
                    "server": "http://127.0.0.1:4242",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 1,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "enabledb": true
                  },
                  "summary": "OpenTSDB Bridge"
                },
                "mongodb_sharded": {
                  "value": {
                    "name": "mongodb_sharded_demo",
                    "type": "mongodb_sharded",
                    "pool_size": 8,
                    "enable": true,
                    "password": "******",
                    "username": "myuser",
                    "database": "mqtt",
                    "servers": "localhost:27017, localhost:27018",
                    "collection": "mycol",
                    "w_mode": "safe",
                    "srv_record": false,
                    "mongo_type": "sharded"
                  },
                  "summary": "MongoDB (Sharded) Bridge"
                },
                "mongodb_rs": {
                  "value": {
                    "name": "mongodb_rs_demo",
                    "type": "mongodb_rs",
                    "pool_size": 8,
                    "enable": true,
                    "password": "******",
                    "username": "myuser",
                    "database": "mqtt",
                    "servers": "localhost:27017, localhost:27018",
                    "collection": "mycol",
                    "r_mode": "safe",
                    "w_mode": "safe",
                    "replica_set_name": "rs",
                    "srv_record": false,
                    "mongo_type": "rs"
                  },
                  "summary": "MongoDB (Replica Set) Bridge"
                },
                "oracle": {
                  "value": {
                    "name": "foo",
                    "type": "oracle",
                    "pool_size": 8,
                    "server": "127.0.0.1:1521",
                    "enable": true,
                    "password": "******",
                    "username": "root",
                    "service_name": "ORCL",
                    "sql": "insert into t_mqtt_msgs(msgid, topic, qos, payload) values (${id}, ${topic}, ${qos}, ${payload})",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 8,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#",
                    "sid": "ORCL"
                  },
                  "summary": "Oracle Database Bridge"
                },
                "hstreamdb": {
                  "value": {
                    "name": "demo",
                    "stream": "stream",
                    "type": "hstreamdb",
                    "ssl": {
                      "enable": false
                    },
                    "pool_size": 8,
                    "direction": "egress",
                    "url": "http://127.0.0.1:6570",
                    "resource_opts": {
                      "batch_size": 100,
                      "query_mode": "sync",
                      "batch_time": "20ms"
                    },
                    "record_template": "{ \"temperature\": ${payload.temperature}, \"humidity\": ${payload.humidity} }"
                  },
                  "summary": "HStreamDB Bridge"
                },
                "influxdb_api_v1": {
                  "value": {
                    "name": "demo",
                    "type": "influxdb_api_v1",
                    "ssl": {
                      "enable": false
                    },
                    "server": "127.0.0.1:8086",
                    "enable": true,
                    "precision": "ms",
                    "password": "******",
                    "username": "example_username",
                    "database": "example_database",
                    "resource_opts": {
                      "batch_size": 100,
                      "batch_time": "20ms"
                    },
                    "local_topic": "local/topic/#",
                    "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,bool=${payload.bool}",
                    "influxdb_type": "influxdb_api_v1"
                  },
                  "summary": "InfluxDB HTTP API V1 Bridge"
                },
                "gcp_pubsub": {
                  "value": {
                    "service_account_json": {
                      "type": "service_account",
                      "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQI...",
                      "client_id": "123812831923812319190",
                      "project_id": "myproject",
                      "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                      "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                      "client_email": "test@myproject.iam.gserviceaccount.com",
                      "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/test%40myproject.iam.gserviceaccount.com",
                      "private_key_id": "kid",
                      "token_uri": "https://oauth2.googleapis.com/token"
                    },
                    "pubsub_topic": "mytopic"
                  },
                  "summary": "GCP PubSub Producer Bridge"
                },
                "redis_single": {
                  "value": {
                    "name": "redis_bridge",
                    "type": "redis_single",
                    "ssl": {
                      "enable": false
                    },
                    "pool_size": 8,
                    "server": "127.0.0.1:6379",
                    "enable": true,
                    "password": "******",
                    "database": 1,
                    "resource_opts": {
                      "batch_size": 1,
                      "batch_time": "20ms"
                    },
                    "redis_type": "single",
                    "local_topic": "local/topic/#",
                    "command_template": [
                      "LPUSH",
                      "MSGS",
                      "${payload}"
                    ]
                  },
                  "summary": "Redis Single Node Bridge"
                },
                "mqtt_example": {
                  "value": {
                    "name": "mqtt_example",
                    "type": "mqtt",
                    "keepalive": "300s",
                    "ssl": {
                      "enable": false
                    },
                    "server": "127.0.0.1:1883",
                    "enable": true,
                    "password": "******",
                    "username": "foo",
                    "proto_ver": "v4",
                    "clean_start": true,
                    "retry_interval": "15s",
                    "max_inflight": 100,
                    "resource_opts": {
                      "query_mode": "sync",
                      "max_buffer_bytes": 104857600,
                      "health_check_interval": "15s"
                    },
                    "ingress": {
                      "local": {
                        "retain": "${retain}",
                        "payload": "${payload}",
                        "topic": "from_aws/${topic}",
                        "qos": "${qos}"
                      },
                      "remote": {
                        "topic": "aws/#",
                        "qos": 1
                      }
                    },
                    "egress": {
                      "local": {
                        "topic": "emqx/#"
                      },
                      "remote": {
                        "retain": false,
                        "payload": "${payload}",
                        "topic": "from_emqx/${topic}",
                        "qos": "${qos}"
                      }
                    }
                  },
                  "summary": "MQTT Bridge"
                },
                "cassandra": {
                  "value": {
                    "name": "foo",
                    "type": "cassandra",
                    "pool_size": 8,
                    "enable": true,
                    "password": "******",
                    "username": "root",
                    "cql": "insert into mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic},  ${qos}, ${payload}, ${timestamp})",
                    "servers": "127.0.0.1:9042",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 8,
                      "query_mode": "sync",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#",
                    "keyspace": "mqtt"
                  },
                  "summary": "Cassandra Bridge"
                },
                "gcp_pubsub_consumer": {
                  "value": {
                    "connect_timeout": "15s",
                    "consumer": {
                      "topic_mapping": [
                        {
                          "qos": 1,
                          "mqtt_topic": "mqtt/topic/1",
                          "payload_template": "${.}",
                          "pubsub_topic": "pubsub-topic-1"
                        },
                        {
                          "qos": 2,
                          "mqtt_topic": "mqtt/topic/2",
                          "payload_template": "v = ${.value}, a = ${.attributes}, o = ${.ordering_key}",
                          "pubsub_topic": "pubsub-topic-2"
                        }
                      ],
                      "pull_max_messages": 100
                    },
                    "resource_opts": {
                      "request_ttl": "20s"
                    },
                    "service_account_json": {
                      "type": "service_account",
                      "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQI...",
                      "client_id": "123812831923812319190",
                      "project_id": "myproject",
                      "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                      "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                      "client_email": "test@myproject.iam.gserviceaccount.com",
                      "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/test%40myproject.iam.gserviceaccount.com",
                      "private_key_id": "kid",
                      "token_uri": "https://oauth2.googleapis.com/token"
                    }
                  },
                  "summary": "GCP PubSub Consumer Bridge"
                },
                "clickhouse": {
                  "value": {
                    "name": "foo",
                    "type": "clickhouse",
                    "pool_size": 8,
                    "server": "127.0.0.1:8123",
                    "enable": true,
                    "password": "******",
                    "username": "default",
                    "database": "mqtt",
                    "sql": "INSERT INTO messages(data, arrived) VALUES ('${payload}', ${timestamp})",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 8,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#",
                    "batch_value_separator": ", "
                  },
                  "summary": "Clickhouse Bridge"
                },
                "sqlserver": {
                  "value": {
                    "driver": "ms-sql",
                    "name": "bar",
                    "type": "sqlserver",
                    "pool_size": 8,
                    "server": "127.0.0.1:1433",
                    "enable": true,
                    "password": "******",
                    "username": "sa",
                    "database": "test",
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload) values ( ${id}, ${topic}, ${qos}, ${payload} )",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 1,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#"
                  },
                  "summary": "Microsoft SQL Server Bridge"
                },
                "matrix": {
                  "value": {
                    "name": "foo",
                    "type": "matrix",
                    "pool_size": 8,
                    "server": "127.0.0.1:5432",
                    "enable": true,
                    "password": "******",
                    "username": "root",
                    "database": "mqtt",
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 8,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#"
                  },
                  "summary": "Matrix Bridge"
                },
                "kafka_consumer": {
                  "value": {
                    "name": "my_kafka_producer_action",
                    "type": "kafka_producer",
                    "authentication": {
                      "mechanism": "plain",
                      "password": "******",
                      "username": "username"
                    },
                    "connect_timeout": "5s",
                    "enable": true,
                    "socket_opts": {
                      "nodelay": true,
                      "recbuf": "1024KB",
                      "sndbuf": "1024KB",
                      "tcp_keepalive": "none"
                    },
                    "kafka": {
                      "max_batch_bytes": "896KB",
                      "offset_reset_policy": "latest",
                      "offset_commit_interval_seconds": 5
                    },
                    "min_metadata_refresh_interval": "3s",
                    "topic_mapping": [
                      {
                        "qos": 1,
                        "mqtt_topic": "mqtt/topic/${.offset}",
                        "payload_template": "${.}",
                        "kafka_topic": "kafka-topic-1"
                      },
                      {
                        "qos": 2,
                        "mqtt_topic": "mqtt/topic/2",
                        "payload_template": "v = ${.value}",
                        "kafka_topic": "kafka-topic-2"
                      }
                    ],
                    "bootstrap_hosts": "localhost:9092",
                    "value_encoding_mode": "none",
                    "key_encoding_mode": "none",
                    "metadata_request_timeout": "4s"
                  },
                  "summary": "Kafka Consumer Bridge"
                },
                "rocketmq": {
                  "value": {
                    "name": "foo",
                    "type": "rocketmq",
                    "server": "127.0.0.1:9876",
                    "template": "",
                    "enable": true,
                    "topic": "TopicTest",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 1,
                      "query_mode": "sync",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#"
                  },
                  "summary": "RocketMQ Bridge"
                },
                "timescale": {
                  "value": {
                    "name": "foo",
                    "type": "timescale",
                    "pool_size": 8,
                    "server": "127.0.0.1:5432",
                    "enable": true,
                    "password": "******",
                    "username": "root",
                    "database": "mqtt",
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 8,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#"
                  },
                  "summary": "Timescale Bridge"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/bridge_kafka.post_producer"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_timescale.post"
                  },
                  {
                    "$ref": "#/components/schemas/rocketmq.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_kafka.post_consumer"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_matrix.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_sqlserver.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_clickhouse.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_gcp_pubsub.post_consumer"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_cassa.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_redis.post_single"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_gcp_pubsub.post_producer"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_influxdb.post_api_v1"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_hstreamdb.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_oracle.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mongodb.post_rs"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mongodb.post_sharded"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_opents.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_greptimedb.post_grpc_v1"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mongodb.post_single"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_tdengine.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_dynamo.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_rabbitmq.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mqtt.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_kinesis.post_producer"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mysql.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_redis.post_cluster"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_pgsql.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_pulsar.post_producer"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_redis.post_sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_azure_event_hub.post_producer"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_http.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_iotdb.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_influxdb.post_api_v2"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/sso/saml/acs": {
      "post": {
        "tags": [
          "Dashboard Single Sign-On"
        ],
        "parameters": [],
        "responses": {
          "302": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "REDIRECT"
                      ]
                    },
                    "message": {
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "401": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_USERNAME_OR_PWD"
                      ]
                    },
                    "message": {
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BACKEND_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": []
      }
    },
    "/monitor/nodes/{node}": {
      "get": {
        "description": "List the monitor (statistics) data on the specified node.",
        "tags": [
          "Metrics"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "node",
            "description": "EMQX node name.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "emqx@127.0.0.1"
          },
          {
            "in": "query",
            "name": "latest",
            "description": "The latest N seconds data. Like 300 for 5 min.",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 1
            },
            "example": 300
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/emqx_dashboard_monitor_api.sampler"
                  }
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Node not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/prometheus/stats": {
      "get": {
        "description": "Get Prometheus Metrics",
        "tags": [
          "Monitor"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_prometheus_api.mode"
          }
        ],
        "responses": {
          "200": {
            "description": "Get Prometheus Data.",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          }
        },
        "security": []
      }
    },
    "/trace/{name}/log_detail": {
      "get": {
        "description": "get trace log file's metadata, such as size, last update time",
        "tags": [
          "Trace"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/trace.name"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/trace.log_file_detail"
                  }
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Trace Name Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/authentication/{id}": {
      "get": {
        "description": "Get authenticator from global authentication chain.",
        "tags": [
          "Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Authenticator ID.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "jwt": {
                    "value": {
                      "mechanism": "jwt",
                      "secret": "mysecret",
                      "algorithm": "hmac-based",
                      "secret_base64_encoded": false,
                      "use_jwks": false,
                      "verify_claims": {
                        "username": "${username}"
                      }
                    },
                    "summary": "JWT authentication"
                  },
                  "password_based:built_in_database": {
                    "value": {
                      "mechanism": "password_based",
                      "backend": "built_in_database",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "user_id_type": "username"
                    },
                    "summary": "Built-in password_based authentication"
                  },
                  "password_based:http": {
                    "value": {
                      "ssl": {
                        "enable": false
                      },
                      "connect_timeout": "5s",
                      "mechanism": "password_based",
                      "pool_size": 8,
                      "body": {
                        "password": "${password}",
                        "username": "${username}"
                      },
                      "headers": {
                        "content-type": "application/json"
                      },
                      "url": "http://127.0.0.1:18083",
                      "method": "post",
                      "backend": "http",
                      "request_timeout": "5s",
                      "enable_pipelining": 100
                    },
                    "summary": "password_based authentication through external HTTP API"
                  },
                  "password_based:mongodb": {
                    "value": {
                      "mechanism": "password_based",
                      "filter": {
                        "username": "${username}"
                      },
                      "server": "127.0.0.1:27017",
                      "database": "example",
                      "backend": "mongodb",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "collection": "users",
                      "is_superuser_field": "is_superuser",
                      "password_hash_field": "password_hash",
                      "salt_field": "salt"
                    },
                    "summary": "password_based authentication with MongoDB backend"
                  },
                  "password_based:redis": {
                    "value": {
                      "mechanism": "password_based",
                      "cmd": "HMGET ${username} password_hash salt",
                      "server": "127.0.0.1:6379",
                      "database": 0,
                      "backend": "redis",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "redis_type": "single"
                    },
                    "summary": "password_based authentication with Redis backend"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authn.kerberos"
                    },
                    {
                      "$ref": "#/components/schemas/authn.scram_restapi_post"
                    },
                    {
                      "$ref": "#/components/schemas/authn.scram_restapi_get"
                    },
                    {
                      "$ref": "#/components/schemas/authn.gcp_device"
                    },
                    {
                      "$ref": "#/components/schemas/authn.ldap_deprecated"
                    },
                    {
                      "$ref": "#/components/schemas/authn.ldap"
                    },
                    {
                      "$ref": "#/components/schemas/authn.scram"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_jwks"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_public_key"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_hmac"
                    },
                    {
                      "$ref": "#/components/schemas/authn.http_post"
                    },
                    {
                      "$ref": "#/components/schemas/authn.http_get"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_single"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_sharded"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_rs"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_single"
                    },
                    {
                      "$ref": "#/components/schemas/authn.postgresql"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mysql"
                    },
                    {
                      "$ref": "#/components/schemas/authn.builtin_db"
                    }
                  ]
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update authenticator from global authentication chain.",
        "tags": [
          "Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Authenticator ID.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Authenticator updated"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "409": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "ALREADY_EXISTS"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "ALREADY_EXISTS"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "jwt": {
                  "value": {
                    "mechanism": "jwt",
                    "secret": "mysecret",
                    "algorithm": "hmac-based",
                    "secret_base64_encoded": false,
                    "use_jwks": false,
                    "verify_claims": {
                      "username": "${username}"
                    }
                  },
                  "summary": "JWT authentication"
                },
                "password_based:built_in_database": {
                  "value": {
                    "mechanism": "password_based",
                    "backend": "built_in_database",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "user_id_type": "username"
                  },
                  "summary": "Built-in password_based authentication"
                },
                "password_based:http": {
                  "value": {
                    "ssl": {
                      "enable": false
                    },
                    "connect_timeout": "5s",
                    "mechanism": "password_based",
                    "pool_size": 8,
                    "body": {
                      "password": "${password}",
                      "username": "${username}"
                    },
                    "headers": {
                      "content-type": "application/json"
                    },
                    "url": "http://127.0.0.1:18083",
                    "method": "post",
                    "backend": "http",
                    "request_timeout": "5s",
                    "enable_pipelining": 100
                  },
                  "summary": "password_based authentication through external HTTP API"
                },
                "password_based:mongodb": {
                  "value": {
                    "mechanism": "password_based",
                    "filter": {
                      "username": "${username}"
                    },
                    "server": "127.0.0.1:27017",
                    "database": "example",
                    "backend": "mongodb",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "collection": "users",
                    "is_superuser_field": "is_superuser",
                    "password_hash_field": "password_hash",
                    "salt_field": "salt"
                  },
                  "summary": "password_based authentication with MongoDB backend"
                },
                "password_based:redis": {
                  "value": {
                    "mechanism": "password_based",
                    "cmd": "HMGET ${username} password_hash salt",
                    "server": "127.0.0.1:6379",
                    "database": 0,
                    "backend": "redis",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "redis_type": "single"
                  },
                  "summary": "password_based authentication with Redis backend"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/authn.kerberos"
                  },
                  {
                    "$ref": "#/components/schemas/authn.scram_restapi_post"
                  },
                  {
                    "$ref": "#/components/schemas/authn.scram_restapi_get"
                  },
                  {
                    "$ref": "#/components/schemas/authn.gcp_device"
                  },
                  {
                    "$ref": "#/components/schemas/authn.ldap_deprecated"
                  },
                  {
                    "$ref": "#/components/schemas/authn.ldap"
                  },
                  {
                    "$ref": "#/components/schemas/authn.scram"
                  },
                  {
                    "$ref": "#/components/schemas/authn.jwt_jwks"
                  },
                  {
                    "$ref": "#/components/schemas/authn.jwt_public_key"
                  },
                  {
                    "$ref": "#/components/schemas/authn.jwt_hmac"
                  },
                  {
                    "$ref": "#/components/schemas/authn.http_post"
                  },
                  {
                    "$ref": "#/components/schemas/authn.http_get"
                  },
                  {
                    "$ref": "#/components/schemas/authn.redis_sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/authn.redis_cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn.redis_single"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mongo_sharded"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mongo_rs"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mongo_single"
                  },
                  {
                    "$ref": "#/components/schemas/authn.postgresql"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mysql"
                  },
                  {
                    "$ref": "#/components/schemas/authn.builtin_db_api"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete authenticator from global authentication chain.",
        "tags": [
          "Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Authenticator ID.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Authenticator deleted"
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/schema_registry/{name}": {
      "get": {
        "description": "Get a schema by its name",
        "tags": [
          "Schema Registry"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "The schema name",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "my_schema"
          }
        ],
        "summary": "Get registered schema",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "avro_schema": {
                    "value": {
                      "name": "my_avro_schema",
                      "type": "avro",
                      "description": "My Avro Schema",
                      "source": "{\"type\":\"record\",\"fields\":[{\"type\":\"int\",\"name\":\"i\"},{\"type\":\"string\",\"name\":\"s\"}]}"
                    },
                    "summary": "Avro"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/schema_registry.get_json"
                    },
                    {
                      "$ref": "#/components/schemas/schema_registry.get_protobuf"
                    },
                    {
                      "$ref": "#/components/schemas/schema_registry.get_avro"
                    }
                  ]
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Schema not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update an existing schema",
        "tags": [
          "Schema Registry"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "The schema name",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "my_schema"
          }
        ],
        "summary": "Update a schema",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "avro_schema": {
                    "value": {
                      "name": "my_avro_schema",
                      "type": "avro",
                      "description": "My Avro Schema",
                      "source": "{\"type\":\"record\",\"fields\":[{\"type\":\"int\",\"name\":\"i\"},{\"type\":\"string\",\"name\":\"s\"}]}"
                    },
                    "summary": "Avro"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/schema_registry.json"
                    },
                    {
                      "$ref": "#/components/schemas/schema_registry.protobuf"
                    },
                    {
                      "$ref": "#/components/schemas/schema_registry.avro"
                    }
                  ]
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Schema not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "avro_schema": {
                  "value": {
                    "name": "my_avro_schema",
                    "type": "avro",
                    "description": "My Avro Schema",
                    "source": "{\"type\":\"record\",\"fields\":[{\"type\":\"int\",\"name\":\"i\"},{\"type\":\"string\",\"name\":\"s\"}]}"
                  },
                  "summary": "Avro"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/schema_registry.json"
                  },
                  {
                    "$ref": "#/components/schemas/schema_registry.protobuf"
                  },
                  {
                    "$ref": "#/components/schemas/schema_registry.avro"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete a schema",
        "tags": [
          "Schema Registry"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "The schema name",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "my_schema"
          }
        ],
        "summary": "Delete registered schema",
        "responses": {
          "204": {
            "description": "Schema deleted"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Schema not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/publish": {
      "post": {
        "description": "Possible HTTP status response codes are:<br/><br/><code>200</code>: The message is delivered to at least one subscriber;<br/><br/><code>202</code>: No matched subscribers;<br/><br/><code>400</code>: Message is invalid. for example bad topic name, or QoS is out of range;<br/><br/><code>503</code>: Failed to deliver the message to subscriber(s)",
        "tags": [
          "Publish"
        ],
        "parameters": [],
        "summary": "Publish a message",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_publish.publish_ok"
                }
              }
            }
          },
          "202": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_publish.publish_error"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_publish.bad_request"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_publish.publish_error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx_mgmt_api_publish.publish_message"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/nodes/{node}/metrics": {
      "get": {
        "description": "Get node run-time counter metrics. Such as received or sent bytes or messages, the number of succeeded or failed authentications or authorizations, etc.",
        "tags": [
          "Nodes"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_mgmt_api_nodes.node_name"
          }
        ],
        "responses": {
          "200": {
            "description": "Get node metrics successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_metrics.node_metrics"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Node not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/configs/global_zone": {
      "get": {
        "description": "Get the MQTT-related configuration",
        "tags": [
          "Configs"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "mqtt": {
                      "$ref": "#/components/schemas/emqx.mqtt"
                    },
                    "flapping_detect": {
                      "$ref": "#/components/schemas/emqx.flapping_detect"
                    },
                    "force_shutdown": {
                      "$ref": "#/components/schemas/emqx.force_shutdown"
                    },
                    "force_gc": {
                      "$ref": "#/components/schemas/emqx.force_gc"
                    },
                    "durable_sessions": {
                      "$ref": "#/components/schemas/emqx.durable_sessions"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update MQTT-related configuration",
        "tags": [
          "Configs"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "mqtt": {
                      "$ref": "#/components/schemas/emqx.mqtt"
                    },
                    "flapping_detect": {
                      "$ref": "#/components/schemas/emqx.flapping_detect"
                    },
                    "force_shutdown": {
                      "$ref": "#/components/schemas/emqx.force_shutdown"
                    },
                    "force_gc": {
                      "$ref": "#/components/schemas/emqx.force_gc"
                    },
                    "durable_sessions": {
                      "$ref": "#/components/schemas/emqx.durable_sessions"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UPDATE_FAILED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "403": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UPDATE_FAILED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "mqtt": {
                    "$ref": "#/components/schemas/emqx.mqtt"
                  },
                  "flapping_detect": {
                    "$ref": "#/components/schemas/emqx.flapping_detect"
                  },
                  "force_shutdown": {
                    "$ref": "#/components/schemas/emqx.force_shutdown"
                  },
                  "force_gc": {
                    "$ref": "#/components/schemas/emqx.force_gc"
                  },
                  "durable_sessions": {
                    "$ref": "#/components/schemas/emqx.durable_sessions"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/sources/{id}/enable/{enable}": {
      "put": {
        "description": "Enable or Disable bridge on all nodes in the cluster.",
        "tags": [
          "Sources"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_action"
          },
          {
            "in": "path",
            "name": "enable",
            "description": "Whether to enable this bridge.",
            "required": true,
            "schema": {
              "type": "boolean"
            },
            "example": true
          }
        ],
        "summary": "Enable or disable bridge",
        "responses": {
          "204": {
            "description": "Success"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bridge not found or invalid operation"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Service unavailable"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/data/files": {
      "get": {
        "description": "List backup files",
        "tags": [
          "Data Backup"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "data": [
                    {
                      "node": "emqx@127.0.0.1",
                      "size": 22740,
                      "filename": "emqx-export-2023-09-02-11-11-33.012.tar.gz",
                      "created_at": "2023-09-02T11:11:33+02:00",
                      "created_at_sec": 1693645893
                    },
                    {
                      "node": "emqx@127.0.0.1",
                      "size": 22740,
                      "filename": "emqx-export-2023-11-23-19-13-19.043.tar.gz",
                      "created_at": "2023-11-23T19:13:19+02:00",
                      "created_at_sec": 1700759599
                    }
                  ],
                  "meta": {
                    "count": 300,
                    "limit": 20,
                    "page": 0
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_data_backup.files_response"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Upload a data backup file",
        "tags": [
          "Data Backup"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad backup file"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "multipart/form-data": {
              "schema": {
                "type": "object",
                "properties": {
                  "filename": {
                    "type": "string",
                    "format": "binary"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/bridges/{id}/enable/{enable}": {
      "put": {
        "description": "Enable or Disable bridges on all nodes in the cluster.",
        "tags": [
          "Bridges"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge Id. Must be of format {type}:{name}",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:http_example"
          },
          {
            "in": "path",
            "name": "enable",
            "description": "Whether to enable this bridge",
            "required": true,
            "schema": {
              "type": "boolean"
            },
            "example": true
          }
        ],
        "summary": "Enable or disable bridge",
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "bridge already exists as non Bridge V1 compatible action"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bridge not found or invalid operation"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Service unavailable"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/load_rebalance/status": {
      "get": {
        "description": "Get rebalance status of the current node",
        "tags": [
          "Load Rebalance"
        ],
        "parameters": [],
        "summary": "Get rebalance status",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/load_rebalance.local_status_enabled"
                    },
                    {
                      "$ref": "#/components/schemas/load_rebalance.local_status_disabled"
                    }
                  ]
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/bridges/{id}/metrics": {
      "get": {
        "description": "Get bridge metrics by Id",
        "tags": [
          "Bridges"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge Id. Must be of format {type}:{name}",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:http_example"
          }
        ],
        "summary": "Get bridge metrics",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "metrics": {
                      "description": "Bridge metrics.",
                      "$ref": "#/components/schemas/bridge.metrics"
                    },
                    "node_metrics": {
                      "type": "array",
                      "description": "Node metrics.",
                      "items": {
                        "$ref": "#/components/schemas/bridge.node_metrics"
                      }
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bridge not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/users": {
      "get": {
        "description": "Dashboard list users",
        "tags": [
          "Dashboard"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Dashboard list users",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/dashboard.user"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Create dashboard user",
        "tags": [
          "Dashboard"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "username": {
                      "type": "string",
                      "description": "Dashboard Username",
                      "maxLength": 100,
                      "example": "admin"
                    },
                    "role": {
                      "default": "administrator",
                      "type": "string",
                      "description": "User role",
                      "example": "administrator"
                    },
                    "description": {
                      "type": "string",
                      "description": "Dashboard User Description",
                      "example": "administrator"
                    },
                    "backend": {
                      "type": "string",
                      "description": "User account source",
                      "example": "local"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "username": {
                    "type": "string",
                    "description": "Dashboard Username",
                    "maxLength": 100,
                    "example": "admin"
                  },
                  "password": {
                    "type": "string",
                    "description": "Dashboard Password",
                    "maxLength": 100,
                    "example": "public"
                  },
                  "role": {
                    "default": "administrator",
                    "type": "string",
                    "description": "User role",
                    "example": "administrator"
                  },
                  "description": {
                    "type": "string",
                    "description": "Dashboard User Description",
                    "example": "administrator"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/authorization/sources/{type}/status": {
      "get": {
        "description": "Get a authorization source",
        "tags": [
          "Authorization"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "type",
            "description": "Authorization type",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "file",
                "built_in_database",
                "http",
                "redis",
                "mysql",
                "postgresql",
                "mongodb",
                "ldap"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "metrics_example": {
                    "value": {
                      "status": "connected",
                      "metrics": {
                        "nomatch": 0,
                        "total": 0,
                        "allow": 0,
                        "deny": 0,
                        "rate": 0,
                        "rate_last5m": 0,
                        "rate_max": 0
                      },
                      "node_status": [
                        {
                          "node": "emqx@127.0.0.1",
                          "status": "connected"
                        }
                      ],
                      "resource_metrics": {
                        "success": 0,
                        "matched": 0,
                        "failed": 0,
                        "rate": 0,
                        "rate_last5m": 0,
                        "rate_max": 0
                      },
                      "node_metrics": [
                        {
                          "node": "emqx@127.0.0.1",
                          "metrics": {
                            "nomatch": 0,
                            "total": 0,
                            "allow": 0,
                            "deny": 0,
                            "rate": 0,
                            "rate_last5m": 0,
                            "rate_max": 0
                          }
                        }
                      ],
                      "node_resource_metrics": [
                        {
                          "node": "emqx@127.0.0.1",
                          "metrics": {
                            "success": 0,
                            "matched": 0,
                            "failed": 0,
                            "rate": 0,
                            "rate_last5m": 0,
                            "rate_max": 0
                          }
                        }
                      ]
                    },
                    "summary": "Showing a typical metrics example"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authz_schema.metrics_status_fields"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/sources_probe": {
      "post": {
        "description": "Test creating a new bridge.",
        "tags": [
          "Sources"
        ],
        "parameters": [],
        "summary": "Test creating bridge",
        "responses": {
          "204": {
            "description": "Test bridge OK"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "TEST_FAILED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "bridge test failed"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "gcp_pubsub_consumer": {
                  "value": {
                    "name": "my_action",
                    "type": "gcp_pubsub_consumer",
                    "description": "my source",
                    "enable": true,
                    "parameters": {
                      "topic": "my-topic",
                      "pull_max_messages": 100
                    },
                    "connector": "my_connector",
                    "resource_opts": {
                      "request_ttl": "45s",
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "GCP PubSub Consumer Source"
                },
                "kafka_consumer": {
                  "value": {
                    "name": "my_source",
                    "type": "kafka_consumer",
                    "parameters": {
                      "topic": "mytopic"
                    },
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "Kafka Consumer Source"
                },
                "mqtt": {
                  "value": {
                    "name": "mqtt_source",
                    "type": "mqtt",
                    "description": "My example mqtt source",
                    "enable": true,
                    "parameters": {
                      "topic": "remote/topic",
                      "qos": 1
                    },
                    "connector": "mqtt_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "MQTT Subscriber Source"
                },
                "rabbitmq": {
                  "value": {
                    "name": "rabbitmq_source",
                    "type": "rabbitmq",
                    "description": "My example rabbitmq source",
                    "enable": true,
                    "parameters": {
                      "queue": "test_queue",
                      "no_ack": true
                    },
                    "connector": "rabbitmq_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "RabbitMQ Subscriber Source"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/bridge_rabbitmq.post_source"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mqtt_publisher.post_source"
                  },
                  {
                    "$ref": "#/components/schemas/kafka_consumer.post_source"
                  },
                  {
                    "$ref": "#/components/schemas/gcp_pubsub_consumer.post_source"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gcp_devices/{deviceid}": {
      "get": {
        "description": "Get a device imported from GCP IoT Core",
        "tags": [
          "GCP Devices"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "deviceid",
            "description": "Device identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "c2-ec-x509"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_gcp_device_api.gcp_device_all_info"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "The GCP device was not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update a device imported from GCP IoT Core",
        "tags": [
          "GCP Devices"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "deviceid",
            "description": "Device identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "c2-ec-x509"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_gcp_device_api.gcp_device_info"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx_gcp_device_api.gcp_device"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Remove a device imported from GCP IoT Core",
        "tags": [
          "GCP Devices"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "deviceid",
            "description": "Device identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "c2-ec-x509"
          }
        ],
        "responses": {
          "204": {
            "description": "GCP device deleted"
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/listeners": {
      "get": {
        "description": "List all running node's listeners for the specified type.",
        "tags": [
          "Listeners"
        ],
        "parameters": [
          {
            "in": "query",
            "name": "type",
            "description": "Listener type",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "tcp",
                "ssl",
                "ws",
                "wss",
                "quic"
              ]
            },
            "example": "tcp"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": [
                  {
                    "id": "tcp:demo",
                    "name": "demo",
                    "status": {
                      "running": true,
                      "max_connections": 2048000,
                      "current_connections": 201
                    },
                    "type": "tcp",
                    "bind": "0.0.0.0:1884",
                    "number": 2,
                    "enable": true,
                    "node_status": [
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "running": true,
                          "max_connections": 1024000,
                          "current_connections": 100
                        }
                      },
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "running": true,
                          "max_connections": 1024000,
                          "current_connections": 101
                        }
                      }
                    ],
                    "acceptors": 16
                  },
                  {
                    "id": "tcp:default",
                    "name": "default",
                    "status": {
                      "running": true,
                      "max_connections": "infinity",
                      "current_connections": 501
                    },
                    "type": "tcp",
                    "bind": "0.0.0.0:1883",
                    "number": 2,
                    "enable": true,
                    "node_status": [
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "running": true,
                          "max_connections": "infinity",
                          "current_connections": 200
                        }
                      },
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "running": true,
                          "max_connections": "infinity",
                          "current_connections": 301
                        }
                      }
                    ],
                    "acceptors": 32
                  }
                ],
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/listeners.listener_id_status"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Create the specified listener on all nodes.",
        "tags": [
          "Listeners"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "id": "tcp:demo",
                  "running": true,
                  "type": "tcp",
                  "bind": "0.0.0.0:1884",
                  "tcp_options": {
                    "buffer": "4KB",
                    "high_watermark": "1MB",
                    "nodelay": false,
                    "reuseaddr": true,
                    "send_timeout": "15s",
                    "send_timeout_close": true,
                    "backlog": 1024,
                    "active_n": 100
                  },
                  "max_connections": 204800,
                  "acceptors": 16,
                  "proxy_protocol": false,
                  "access_rules": [
                    "allow all"
                  ],
                  "proxy_protocol_timeout": "3s",
                  "zone": "default",
                  "mountpoint": "/",
                  "current_connections": 10240
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/listeners.wss_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.ws_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.tcp_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.ssl_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.quic_required_bind"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_LISTENER_ID",
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "example": {
                "name": "demo",
                "running": true,
                "type": "tcp",
                "bind": "0.0.0.0:1884",
                "tcp_options": {
                  "buffer": "4KB",
                  "high_watermark": "1MB",
                  "nodelay": false,
                  "reuseaddr": true,
                  "send_timeout": "15s",
                  "send_timeout_close": true,
                  "backlog": 1024,
                  "active_n": 100
                },
                "max_connections": 204800,
                "acceptors": 16,
                "proxy_protocol": false,
                "access_rules": [
                  "allow all"
                ],
                "proxy_protocol_timeout": "3s",
                "zone": "default",
                "mountpoint": "/",
                "current_connections": 10240
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/listeners.with_name_quic_required_bind"
                  },
                  {
                    "$ref": "#/components/schemas/listeners.with_name_wss_required_bind"
                  },
                  {
                    "$ref": "#/components/schemas/listeners.with_name_ws_required_bind"
                  },
                  {
                    "$ref": "#/components/schemas/listeners.with_name_ssl_required_bind"
                  },
                  {
                    "$ref": "#/components/schemas/listeners.with_name_tcp_required_bind"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/cluster/links": {
      "get": {
        "description": "Get cluster links configuration",
        "tags": [
          "Cluster"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": [
                  {
                    "enable": true,
                    "name": "emqxcl_b",
                    "node_status": [
                      {
                        "node": "emqx1@emqx.net",
                        "status": "connected"
                      }
                    ],
                    "pool_size": 10,
                    "server": "emqxcl_b.host:1883",
                    "ssl": {
                      "enable": false
                    },
                    "status": "connected",
                    "topics": [
                      "t/topic-example",
                      "t/topic-filter-example/1/#"
                    ]
                  },
                  {
                    "enable": true,
                    "name": "emqxcl_c",
                    "node_status": [
                      {
                        "node": "emqx1@emqx.net",
                        "status": "connected"
                      }
                    ],
                    "pool_size": 10,
                    "server": "emqxcl_c.host:1883",
                    "ssl": {
                      "enable": false
                    },
                    "status": "connected",
                    "topics": [
                      "t/topic-example",
                      "t/topic-filter-example/1/#"
                    ]
                  }
                ],
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/cluster_link.link_config_response"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Create a cluster link",
        "tags": [
          "Cluster"
        ],
        "parameters": [],
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "enable": true,
                  "name": "emqxcl_b",
                  "node_status": [
                    {
                      "node": "emqx1@emqx.net",
                      "status": "connected"
                    }
                  ],
                  "pool_size": 10,
                  "server": "emqxcl_b.host:1883",
                  "ssl": {
                    "enable": false
                  },
                  "status": "connected",
                  "topics": [
                    "t/topic-example",
                    "t/topic-filter-example/1/#"
                  ]
                },
                "schema": {
                  "$ref": "#/components/schemas/cluster_link.link_config_response"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST",
                        "ALREADY_EXISTS"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Update Config Failed"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "example": {
                "enable": true,
                "name": "emqxcl_b",
                "pool_size": 10,
                "server": "emqxcl_b.host:1883",
                "ssl": {
                  "enable": false
                },
                "topics": [
                  "t/topic-example",
                  "t/topic-filter-example/1/#"
                ]
              },
              "schema": {
                "$ref": "#/components/schemas/cluster.link"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/trace/{name}/download": {
      "get": {
        "description": "Download trace log by name",
        "tags": [
          "Trace"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/trace.name"
          },
          {
            "$ref": "#/components/parameters/trace.node"
          }
        ],
        "responses": {
          "200": {
            "description": "A trace zip file",
            "content": {
              "application/octet-stream": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "NODE_ERROR"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Trace Name or Node Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/clients/{clientid}": {
      "get": {
        "description": "Get clients info by client ID",
        "tags": [
          "Clients"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "heap_size": 610,
                  "send_msg.dropped.expired": 0,
                  "send_oct": 31,
                  "recv_msg.qos1": 0,
                  "is_persistent": false,
                  "send_pkt": 4,
                  "clean_start": true,
                  "inflight_cnt": 0,
                  "node": "emqx@127.0.0.1",
                  "send_msg.dropped.queue_full": 0,
                  "awaiting_rel_cnt": 0,
                  "inflight_max": 32,
                  "created_at": "2024-01-01T12:34:56.789+08:00",
                  "subscriptions_cnt": 1,
                  "mailbox_len": 0,
                  "send_cnt": 4,
                  "connected": true,
                  "ip_address": "127.0.0.1",
                  "awaiting_rel_max": 100,
                  "recv_msg.qos2": 0,
                  "proto_ver": 5,
                  "mountpoint": "null",
                  "proto_name": "MQTT",
                  "durable": false,
                  "port": 52571,
                  "connected_at": "2024-01-01T12:34:56.789+08:00",
                  "enable_authn": true,
                  "expiry_interval": 0,
                  "username": null,
                  "recv_msg": 0,
                  "recv_oct": 49,
                  "send_msg.dropped.too_large": 0,
                  "keepalive": 60,
                  "send_msg.qos1": 0,
                  "send_msg.qos2": 0,
                  "recv_msg.qos0": 0,
                  "send_msg.qos0": 0,
                  "subscriptions_max": "infinity",
                  "mqueue_max": 1000,
                  "mqueue_dropped": 0,
                  "clientid": "01",
                  "is_bridge": false,
                  "peerport": 52571,
                  "send_msg": 0,
                  "listener": "tcp:default",
                  "recv_cnt": 4,
                  "recv_pkt": 4,
                  "recv_msg.dropped": 0,
                  "send_msg.dropped": 0,
                  "recv_msg.dropped.await_pubrel_timeout": 0,
                  "reductions": 6836,
                  "mqueue_len": 0
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_clients.client"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "CLIENTID_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Client ID not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Kick out client by client ID",
        "tags": [
          "Clients"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Kick out client successfully"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "CLIENTID_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Client ID not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/sources/{id}/metrics": {
      "get": {
        "description": "Get bridge metrics by id.",
        "tags": [
          "Sources"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_action"
          }
        ],
        "summary": "Get source metrics",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "metrics": {
                      "description": "Bridge metrics.",
                      "$ref": "#/components/schemas/bridge.metrics"
                    },
                    "node_metrics": {
                      "type": "array",
                      "description": "Node metrics.",
                      "items": {
                        "$ref": "#/components/schemas/bridge.node_metrics"
                      }
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Source not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/{name}/authentication": {
      "get": {
        "description": "Gets the configuration of the specified gateway authenticator.<br/><br/>Returns 404 when gateway or authentication is not enabled.",
        "tags": [
          "Gateway Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "gbt32960",
                "jt808",
                "lwm2m",
                "mqttsn",
                "ocpp",
                "stomp"
              ]
            },
            "example": "stomp"
          }
        ],
        "summary": "Get authenticator configuration",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "jwt": {
                    "value": {
                      "mechanism": "jwt",
                      "secret": "mysecret",
                      "algorithm": "hmac-based",
                      "secret_base64_encoded": false,
                      "use_jwks": false,
                      "verify_claims": {
                        "username": "${username}"
                      }
                    },
                    "summary": "JWT authentication"
                  },
                  "password_based:built_in_database": {
                    "value": {
                      "mechanism": "password_based",
                      "backend": "built_in_database",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "user_id_type": "username"
                    },
                    "summary": "Built-in password_based authentication"
                  },
                  "password_based:http": {
                    "value": {
                      "ssl": {
                        "enable": false
                      },
                      "connect_timeout": "5s",
                      "mechanism": "password_based",
                      "pool_size": 8,
                      "body": {
                        "password": "${password}",
                        "username": "${username}"
                      },
                      "headers": {
                        "content-type": "application/json"
                      },
                      "url": "http://127.0.0.1:18083",
                      "method": "post",
                      "backend": "http",
                      "request_timeout": "5s",
                      "enable_pipelining": 100
                    },
                    "summary": "password_based authentication through external HTTP API"
                  },
                  "password_based:mongodb": {
                    "value": {
                      "mechanism": "password_based",
                      "filter": {
                        "username": "${username}"
                      },
                      "server": "127.0.0.1:27017",
                      "database": "example",
                      "backend": "mongodb",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "collection": "users",
                      "is_superuser_field": "is_superuser",
                      "password_hash_field": "password_hash",
                      "salt_field": "salt"
                    },
                    "summary": "password_based authentication with MongoDB backend"
                  },
                  "password_based:redis": {
                    "value": {
                      "mechanism": "password_based",
                      "cmd": "HMGET ${username} password_hash salt",
                      "server": "127.0.0.1:6379",
                      "database": 0,
                      "backend": "redis",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "redis_type": "single"
                    },
                    "summary": "password_based authentication with Redis backend"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authn.kerberos"
                    },
                    {
                      "$ref": "#/components/schemas/authn.gcp_device"
                    },
                    {
                      "$ref": "#/components/schemas/authn.ldap_deprecated"
                    },
                    {
                      "$ref": "#/components/schemas/authn.ldap"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_jwks"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_public_key"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_hmac"
                    },
                    {
                      "$ref": "#/components/schemas/authn.http_post"
                    },
                    {
                      "$ref": "#/components/schemas/authn.http_get"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_single"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_sharded"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_rs"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_single"
                    },
                    {
                      "$ref": "#/components/schemas/authn.postgresql"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mysql"
                    },
                    {
                      "$ref": "#/components/schemas/authn.builtin_db"
                    }
                  ]
                }
              }
            }
          },
          "204": {
            "description": "Authenticator not initialized"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update the configuration of the specified gateway authenticator, or disable the authenticator.",
        "tags": [
          "Gateway Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "gbt32960",
                "jt808",
                "lwm2m",
                "mqttsn",
                "ocpp",
                "stomp"
              ]
            },
            "example": "stomp"
          }
        ],
        "summary": "Update authenticator configuration",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "jwt": {
                    "value": {
                      "mechanism": "jwt",
                      "secret": "mysecret",
                      "algorithm": "hmac-based",
                      "secret_base64_encoded": false,
                      "use_jwks": false,
                      "verify_claims": {
                        "username": "${username}"
                      }
                    },
                    "summary": "JWT authentication"
                  },
                  "password_based:built_in_database": {
                    "value": {
                      "mechanism": "password_based",
                      "backend": "built_in_database",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "user_id_type": "username"
                    },
                    "summary": "Built-in password_based authentication"
                  },
                  "password_based:http": {
                    "value": {
                      "ssl": {
                        "enable": false
                      },
                      "connect_timeout": "5s",
                      "mechanism": "password_based",
                      "pool_size": 8,
                      "body": {
                        "password": "${password}",
                        "username": "${username}"
                      },
                      "headers": {
                        "content-type": "application/json"
                      },
                      "url": "http://127.0.0.1:18083",
                      "method": "post",
                      "backend": "http",
                      "request_timeout": "5s",
                      "enable_pipelining": 100
                    },
                    "summary": "password_based authentication through external HTTP API"
                  },
                  "password_based:mongodb": {
                    "value": {
                      "mechanism": "password_based",
                      "filter": {
                        "username": "${username}"
                      },
                      "server": "127.0.0.1:27017",
                      "database": "example",
                      "backend": "mongodb",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "collection": "users",
                      "is_superuser_field": "is_superuser",
                      "password_hash_field": "password_hash",
                      "salt_field": "salt"
                    },
                    "summary": "password_based authentication with MongoDB backend"
                  },
                  "password_based:redis": {
                    "value": {
                      "mechanism": "password_based",
                      "cmd": "HMGET ${username} password_hash salt",
                      "server": "127.0.0.1:6379",
                      "database": 0,
                      "backend": "redis",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "redis_type": "single"
                    },
                    "summary": "password_based authentication with Redis backend"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authn.kerberos"
                    },
                    {
                      "$ref": "#/components/schemas/authn.gcp_device"
                    },
                    {
                      "$ref": "#/components/schemas/authn.ldap_deprecated"
                    },
                    {
                      "$ref": "#/components/schemas/authn.ldap"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_jwks"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_public_key"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_hmac"
                    },
                    {
                      "$ref": "#/components/schemas/authn.http_post"
                    },
                    {
                      "$ref": "#/components/schemas/authn.http_get"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_single"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_sharded"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_rs"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_single"
                    },
                    {
                      "$ref": "#/components/schemas/authn.postgresql"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mysql"
                    },
                    {
                      "$ref": "#/components/schemas/authn.builtin_db"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "jwt": {
                  "value": {
                    "mechanism": "jwt",
                    "secret": "mysecret",
                    "algorithm": "hmac-based",
                    "secret_base64_encoded": false,
                    "use_jwks": false,
                    "verify_claims": {
                      "username": "${username}"
                    }
                  },
                  "summary": "JWT authentication"
                },
                "password_based:built_in_database": {
                  "value": {
                    "mechanism": "password_based",
                    "backend": "built_in_database",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "user_id_type": "username"
                  },
                  "summary": "Built-in password_based authentication"
                },
                "password_based:http": {
                  "value": {
                    "ssl": {
                      "enable": false
                    },
                    "connect_timeout": "5s",
                    "mechanism": "password_based",
                    "pool_size": 8,
                    "body": {
                      "password": "${password}",
                      "username": "${username}"
                    },
                    "headers": {
                      "content-type": "application/json"
                    },
                    "url": "http://127.0.0.1:18083",
                    "method": "post",
                    "backend": "http",
                    "request_timeout": "5s",
                    "enable_pipelining": 100
                  },
                  "summary": "password_based authentication through external HTTP API"
                },
                "password_based:mongodb": {
                  "value": {
                    "mechanism": "password_based",
                    "filter": {
                      "username": "${username}"
                    },
                    "server": "127.0.0.1:27017",
                    "database": "example",
                    "backend": "mongodb",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "collection": "users",
                    "is_superuser_field": "is_superuser",
                    "password_hash_field": "password_hash",
                    "salt_field": "salt"
                  },
                  "summary": "password_based authentication with MongoDB backend"
                },
                "password_based:redis": {
                  "value": {
                    "mechanism": "password_based",
                    "cmd": "HMGET ${username} password_hash salt",
                    "server": "127.0.0.1:6379",
                    "database": 0,
                    "backend": "redis",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "redis_type": "single"
                  },
                  "summary": "password_based authentication with Redis backend"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/authn.kerberos"
                  },
                  {
                    "$ref": "#/components/schemas/authn.gcp_device"
                  },
                  {
                    "$ref": "#/components/schemas/authn.ldap_deprecated"
                  },
                  {
                    "$ref": "#/components/schemas/authn.ldap"
                  },
                  {
                    "$ref": "#/components/schemas/authn.jwt_jwks"
                  },
                  {
                    "$ref": "#/components/schemas/authn.jwt_public_key"
                  },
                  {
                    "$ref": "#/components/schemas/authn.jwt_hmac"
                  },
                  {
                    "$ref": "#/components/schemas/authn.http_post"
                  },
                  {
                    "$ref": "#/components/schemas/authn.http_get"
                  },
                  {
                    "$ref": "#/components/schemas/authn.redis_sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/authn.redis_cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn.redis_single"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mongo_sharded"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mongo_rs"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mongo_single"
                  },
                  {
                    "$ref": "#/components/schemas/authn.postgresql"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mysql"
                  },
                  {
                    "$ref": "#/components/schemas/authn.builtin_db"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete the authenticator of the specified gateway.",
        "tags": [
          "Gateway Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "gbt32960",
                "jt808",
                "lwm2m",
                "mqttsn",
                "ocpp",
                "stomp"
              ]
            },
            "example": "stomp"
          }
        ],
        "summary": "Delete gateway authenticator",
        "responses": {
          "204": {
            "description": "Deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Enables the authenticator for client authentication for the specified gateway. <br/><br/>When the authenticator is not configured or turned off, all client connections are assumed to be allowed. <br/><br/>Note: Only one authenticator is allowed to be enabled at a time in the gateway, rather than allowing multiple authenticators to be configured to form an authentication chain as in MQTT.",
        "tags": [
          "Gateway Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "gbt32960",
                "jt808",
                "lwm2m",
                "mqttsn",
                "ocpp",
                "stomp"
              ]
            },
            "example": "stomp"
          }
        ],
        "summary": "Create authenticator for gateway",
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "jwt": {
                    "value": {
                      "mechanism": "jwt",
                      "secret": "mysecret",
                      "algorithm": "hmac-based",
                      "secret_base64_encoded": false,
                      "use_jwks": false,
                      "verify_claims": {
                        "username": "${username}"
                      }
                    },
                    "summary": "JWT authentication"
                  },
                  "password_based:built_in_database": {
                    "value": {
                      "mechanism": "password_based",
                      "backend": "built_in_database",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "user_id_type": "username"
                    },
                    "summary": "Built-in password_based authentication"
                  },
                  "password_based:http": {
                    "value": {
                      "ssl": {
                        "enable": false
                      },
                      "connect_timeout": "5s",
                      "mechanism": "password_based",
                      "pool_size": 8,
                      "body": {
                        "password": "${password}",
                        "username": "${username}"
                      },
                      "headers": {
                        "content-type": "application/json"
                      },
                      "url": "http://127.0.0.1:18083",
                      "method": "post",
                      "backend": "http",
                      "request_timeout": "5s",
                      "enable_pipelining": 100
                    },
                    "summary": "password_based authentication through external HTTP API"
                  },
                  "password_based:mongodb": {
                    "value": {
                      "mechanism": "password_based",
                      "filter": {
                        "username": "${username}"
                      },
                      "server": "127.0.0.1:27017",
                      "database": "example",
                      "backend": "mongodb",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "collection": "users",
                      "is_superuser_field": "is_superuser",
                      "password_hash_field": "password_hash",
                      "salt_field": "salt"
                    },
                    "summary": "password_based authentication with MongoDB backend"
                  },
                  "password_based:redis": {
                    "value": {
                      "mechanism": "password_based",
                      "cmd": "HMGET ${username} password_hash salt",
                      "server": "127.0.0.1:6379",
                      "database": 0,
                      "backend": "redis",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "redis_type": "single"
                    },
                    "summary": "password_based authentication with Redis backend"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authn.kerberos"
                    },
                    {
                      "$ref": "#/components/schemas/authn.gcp_device"
                    },
                    {
                      "$ref": "#/components/schemas/authn.ldap_deprecated"
                    },
                    {
                      "$ref": "#/components/schemas/authn.ldap"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_jwks"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_public_key"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_hmac"
                    },
                    {
                      "$ref": "#/components/schemas/authn.http_post"
                    },
                    {
                      "$ref": "#/components/schemas/authn.http_get"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_single"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_sharded"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_rs"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_single"
                    },
                    {
                      "$ref": "#/components/schemas/authn.postgresql"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mysql"
                    },
                    {
                      "$ref": "#/components/schemas/authn.builtin_db"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "jwt": {
                  "value": {
                    "mechanism": "jwt",
                    "secret": "mysecret",
                    "algorithm": "hmac-based",
                    "secret_base64_encoded": false,
                    "use_jwks": false,
                    "verify_claims": {
                      "username": "${username}"
                    }
                  },
                  "summary": "JWT authentication"
                },
                "password_based:built_in_database": {
                  "value": {
                    "mechanism": "password_based",
                    "backend": "built_in_database",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "user_id_type": "username"
                  },
                  "summary": "Built-in password_based authentication"
                },
                "password_based:http": {
                  "value": {
                    "ssl": {
                      "enable": false
                    },
                    "connect_timeout": "5s",
                    "mechanism": "password_based",
                    "pool_size": 8,
                    "body": {
                      "password": "${password}",
                      "username": "${username}"
                    },
                    "headers": {
                      "content-type": "application/json"
                    },
                    "url": "http://127.0.0.1:18083",
                    "method": "post",
                    "backend": "http",
                    "request_timeout": "5s",
                    "enable_pipelining": 100
                  },
                  "summary": "password_based authentication through external HTTP API"
                },
                "password_based:mongodb": {
                  "value": {
                    "mechanism": "password_based",
                    "filter": {
                      "username": "${username}"
                    },
                    "server": "127.0.0.1:27017",
                    "database": "example",
                    "backend": "mongodb",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "collection": "users",
                    "is_superuser_field": "is_superuser",
                    "password_hash_field": "password_hash",
                    "salt_field": "salt"
                  },
                  "summary": "password_based authentication with MongoDB backend"
                },
                "password_based:redis": {
                  "value": {
                    "mechanism": "password_based",
                    "cmd": "HMGET ${username} password_hash salt",
                    "server": "127.0.0.1:6379",
                    "database": 0,
                    "backend": "redis",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "redis_type": "single"
                  },
                  "summary": "password_based authentication with Redis backend"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/authn.kerberos"
                  },
                  {
                    "$ref": "#/components/schemas/authn.gcp_device"
                  },
                  {
                    "$ref": "#/components/schemas/authn.ldap_deprecated"
                  },
                  {
                    "$ref": "#/components/schemas/authn.ldap"
                  },
                  {
                    "$ref": "#/components/schemas/authn.jwt_jwks"
                  },
                  {
                    "$ref": "#/components/schemas/authn.jwt_public_key"
                  },
                  {
                    "$ref": "#/components/schemas/authn.jwt_hmac"
                  },
                  {
                    "$ref": "#/components/schemas/authn.http_post"
                  },
                  {
                    "$ref": "#/components/schemas/authn.http_get"
                  },
                  {
                    "$ref": "#/components/schemas/authn.redis_sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/authn.redis_cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn.redis_single"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mongo_sharded"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mongo_rs"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mongo_single"
                  },
                  {
                    "$ref": "#/components/schemas/authn.postgresql"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mysql"
                  },
                  {
                    "$ref": "#/components/schemas/authn.builtin_db"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/clients/{clientid}/unsubscribe/bulk": {
      "post": {
        "description": "Unsubscribe bulk",
        "tags": [
          "Clients"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Unsubscribe OK"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "CLIENTID_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Client ID not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_clients.unsubscribe"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/clients/{clientid}/subscribe/bulk": {
      "post": {
        "description": "Subscribe bulk",
        "tags": [
          "Clients"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/emqx_mgmt_api_subscriptions.subscription"
                  }
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "CLIENTID_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Client ID not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_clients.subscribe"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/sources/{id}/{operation}": {
      "post": {
        "description": "Start bridge on all nodes in the cluster.",
        "tags": [
          "Sources"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_action"
          },
          {
            "in": "path",
            "name": "operation",
            "description": "Operation can be one of: 'start'.",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "start"
              ]
            },
            "example": "start"
          }
        ],
        "summary": "Manually start a bridge",
        "responses": {
          "204": {
            "description": "Operation success"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Problem with configuration of external service"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bridge not found or invalid operation"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "501": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_IMPLEMENTED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Implemented"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Service unavailable"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/connectors/{id}/{operation}": {
      "post": {
        "description": "Start connector on all nodes in the cluster.",
        "tags": [
          "Connectors"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The connector id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_connector"
          },
          {
            "in": "path",
            "name": "operation",
            "description": "Operation can be one of: 'start'.",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "start"
              ]
            },
            "example": "start"
          }
        ],
        "summary": "Manually start a connector",
        "responses": {
          "204": {
            "description": "Operation success"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Problem with configuration of external service"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Connector not found or invalid operation"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "501": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_IMPLEMENTED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Implemented"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Service unavailable"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/configs/alarm": {
      "get": {
        "description": "Get the sub-configurations under *alarm*",
        "tags": [
          "Configs"
        ],
        "parameters": [],
        "summary": "Get the sub-configurations under *alarm*",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx.alarm"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "config not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update the sub-configurations under *alarm*",
        "tags": [
          "Configs"
        ],
        "parameters": [],
        "summary": "Update the sub-configurations under *alarm*",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx.alarm"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UPDATE_FAILED",
                        "INVALID_CONFIG"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "403": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UPDATE_FAILED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx.alarm"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/load_rebalance/{node}/evacuation/stop": {
      "post": {
        "description": "Stop evacuation process",
        "tags": [
          "Load Rebalance"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "node",
            "description": "Node name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "summary": "Stop evacuation on a node",
        "responses": {
          "200": {
            "description": "The response is empty",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "example": {}
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/configs/file_transfer": {
      "get": {
        "description": "Get the sub-configurations under *file_transfer*",
        "tags": [
          "Configs"
        ],
        "parameters": [],
        "summary": "Get the sub-configurations under *file_transfer*",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx.file_transfer"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "config not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update the sub-configurations under *file_transfer*",
        "tags": [
          "Configs"
        ],
        "parameters": [],
        "summary": "Update the sub-configurations under *file_transfer*",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx.file_transfer"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UPDATE_FAILED",
                        "INVALID_CONFIG"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "403": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UPDATE_FAILED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx.file_transfer"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/actions": {
      "get": {
        "description": "List all created bridges.",
        "tags": [
          "Actions"
        ],
        "parameters": [],
        "summary": "List bridges",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": [
                  {
                    "name": "my_http_action",
                    "status": "connected",
                    "type": "http",
                    "enable": true,
                    "parameters": {
                      "path": "/room/${room_no}",
                      "body": "${.}",
                      "headers": {},
                      "method": "post"
                    },
                    "connector": "my_http_connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "worker_pool_size": 16,
                      "query_mode": "async",
                      "health_check_interval": "15s"
                    }
                  },
                  {
                    "name": "my_confluent_producer_action",
                    "status": "connected",
                    "type": "confluent_producer",
                    "enable": true,
                    "parameters": {
                      "message": {
                        "value": "${.}",
                        "key": "${.clientid}"
                      },
                      "buffer": {
                        "mode": "hybrid",
                        "memory_overload_protection": true,
                        "segment_bytes": "100MB",
                        "per_partition_limit": "2GB"
                      },
                      "topic": "topic",
                      "max_inflight": 10,
                      "required_acks": "all_isr",
                      "max_batch_bytes": "896KB",
                      "partition_count_refresh_interval": "60s",
                      "kafka_header_value_encode_mode": "none",
                      "kafka_ext_headers": [
                        {
                          "kafka_ext_header_value": "${clientid}",
                          "kafka_ext_header_key": "clientid"
                        },
                        {
                          "kafka_ext_header_value": "${topic}",
                          "kafka_ext_header_key": "topic"
                        }
                      ],
                      "kafka_headers": "${.pub_props}",
                      "partition_strategy": "random"
                    },
                    "connector": "my_confluent_producer_connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "local_topic": "mqtt/local/topic"
                  },
                  {
                    "name": "iotdb_action",
                    "status": "connected",
                    "type": "iotdb",
                    "description": "My example iotdb action",
                    "enable": true,
                    "parameters": {
                      "data": [
                        {
                          "timestamp": "now",
                          "value": "${st}",
                          "data_type": "BOOLEAN",
                          "measurement": "status"
                        }
                      ],
                      "device_id": "my_device",
                      "is_aligned": false
                    },
                    "connector": "iotdb_connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  {
                    "status": "connected",
                    "description": "my action",
                    "enable": true,
                    "parameters": {
                      "mode": "direct",
                      "content": "${.payload}",
                      "blob": "${.payload.blob}",
                      "container": "${.payload.container}"
                    },
                    "connector": "my_connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 16,
                      "query_mode": "sync",
                      "batch_time": "0ms",
                      "inflight_window": 100,
                      "request_ttl": "45s",
                      "health_check_interval": "30s"
                    }
                  },
                  {
                    "status": "connected",
                    "description": "my action",
                    "enable": true,
                    "parameters": {
                      "sql": "insert into mqtt (key, value) values (${.id}, ${.payload})"
                    },
                    "connector": "my_connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "worker_pool_size": 16,
                      "query_mode": "sync",
                      "inflight_window": 100,
                      "request_ttl": "45s",
                      "health_check_interval": "30s"
                    }
                  },
                  {
                    "name": "datalayers_action",
                    "status": "connected",
                    "type": "datalayers",
                    "description": "My example datalayers action",
                    "enable": true,
                    "parameters": {
                      "precision": "ms",
                      "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,bool=${payload.bool}"
                    },
                    "connector": "datalayers_connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  {
                    "name": "my_azure_event_hub_producer_action",
                    "status": "connected",
                    "type": "azure_event_hub_producer",
                    "enable": true,
                    "parameters": {
                      "message": {
                        "value": "${.}",
                        "key": "${.clientid}"
                      },
                      "buffer": {
                        "mode": "hybrid",
                        "memory_overload_protection": true,
                        "segment_bytes": "100MB",
                        "per_partition_limit": "2GB"
                      },
                      "topic": "topic",
                      "max_inflight": 10,
                      "required_acks": "all_isr",
                      "max_batch_bytes": "896KB",
                      "partition_count_refresh_interval": "60s",
                      "kafka_header_value_encode_mode": "none",
                      "kafka_ext_headers": [
                        {
                          "kafka_ext_header_value": "${clientid}",
                          "kafka_ext_header_key": "clientid"
                        },
                        {
                          "kafka_ext_header_value": "${topic}",
                          "kafka_ext_header_key": "topic"
                        }
                      ],
                      "kafka_headers": "${.pub_props}",
                      "partition_strategy": "random"
                    },
                    "connector": "my_azure_event_hub_producer_connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "local_topic": "mqtt/local/topic"
                  },
                  {
                    "name": "my_kafka_producer_action",
                    "status": "connected",
                    "type": "kafka_producer",
                    "enable": true,
                    "parameters": {
                      "message": {
                        "timestamp": "${.timestamp}",
                        "value": "${.}",
                        "key": "${.clientid}"
                      },
                      "buffer": {
                        "mode": "hybrid",
                        "memory_overload_protection": true,
                        "segment_bytes": "100MB",
                        "per_partition_limit": "2GB"
                      },
                      "compression": "no_compression",
                      "topic": "kafka-topic",
                      "max_inflight": 10,
                      "required_acks": "all_isr",
                      "max_batch_bytes": "896KB",
                      "partitions_limit": "all_partitions",
                      "partition_count_refresh_interval": "60s",
                      "kafka_header_value_encode_mode": "none",
                      "kafka_ext_headers": [
                        {
                          "kafka_ext_header_value": "${clientid}",
                          "kafka_ext_header_key": "clientid"
                        },
                        {
                          "kafka_ext_header_value": "${topic}",
                          "kafka_ext_header_key": "topic"
                        }
                      ],
                      "kafka_headers": "${pub_props}",
                      "partition_strategy": "random"
                    },
                    "connector": "my_kafka_producer_connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "health_check_interval": "32s"
                    },
                    "local_topic": "mqtt/local/topic"
                  },
                  {
                    "name": "kinesis_action",
                    "status": "connected",
                    "type": "kinesis",
                    "description": "My example kinesis action",
                    "enable": true,
                    "parameters": {
                      "partition_key": "any_key",
                      "payload_template": "${.}",
                      "stream_name": "my_stream"
                    },
                    "connector": "kinesis_connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  {
                    "name": "my_action",
                    "status": "connected",
                    "type": "pgsql",
                    "enable": true,
                    "connector": "my_connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 16,
                      "max_buffer_bytes": "256MB",
                      "batch_time": "50ms",
                      "inflight_window": 100,
                      "request_ttl": "45s"
                    },
                    "parameters": {
                      "sql": "INSERT INTO client_events(clientid, event, created_at)VALUES (\n  ${clientid},\n  ${event},\n  TO_TIMESTAMP((${timestamp} :: bigint))\n)"
                    }
                  },
                  {
                    "name": "mysql_action",
                    "status": "connected",
                    "type": "mysql",
                    "description": "My example mysql action",
                    "enable": true,
                    "parameters": {
                      "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, FROM_UNIXTIME(${timestamp}/1000))"
                    },
                    "connector": "mysql_connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  {
                    "name": "mqtt_action",
                    "status": "connected",
                    "type": "mqtt",
                    "description": "My example mqtt action",
                    "enable": true,
                    "parameters": {
                      "retain": false,
                      "payload": "${.payload}",
                      "topic": "remote/topic",
                      "qos": 2
                    },
                    "connector": "mqtt_connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  {
                    "name": "rabbitmq_action",
                    "status": "connected",
                    "type": "rabbitmq",
                    "description": "My example rabbitmq action",
                    "enable": true,
                    "parameters": {
                      "exchange": "test_exchange",
                      "payload_template": "${.payload}",
                      "routing_key": "/",
                      "wait_for_publish_confirmations": true,
                      "delivery_mode": "non_persistent",
                      "publish_confirmation_timeout": "30s"
                    },
                    "connector": "rabbitmq_connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  {
                    "status": "connected",
                    "description": "My action",
                    "enable": true,
                    "parameters": {
                      "command_template": [
                        "LPUSH",
                        "MSGS",
                        "${payload}"
                      ]
                    },
                    "connector": "my_connector_name",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "batch_size": 1
                    }
                  },
                  {
                    "name": "dynamo_action",
                    "status": "connected",
                    "type": "dynamo",
                    "description": "My example dynamo action",
                    "enable": true,
                    "connector": "dynamo_connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "health_check_interval": "30s"
                    },
                    "parameters": {
                      "hash_key": "clientid",
                      "table": "mqtt_msg",
                      "template": ""
                    }
                  },
                  {
                    "name": "tdengine_action",
                    "status": "connected",
                    "type": "tdengine",
                    "description": "My example tdengine action",
                    "enable": true,
                    "parameters": {
                      "database": "mqtt",
                      "sql": "insert into t_mqtt_msg(ts, msgid, mqtt_topic, qos, payload, arrived) values (${ts}, '${id}', '${topic}', ${qos}, '${payload}', ${timestamp})"
                    },
                    "connector": "tdengine_connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  {
                    "status": "connected",
                    "description": "My upload action",
                    "enable": true,
                    "parameters": {
                      "mode": "direct",
                      "key": "${topic}",
                      "content": "${payload}",
                      "bucket": "${clientid}",
                      "acl": "public_read"
                    },
                    "connector": "my_s3_connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "query_mode": "sync",
                      "inflight_window": 10
                    }
                  },
                  {
                    "name": "greptimedb_action",
                    "status": "connected",
                    "type": "greptimedb",
                    "description": "My example greptimedb action",
                    "enable": true,
                    "parameters": {
                      "precision": "ms",
                      "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,uint_value=${payload.uint_key}u,bool=${payload.bool}"
                    },
                    "connector": "greptimedb_connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  {
                    "name": "opents_action",
                    "status": "connected",
                    "type": "opents",
                    "description": "My example opents action",
                    "enable": true,
                    "parameters": {
                      "data": [
                        {
                          "value": "${value}",
                          "tags": "${tags}",
                          "metric": "${metric}"
                        }
                      ]
                    },
                    "connector": "opents_connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  {
                    "name": "oracle_action",
                    "status": "connected",
                    "type": "oracle",
                    "description": "My example oracle action",
                    "enable": true,
                    "parameters": {
                      "sql": "insert into t_mqtt_msgs(msgid, topic, qos, payload) values (${id}, ${topic}, ${qos}, ${payload})"
                    },
                    "connector": "oracle_connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  {
                    "name": "hstreamdb_action",
                    "status": "connected",
                    "type": "hstreamdb",
                    "description": "My example hstreamdb action",
                    "enable": true,
                    "connector": "hstreamdb_connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "health_check_interval": "30s"
                    },
                    "parameters": {
                      "aggregation_pool_size": 8,
                      "partition_key": "hej",
                      "record_template": "${payload}",
                      "stream": "mqtt_message",
                      "writer_pool_size": 8
                    }
                  },
                  {
                    "name": "cassandra_action",
                    "status": "connected",
                    "type": "cassandra",
                    "description": "My example cassandra action",
                    "enable": true,
                    "parameters": {
                      "cql": "insert into mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic},  ${qos}, ${payload}, ${timestamp})"
                    },
                    "connector": "cassandra_connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  {
                    "name": "clickhouse_action",
                    "status": "connected",
                    "type": "clickhouse",
                    "description": "My example clickhouse action",
                    "enable": true,
                    "parameters": {
                      "sql": "INSERT INTO messages(data, arrived) VALUES ('${payload}', ${timestamp})",
                      "batch_value_separator": ", "
                    },
                    "connector": "clickhouse_connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  {
                    "name": "influxdb_action",
                    "status": "connected",
                    "type": "influxdb",
                    "description": "My example influxdb action",
                    "enable": true,
                    "parameters": {
                      "precision": "ms",
                      "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,bool=${payload.bool}"
                    },
                    "connector": "influxdb_connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  {
                    "name": "sqlserver_action",
                    "status": "connected",
                    "type": "sqlserver",
                    "description": "My example sqlserver action",
                    "enable": true,
                    "connector": "sqlserver_connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "health_check_interval": "30s"
                    },
                    "parameters": {
                      "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload) values ( ${id}, ${topic}, ${qos}, ${payload} )"
                    }
                  },
                  {
                    "name": "my_action",
                    "status": "connected",
                    "type": "matrix",
                    "enable": true,
                    "connector": "my_connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 16,
                      "max_buffer_bytes": "256MB",
                      "batch_time": "50ms",
                      "inflight_window": 100,
                      "request_ttl": "45s"
                    },
                    "parameters": {
                      "sql": "INSERT INTO client_events(clientid, event, created_at)VALUES (\n  ${clientid},\n  ${event},\n  TO_TIMESTAMP((${timestamp} :: bigint))\n)"
                    }
                  },
                  {
                    "status": "connected",
                    "description": "my action",
                    "enable": true,
                    "parameters": {
                      "mode": "aggregated",
                      "blob": "${action}/${node}/${datetime.rfc3339}/${sequence}",
                      "container": "mycontainer",
                      "aggregation": {
                        "container": {
                          "type": "csv",
                          "column_order": [
                            "a",
                            "b"
                          ]
                        },
                        "max_records": 10000,
                        "time_interval": "4s"
                      }
                    },
                    "connector": "my_connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "batch_size": 100,
                      "worker_pool_size": 16,
                      "query_mode": "sync",
                      "batch_time": "10ms",
                      "inflight_window": 100,
                      "request_ttl": "45s",
                      "health_check_interval": "30s"
                    }
                  },
                  {
                    "name": "rocketmq_action",
                    "status": "connected",
                    "type": "rocketmq",
                    "description": "My example rocketmq action",
                    "enable": true,
                    "connector": "rocketmq_connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "health_check_interval": "30s"
                    },
                    "parameters": {
                      "refresh_interval": "3s",
                      "send_buffer": "1024KB",
                      "sync_timeout": "3s",
                      "template": "",
                      "topic": "TopicTest"
                    }
                  },
                  {
                    "name": "pulsar_action",
                    "status": "connected",
                    "type": "pulsar",
                    "description": "My example pulsar action",
                    "enable": true,
                    "parameters": {
                      "message": {
                        "value": "${.}",
                        "key": "${.clientid}"
                      },
                      "sync_timeout": "5s",
                      "pulsar_topic": "test_topic"
                    },
                    "connector": "pulsar_connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  {
                    "name": "syskeeper_forwarder",
                    "status": "connected",
                    "type": "syskeeper_forwarder",
                    "enable": true,
                    "parameters": {
                      "template": "${payload}",
                      "target_topic": "${topic}"
                    },
                    "connector": "syskeeper_forwarder",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "worker_pool_size": 16
                    }
                  },
                  {
                    "status": "connected",
                    "description": "My aggregated upload action",
                    "enable": true,
                    "parameters": {
                      "mode": "aggregated",
                      "key": "${action}/${node}/${datetime.rfc3339utc}_N${sequence}.csv",
                      "bucket": "mqtt-aggregated",
                      "acl": "public_read",
                      "aggregation": {
                        "max_records": 100000,
                        "time_interval": "15m"
                      },
                      "container": {
                        "type": "csv",
                        "column_order": [
                          "clientid",
                          "topic",
                          "publish_received_at"
                        ]
                      }
                    },
                    "connector": "my_s3_connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "query_mode": "async",
                      "inflight_window": 100,
                      "health_check_interval": "10s"
                    }
                  },
                  {
                    "name": "elasticsearch_action",
                    "status": "connected",
                    "type": "elasticsearch",
                    "description": "My example elasticsearch action",
                    "enable": true,
                    "parameters": {
                      "index": "${payload.index}",
                      "action": "create",
                      "doc": "${payload.doc}",
                      "overwrite": true
                    },
                    "connector": "elasticsearch_connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  {
                    "status": "connected",
                    "description": "My action",
                    "enable": true,
                    "parameters": {
                      "payload_template": "${payload}",
                      "pubsub_topic": "mytopic",
                      "ordering_key_template": "${payload.ok}",
                      "attributes_template": [
                        {
                          "value": "${payload.attrs.v}",
                          "key": "${payload.attrs.k}"
                        }
                      ]
                    },
                    "connector": "my_connector_name",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "batch_size": 5
                    },
                    "local_topic": "local/topic"
                  },
                  {
                    "name": "mongodb_action",
                    "status": "connected",
                    "type": "mongodb",
                    "description": "My example mongodb action",
                    "enable": true,
                    "parameters": {
                      "collection": "mycol"
                    },
                    "connector": "mongodb_connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  {
                    "name": "my_action",
                    "status": "connected",
                    "type": "timescale",
                    "enable": true,
                    "connector": "my_connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 16,
                      "max_buffer_bytes": "256MB",
                      "batch_time": "50ms",
                      "inflight_window": 100,
                      "request_ttl": "45s"
                    },
                    "parameters": {
                      "sql": "INSERT INTO client_events(clientid, event, created_at)VALUES (\n  ${clientid},\n  ${event},\n  TO_TIMESTAMP((${timestamp} :: bigint))\n)"
                    }
                  }
                ],
                "schema": {
                  "type": "array",
                  "items": {
                    "oneOf": [
                      {
                        "$ref": "#/components/schemas/bridge_timescale.get_bridge_v2"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_mongodb.get_bridge_v2"
                      },
                      {
                        "$ref": "#/components/schemas/gcp_pubsub_producer.get_bridge_v2"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_elasticsearch.get_bridge_v2"
                      },
                      {
                        "$ref": "#/components/schemas/action_azure_blob_storage.get_bridge_v2"
                      },
                      {
                        "$ref": "#/components/schemas/syskeeper.get_bridge_v2"
                      },
                      {
                        "$ref": "#/components/schemas/pulsar.get_bridge_v2"
                      },
                      {
                        "$ref": "#/components/schemas/rocketmq.get_bridge_v2"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_matrix.get_bridge_v2"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_sqlserver.get_bridge_v2"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_influxdb.get_bridge_v2"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_clickhouse.get_bridge_v2"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_cassa.get_bridge_v2"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_hstreamdb.get_bridge_v2"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_oracle.get_bridge_v2"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_opents.get_bridge_v2"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_greptimedb.get_bridge_v2"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_s3.get_bridge_v2"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_tdengine.get_bridge_v2"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_dynamo.get_bridge_v2"
                      },
                      {
                        "$ref": "#/components/schemas/redis.get_bridge_v2"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_rabbitmq.get_bridge_v2"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_mqtt_publisher.get_bridge_v2"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_mysql.get_bridge_v2"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_pgsql.get_bridge_v2"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_kinesis.get_bridge_v2"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_kafka.get_bridge_v2"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_azure_event_hub.get_bridge_v2"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_datalayers.get_bridge_v2"
                      },
                      {
                        "$ref": "#/components/schemas/action_couchbase.get_bridge_v2"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_iotdb.get_bridge_v2"
                      },
                      {
                        "$ref": "#/components/schemas/confluent.get_bridge_v2"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_http.get_bridge_v2"
                      }
                    ]
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Create a new bridge by type and name.",
        "tags": [
          "Actions"
        ],
        "parameters": [],
        "summary": "Create bridge",
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "http": {
                    "value": {
                      "name": "my_http_action",
                      "status": "connected",
                      "type": "http",
                      "enable": true,
                      "parameters": {
                        "path": "/room/${room_no}",
                        "body": "${.}",
                        "headers": {},
                        "method": "post"
                      },
                      "connector": "my_http_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "worker_pool_size": 16,
                        "query_mode": "async",
                        "health_check_interval": "15s"
                      }
                    },
                    "summary": "HTTP Action"
                  },
                  "confluent_producer": {
                    "value": {
                      "name": "my_confluent_producer_action",
                      "status": "connected",
                      "type": "confluent_producer",
                      "enable": true,
                      "parameters": {
                        "message": {
                          "value": "${.}",
                          "key": "${.clientid}"
                        },
                        "buffer": {
                          "mode": "hybrid",
                          "memory_overload_protection": true,
                          "segment_bytes": "100MB",
                          "per_partition_limit": "2GB"
                        },
                        "topic": "topic",
                        "max_inflight": 10,
                        "required_acks": "all_isr",
                        "max_batch_bytes": "896KB",
                        "partition_count_refresh_interval": "60s",
                        "kafka_header_value_encode_mode": "none",
                        "kafka_ext_headers": [
                          {
                            "kafka_ext_header_value": "${clientid}",
                            "kafka_ext_header_key": "clientid"
                          },
                          {
                            "kafka_ext_header_value": "${topic}",
                            "kafka_ext_header_key": "topic"
                          }
                        ],
                        "kafka_headers": "${.pub_props}",
                        "partition_strategy": "random"
                      },
                      "connector": "my_confluent_producer_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "local_topic": "mqtt/local/topic"
                    },
                    "summary": "Confluent Action"
                  },
                  "iotdb": {
                    "value": {
                      "name": "iotdb_action",
                      "status": "connected",
                      "type": "iotdb",
                      "description": "My example iotdb action",
                      "enable": true,
                      "parameters": {
                        "data": [
                          {
                            "timestamp": "now",
                            "value": "${st}",
                            "data_type": "BOOLEAN",
                            "measurement": "status"
                          }
                        ],
                        "device_id": "my_device",
                        "is_aligned": false
                      },
                      "connector": "iotdb_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "Apache IoTDB Bridge"
                  },
                  "direct_azure_blob_storage": {
                    "value": {
                      "status": "connected",
                      "description": "my action",
                      "enable": true,
                      "parameters": {
                        "mode": "direct",
                        "content": "${.payload}",
                        "blob": "${.payload.blob}",
                        "container": "${.payload.container}"
                      },
                      "connector": "my_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 16,
                        "query_mode": "sync",
                        "batch_time": "0ms",
                        "inflight_window": 100,
                        "request_ttl": "45s",
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "Azure Blob Storage Direct Upload Action"
                  },
                  "couchbase": {
                    "value": {
                      "status": "connected",
                      "description": "my action",
                      "enable": true,
                      "parameters": {
                        "sql": "insert into mqtt (key, value) values (${.id}, ${.payload})"
                      },
                      "connector": "my_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "worker_pool_size": 16,
                        "query_mode": "sync",
                        "inflight_window": 100,
                        "request_ttl": "45s",
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "Couchbase Action"
                  },
                  "datalayers": {
                    "value": {
                      "name": "datalayers_action",
                      "status": "connected",
                      "type": "datalayers",
                      "description": "My example datalayers action",
                      "enable": true,
                      "parameters": {
                        "precision": "ms",
                        "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,bool=${payload.bool}"
                      },
                      "connector": "datalayers_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "Datalayers Action"
                  },
                  "azure_event_hub_producer": {
                    "value": {
                      "name": "my_azure_event_hub_producer_action",
                      "status": "connected",
                      "type": "azure_event_hub_producer",
                      "enable": true,
                      "parameters": {
                        "message": {
                          "value": "${.}",
                          "key": "${.clientid}"
                        },
                        "buffer": {
                          "mode": "hybrid",
                          "memory_overload_protection": true,
                          "segment_bytes": "100MB",
                          "per_partition_limit": "2GB"
                        },
                        "topic": "topic",
                        "max_inflight": 10,
                        "required_acks": "all_isr",
                        "max_batch_bytes": "896KB",
                        "partition_count_refresh_interval": "60s",
                        "kafka_header_value_encode_mode": "none",
                        "kafka_ext_headers": [
                          {
                            "kafka_ext_header_value": "${clientid}",
                            "kafka_ext_header_key": "clientid"
                          },
                          {
                            "kafka_ext_header_value": "${topic}",
                            "kafka_ext_header_key": "topic"
                          }
                        ],
                        "kafka_headers": "${.pub_props}",
                        "partition_strategy": "random"
                      },
                      "connector": "my_azure_event_hub_producer_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "local_topic": "mqtt/local/topic"
                    },
                    "summary": "Azure Event Hub Action"
                  },
                  "kafka_producer": {
                    "value": {
                      "name": "my_kafka_producer_action",
                      "status": "connected",
                      "type": "kafka_producer",
                      "enable": true,
                      "parameters": {
                        "message": {
                          "timestamp": "${.timestamp}",
                          "value": "${.}",
                          "key": "${.clientid}"
                        },
                        "buffer": {
                          "mode": "hybrid",
                          "memory_overload_protection": true,
                          "segment_bytes": "100MB",
                          "per_partition_limit": "2GB"
                        },
                        "compression": "no_compression",
                        "topic": "kafka-topic",
                        "max_inflight": 10,
                        "required_acks": "all_isr",
                        "max_batch_bytes": "896KB",
                        "partitions_limit": "all_partitions",
                        "partition_count_refresh_interval": "60s",
                        "kafka_header_value_encode_mode": "none",
                        "kafka_ext_headers": [
                          {
                            "kafka_ext_header_value": "${clientid}",
                            "kafka_ext_header_key": "clientid"
                          },
                          {
                            "kafka_ext_header_value": "${topic}",
                            "kafka_ext_header_key": "topic"
                          }
                        ],
                        "kafka_headers": "${pub_props}",
                        "partition_strategy": "random"
                      },
                      "connector": "my_kafka_producer_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "32s"
                      },
                      "local_topic": "mqtt/local/topic"
                    },
                    "summary": "Kafka Producer Action"
                  },
                  "kinesis": {
                    "value": {
                      "name": "kinesis_action",
                      "status": "connected",
                      "type": "kinesis",
                      "description": "My example kinesis action",
                      "enable": true,
                      "parameters": {
                        "partition_key": "any_key",
                        "payload_template": "${.}",
                        "stream_name": "my_stream"
                      },
                      "connector": "kinesis_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "Kinesis Action"
                  },
                  "pgsql": {
                    "value": {
                      "name": "my_action",
                      "status": "connected",
                      "type": "pgsql",
                      "enable": true,
                      "connector": "my_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 16,
                        "max_buffer_bytes": "256MB",
                        "batch_time": "50ms",
                        "inflight_window": 100,
                        "request_ttl": "45s"
                      },
                      "parameters": {
                        "sql": "INSERT INTO client_events(clientid, event, created_at)VALUES (\n  ${clientid},\n  ${event},\n  TO_TIMESTAMP((${timestamp} :: bigint))\n)"
                      }
                    },
                    "summary": "PostgreSQL Action"
                  },
                  "mysql": {
                    "value": {
                      "name": "mysql_action",
                      "status": "connected",
                      "type": "mysql",
                      "description": "My example mysql action",
                      "enable": true,
                      "parameters": {
                        "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, FROM_UNIXTIME(${timestamp}/1000))"
                      },
                      "connector": "mysql_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "MySQL Action"
                  },
                  "mqtt": {
                    "value": {
                      "name": "mqtt_action",
                      "status": "connected",
                      "type": "mqtt",
                      "description": "My example mqtt action",
                      "enable": true,
                      "parameters": {
                        "retain": false,
                        "payload": "${.payload}",
                        "topic": "remote/topic",
                        "qos": 2
                      },
                      "connector": "mqtt_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "MQTT Producer Action"
                  },
                  "rabbitmq": {
                    "value": {
                      "name": "rabbitmq_action",
                      "status": "connected",
                      "type": "rabbitmq",
                      "description": "My example rabbitmq action",
                      "enable": true,
                      "parameters": {
                        "exchange": "test_exchange",
                        "payload_template": "${.payload}",
                        "routing_key": "/",
                        "wait_for_publish_confirmations": true,
                        "delivery_mode": "non_persistent",
                        "publish_confirmation_timeout": "30s"
                      },
                      "connector": "rabbitmq_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "RabbitMQ Producer Action"
                  },
                  "redis": {
                    "value": {
                      "status": "connected",
                      "description": "My action",
                      "enable": true,
                      "parameters": {
                        "command_template": [
                          "LPUSH",
                          "MSGS",
                          "${payload}"
                        ]
                      },
                      "connector": "my_connector_name",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "batch_size": 1
                      }
                    },
                    "summary": "Redis Action"
                  },
                  "dynamo": {
                    "value": {
                      "name": "dynamo_action",
                      "status": "connected",
                      "type": "dynamo",
                      "description": "My example dynamo action",
                      "enable": true,
                      "connector": "dynamo_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      },
                      "parameters": {
                        "hash_key": "clientid",
                        "table": "mqtt_msg",
                        "template": ""
                      }
                    },
                    "summary": "DynamoDB Action"
                  },
                  "tdengine": {
                    "value": {
                      "name": "tdengine_action",
                      "status": "connected",
                      "type": "tdengine",
                      "description": "My example tdengine action",
                      "enable": true,
                      "parameters": {
                        "database": "mqtt",
                        "sql": "insert into t_mqtt_msg(ts, msgid, mqtt_topic, qos, payload, arrived) values (${ts}, '${id}', '${topic}', ${qos}, '${payload}', ${timestamp})"
                      },
                      "connector": "tdengine_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "TDengine Action"
                  },
                  "s3": {
                    "value": {
                      "status": "connected",
                      "description": "My upload action",
                      "enable": true,
                      "parameters": {
                        "mode": "direct",
                        "key": "${topic}",
                        "content": "${payload}",
                        "bucket": "${clientid}",
                        "acl": "public_read"
                      },
                      "connector": "my_s3_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "query_mode": "sync",
                        "inflight_window": 10
                      }
                    },
                    "summary": "S3 Direct Upload"
                  },
                  "greptimedb": {
                    "value": {
                      "name": "greptimedb_action",
                      "status": "connected",
                      "type": "greptimedb",
                      "description": "My example greptimedb action",
                      "enable": true,
                      "parameters": {
                        "precision": "ms",
                        "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,uint_value=${payload.uint_key}u,bool=${payload.bool}"
                      },
                      "connector": "greptimedb_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "GreptimeDB Action"
                  },
                  "opents": {
                    "value": {
                      "name": "opents_action",
                      "status": "connected",
                      "type": "opents",
                      "description": "My example opents action",
                      "enable": true,
                      "parameters": {
                        "data": [
                          {
                            "value": "${value}",
                            "tags": "${tags}",
                            "metric": "${metric}"
                          }
                        ]
                      },
                      "connector": "opents_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "OpenTSDB Action"
                  },
                  "oracle": {
                    "value": {
                      "name": "oracle_action",
                      "status": "connected",
                      "type": "oracle",
                      "description": "My example oracle action",
                      "enable": true,
                      "parameters": {
                        "sql": "insert into t_mqtt_msgs(msgid, topic, qos, payload) values (${id}, ${topic}, ${qos}, ${payload})"
                      },
                      "connector": "oracle_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "Oracle Action"
                  },
                  "hstreamdb": {
                    "value": {
                      "name": "hstreamdb_action",
                      "status": "connected",
                      "type": "hstreamdb",
                      "description": "My example hstreamdb action",
                      "enable": true,
                      "connector": "hstreamdb_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      },
                      "parameters": {
                        "aggregation_pool_size": 8,
                        "partition_key": "hej",
                        "record_template": "${payload}",
                        "stream": "mqtt_message",
                        "writer_pool_size": 8
                      }
                    },
                    "summary": "HStreamDB Action"
                  },
                  "cassandra": {
                    "value": {
                      "name": "cassandra_action",
                      "status": "connected",
                      "type": "cassandra",
                      "description": "My example cassandra action",
                      "enable": true,
                      "parameters": {
                        "cql": "insert into mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic},  ${qos}, ${payload}, ${timestamp})"
                      },
                      "connector": "cassandra_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "Cassandra Action"
                  },
                  "clickhouse": {
                    "value": {
                      "name": "clickhouse_action",
                      "status": "connected",
                      "type": "clickhouse",
                      "description": "My example clickhouse action",
                      "enable": true,
                      "parameters": {
                        "sql": "INSERT INTO messages(data, arrived) VALUES ('${payload}', ${timestamp})",
                        "batch_value_separator": ", "
                      },
                      "connector": "clickhouse_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "ClickHouse Action"
                  },
                  "influxdb": {
                    "value": {
                      "name": "influxdb_action",
                      "status": "connected",
                      "type": "influxdb",
                      "description": "My example influxdb action",
                      "enable": true,
                      "parameters": {
                        "precision": "ms",
                        "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,bool=${payload.bool}"
                      },
                      "connector": "influxdb_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "InfluxDB Action"
                  },
                  "sqlserver": {
                    "value": {
                      "name": "sqlserver_action",
                      "status": "connected",
                      "type": "sqlserver",
                      "description": "My example sqlserver action",
                      "enable": true,
                      "connector": "sqlserver_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      },
                      "parameters": {
                        "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload) values ( ${id}, ${topic}, ${qos}, ${payload} )"
                      }
                    },
                    "summary": "Microsoft SQL Server Action"
                  },
                  "matrix": {
                    "value": {
                      "name": "my_action",
                      "status": "connected",
                      "type": "matrix",
                      "enable": true,
                      "connector": "my_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 16,
                        "max_buffer_bytes": "256MB",
                        "batch_time": "50ms",
                        "inflight_window": 100,
                        "request_ttl": "45s"
                      },
                      "parameters": {
                        "sql": "INSERT INTO client_events(clientid, event, created_at)VALUES (\n  ${clientid},\n  ${event},\n  TO_TIMESTAMP((${timestamp} :: bigint))\n)"
                      }
                    },
                    "summary": "Matrix Action"
                  },
                  "aggregated_azure_blob_storage": {
                    "value": {
                      "status": "connected",
                      "description": "my action",
                      "enable": true,
                      "parameters": {
                        "mode": "aggregated",
                        "blob": "${action}/${node}/${datetime.rfc3339}/${sequence}",
                        "container": "mycontainer",
                        "aggregation": {
                          "container": {
                            "type": "csv",
                            "column_order": [
                              "a",
                              "b"
                            ]
                          },
                          "max_records": 10000,
                          "time_interval": "4s"
                        }
                      },
                      "connector": "my_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "batch_size": 100,
                        "worker_pool_size": 16,
                        "query_mode": "sync",
                        "batch_time": "10ms",
                        "inflight_window": 100,
                        "request_ttl": "45s",
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "Azure Blob Storage Aggregated Upload Action"
                  },
                  "rocketmq": {
                    "value": {
                      "name": "rocketmq_action",
                      "status": "connected",
                      "type": "rocketmq",
                      "description": "My example rocketmq action",
                      "enable": true,
                      "connector": "rocketmq_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      },
                      "parameters": {
                        "refresh_interval": "3s",
                        "send_buffer": "1024KB",
                        "sync_timeout": "3s",
                        "template": "",
                        "topic": "TopicTest"
                      }
                    },
                    "summary": "RocketMQ Action"
                  },
                  "pulsar": {
                    "value": {
                      "name": "pulsar_action",
                      "status": "connected",
                      "type": "pulsar",
                      "description": "My example pulsar action",
                      "enable": true,
                      "parameters": {
                        "message": {
                          "value": "${.}",
                          "key": "${.clientid}"
                        },
                        "sync_timeout": "5s",
                        "pulsar_topic": "test_topic"
                      },
                      "connector": "pulsar_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "Pulsar Producer Action"
                  },
                  "syskeeper_forwarder": {
                    "value": {
                      "name": "syskeeper_forwarder",
                      "status": "connected",
                      "type": "syskeeper_forwarder",
                      "enable": true,
                      "parameters": {
                        "template": "${payload}",
                        "target_topic": "${topic}"
                      },
                      "connector": "syskeeper_forwarder",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "worker_pool_size": 16
                      }
                    },
                    "summary": "Syskeeper Forwarder Bridge"
                  },
                  "s3_aggreg": {
                    "value": {
                      "status": "connected",
                      "description": "My aggregated upload action",
                      "enable": true,
                      "parameters": {
                        "mode": "aggregated",
                        "key": "${action}/${node}/${datetime.rfc3339utc}_N${sequence}.csv",
                        "bucket": "mqtt-aggregated",
                        "acl": "public_read",
                        "aggregation": {
                          "max_records": 100000,
                          "time_interval": "15m"
                        },
                        "container": {
                          "type": "csv",
                          "column_order": [
                            "clientid",
                            "topic",
                            "publish_received_at"
                          ]
                        }
                      },
                      "connector": "my_s3_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "query_mode": "async",
                        "inflight_window": 100,
                        "health_check_interval": "10s"
                      }
                    },
                    "summary": "S3 Aggregated Upload"
                  },
                  "elasticsearch": {
                    "value": {
                      "name": "elasticsearch_action",
                      "status": "connected",
                      "type": "elasticsearch",
                      "description": "My example elasticsearch action",
                      "enable": true,
                      "parameters": {
                        "index": "${payload.index}",
                        "action": "create",
                        "doc": "${payload.doc}",
                        "overwrite": true
                      },
                      "connector": "elasticsearch_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "Elastic Search Bridge"
                  },
                  "gcp_pubsub_producer": {
                    "value": {
                      "status": "connected",
                      "description": "My action",
                      "enable": true,
                      "parameters": {
                        "payload_template": "${payload}",
                        "pubsub_topic": "mytopic",
                        "ordering_key_template": "${payload.ok}",
                        "attributes_template": [
                          {
                            "value": "${payload.attrs.v}",
                            "key": "${payload.attrs.k}"
                          }
                        ]
                      },
                      "connector": "my_connector_name",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "batch_size": 5
                      },
                      "local_topic": "local/topic"
                    },
                    "summary": "GCP PubSub Producer Action"
                  },
                  "mongodb": {
                    "value": {
                      "name": "mongodb_action",
                      "status": "connected",
                      "type": "mongodb",
                      "description": "My example mongodb action",
                      "enable": true,
                      "parameters": {
                        "collection": "mycol"
                      },
                      "connector": "mongodb_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "MongoDB Action"
                  },
                  "timescale": {
                    "value": {
                      "name": "my_action",
                      "status": "connected",
                      "type": "timescale",
                      "enable": true,
                      "connector": "my_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 16,
                        "max_buffer_bytes": "256MB",
                        "batch_time": "50ms",
                        "inflight_window": 100,
                        "request_ttl": "45s"
                      },
                      "parameters": {
                        "sql": "INSERT INTO client_events(clientid, event, created_at)VALUES (\n  ${clientid},\n  ${event},\n  TO_TIMESTAMP((${timestamp} :: bigint))\n)"
                      }
                    },
                    "summary": "Timescale Action"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/bridge_timescale.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mongodb.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/gcp_pubsub_producer.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_elasticsearch.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/action_azure_blob_storage.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/syskeeper.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/pulsar.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/rocketmq.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_matrix.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_sqlserver.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_influxdb.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_clickhouse.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_cassa.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_hstreamdb.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_oracle.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_opents.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_greptimedb.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_s3.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_tdengine.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_dynamo.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/redis.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_rabbitmq.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mqtt_publisher.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mysql.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_pgsql.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_kinesis.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_kafka.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_azure_event_hub.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_datalayers.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/action_couchbase.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_iotdb.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/confluent.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_http.get_bridge_v2"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "ALREADY_EXISTS"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bridge already exists"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "http": {
                  "value": {
                    "name": "my_http_action",
                    "type": "http",
                    "enable": true,
                    "parameters": {
                      "path": "/room/${room_no}",
                      "body": "${.}",
                      "headers": {},
                      "method": "post"
                    },
                    "connector": "my_http_connector",
                    "resource_opts": {
                      "worker_pool_size": 16,
                      "query_mode": "async",
                      "health_check_interval": "15s"
                    }
                  },
                  "summary": "HTTP Action"
                },
                "confluent_producer": {
                  "value": {
                    "name": "my_confluent_producer_action",
                    "type": "confluent_producer",
                    "enable": true,
                    "parameters": {
                      "message": {
                        "value": "${.}",
                        "key": "${.clientid}"
                      },
                      "buffer": {
                        "mode": "hybrid",
                        "memory_overload_protection": true,
                        "segment_bytes": "100MB",
                        "per_partition_limit": "2GB"
                      },
                      "topic": "topic",
                      "max_inflight": 10,
                      "required_acks": "all_isr",
                      "max_batch_bytes": "896KB",
                      "partition_count_refresh_interval": "60s",
                      "kafka_header_value_encode_mode": "none",
                      "kafka_ext_headers": [
                        {
                          "kafka_ext_header_value": "${clientid}",
                          "kafka_ext_header_key": "clientid"
                        },
                        {
                          "kafka_ext_header_value": "${topic}",
                          "kafka_ext_header_key": "topic"
                        }
                      ],
                      "kafka_headers": "${.pub_props}",
                      "partition_strategy": "random"
                    },
                    "connector": "my_confluent_producer_connector",
                    "local_topic": "mqtt/local/topic"
                  },
                  "summary": "Confluent Action"
                },
                "iotdb": {
                  "value": {
                    "name": "iotdb_action",
                    "type": "iotdb",
                    "description": "My example iotdb action",
                    "enable": true,
                    "parameters": {
                      "data": [
                        {
                          "timestamp": "now",
                          "value": "${st}",
                          "data_type": "BOOLEAN",
                          "measurement": "status"
                        }
                      ],
                      "device_id": "my_device",
                      "is_aligned": false
                    },
                    "connector": "iotdb_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "Apache IoTDB Bridge"
                },
                "direct_azure_blob_storage": {
                  "value": {
                    "name": "my_action",
                    "type": "azure_blob_storage",
                    "description": "my action",
                    "enable": true,
                    "parameters": {
                      "mode": "direct",
                      "content": "${.payload}",
                      "blob": "${.payload.blob}",
                      "container": "${.payload.container}"
                    },
                    "connector": "my_connector",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 16,
                      "query_mode": "sync",
                      "batch_time": "0ms",
                      "inflight_window": 100,
                      "request_ttl": "45s",
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "Azure Blob Storage Direct Upload Action"
                },
                "couchbase": {
                  "value": {
                    "name": "my_action",
                    "type": "couchbase",
                    "description": "my action",
                    "enable": true,
                    "parameters": {
                      "sql": "insert into mqtt (key, value) values (${.id}, ${.payload})"
                    },
                    "connector": "my_connector",
                    "resource_opts": {
                      "worker_pool_size": 16,
                      "query_mode": "sync",
                      "inflight_window": 100,
                      "request_ttl": "45s",
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "Couchbase Action"
                },
                "datalayers": {
                  "value": {
                    "name": "datalayers_action",
                    "type": "datalayers",
                    "description": "My example datalayers action",
                    "enable": true,
                    "parameters": {
                      "precision": "ms",
                      "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,bool=${payload.bool}"
                    },
                    "connector": "datalayers_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "Datalayers Action"
                },
                "azure_event_hub_producer": {
                  "value": {
                    "name": "my_azure_event_hub_producer_action",
                    "type": "azure_event_hub_producer",
                    "enable": true,
                    "parameters": {
                      "message": {
                        "value": "${.}",
                        "key": "${.clientid}"
                      },
                      "buffer": {
                        "mode": "hybrid",
                        "memory_overload_protection": true,
                        "segment_bytes": "100MB",
                        "per_partition_limit": "2GB"
                      },
                      "topic": "topic",
                      "max_inflight": 10,
                      "required_acks": "all_isr",
                      "max_batch_bytes": "896KB",
                      "partition_count_refresh_interval": "60s",
                      "kafka_header_value_encode_mode": "none",
                      "kafka_ext_headers": [
                        {
                          "kafka_ext_header_value": "${clientid}",
                          "kafka_ext_header_key": "clientid"
                        },
                        {
                          "kafka_ext_header_value": "${topic}",
                          "kafka_ext_header_key": "topic"
                        }
                      ],
                      "kafka_headers": "${.pub_props}",
                      "partition_strategy": "random"
                    },
                    "connector": "my_azure_event_hub_producer_connector",
                    "local_topic": "mqtt/local/topic"
                  },
                  "summary": "Azure Event Hub Action"
                },
                "kafka_producer": {
                  "value": {
                    "name": "my_kafka_producer_action",
                    "type": "kafka_producer",
                    "enable": true,
                    "parameters": {
                      "message": {
                        "timestamp": "${.timestamp}",
                        "value": "${.}",
                        "key": "${.clientid}"
                      },
                      "buffer": {
                        "mode": "hybrid",
                        "memory_overload_protection": true,
                        "segment_bytes": "100MB",
                        "per_partition_limit": "2GB"
                      },
                      "compression": "no_compression",
                      "topic": "kafka-topic",
                      "max_inflight": 10,
                      "required_acks": "all_isr",
                      "max_batch_bytes": "896KB",
                      "partitions_limit": "all_partitions",
                      "partition_count_refresh_interval": "60s",
                      "kafka_header_value_encode_mode": "none",
                      "kafka_ext_headers": [
                        {
                          "kafka_ext_header_value": "${clientid}",
                          "kafka_ext_header_key": "clientid"
                        },
                        {
                          "kafka_ext_header_value": "${topic}",
                          "kafka_ext_header_key": "topic"
                        }
                      ],
                      "kafka_headers": "${pub_props}",
                      "partition_strategy": "random"
                    },
                    "connector": "my_kafka_producer_connector",
                    "resource_opts": {
                      "health_check_interval": "32s"
                    },
                    "local_topic": "mqtt/local/topic"
                  },
                  "summary": "Kafka Producer Action"
                },
                "kinesis": {
                  "value": {
                    "name": "kinesis_action",
                    "type": "kinesis",
                    "description": "My example kinesis action",
                    "enable": true,
                    "parameters": {
                      "partition_key": "any_key",
                      "payload_template": "${.}",
                      "stream_name": "my_stream"
                    },
                    "connector": "kinesis_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "Kinesis Action"
                },
                "pgsql": {
                  "value": {
                    "name": "my_action",
                    "type": "pgsql",
                    "enable": true,
                    "connector": "my_connector",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 16,
                      "max_buffer_bytes": "256MB",
                      "batch_time": "50ms",
                      "inflight_window": 100,
                      "request_ttl": "45s"
                    },
                    "parameters": {
                      "sql": "INSERT INTO client_events(clientid, event, created_at)VALUES (\n  ${clientid},\n  ${event},\n  TO_TIMESTAMP((${timestamp} :: bigint))\n)"
                    }
                  },
                  "summary": "PostgreSQL Action"
                },
                "mysql": {
                  "value": {
                    "name": "mysql_action",
                    "type": "mysql",
                    "description": "My example mysql action",
                    "enable": true,
                    "parameters": {
                      "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, FROM_UNIXTIME(${timestamp}/1000))"
                    },
                    "connector": "mysql_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "MySQL Action"
                },
                "mqtt": {
                  "value": {
                    "name": "mqtt_action",
                    "type": "mqtt",
                    "description": "My example mqtt action",
                    "enable": true,
                    "parameters": {
                      "retain": false,
                      "payload": "${.payload}",
                      "topic": "remote/topic",
                      "qos": 2
                    },
                    "connector": "mqtt_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "MQTT Producer Action"
                },
                "rabbitmq": {
                  "value": {
                    "name": "rabbitmq_action",
                    "type": "rabbitmq",
                    "description": "My example rabbitmq action",
                    "enable": true,
                    "parameters": {
                      "exchange": "test_exchange",
                      "payload_template": "${.payload}",
                      "routing_key": "/",
                      "wait_for_publish_confirmations": true,
                      "delivery_mode": "non_persistent",
                      "publish_confirmation_timeout": "30s"
                    },
                    "connector": "rabbitmq_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "RabbitMQ Producer Action"
                },
                "redis": {
                  "value": {
                    "name": "my_action",
                    "type": "redis",
                    "description": "My action",
                    "enable": true,
                    "parameters": {
                      "command_template": [
                        "LPUSH",
                        "MSGS",
                        "${payload}"
                      ]
                    },
                    "connector": "my_connector_name",
                    "resource_opts": {
                      "batch_size": 1
                    }
                  },
                  "summary": "Redis Action"
                },
                "dynamo": {
                  "value": {
                    "name": "dynamo_action",
                    "type": "dynamo",
                    "description": "My example dynamo action",
                    "enable": true,
                    "connector": "dynamo_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    },
                    "parameters": {
                      "hash_key": "clientid",
                      "table": "mqtt_msg",
                      "template": ""
                    }
                  },
                  "summary": "DynamoDB Action"
                },
                "tdengine": {
                  "value": {
                    "name": "tdengine_action",
                    "type": "tdengine",
                    "description": "My example tdengine action",
                    "enable": true,
                    "parameters": {
                      "database": "mqtt",
                      "sql": "insert into t_mqtt_msg(ts, msgid, mqtt_topic, qos, payload, arrived) values (${ts}, '${id}', '${topic}', ${qos}, '${payload}', ${timestamp})"
                    },
                    "connector": "tdengine_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "TDengine Action"
                },
                "s3": {
                  "value": {
                    "name": "my_s3_action",
                    "type": "s3",
                    "description": "My upload action",
                    "enable": true,
                    "parameters": {
                      "mode": "direct",
                      "key": "${topic}",
                      "content": "${payload}",
                      "bucket": "${clientid}",
                      "acl": "public_read"
                    },
                    "connector": "my_s3_connector",
                    "resource_opts": {
                      "query_mode": "sync",
                      "inflight_window": 10
                    }
                  },
                  "summary": "S3 Direct Upload"
                },
                "greptimedb": {
                  "value": {
                    "name": "greptimedb_action",
                    "type": "greptimedb",
                    "description": "My example greptimedb action",
                    "enable": true,
                    "parameters": {
                      "precision": "ms",
                      "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,uint_value=${payload.uint_key}u,bool=${payload.bool}"
                    },
                    "connector": "greptimedb_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "GreptimeDB Action"
                },
                "opents": {
                  "value": {
                    "name": "opents_action",
                    "type": "opents",
                    "description": "My example opents action",
                    "enable": true,
                    "parameters": {
                      "data": [
                        {
                          "value": "${value}",
                          "tags": "${tags}",
                          "metric": "${metric}"
                        }
                      ]
                    },
                    "connector": "opents_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "OpenTSDB Action"
                },
                "oracle": {
                  "value": {
                    "name": "oracle_action",
                    "type": "oracle",
                    "description": "My example oracle action",
                    "enable": true,
                    "parameters": {
                      "sql": "insert into t_mqtt_msgs(msgid, topic, qos, payload) values (${id}, ${topic}, ${qos}, ${payload})"
                    },
                    "connector": "oracle_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "Oracle Action"
                },
                "hstreamdb": {
                  "value": {
                    "name": "hstreamdb_action",
                    "type": "hstreamdb",
                    "description": "My example hstreamdb action",
                    "enable": true,
                    "connector": "hstreamdb_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    },
                    "parameters": {
                      "aggregation_pool_size": 8,
                      "partition_key": "hej",
                      "record_template": "${payload}",
                      "stream": "mqtt_message",
                      "writer_pool_size": 8
                    }
                  },
                  "summary": "HStreamDB Action"
                },
                "cassandra": {
                  "value": {
                    "name": "cassandra_action",
                    "type": "cassandra",
                    "description": "My example cassandra action",
                    "enable": true,
                    "parameters": {
                      "cql": "insert into mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic},  ${qos}, ${payload}, ${timestamp})"
                    },
                    "connector": "cassandra_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "Cassandra Action"
                },
                "clickhouse": {
                  "value": {
                    "name": "clickhouse_action",
                    "type": "clickhouse",
                    "description": "My example clickhouse action",
                    "enable": true,
                    "parameters": {
                      "sql": "INSERT INTO messages(data, arrived) VALUES ('${payload}', ${timestamp})",
                      "batch_value_separator": ", "
                    },
                    "connector": "clickhouse_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "ClickHouse Action"
                },
                "influxdb": {
                  "value": {
                    "name": "influxdb_action",
                    "type": "influxdb",
                    "description": "My example influxdb action",
                    "enable": true,
                    "parameters": {
                      "precision": "ms",
                      "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,bool=${payload.bool}"
                    },
                    "connector": "influxdb_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "InfluxDB Action"
                },
                "sqlserver": {
                  "value": {
                    "name": "sqlserver_action",
                    "type": "sqlserver",
                    "description": "My example sqlserver action",
                    "enable": true,
                    "connector": "sqlserver_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    },
                    "parameters": {
                      "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload) values ( ${id}, ${topic}, ${qos}, ${payload} )"
                    }
                  },
                  "summary": "Microsoft SQL Server Action"
                },
                "matrix": {
                  "value": {
                    "name": "my_action",
                    "type": "matrix",
                    "enable": true,
                    "connector": "my_connector",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 16,
                      "max_buffer_bytes": "256MB",
                      "batch_time": "50ms",
                      "inflight_window": 100,
                      "request_ttl": "45s"
                    },
                    "parameters": {
                      "sql": "INSERT INTO client_events(clientid, event, created_at)VALUES (\n  ${clientid},\n  ${event},\n  TO_TIMESTAMP((${timestamp} :: bigint))\n)"
                    }
                  },
                  "summary": "Matrix Action"
                },
                "aggregated_azure_blob_storage": {
                  "value": {
                    "name": "my_action",
                    "type": "azure_blob_storage",
                    "description": "my action",
                    "enable": true,
                    "parameters": {
                      "mode": "aggregated",
                      "blob": "${action}/${node}/${datetime.rfc3339}/${sequence}",
                      "container": "mycontainer",
                      "aggregation": {
                        "container": {
                          "type": "csv",
                          "column_order": [
                            "a",
                            "b"
                          ]
                        },
                        "max_records": 10000,
                        "time_interval": "4s"
                      }
                    },
                    "connector": "my_connector",
                    "resource_opts": {
                      "batch_size": 100,
                      "worker_pool_size": 16,
                      "query_mode": "sync",
                      "batch_time": "10ms",
                      "inflight_window": 100,
                      "request_ttl": "45s",
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "Azure Blob Storage Aggregated Upload Action"
                },
                "rocketmq": {
                  "value": {
                    "name": "rocketmq_action",
                    "type": "rocketmq",
                    "description": "My example rocketmq action",
                    "enable": true,
                    "connector": "rocketmq_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    },
                    "parameters": {
                      "refresh_interval": "3s",
                      "send_buffer": "1024KB",
                      "sync_timeout": "3s",
                      "template": "",
                      "topic": "TopicTest"
                    }
                  },
                  "summary": "RocketMQ Action"
                },
                "pulsar": {
                  "value": {
                    "name": "pulsar_action",
                    "type": "pulsar",
                    "description": "My example pulsar action",
                    "enable": true,
                    "parameters": {
                      "message": {
                        "value": "${.}",
                        "key": "${.clientid}"
                      },
                      "sync_timeout": "5s",
                      "pulsar_topic": "test_topic"
                    },
                    "connector": "pulsar_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "Pulsar Producer Action"
                },
                "syskeeper_forwarder": {
                  "value": {
                    "name": "syskeeper_forwarder",
                    "type": "syskeeper_forwarder",
                    "enable": true,
                    "parameters": {
                      "template": "${payload}",
                      "target_topic": "${topic}"
                    },
                    "connector": "syskeeper_forwarder",
                    "resource_opts": {
                      "worker_pool_size": 16
                    }
                  },
                  "summary": "Syskeeper Forwarder Bridge"
                },
                "s3_aggreg": {
                  "value": {
                    "name": "my_s3_action",
                    "type": "s3",
                    "description": "My aggregated upload action",
                    "enable": true,
                    "parameters": {
                      "mode": "aggregated",
                      "key": "${action}/${node}/${datetime.rfc3339utc}_N${sequence}.csv",
                      "bucket": "mqtt-aggregated",
                      "acl": "public_read",
                      "aggregation": {
                        "max_records": 100000,
                        "time_interval": "15m"
                      },
                      "container": {
                        "type": "csv",
                        "column_order": [
                          "clientid",
                          "topic",
                          "publish_received_at"
                        ]
                      }
                    },
                    "connector": "my_s3_connector",
                    "resource_opts": {
                      "query_mode": "async",
                      "inflight_window": 100,
                      "health_check_interval": "10s"
                    }
                  },
                  "summary": "S3 Aggregated Upload"
                },
                "elasticsearch": {
                  "value": {
                    "name": "elasticsearch_action",
                    "type": "elasticsearch",
                    "description": "My example elasticsearch action",
                    "enable": true,
                    "parameters": {
                      "index": "${payload.index}",
                      "action": "create",
                      "doc": "${payload.doc}",
                      "overwrite": true
                    },
                    "connector": "elasticsearch_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "Elastic Search Bridge"
                },
                "gcp_pubsub_producer": {
                  "value": {
                    "name": "my_action",
                    "type": "gcp_pubsub_producer",
                    "description": "My action",
                    "enable": true,
                    "parameters": {
                      "payload_template": "${payload}",
                      "pubsub_topic": "mytopic",
                      "ordering_key_template": "${payload.ok}",
                      "attributes_template": [
                        {
                          "value": "${payload.attrs.v}",
                          "key": "${payload.attrs.k}"
                        }
                      ]
                    },
                    "connector": "my_connector_name",
                    "resource_opts": {
                      "batch_size": 5
                    },
                    "local_topic": "local/topic"
                  },
                  "summary": "GCP PubSub Producer Action"
                },
                "mongodb": {
                  "value": {
                    "name": "mongodb_action",
                    "type": "mongodb",
                    "description": "My example mongodb action",
                    "enable": true,
                    "parameters": {
                      "collection": "mycol"
                    },
                    "connector": "mongodb_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "MongoDB Action"
                },
                "timescale": {
                  "value": {
                    "name": "my_action",
                    "type": "timescale",
                    "enable": true,
                    "connector": "my_connector",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 16,
                      "max_buffer_bytes": "256MB",
                      "batch_time": "50ms",
                      "inflight_window": 100,
                      "request_ttl": "45s"
                    },
                    "parameters": {
                      "sql": "INSERT INTO client_events(clientid, event, created_at)VALUES (\n  ${clientid},\n  ${event},\n  TO_TIMESTAMP((${timestamp} :: bigint))\n)"
                    }
                  },
                  "summary": "Timescale Action"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/bridge_timescale.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mongodb.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/gcp_pubsub_producer.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_elasticsearch.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/action_azure_blob_storage.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/syskeeper.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/pulsar.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/rocketmq.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_matrix.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_sqlserver.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_influxdb.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_clickhouse.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_cassa.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_hstreamdb.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_oracle.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_opents.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_greptimedb.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_s3.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_tdengine.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_dynamo.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/redis.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_rabbitmq.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mqtt_publisher.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mysql.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_pgsql.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_kinesis.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_kafka.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_azure_event_hub.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_datalayers.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/action_couchbase.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_iotdb.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/confluent.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_http.post_bridge_v2"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/nodes/{node}": {
      "get": {
        "description": "Get node info",
        "tags": [
          "Nodes"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_mgmt_api_nodes.node_name"
          }
        ],
        "responses": {
          "200": {
            "description": "Get node info successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_nodes.node_info"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Node not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/ds/storages/{ds}/replicas/{site}": {
      "put": {
        "description": "Add site as a replica for the durable storage",
        "tags": [
          "Durable storage"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "ds",
            "description": "Durable storage ID",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "messages"
              ]
            },
            "example": "messages"
          },
          {
            "in": "path",
            "name": "site",
            "description": "Site ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "F9967F15E94B8C70"
          }
        ],
        "responses": {
          "202": {
            "description": "OK"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Object not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Remove site as a replica for the durable storage",
        "tags": [
          "Durable storage"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "ds",
            "description": "Durable storage ID",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "messages"
              ]
            },
            "example": "messages"
          },
          {
            "in": "path",
            "name": "site",
            "description": "Site ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "F9967F15E94B8C70"
          }
        ],
        "responses": {
          "202": {
            "description": "OK"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Object not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/mqtt/delayed/messages/{topic}": {
      "delete": {
        "description": "Delete delayed message",
        "tags": [
          "MQTT"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "topic",
            "description": "Topic",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Delete delayed message success"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "INVALID_TOPIC_NAME"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Topic Name"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "MESSAGE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not found delayed message for this topic"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/coap/clients/{clientid}/request": {
      "post": {
        "description": "Send a CoAP request message to the client",
        "tags": [
          "CoAP Gateways"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "summary": "Send a Request to a Client",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "id": {
                      "type": "integer",
                      "description": "Message ID"
                    },
                    "token": {
                      "type": "string",
                      "description": "Message token, can be empty"
                    },
                    "method": {
                      "type": "string",
                      "description": "Response code"
                    },
                    "payload": {
                      "type": "string",
                      "description": "The content of the payload"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "CLIENT_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Client not found error"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "504": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "CLIENT_NOT_RESPONSE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Waiting for client response timeout"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "token": {
                    "type": "string",
                    "description": "Message token, can be empty"
                  },
                  "method": {
                    "type": "string",
                    "enum": [
                      "get",
                      "put",
                      "post",
                      "delete"
                    ],
                    "description": "Request method type"
                  },
                  "timeout": {
                    "type": "string",
                    "description": "Timespan for response",
                    "example": "32s"
                  },
                  "content_type": {
                    "type": "string",
                    "enum": [
                      "text/plain",
                      "application/json",
                      "application/octet-stream"
                    ],
                    "description": "Payload type"
                  },
                  "payload": {
                    "type": "string",
                    "description": "The content of the payload"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/listeners/{id}/stop": {
      "post": {
        "description": "Stop the listener on all nodes.",
        "tags": [
          "Listeners"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/listeners.listener_id"
          }
        ],
        "responses": {
          "200": {
            "description": "Updated"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST",
                        "BAD_LISTENER_ID"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/topics": {
      "get": {
        "description": "Topics list",
        "tags": [
          "Topics"
        ],
        "parameters": [
          {
            "in": "query",
            "name": "topic",
            "description": "Topic Name",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": ""
          },
          {
            "in": "query",
            "name": "node",
            "description": "Node Name",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "emqx@127.0.0.1"
          },
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "data": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/emqx_mgmt_api_topics.topic"
                      }
                    },
                    "meta": {
                      "$ref": "#/components/schemas/public.meta"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/cluster/{node}/invite_async": {
      "put": {
        "description": "Send a join invitation to a node to join the cluster but do not wait for the join result. Join status can be retrieved with `GET api/<version>/invitation`",
        "tags": [
          "Cluster"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/cluster.node"
          }
        ],
        "responses": {
          "200": {
            "description": "ok"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/load_rebalance/{node}/start": {
      "post": {
        "description": "Start rebalance process",
        "tags": [
          "Load Rebalance"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "node",
            "description": "Node name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "summary": "Start rebalancing with the node as coordinator",
        "responses": {
          "200": {
            "description": "The response is empty",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "example": {}
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "rebalance": {
                  "nodes": [
                    "othernode@127.0.0.1"
                  ],
                  "wait_takeover": "10s",
                  "sess_evict_rate": 20,
                  "conn_evict_rate": 10,
                  "wait_health_check": "10s",
                  "rel_sess_threshold": 1.5,
                  "rel_conn_threshold": 1.5,
                  "abs_sess_threshold": 10,
                  "abs_conn_threshold": 10
                }
              },
              "schema": {
                "$ref": "#/components/schemas/load_rebalance.rebalance_start"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/authorization/sources": {
      "get": {
        "description": "List all authorization sources",
        "tags": [
          "Authorization"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_authz_api_sources.sources"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Add a new source",
        "tags": [
          "Authorization"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": "Authorization source created successfully"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/authz.ldap"
                  },
                  {
                    "$ref": "#/components/schemas/authz.mongo_sharded"
                  },
                  {
                    "$ref": "#/components/schemas/authz.mongo_rs"
                  },
                  {
                    "$ref": "#/components/schemas/authz.mongo_single"
                  },
                  {
                    "$ref": "#/components/schemas/authz.postgresql"
                  },
                  {
                    "$ref": "#/components/schemas/authz.mysql"
                  },
                  {
                    "$ref": "#/components/schemas/authz.redis_cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authz.redis_sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/authz.redis_single"
                  },
                  {
                    "$ref": "#/components/schemas/authz.http_post"
                  },
                  {
                    "$ref": "#/components/schemas/authz.http_get"
                  },
                  {
                    "$ref": "#/components/schemas/authz.builtin_db"
                  },
                  {
                    "$ref": "#/components/schemas/authz.api_file"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/plugins": {
      "get": {
        "description": "Plugins are launched in top-down order.<br/>Use `POST /plugins/{name}/move` to change the boot order.",
        "tags": [
          "Plugins"
        ],
        "parameters": [],
        "summary": "List all installed plugins",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/plugins.plugin"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/message_transformations/reorder": {
      "post": {
        "description": "Reorder of all transformations",
        "tags": [
          "Message Transformation"
        ],
        "parameters": [],
        "summary": "Reorder all transformations",
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "not_found": {
                      "type": "array",
                      "description": "Transformations not found",
                      "items": {
                        "type": "string"
                      }
                    },
                    "not_reordered": {
                      "type": "array",
                      "description": "Transformations not referenced in input",
                      "items": {
                        "type": "string"
                      }
                    },
                    "duplicated": {
                      "type": "array",
                      "description": "Duplicated transformations in input",
                      "items": {
                        "type": "string"
                      }
                    },
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "reorder": {
                  "value": {
                    "order": [
                      "bar",
                      "foo",
                      "baz"
                    ]
                  },
                  "summary": "Update"
                }
              },
              "schema": {
                "$ref": "#/components/schemas/message_transformation_http_api.reorder"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/login": {
      "post": {
        "description": "Get Dashboard Auth Token.",
        "tags": [
          "Dashboard"
        ],
        "parameters": [],
        "summary": "Dashboard authentication",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "role": {
                      "default": "administrator",
                      "type": "string",
                      "description": "User role",
                      "example": "administrator"
                    },
                    "token": {
                      "type": "string",
                      "description": "Dashboard Auth Token"
                    },
                    "version": {
                      "type": "string",
                      "description": "EMQX Version",
                      "example": "5.0.0"
                    },
                    "license": {
                      "properties": {
                        "edition": {
                          "type": "string",
                          "enum": [
                            "opensource",
                            "enterprise"
                          ],
                          "description": "EMQX License. opensource or enterprise",
                          "example": "opensource"
                        }
                      },
                      "type": "object"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "401": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_USERNAME_OR_PWD"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Login failed. Bad username or password"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "username": {
                    "type": "string",
                    "description": "Dashboard Username",
                    "maxLength": 100,
                    "example": "admin"
                  },
                  "password": {
                    "type": "string",
                    "description": "Dashboard Password",
                    "maxLength": 100,
                    "example": "public"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "security": []
      }
    },
    "/bridges/{id}": {
      "get": {
        "description": "Get a bridge by Id",
        "tags": [
          "Bridges"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge Id. Must be of format {type}:{name}",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:http_example"
          }
        ],
        "summary": "Get bridge",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "influxdb_api_v2": {
                    "value": {
                      "name": "demo",
                      "type": "influxdb_api_v2",
                      "ssl": {
                        "enable": false
                      },
                      "server": "127.0.0.1:8086",
                      "enable": true,
                      "precision": "ms",
                      "org": "examlpe_org",
                      "token": "example_token",
                      "bucket": "example_bucket",
                      "resource_opts": {
                        "batch_size": 100,
                        "batch_time": "20ms"
                      },
                      "local_topic": "local/topic/#",
                      "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,uint_value=${payload.uint_key}u,bool=${payload.bool}",
                      "influxdb_type": "influxdb_api_v2"
                    },
                    "summary": "InfluxDB HTTP API V2 Bridge"
                  },
                  "iotdb": {
                    "value": {
                      "name": "My IoTDB Bridge",
                      "type": "iotdb",
                      "ssl": {
                        "enable": false
                      },
                      "authentication": {
                        "password": "*****",
                        "username": "root"
                      },
                      "connect_timeout": "15s",
                      "pool_size": 8,
                      "enable": true,
                      "base_url": "http://iotdb.local:18080/",
                      "pool_type": "random",
                      "resource_opts": {
                        "worker_pool_size": 8,
                        "query_mode": "async",
                        "max_buffer_bytes": 268435456,
                        "health_check_interval": "15s"
                      },
                      "enable_pipelining": 100,
                      "iotdb_version": "v1.1.x",
                      "device_id": "my_device",
                      "is_aligned": false
                    },
                    "summary": "Apache IoTDB Bridge"
                  },
                  "azure_event_hub_producer": {
                    "value": {
                      "name": "my_azure_event_hub_producer",
                      "status": "connected",
                      "type": "azure_event_hub_producer",
                      "authentication": {
                        "password": "******"
                      },
                      "connect_timeout": "5s",
                      "enable": true,
                      "parameters": {
                        "message": {
                          "value": "${.}",
                          "key": "${.clientid}"
                        },
                        "buffer": {
                          "mode": "hybrid",
                          "memory_overload_protection": true,
                          "segment_bytes": "100MB",
                          "per_partition_limit": "2GB"
                        },
                        "topic": "topic",
                        "max_inflight": 10,
                        "required_acks": "all_isr",
                        "max_batch_bytes": "896KB",
                        "partition_count_refresh_interval": "60s",
                        "kafka_header_value_encode_mode": "none",
                        "kafka_ext_headers": [
                          {
                            "kafka_ext_header_value": "${clientid}",
                            "kafka_ext_header_key": "clientid"
                          },
                          {
                            "kafka_ext_header_value": "${topic}",
                            "kafka_ext_header_key": "topic"
                          }
                        ],
                        "kafka_headers": "${.pub_props}",
                        "partition_strategy": "random"
                      },
                      "socket_opts": {
                        "nodelay": true,
                        "recbuf": "1024KB",
                        "sndbuf": "1024KB",
                        "tcp_keepalive": "none"
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "local_topic": "mqtt/local/topic",
                      "min_metadata_refresh_interval": "3s",
                      "bootstrap_hosts": "namespace.servicebus.windows.net:9093",
                      "metadata_request_timeout": "4s"
                    },
                    "summary": "Azure Event Hub Producer Bridge"
                  },
                  "kafka_producer": {
                    "value": {
                      "name": "my_kafka_producer_action",
                      "status": "connected",
                      "type": "kafka_producer",
                      "authentication": {
                        "mechanism": "plain",
                        "password": "******",
                        "username": "username"
                      },
                      "connect_timeout": "5s",
                      "enable": true,
                      "socket_opts": {
                        "nodelay": true,
                        "recbuf": "1024KB",
                        "sndbuf": "1024KB",
                        "tcp_keepalive": "none"
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "local_topic": "mqtt/local/topic",
                      "kafka": {
                        "message": {
                          "timestamp": "${.timestamp}",
                          "value": "${.}",
                          "key": "${.clientid}"
                        },
                        "buffer": {
                          "mode": "hybrid",
                          "memory_overload_protection": true,
                          "segment_bytes": "100MB",
                          "per_partition_limit": "2GB"
                        },
                        "compression": "no_compression",
                        "topic": "kafka-topic",
                        "max_inflight": 10,
                        "required_acks": "all_isr",
                        "max_batch_bytes": "896KB",
                        "partitions_limit": "all_partitions",
                        "partition_count_refresh_interval": "60s",
                        "kafka_header_value_encode_mode": "none",
                        "kafka_ext_headers": [
                          {
                            "kafka_ext_header_value": "${clientid}",
                            "kafka_ext_header_key": "clientid"
                          },
                          {
                            "kafka_ext_header_value": "${topic}",
                            "kafka_ext_header_key": "topic"
                          }
                        ],
                        "kafka_headers": "${pub_props}",
                        "partition_strategy": "random"
                      },
                      "min_metadata_refresh_interval": "3s",
                      "bootstrap_hosts": "localhost:9092",
                      "metadata_request_timeout": "4s"
                    },
                    "summary": "Kafka Producer Bridge"
                  },
                  "redis_sentinel": {
                    "value": {
                      "name": "redis_bridge",
                      "type": "redis_sentinel",
                      "ssl": {
                        "enable": false
                      },
                      "pool_size": 8,
                      "enable": true,
                      "password": "******",
                      "database": 1,
                      "servers": [
                        "127.0.0.1:26379"
                      ],
                      "resource_opts": {
                        "batch_size": 1,
                        "batch_time": "20ms"
                      },
                      "sentinel": "mymaster",
                      "redis_type": "sentinel",
                      "local_topic": "local/topic/#",
                      "command_template": [
                        "LPUSH",
                        "MSGS",
                        "${payload}"
                      ]
                    },
                    "summary": "Redis Sentinel Bridge"
                  },
                  "pulsar_producer": {
                    "value": {
                      "authentication": "none",
                      "batch_size": 1,
                      "buffer": {
                        "memory_overload_protection": true,
                        "mode": "memory",
                        "per_partition_limit": "10MB",
                        "segment_bytes": "5MB"
                      },
                      "compression": "no_compression",
                      "enable": true,
                      "local_topic": "mqtt/topic/-576460752303423482",
                      "max_batch_bytes": "900KB",
                      "message": {
                        "key": "${.clientid}",
                        "value": "${.}"
                      },
                      "name": "pulsar_example_name",
                      "pulsar_topic": "pulsar_example_topic",
                      "retention_period": "infinity",
                      "send_buffer": "1MB",
                      "servers": "pulsar://127.0.0.1:6650",
                      "ssl": {
                        "enable": false,
                        "server_name_indication": "auto",
                        "verify": "verify_none"
                      },
                      "strategy": "key_dispatch",
                      "sync_timeout": "5s",
                      "type": "pulsar_producer"
                    },
                    "summary": "Pulsar Producer Bridge"
                  },
                  "pgsql": {
                    "value": {
                      "name": "foo",
                      "status": "connected",
                      "type": "pgsql",
                      "pool_size": 8,
                      "server": "127.0.0.1:5432",
                      "enable": true,
                      "password": "******",
                      "username": "root",
                      "database": "mqtt",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 8,
                        "query_mode": "async",
                        "max_buffer_bytes": 268435456,
                        "batch_time": 0,
                        "health_check_interval": "15s"
                      },
                      "local_topic": "local/topic/#"
                    },
                    "summary": "PostgreSQL Bridge"
                  },
                  "redis_cluster": {
                    "value": {
                      "name": "redis_bridge",
                      "type": "redis_cluster",
                      "ssl": {
                        "enable": false
                      },
                      "pool_size": 8,
                      "enable": true,
                      "password": "******",
                      "servers": [
                        "127.0.0.1:6379"
                      ],
                      "resource_opts": {},
                      "redis_type": "cluster",
                      "local_topic": "local/topic/#",
                      "command_template": [
                        "LPUSH",
                        "MSGS",
                        "${payload}"
                      ]
                    },
                    "summary": "Redis Cluster Bridge"
                  },
                  "mysql": {
                    "value": {
                      "name": "foo",
                      "type": "mysql",
                      "pool_size": 8,
                      "server": "127.0.0.1:3306",
                      "enable": true,
                      "password": "******",
                      "username": "root",
                      "database": "test",
                      "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, FROM_UNIXTIME(${timestamp}/1000))",
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 1,
                        "query_mode": "async",
                        "max_buffer_bytes": 268435456,
                        "batch_time": 0,
                        "health_check_interval": "15s"
                      },
                      "local_topic": "local/topic/#"
                    },
                    "summary": "MySQL Bridge"
                  },
                  "kinesis_producer": {
                    "value": {
                      "name": "foo",
                      "type": "kinesis_producer",
                      "enable": true,
                      "max_retries": 3,
                      "aws_secret_access_key": "******",
                      "resource_opts": {
                        "worker_pool_size": 1,
                        "query_mode": "async",
                        "max_buffer_bytes": 104857600,
                        "inflight_window": 100,
                        "health_check_interval": 15000
                      },
                      "endpoint": "https://kinesis.us-east-1.amazonaws.com",
                      "partition_key": "key",
                      "aws_access_key_id": "aws_access_key_id",
                      "stream_name": "stream_name"
                    },
                    "summary": "Amazon Kinesis Producer Bridge"
                  },
                  "http_example": {
                    "value": {
                      "name": "http_example",
                      "type": "http",
                      "ssl": {
                        "enable": false
                      },
                      "connect_timeout": "15s",
                      "pool_size": 4,
                      "enable": true,
                      "body": "${payload}",
                      "url": "http://localhost:9901/messages/${topic}",
                      "method": "post",
                      "max_retries": 3,
                      "request_timeout": "15s",
                      "pool_type": "random",
                      "resource_opts": {
                        "worker_pool_size": 1,
                        "query_mode": "async",
                        "max_buffer_bytes": 104857600,
                        "inflight_window": 100,
                        "health_check_interval": 15000
                      },
                      "enable_pipelining": 100,
                      "local_topic": "emqx_http/#"
                    },
                    "summary": "HTTP"
                  },
                  "rabbitmq": {
                    "value": {
                      "timeout": 5,
                      "name": "foo",
                      "port": 5672,
                      "type": "rabbitmq",
                      "exchange": "messages",
                      "pool_size": 8,
                      "server": "localhost",
                      "enable": true,
                      "password": "******",
                      "username": "guest",
                      "heartbeat": "30s",
                      "durable": false,
                      "auto_reconnect": "2s",
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 8,
                        "query_mode": "async",
                        "max_buffer_bytes": 268435456,
                        "batch_time": 0,
                        "health_check_interval": "15s"
                      },
                      "payload_template": "",
                      "routing_key": "my_routing_key",
                      "virtual_host": "/",
                      "exchange_type": "topic"
                    },
                    "summary": "RabbitMQ Bridge"
                  },
                  "dynamo": {
                    "value": {
                      "name": "foo",
                      "table": "mqtt",
                      "type": "dynamo",
                      "pool_size": 8,
                      "template": "",
                      "enable": true,
                      "url": "http://127.0.0.1:8000",
                      "aws_secret_access_key": "******",
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 8,
                        "query_mode": "sync",
                        "max_buffer_bytes": 268435456,
                        "batch_time": 0,
                        "health_check_interval": "15s"
                      },
                      "local_topic": "local/topic/#",
                      "aws_access_key_id": "root"
                    },
                    "summary": "DynamoDB Bridge"
                  },
                  "tdengine": {
                    "value": {
                      "name": "foo",
                      "type": "tdengine",
                      "pool_size": 8,
                      "server": "127.0.0.1:6041",
                      "enable": true,
                      "password": "******",
                      "username": "root",
                      "database": "mqtt",
                      "sql": "insert into t_mqtt_msg(ts, msgid, mqtt_topic, qos, payload, arrived) values (${ts}, '${id}', '${topic}', ${qos}, '${payload}', ${timestamp})",
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 8,
                        "query_mode": "sync",
                        "max_buffer_bytes": 268435456,
                        "batch_time": 0,
                        "health_check_interval": "15s"
                      },
                      "local_topic": "local/topic/#"
                    },
                    "summary": "TDengine Bridge"
                  },
                  "mongodb_single": {
                    "value": {
                      "name": "mongodb_single_demo",
                      "type": "mongodb_single",
                      "pool_size": 8,
                      "server": "localhost:27017",
                      "enable": true,
                      "password": "******",
                      "username": "myuser",
                      "database": "mqtt",
                      "collection": "mycol",
                      "w_mode": "safe",
                      "srv_record": false,
                      "mongo_type": "single"
                    },
                    "summary": "MongoDB (Standalone) Bridge"
                  },
                  "greptimedb": {
                    "value": {
                      "name": "demo",
                      "type": "greptimedb",
                      "ssl": {
                        "enable": false
                      },
                      "server": "127.0.0.1:4001",
                      "enable": true,
                      "precision": "ms",
                      "password": "******",
                      "username": "example_username",
                      "resource_opts": {
                        "batch_size": 100,
                        "batch_time": "20ms"
                      },
                      "local_topic": "local/topic/#",
                      "dbname": "example_db",
                      "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,uint_value=${payload.uint_key}u,bool=${payload.bool}"
                    },
                    "summary": "Greptimedb HTTP API V2 Bridge"
                  },
                  "opents": {
                    "value": {
                      "name": "foo",
                      "type": "opents",
                      "pool_size": 8,
                      "server": "http://127.0.0.1:4242",
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 1,
                        "query_mode": "async",
                        "max_buffer_bytes": 268435456,
                        "batch_time": 0,
                        "health_check_interval": "15s"
                      },
                      "enabledb": true
                    },
                    "summary": "OpenTSDB Bridge"
                  },
                  "mongodb_sharded": {
                    "value": {
                      "name": "mongodb_sharded_demo",
                      "type": "mongodb_sharded",
                      "pool_size": 8,
                      "enable": true,
                      "password": "******",
                      "username": "myuser",
                      "database": "mqtt",
                      "servers": "localhost:27017, localhost:27018",
                      "collection": "mycol",
                      "w_mode": "safe",
                      "srv_record": false,
                      "mongo_type": "sharded"
                    },
                    "summary": "MongoDB (Sharded) Bridge"
                  },
                  "mongodb_rs": {
                    "value": {
                      "name": "mongodb_rs_demo",
                      "type": "mongodb_rs",
                      "pool_size": 8,
                      "enable": true,
                      "password": "******",
                      "username": "myuser",
                      "database": "mqtt",
                      "servers": "localhost:27017, localhost:27018",
                      "collection": "mycol",
                      "r_mode": "safe",
                      "w_mode": "safe",
                      "replica_set_name": "rs",
                      "srv_record": false,
                      "mongo_type": "rs"
                    },
                    "summary": "MongoDB (Replica Set) Bridge"
                  },
                  "oracle": {
                    "value": {
                      "name": "foo",
                      "type": "oracle",
                      "pool_size": 8,
                      "server": "127.0.0.1:1521",
                      "enable": true,
                      "password": "******",
                      "username": "root",
                      "service_name": "ORCL",
                      "sql": "insert into t_mqtt_msgs(msgid, topic, qos, payload) values (${id}, ${topic}, ${qos}, ${payload})",
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 8,
                        "query_mode": "async",
                        "max_buffer_bytes": 268435456,
                        "batch_time": 0,
                        "health_check_interval": "15s"
                      },
                      "local_topic": "local/topic/#",
                      "sid": "ORCL"
                    },
                    "summary": "Oracle Database Bridge"
                  },
                  "hstreamdb": {
                    "value": {
                      "name": "demo",
                      "stream": "stream",
                      "type": "hstreamdb",
                      "ssl": {
                        "enable": false
                      },
                      "pool_size": 8,
                      "direction": "egress",
                      "url": "http://127.0.0.1:6570",
                      "resource_opts": {
                        "batch_size": 100,
                        "query_mode": "sync",
                        "batch_time": "20ms"
                      },
                      "record_template": "{ \"temperature\": ${payload.temperature}, \"humidity\": ${payload.humidity} }"
                    },
                    "summary": "HStreamDB Bridge"
                  },
                  "influxdb_api_v1": {
                    "value": {
                      "name": "demo",
                      "type": "influxdb_api_v1",
                      "ssl": {
                        "enable": false
                      },
                      "server": "127.0.0.1:8086",
                      "enable": true,
                      "precision": "ms",
                      "password": "******",
                      "username": "example_username",
                      "database": "example_database",
                      "resource_opts": {
                        "batch_size": 100,
                        "batch_time": "20ms"
                      },
                      "local_topic": "local/topic/#",
                      "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,bool=${payload.bool}",
                      "influxdb_type": "influxdb_api_v1"
                    },
                    "summary": "InfluxDB HTTP API V1 Bridge"
                  },
                  "gcp_pubsub": {
                    "value": {
                      "service_account_json": {
                        "type": "service_account",
                        "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQI...",
                        "client_id": "123812831923812319190",
                        "project_id": "myproject",
                        "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                        "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                        "client_email": "test@myproject.iam.gserviceaccount.com",
                        "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/test%40myproject.iam.gserviceaccount.com",
                        "private_key_id": "kid",
                        "token_uri": "https://oauth2.googleapis.com/token"
                      },
                      "pubsub_topic": "mytopic"
                    },
                    "summary": "GCP PubSub Producer Bridge"
                  },
                  "redis_single": {
                    "value": {
                      "name": "redis_bridge",
                      "type": "redis_single",
                      "ssl": {
                        "enable": false
                      },
                      "pool_size": 8,
                      "server": "127.0.0.1:6379",
                      "enable": true,
                      "password": "******",
                      "database": 1,
                      "resource_opts": {
                        "batch_size": 1,
                        "batch_time": "20ms"
                      },
                      "redis_type": "single",
                      "local_topic": "local/topic/#",
                      "command_template": [
                        "LPUSH",
                        "MSGS",
                        "${payload}"
                      ]
                    },
                    "summary": "Redis Single Node Bridge"
                  },
                  "mqtt_example": {
                    "value": {
                      "name": "mqtt_example",
                      "type": "mqtt",
                      "keepalive": "300s",
                      "ssl": {
                        "enable": false
                      },
                      "server": "127.0.0.1:1883",
                      "enable": true,
                      "password": "******",
                      "username": "foo",
                      "proto_ver": "v4",
                      "clean_start": true,
                      "retry_interval": "15s",
                      "max_inflight": 100,
                      "resource_opts": {
                        "query_mode": "sync",
                        "max_buffer_bytes": 104857600,
                        "health_check_interval": "15s"
                      },
                      "ingress": {
                        "local": {
                          "retain": "${retain}",
                          "payload": "${payload}",
                          "topic": "from_aws/${topic}",
                          "qos": "${qos}"
                        },
                        "remote": {
                          "topic": "aws/#",
                          "qos": 1
                        }
                      },
                      "egress": {
                        "local": {
                          "topic": "emqx/#"
                        },
                        "remote": {
                          "retain": false,
                          "payload": "${payload}",
                          "topic": "from_emqx/${topic}",
                          "qos": "${qos}"
                        }
                      }
                    },
                    "summary": "MQTT Bridge"
                  },
                  "cassandra": {
                    "value": {
                      "name": "foo",
                      "type": "cassandra",
                      "pool_size": 8,
                      "enable": true,
                      "password": "******",
                      "username": "root",
                      "cql": "insert into mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic},  ${qos}, ${payload}, ${timestamp})",
                      "servers": "127.0.0.1:9042",
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 8,
                        "query_mode": "sync",
                        "max_buffer_bytes": 268435456,
                        "batch_time": 0,
                        "health_check_interval": "15s"
                      },
                      "local_topic": "local/topic/#",
                      "keyspace": "mqtt"
                    },
                    "summary": "Cassandra Bridge"
                  },
                  "gcp_pubsub_consumer": {
                    "value": {
                      "connect_timeout": "15s",
                      "consumer": {
                        "topic_mapping": [
                          {
                            "qos": 1,
                            "mqtt_topic": "mqtt/topic/1",
                            "payload_template": "${.}",
                            "pubsub_topic": "pubsub-topic-1"
                          },
                          {
                            "qos": 2,
                            "mqtt_topic": "mqtt/topic/2",
                            "payload_template": "v = ${.value}, a = ${.attributes}, o = ${.ordering_key}",
                            "pubsub_topic": "pubsub-topic-2"
                          }
                        ],
                        "pull_max_messages": 100
                      },
                      "resource_opts": {
                        "request_ttl": "20s"
                      },
                      "service_account_json": {
                        "type": "service_account",
                        "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQI...",
                        "client_id": "123812831923812319190",
                        "project_id": "myproject",
                        "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                        "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                        "client_email": "test@myproject.iam.gserviceaccount.com",
                        "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/test%40myproject.iam.gserviceaccount.com",
                        "private_key_id": "kid",
                        "token_uri": "https://oauth2.googleapis.com/token"
                      }
                    },
                    "summary": "GCP PubSub Consumer Bridge"
                  },
                  "clickhouse": {
                    "value": {
                      "name": "foo",
                      "type": "clickhouse",
                      "pool_size": 8,
                      "server": "127.0.0.1:8123",
                      "enable": true,
                      "password": "******",
                      "username": "default",
                      "database": "mqtt",
                      "sql": "INSERT INTO messages(data, arrived) VALUES ('${payload}', ${timestamp})",
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 8,
                        "query_mode": "async",
                        "max_buffer_bytes": 268435456,
                        "batch_time": 0,
                        "health_check_interval": "15s"
                      },
                      "local_topic": "local/topic/#",
                      "batch_value_separator": ", "
                    },
                    "summary": "Clickhouse Bridge"
                  },
                  "sqlserver": {
                    "value": {
                      "driver": "ms-sql",
                      "name": "bar",
                      "type": "sqlserver",
                      "pool_size": 8,
                      "server": "127.0.0.1:1433",
                      "enable": true,
                      "password": "******",
                      "username": "sa",
                      "database": "test",
                      "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload) values ( ${id}, ${topic}, ${qos}, ${payload} )",
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 1,
                        "query_mode": "async",
                        "max_buffer_bytes": 268435456,
                        "batch_time": 0,
                        "health_check_interval": "15s"
                      },
                      "local_topic": "local/topic/#"
                    },
                    "summary": "Microsoft SQL Server Bridge"
                  },
                  "matrix": {
                    "value": {
                      "name": "foo",
                      "status": "connected",
                      "type": "matrix",
                      "pool_size": 8,
                      "server": "127.0.0.1:5432",
                      "enable": true,
                      "password": "******",
                      "username": "root",
                      "database": "mqtt",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 8,
                        "query_mode": "async",
                        "max_buffer_bytes": 268435456,
                        "batch_time": 0,
                        "health_check_interval": "15s"
                      },
                      "local_topic": "local/topic/#"
                    },
                    "summary": "Matrix Bridge"
                  },
                  "kafka_consumer": {
                    "value": {
                      "name": "my_kafka_producer_action",
                      "status": "connected",
                      "type": "kafka_producer",
                      "authentication": {
                        "mechanism": "plain",
                        "password": "******",
                        "username": "username"
                      },
                      "connect_timeout": "5s",
                      "enable": true,
                      "socket_opts": {
                        "nodelay": true,
                        "recbuf": "1024KB",
                        "sndbuf": "1024KB",
                        "tcp_keepalive": "none"
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "kafka": {
                        "max_batch_bytes": "896KB",
                        "offset_reset_policy": "latest",
                        "offset_commit_interval_seconds": 5
                      },
                      "min_metadata_refresh_interval": "3s",
                      "topic_mapping": [
                        {
                          "qos": 1,
                          "mqtt_topic": "mqtt/topic/${.offset}",
                          "payload_template": "${.}",
                          "kafka_topic": "kafka-topic-1"
                        },
                        {
                          "qos": 2,
                          "mqtt_topic": "mqtt/topic/2",
                          "payload_template": "v = ${.value}",
                          "kafka_topic": "kafka-topic-2"
                        }
                      ],
                      "bootstrap_hosts": "localhost:9092",
                      "value_encoding_mode": "none",
                      "key_encoding_mode": "none",
                      "metadata_request_timeout": "4s"
                    },
                    "summary": "Kafka Consumer Bridge"
                  },
                  "rocketmq": {
                    "value": {
                      "name": "foo",
                      "type": "rocketmq",
                      "server": "127.0.0.1:9876",
                      "template": "",
                      "enable": true,
                      "topic": "TopicTest",
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 1,
                        "query_mode": "sync",
                        "max_buffer_bytes": 268435456,
                        "batch_time": 0,
                        "health_check_interval": "15s"
                      },
                      "local_topic": "local/topic/#"
                    },
                    "summary": "RocketMQ Bridge"
                  },
                  "timescale": {
                    "value": {
                      "name": "foo",
                      "status": "connected",
                      "type": "timescale",
                      "pool_size": 8,
                      "server": "127.0.0.1:5432",
                      "enable": true,
                      "password": "******",
                      "username": "root",
                      "database": "mqtt",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 8,
                        "query_mode": "async",
                        "max_buffer_bytes": 268435456,
                        "batch_time": 0,
                        "health_check_interval": "15s"
                      },
                      "local_topic": "local/topic/#"
                    },
                    "summary": "Timescale Bridge"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/bridge_kafka.get_producer"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_timescale.get"
                    },
                    {
                      "$ref": "#/components/schemas/rocketmq.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_kafka.get_consumer"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_matrix.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_sqlserver.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_clickhouse.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_gcp_pubsub.get_consumer"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_cassa.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_redis.get_single"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_gcp_pubsub.get_producer"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_influxdb.get_api_v1"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_hstreamdb.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_oracle.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mongodb.get_rs"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mongodb.get_sharded"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_opents.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_greptimedb.get_grpc_v1"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mongodb.get_single"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_tdengine.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_dynamo.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_rabbitmq.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mqtt.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_kinesis.get_producer"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mysql.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_redis.get_cluster"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_pgsql.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_pulsar.get_producer"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_redis.get_sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_azure_event_hub.get_producer"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_http.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_iotdb.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_influxdb.get_api_v2"
                    }
                  ]
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bridge not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update a bridge by Id",
        "tags": [
          "Bridges"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge Id. Must be of format {type}:{name}",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:http_example"
          }
        ],
        "summary": "Update bridge",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "influxdb_api_v2": {
                    "value": {
                      "name": "demo",
                      "type": "influxdb_api_v2",
                      "ssl": {
                        "enable": false
                      },
                      "server": "127.0.0.1:8086",
                      "enable": true,
                      "precision": "ms",
                      "org": "examlpe_org",
                      "token": "example_token",
                      "bucket": "example_bucket",
                      "resource_opts": {
                        "batch_size": 100,
                        "batch_time": "20ms"
                      },
                      "local_topic": "local/topic/#",
                      "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,uint_value=${payload.uint_key}u,bool=${payload.bool}",
                      "influxdb_type": "influxdb_api_v2"
                    },
                    "summary": "InfluxDB HTTP API V2 Bridge"
                  },
                  "iotdb": {
                    "value": {
                      "name": "My IoTDB Bridge",
                      "type": "iotdb",
                      "ssl": {
                        "enable": false
                      },
                      "authentication": {
                        "password": "*****",
                        "username": "root"
                      },
                      "connect_timeout": "15s",
                      "pool_size": 8,
                      "enable": true,
                      "base_url": "http://iotdb.local:18080/",
                      "pool_type": "random",
                      "resource_opts": {
                        "worker_pool_size": 8,
                        "query_mode": "async",
                        "max_buffer_bytes": 268435456,
                        "health_check_interval": "15s"
                      },
                      "enable_pipelining": 100,
                      "iotdb_version": "v1.1.x",
                      "device_id": "my_device",
                      "is_aligned": false
                    },
                    "summary": "Apache IoTDB Bridge"
                  },
                  "azure_event_hub_producer": {
                    "value": {
                      "name": "my_azure_event_hub_producer",
                      "status": "connected",
                      "type": "azure_event_hub_producer",
                      "authentication": {
                        "password": "******"
                      },
                      "connect_timeout": "5s",
                      "enable": true,
                      "parameters": {
                        "message": {
                          "value": "${.}",
                          "key": "${.clientid}"
                        },
                        "buffer": {
                          "mode": "hybrid",
                          "memory_overload_protection": true,
                          "segment_bytes": "100MB",
                          "per_partition_limit": "2GB"
                        },
                        "topic": "topic",
                        "max_inflight": 10,
                        "required_acks": "all_isr",
                        "max_batch_bytes": "896KB",
                        "partition_count_refresh_interval": "60s",
                        "kafka_header_value_encode_mode": "none",
                        "kafka_ext_headers": [
                          {
                            "kafka_ext_header_value": "${clientid}",
                            "kafka_ext_header_key": "clientid"
                          },
                          {
                            "kafka_ext_header_value": "${topic}",
                            "kafka_ext_header_key": "topic"
                          }
                        ],
                        "kafka_headers": "${.pub_props}",
                        "partition_strategy": "random"
                      },
                      "socket_opts": {
                        "nodelay": true,
                        "recbuf": "1024KB",
                        "sndbuf": "1024KB",
                        "tcp_keepalive": "none"
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "local_topic": "mqtt/local/topic",
                      "min_metadata_refresh_interval": "3s",
                      "bootstrap_hosts": "namespace.servicebus.windows.net:9093",
                      "metadata_request_timeout": "4s"
                    },
                    "summary": "Azure Event Hub Producer Bridge"
                  },
                  "kafka_producer": {
                    "value": {
                      "name": "my_kafka_producer_action",
                      "status": "connected",
                      "type": "kafka_producer",
                      "authentication": {
                        "mechanism": "plain",
                        "password": "******",
                        "username": "username"
                      },
                      "connect_timeout": "5s",
                      "enable": true,
                      "socket_opts": {
                        "nodelay": true,
                        "recbuf": "1024KB",
                        "sndbuf": "1024KB",
                        "tcp_keepalive": "none"
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "local_topic": "mqtt/local/topic",
                      "kafka": {
                        "message": {
                          "timestamp": "${.timestamp}",
                          "value": "${.}",
                          "key": "${.clientid}"
                        },
                        "buffer": {
                          "mode": "hybrid",
                          "memory_overload_protection": true,
                          "segment_bytes": "100MB",
                          "per_partition_limit": "2GB"
                        },
                        "compression": "no_compression",
                        "topic": "kafka-topic",
                        "max_inflight": 10,
                        "required_acks": "all_isr",
                        "max_batch_bytes": "896KB",
                        "partitions_limit": "all_partitions",
                        "partition_count_refresh_interval": "60s",
                        "kafka_header_value_encode_mode": "none",
                        "kafka_ext_headers": [
                          {
                            "kafka_ext_header_value": "${clientid}",
                            "kafka_ext_header_key": "clientid"
                          },
                          {
                            "kafka_ext_header_value": "${topic}",
                            "kafka_ext_header_key": "topic"
                          }
                        ],
                        "kafka_headers": "${pub_props}",
                        "partition_strategy": "random"
                      },
                      "min_metadata_refresh_interval": "3s",
                      "bootstrap_hosts": "localhost:9092",
                      "metadata_request_timeout": "4s"
                    },
                    "summary": "Kafka Producer Bridge"
                  },
                  "redis_sentinel": {
                    "value": {
                      "name": "redis_bridge",
                      "type": "redis_sentinel",
                      "ssl": {
                        "enable": false
                      },
                      "pool_size": 8,
                      "enable": true,
                      "password": "******",
                      "database": 1,
                      "servers": [
                        "127.0.0.1:26379"
                      ],
                      "resource_opts": {
                        "batch_size": 1,
                        "batch_time": "20ms"
                      },
                      "sentinel": "mymaster",
                      "redis_type": "sentinel",
                      "local_topic": "local/topic/#",
                      "command_template": [
                        "LPUSH",
                        "MSGS",
                        "${payload}"
                      ]
                    },
                    "summary": "Redis Sentinel Bridge"
                  },
                  "pulsar_producer": {
                    "value": {
                      "authentication": "none",
                      "batch_size": 1,
                      "buffer": {
                        "memory_overload_protection": true,
                        "mode": "memory",
                        "per_partition_limit": "10MB",
                        "segment_bytes": "5MB"
                      },
                      "compression": "no_compression",
                      "enable": true,
                      "local_topic": "mqtt/topic/-576460752303423482",
                      "max_batch_bytes": "900KB",
                      "message": {
                        "key": "${.clientid}",
                        "value": "${.}"
                      },
                      "name": "pulsar_example_name",
                      "pulsar_topic": "pulsar_example_topic",
                      "retention_period": "infinity",
                      "send_buffer": "1MB",
                      "servers": "pulsar://127.0.0.1:6650",
                      "ssl": {
                        "enable": false,
                        "server_name_indication": "auto",
                        "verify": "verify_none"
                      },
                      "strategy": "key_dispatch",
                      "sync_timeout": "5s",
                      "type": "pulsar_producer"
                    },
                    "summary": "Pulsar Producer Bridge"
                  },
                  "pgsql": {
                    "value": {
                      "name": "foo",
                      "status": "connected",
                      "type": "pgsql",
                      "pool_size": 8,
                      "server": "127.0.0.1:5432",
                      "enable": true,
                      "password": "******",
                      "username": "root",
                      "database": "mqtt",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 8,
                        "query_mode": "async",
                        "max_buffer_bytes": 268435456,
                        "batch_time": 0,
                        "health_check_interval": "15s"
                      },
                      "local_topic": "local/topic/#"
                    },
                    "summary": "PostgreSQL Bridge"
                  },
                  "redis_cluster": {
                    "value": {
                      "name": "redis_bridge",
                      "type": "redis_cluster",
                      "ssl": {
                        "enable": false
                      },
                      "pool_size": 8,
                      "enable": true,
                      "password": "******",
                      "servers": [
                        "127.0.0.1:6379"
                      ],
                      "resource_opts": {},
                      "redis_type": "cluster",
                      "local_topic": "local/topic/#",
                      "command_template": [
                        "LPUSH",
                        "MSGS",
                        "${payload}"
                      ]
                    },
                    "summary": "Redis Cluster Bridge"
                  },
                  "mysql": {
                    "value": {
                      "name": "foo",
                      "type": "mysql",
                      "pool_size": 8,
                      "server": "127.0.0.1:3306",
                      "enable": true,
                      "password": "******",
                      "username": "root",
                      "database": "test",
                      "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, FROM_UNIXTIME(${timestamp}/1000))",
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 1,
                        "query_mode": "async",
                        "max_buffer_bytes": 268435456,
                        "batch_time": 0,
                        "health_check_interval": "15s"
                      },
                      "local_topic": "local/topic/#"
                    },
                    "summary": "MySQL Bridge"
                  },
                  "kinesis_producer": {
                    "value": {
                      "name": "foo",
                      "type": "kinesis_producer",
                      "enable": true,
                      "max_retries": 3,
                      "aws_secret_access_key": "******",
                      "resource_opts": {
                        "worker_pool_size": 1,
                        "query_mode": "async",
                        "max_buffer_bytes": 104857600,
                        "inflight_window": 100,
                        "health_check_interval": 15000
                      },
                      "endpoint": "https://kinesis.us-east-1.amazonaws.com",
                      "partition_key": "key",
                      "aws_access_key_id": "aws_access_key_id",
                      "stream_name": "stream_name"
                    },
                    "summary": "Amazon Kinesis Producer Bridge"
                  },
                  "http_example": {
                    "value": {
                      "name": "http_example",
                      "type": "http",
                      "ssl": {
                        "enable": false
                      },
                      "connect_timeout": "15s",
                      "pool_size": 4,
                      "enable": true,
                      "body": "${payload}",
                      "url": "http://localhost:9901/messages/${topic}",
                      "method": "post",
                      "max_retries": 3,
                      "request_timeout": "15s",
                      "pool_type": "random",
                      "resource_opts": {
                        "worker_pool_size": 1,
                        "query_mode": "async",
                        "max_buffer_bytes": 104857600,
                        "inflight_window": 100,
                        "health_check_interval": 15000
                      },
                      "enable_pipelining": 100,
                      "local_topic": "emqx_http/#"
                    },
                    "summary": "HTTP"
                  },
                  "rabbitmq": {
                    "value": {
                      "timeout": 5,
                      "name": "foo",
                      "port": 5672,
                      "type": "rabbitmq",
                      "exchange": "messages",
                      "pool_size": 8,
                      "server": "localhost",
                      "enable": true,
                      "password": "******",
                      "username": "guest",
                      "heartbeat": "30s",
                      "durable": false,
                      "auto_reconnect": "2s",
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 8,
                        "query_mode": "async",
                        "max_buffer_bytes": 268435456,
                        "batch_time": 0,
                        "health_check_interval": "15s"
                      },
                      "payload_template": "",
                      "routing_key": "my_routing_key",
                      "virtual_host": "/",
                      "exchange_type": "topic"
                    },
                    "summary": "RabbitMQ Bridge"
                  },
                  "dynamo": {
                    "value": {
                      "name": "foo",
                      "table": "mqtt",
                      "type": "dynamo",
                      "pool_size": 8,
                      "template": "",
                      "enable": true,
                      "url": "http://127.0.0.1:8000",
                      "aws_secret_access_key": "******",
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 8,
                        "query_mode": "sync",
                        "max_buffer_bytes": 268435456,
                        "batch_time": 0,
                        "health_check_interval": "15s"
                      },
                      "local_topic": "local/topic/#",
                      "aws_access_key_id": "root"
                    },
                    "summary": "DynamoDB Bridge"
                  },
                  "tdengine": {
                    "value": {
                      "name": "foo",
                      "type": "tdengine",
                      "pool_size": 8,
                      "server": "127.0.0.1:6041",
                      "enable": true,
                      "password": "******",
                      "username": "root",
                      "database": "mqtt",
                      "sql": "insert into t_mqtt_msg(ts, msgid, mqtt_topic, qos, payload, arrived) values (${ts}, '${id}', '${topic}', ${qos}, '${payload}', ${timestamp})",
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 8,
                        "query_mode": "sync",
                        "max_buffer_bytes": 268435456,
                        "batch_time": 0,
                        "health_check_interval": "15s"
                      },
                      "local_topic": "local/topic/#"
                    },
                    "summary": "TDengine Bridge"
                  },
                  "mongodb_single": {
                    "value": {
                      "name": "mongodb_single_demo",
                      "type": "mongodb_single",
                      "pool_size": 8,
                      "server": "localhost:27017",
                      "enable": true,
                      "password": "******",
                      "username": "myuser",
                      "database": "mqtt",
                      "collection": "mycol",
                      "w_mode": "safe",
                      "srv_record": false,
                      "mongo_type": "single"
                    },
                    "summary": "MongoDB (Standalone) Bridge"
                  },
                  "greptimedb": {
                    "value": {
                      "name": "demo",
                      "type": "greptimedb",
                      "ssl": {
                        "enable": false
                      },
                      "server": "127.0.0.1:4001",
                      "enable": true,
                      "precision": "ms",
                      "password": "******",
                      "username": "example_username",
                      "resource_opts": {
                        "batch_size": 100,
                        "batch_time": "20ms"
                      },
                      "local_topic": "local/topic/#",
                      "dbname": "example_db",
                      "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,uint_value=${payload.uint_key}u,bool=${payload.bool}"
                    },
                    "summary": "Greptimedb HTTP API V2 Bridge"
                  },
                  "opents": {
                    "value": {
                      "name": "foo",
                      "type": "opents",
                      "pool_size": 8,
                      "server": "http://127.0.0.1:4242",
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 1,
                        "query_mode": "async",
                        "max_buffer_bytes": 268435456,
                        "batch_time": 0,
                        "health_check_interval": "15s"
                      },
                      "enabledb": true
                    },
                    "summary": "OpenTSDB Bridge"
                  },
                  "mongodb_sharded": {
                    "value": {
                      "name": "mongodb_sharded_demo",
                      "type": "mongodb_sharded",
                      "pool_size": 8,
                      "enable": true,
                      "password": "******",
                      "username": "myuser",
                      "database": "mqtt",
                      "servers": "localhost:27017, localhost:27018",
                      "collection": "mycol",
                      "w_mode": "safe",
                      "srv_record": false,
                      "mongo_type": "sharded"
                    },
                    "summary": "MongoDB (Sharded) Bridge"
                  },
                  "mongodb_rs": {
                    "value": {
                      "name": "mongodb_rs_demo",
                      "type": "mongodb_rs",
                      "pool_size": 8,
                      "enable": true,
                      "password": "******",
                      "username": "myuser",
                      "database": "mqtt",
                      "servers": "localhost:27017, localhost:27018",
                      "collection": "mycol",
                      "r_mode": "safe",
                      "w_mode": "safe",
                      "replica_set_name": "rs",
                      "srv_record": false,
                      "mongo_type": "rs"
                    },
                    "summary": "MongoDB (Replica Set) Bridge"
                  },
                  "oracle": {
                    "value": {
                      "name": "foo",
                      "type": "oracle",
                      "pool_size": 8,
                      "server": "127.0.0.1:1521",
                      "enable": true,
                      "password": "******",
                      "username": "root",
                      "service_name": "ORCL",
                      "sql": "insert into t_mqtt_msgs(msgid, topic, qos, payload) values (${id}, ${topic}, ${qos}, ${payload})",
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 8,
                        "query_mode": "async",
                        "max_buffer_bytes": 268435456,
                        "batch_time": 0,
                        "health_check_interval": "15s"
                      },
                      "local_topic": "local/topic/#",
                      "sid": "ORCL"
                    },
                    "summary": "Oracle Database Bridge"
                  },
                  "hstreamdb": {
                    "value": {
                      "name": "demo",
                      "stream": "stream",
                      "type": "hstreamdb",
                      "ssl": {
                        "enable": false
                      },
                      "pool_size": 8,
                      "direction": "egress",
                      "url": "http://127.0.0.1:6570",
                      "resource_opts": {
                        "batch_size": 100,
                        "query_mode": "sync",
                        "batch_time": "20ms"
                      },
                      "record_template": "{ \"temperature\": ${payload.temperature}, \"humidity\": ${payload.humidity} }"
                    },
                    "summary": "HStreamDB Bridge"
                  },
                  "influxdb_api_v1": {
                    "value": {
                      "name": "demo",
                      "type": "influxdb_api_v1",
                      "ssl": {
                        "enable": false
                      },
                      "server": "127.0.0.1:8086",
                      "enable": true,
                      "precision": "ms",
                      "password": "******",
                      "username": "example_username",
                      "database": "example_database",
                      "resource_opts": {
                        "batch_size": 100,
                        "batch_time": "20ms"
                      },
                      "local_topic": "local/topic/#",
                      "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,bool=${payload.bool}",
                      "influxdb_type": "influxdb_api_v1"
                    },
                    "summary": "InfluxDB HTTP API V1 Bridge"
                  },
                  "gcp_pubsub": {
                    "value": {
                      "service_account_json": {
                        "type": "service_account",
                        "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQI...",
                        "client_id": "123812831923812319190",
                        "project_id": "myproject",
                        "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                        "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                        "client_email": "test@myproject.iam.gserviceaccount.com",
                        "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/test%40myproject.iam.gserviceaccount.com",
                        "private_key_id": "kid",
                        "token_uri": "https://oauth2.googleapis.com/token"
                      },
                      "pubsub_topic": "mytopic"
                    },
                    "summary": "GCP PubSub Producer Bridge"
                  },
                  "redis_single": {
                    "value": {
                      "name": "redis_bridge",
                      "type": "redis_single",
                      "ssl": {
                        "enable": false
                      },
                      "pool_size": 8,
                      "server": "127.0.0.1:6379",
                      "enable": true,
                      "password": "******",
                      "database": 1,
                      "resource_opts": {
                        "batch_size": 1,
                        "batch_time": "20ms"
                      },
                      "redis_type": "single",
                      "local_topic": "local/topic/#",
                      "command_template": [
                        "LPUSH",
                        "MSGS",
                        "${payload}"
                      ]
                    },
                    "summary": "Redis Single Node Bridge"
                  },
                  "mqtt_example": {
                    "value": {
                      "name": "mqtt_example",
                      "type": "mqtt",
                      "keepalive": "300s",
                      "ssl": {
                        "enable": false
                      },
                      "server": "127.0.0.1:1883",
                      "enable": true,
                      "password": "******",
                      "username": "foo",
                      "proto_ver": "v4",
                      "clean_start": true,
                      "retry_interval": "15s",
                      "max_inflight": 100,
                      "resource_opts": {
                        "query_mode": "sync",
                        "max_buffer_bytes": 104857600,
                        "health_check_interval": "15s"
                      },
                      "ingress": {
                        "local": {
                          "retain": "${retain}",
                          "payload": "${payload}",
                          "topic": "from_aws/${topic}",
                          "qos": "${qos}"
                        },
                        "remote": {
                          "topic": "aws/#",
                          "qos": 1
                        }
                      },
                      "egress": {
                        "local": {
                          "topic": "emqx/#"
                        },
                        "remote": {
                          "retain": false,
                          "payload": "${payload}",
                          "topic": "from_emqx/${topic}",
                          "qos": "${qos}"
                        }
                      }
                    },
                    "summary": "MQTT Bridge"
                  },
                  "cassandra": {
                    "value": {
                      "name": "foo",
                      "type": "cassandra",
                      "pool_size": 8,
                      "enable": true,
                      "password": "******",
                      "username": "root",
                      "cql": "insert into mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic},  ${qos}, ${payload}, ${timestamp})",
                      "servers": "127.0.0.1:9042",
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 8,
                        "query_mode": "sync",
                        "max_buffer_bytes": 268435456,
                        "batch_time": 0,
                        "health_check_interval": "15s"
                      },
                      "local_topic": "local/topic/#",
                      "keyspace": "mqtt"
                    },
                    "summary": "Cassandra Bridge"
                  },
                  "gcp_pubsub_consumer": {
                    "value": {
                      "connect_timeout": "15s",
                      "consumer": {
                        "topic_mapping": [
                          {
                            "qos": 1,
                            "mqtt_topic": "mqtt/topic/1",
                            "payload_template": "${.}",
                            "pubsub_topic": "pubsub-topic-1"
                          },
                          {
                            "qos": 2,
                            "mqtt_topic": "mqtt/topic/2",
                            "payload_template": "v = ${.value}, a = ${.attributes}, o = ${.ordering_key}",
                            "pubsub_topic": "pubsub-topic-2"
                          }
                        ],
                        "pull_max_messages": 100
                      },
                      "resource_opts": {
                        "request_ttl": "20s"
                      },
                      "service_account_json": {
                        "type": "service_account",
                        "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQI...",
                        "client_id": "123812831923812319190",
                        "project_id": "myproject",
                        "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                        "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                        "client_email": "test@myproject.iam.gserviceaccount.com",
                        "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/test%40myproject.iam.gserviceaccount.com",
                        "private_key_id": "kid",
                        "token_uri": "https://oauth2.googleapis.com/token"
                      }
                    },
                    "summary": "GCP PubSub Consumer Bridge"
                  },
                  "clickhouse": {
                    "value": {
                      "name": "foo",
                      "type": "clickhouse",
                      "pool_size": 8,
                      "server": "127.0.0.1:8123",
                      "enable": true,
                      "password": "******",
                      "username": "default",
                      "database": "mqtt",
                      "sql": "INSERT INTO messages(data, arrived) VALUES ('${payload}', ${timestamp})",
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 8,
                        "query_mode": "async",
                        "max_buffer_bytes": 268435456,
                        "batch_time": 0,
                        "health_check_interval": "15s"
                      },
                      "local_topic": "local/topic/#",
                      "batch_value_separator": ", "
                    },
                    "summary": "Clickhouse Bridge"
                  },
                  "sqlserver": {
                    "value": {
                      "driver": "ms-sql",
                      "name": "bar",
                      "type": "sqlserver",
                      "pool_size": 8,
                      "server": "127.0.0.1:1433",
                      "enable": true,
                      "password": "******",
                      "username": "sa",
                      "database": "test",
                      "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload) values ( ${id}, ${topic}, ${qos}, ${payload} )",
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 1,
                        "query_mode": "async",
                        "max_buffer_bytes": 268435456,
                        "batch_time": 0,
                        "health_check_interval": "15s"
                      },
                      "local_topic": "local/topic/#"
                    },
                    "summary": "Microsoft SQL Server Bridge"
                  },
                  "matrix": {
                    "value": {
                      "name": "foo",
                      "status": "connected",
                      "type": "matrix",
                      "pool_size": 8,
                      "server": "127.0.0.1:5432",
                      "enable": true,
                      "password": "******",
                      "username": "root",
                      "database": "mqtt",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 8,
                        "query_mode": "async",
                        "max_buffer_bytes": 268435456,
                        "batch_time": 0,
                        "health_check_interval": "15s"
                      },
                      "local_topic": "local/topic/#"
                    },
                    "summary": "Matrix Bridge"
                  },
                  "kafka_consumer": {
                    "value": {
                      "name": "my_kafka_producer_action",
                      "status": "connected",
                      "type": "kafka_producer",
                      "authentication": {
                        "mechanism": "plain",
                        "password": "******",
                        "username": "username"
                      },
                      "connect_timeout": "5s",
                      "enable": true,
                      "socket_opts": {
                        "nodelay": true,
                        "recbuf": "1024KB",
                        "sndbuf": "1024KB",
                        "tcp_keepalive": "none"
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "kafka": {
                        "max_batch_bytes": "896KB",
                        "offset_reset_policy": "latest",
                        "offset_commit_interval_seconds": 5
                      },
                      "min_metadata_refresh_interval": "3s",
                      "topic_mapping": [
                        {
                          "qos": 1,
                          "mqtt_topic": "mqtt/topic/${.offset}",
                          "payload_template": "${.}",
                          "kafka_topic": "kafka-topic-1"
                        },
                        {
                          "qos": 2,
                          "mqtt_topic": "mqtt/topic/2",
                          "payload_template": "v = ${.value}",
                          "kafka_topic": "kafka-topic-2"
                        }
                      ],
                      "bootstrap_hosts": "localhost:9092",
                      "value_encoding_mode": "none",
                      "key_encoding_mode": "none",
                      "metadata_request_timeout": "4s"
                    },
                    "summary": "Kafka Consumer Bridge"
                  },
                  "rocketmq": {
                    "value": {
                      "name": "foo",
                      "type": "rocketmq",
                      "server": "127.0.0.1:9876",
                      "template": "",
                      "enable": true,
                      "topic": "TopicTest",
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 1,
                        "query_mode": "sync",
                        "max_buffer_bytes": 268435456,
                        "batch_time": 0,
                        "health_check_interval": "15s"
                      },
                      "local_topic": "local/topic/#"
                    },
                    "summary": "RocketMQ Bridge"
                  },
                  "timescale": {
                    "value": {
                      "name": "foo",
                      "status": "connected",
                      "type": "timescale",
                      "pool_size": 8,
                      "server": "127.0.0.1:5432",
                      "enable": true,
                      "password": "******",
                      "username": "root",
                      "database": "mqtt",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 8,
                        "query_mode": "async",
                        "max_buffer_bytes": 268435456,
                        "batch_time": 0,
                        "health_check_interval": "15s"
                      },
                      "local_topic": "local/topic/#"
                    },
                    "summary": "Timescale Bridge"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/bridge_kafka.get_producer"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_timescale.get"
                    },
                    {
                      "$ref": "#/components/schemas/rocketmq.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_kafka.get_consumer"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_matrix.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_sqlserver.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_clickhouse.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_gcp_pubsub.get_consumer"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_cassa.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_redis.get_single"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_gcp_pubsub.get_producer"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_influxdb.get_api_v1"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_hstreamdb.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_oracle.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mongodb.get_rs"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mongodb.get_sharded"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_opents.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_greptimedb.get_grpc_v1"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mongodb.get_single"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_tdengine.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_dynamo.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_rabbitmq.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mqtt.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_kinesis.get_producer"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mysql.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_redis.get_cluster"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_pgsql.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_pulsar.get_producer"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_redis.get_sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_azure_event_hub.get_producer"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_http.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_iotdb.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_influxdb.get_api_v2"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Update bridge failed"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bridge not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "influxdb_api_v2": {
                  "value": {
                    "name": "demo",
                    "type": "influxdb_api_v2",
                    "ssl": {
                      "enable": false
                    },
                    "server": "127.0.0.1:8086",
                    "enable": true,
                    "precision": "ms",
                    "org": "examlpe_org",
                    "token": "example_token",
                    "bucket": "example_bucket",
                    "resource_opts": {
                      "batch_size": 100,
                      "batch_time": "20ms"
                    },
                    "local_topic": "local/topic/#",
                    "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,uint_value=${payload.uint_key}u,bool=${payload.bool}",
                    "influxdb_type": "influxdb_api_v2"
                  },
                  "summary": "InfluxDB HTTP API V2 Bridge"
                },
                "iotdb": {
                  "value": {
                    "name": "My IoTDB Bridge",
                    "type": "iotdb",
                    "ssl": {
                      "enable": false
                    },
                    "authentication": {
                      "password": "*****",
                      "username": "root"
                    },
                    "connect_timeout": "15s",
                    "pool_size": 8,
                    "enable": true,
                    "base_url": "http://iotdb.local:18080/",
                    "pool_type": "random",
                    "resource_opts": {
                      "worker_pool_size": 8,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "health_check_interval": "15s"
                    },
                    "enable_pipelining": 100,
                    "iotdb_version": "v1.1.x",
                    "device_id": "my_device",
                    "is_aligned": false
                  },
                  "summary": "Apache IoTDB Bridge"
                },
                "azure_event_hub_producer": {
                  "value": {
                    "name": "my_azure_event_hub_producer",
                    "type": "azure_event_hub_producer",
                    "authentication": {
                      "password": "******"
                    },
                    "connect_timeout": "5s",
                    "enable": true,
                    "parameters": {
                      "message": {
                        "value": "${.}",
                        "key": "${.clientid}"
                      },
                      "buffer": {
                        "mode": "hybrid",
                        "memory_overload_protection": true,
                        "segment_bytes": "100MB",
                        "per_partition_limit": "2GB"
                      },
                      "topic": "topic",
                      "max_inflight": 10,
                      "required_acks": "all_isr",
                      "max_batch_bytes": "896KB",
                      "partition_count_refresh_interval": "60s",
                      "kafka_header_value_encode_mode": "none",
                      "kafka_ext_headers": [
                        {
                          "kafka_ext_header_value": "${clientid}",
                          "kafka_ext_header_key": "clientid"
                        },
                        {
                          "kafka_ext_header_value": "${topic}",
                          "kafka_ext_header_key": "topic"
                        }
                      ],
                      "kafka_headers": "${.pub_props}",
                      "partition_strategy": "random"
                    },
                    "socket_opts": {
                      "nodelay": true,
                      "recbuf": "1024KB",
                      "sndbuf": "1024KB",
                      "tcp_keepalive": "none"
                    },
                    "local_topic": "mqtt/local/topic",
                    "min_metadata_refresh_interval": "3s",
                    "bootstrap_hosts": "namespace.servicebus.windows.net:9093",
                    "metadata_request_timeout": "4s"
                  },
                  "summary": "Azure Event Hub Producer Bridge"
                },
                "kafka_producer": {
                  "value": {
                    "authentication": {
                      "mechanism": "plain",
                      "password": "******",
                      "username": "username"
                    },
                    "connect_timeout": "5s",
                    "enable": true,
                    "socket_opts": {
                      "nodelay": true,
                      "recbuf": "1024KB",
                      "sndbuf": "1024KB",
                      "tcp_keepalive": "none"
                    },
                    "local_topic": "mqtt/local/topic",
                    "kafka": {
                      "message": {
                        "timestamp": "${.timestamp}",
                        "value": "${.}",
                        "key": "${.clientid}"
                      },
                      "buffer": {
                        "mode": "hybrid",
                        "memory_overload_protection": true,
                        "segment_bytes": "100MB",
                        "per_partition_limit": "2GB"
                      },
                      "compression": "no_compression",
                      "topic": "kafka-topic",
                      "max_inflight": 10,
                      "required_acks": "all_isr",
                      "max_batch_bytes": "896KB",
                      "partitions_limit": "all_partitions",
                      "partition_count_refresh_interval": "60s",
                      "kafka_header_value_encode_mode": "none",
                      "kafka_ext_headers": [
                        {
                          "kafka_ext_header_value": "${clientid}",
                          "kafka_ext_header_key": "clientid"
                        },
                        {
                          "kafka_ext_header_value": "${topic}",
                          "kafka_ext_header_key": "topic"
                        }
                      ],
                      "kafka_headers": "${pub_props}",
                      "partition_strategy": "random"
                    },
                    "min_metadata_refresh_interval": "3s",
                    "bootstrap_hosts": "localhost:9092",
                    "metadata_request_timeout": "4s"
                  },
                  "summary": "Kafka Producer Bridge"
                },
                "redis_sentinel": {
                  "value": {
                    "ssl": {
                      "enable": false
                    },
                    "pool_size": 8,
                    "enable": true,
                    "password": "******",
                    "database": 1,
                    "servers": [
                      "127.0.0.1:26379"
                    ],
                    "resource_opts": {
                      "batch_size": 1,
                      "batch_time": "20ms"
                    },
                    "sentinel": "mymaster",
                    "redis_type": "sentinel",
                    "local_topic": "local/topic/#",
                    "command_template": [
                      "LPUSH",
                      "MSGS",
                      "${payload}"
                    ]
                  },
                  "summary": "Redis Sentinel Bridge"
                },
                "pulsar_producer": {
                  "value": {
                    "authentication": "none",
                    "batch_size": 1,
                    "buffer": {
                      "memory_overload_protection": true,
                      "mode": "memory",
                      "per_partition_limit": "10MB",
                      "segment_bytes": "5MB"
                    },
                    "compression": "no_compression",
                    "enable": true,
                    "local_topic": "mqtt/topic/-576460752303423482",
                    "max_batch_bytes": "900KB",
                    "message": {
                      "key": "${.clientid}",
                      "value": "${.}"
                    },
                    "name": "pulsar_example_name",
                    "pulsar_topic": "pulsar_example_topic",
                    "retention_period": "infinity",
                    "send_buffer": "1MB",
                    "servers": "pulsar://127.0.0.1:6650",
                    "ssl": {
                      "enable": false,
                      "server_name_indication": "auto",
                      "verify": "verify_none"
                    },
                    "strategy": "key_dispatch",
                    "sync_timeout": "5s",
                    "type": "pulsar_producer"
                  },
                  "summary": "Pulsar Producer Bridge"
                },
                "pgsql": {
                  "value": {
                    "name": "foo",
                    "type": "pgsql",
                    "pool_size": 8,
                    "server": "127.0.0.1:5432",
                    "enable": true,
                    "password": "******",
                    "username": "root",
                    "database": "mqtt",
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 8,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#"
                  },
                  "summary": "PostgreSQL Bridge"
                },
                "redis_cluster": {
                  "value": {
                    "ssl": {
                      "enable": false
                    },
                    "pool_size": 8,
                    "enable": true,
                    "password": "******",
                    "servers": [
                      "127.0.0.1:6379"
                    ],
                    "resource_opts": {},
                    "redis_type": "cluster",
                    "local_topic": "local/topic/#",
                    "command_template": [
                      "LPUSH",
                      "MSGS",
                      "${payload}"
                    ]
                  },
                  "summary": "Redis Cluster Bridge"
                },
                "mysql": {
                  "value": {
                    "name": "foo",
                    "type": "mysql",
                    "pool_size": 8,
                    "server": "127.0.0.1:3306",
                    "enable": true,
                    "password": "******",
                    "username": "root",
                    "database": "test",
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, FROM_UNIXTIME(${timestamp}/1000))",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 1,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#"
                  },
                  "summary": "MySQL Bridge"
                },
                "kinesis_producer": {
                  "value": {
                    "name": "foo",
                    "type": "kinesis_producer",
                    "enable": true,
                    "max_retries": 3,
                    "aws_secret_access_key": "******",
                    "resource_opts": {
                      "worker_pool_size": 1,
                      "query_mode": "async",
                      "max_buffer_bytes": 104857600,
                      "inflight_window": 100,
                      "health_check_interval": 15000
                    },
                    "endpoint": "https://kinesis.us-east-1.amazonaws.com",
                    "partition_key": "key",
                    "aws_access_key_id": "aws_access_key_id",
                    "stream_name": "stream_name"
                  },
                  "summary": "Amazon Kinesis Producer Bridge"
                },
                "http_example": {
                  "value": {
                    "ssl": {
                      "enable": false
                    },
                    "connect_timeout": "15s",
                    "pool_size": 4,
                    "enable": true,
                    "body": "${payload}",
                    "url": "http://localhost:9901/messages/${topic}",
                    "method": "post",
                    "max_retries": 3,
                    "request_timeout": "15s",
                    "pool_type": "random",
                    "resource_opts": {
                      "worker_pool_size": 1,
                      "query_mode": "async",
                      "max_buffer_bytes": 104857600,
                      "inflight_window": 100,
                      "health_check_interval": 15000
                    },
                    "enable_pipelining": 100,
                    "local_topic": "emqx_http/#"
                  },
                  "summary": "HTTP"
                },
                "rabbitmq": {
                  "value": {
                    "timeout": 5,
                    "name": "foo",
                    "port": 5672,
                    "type": "rabbitmq",
                    "exchange": "messages",
                    "pool_size": 8,
                    "server": "localhost",
                    "enable": true,
                    "password": "******",
                    "username": "guest",
                    "heartbeat": "30s",
                    "durable": false,
                    "auto_reconnect": "2s",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 8,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "payload_template": "",
                    "routing_key": "my_routing_key",
                    "virtual_host": "/",
                    "exchange_type": "topic"
                  },
                  "summary": "RabbitMQ Bridge"
                },
                "dynamo": {
                  "value": {
                    "name": "foo",
                    "table": "mqtt",
                    "type": "dynamo",
                    "pool_size": 8,
                    "template": "",
                    "enable": true,
                    "url": "http://127.0.0.1:8000",
                    "aws_secret_access_key": "******",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 8,
                      "query_mode": "sync",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#",
                    "aws_access_key_id": "root"
                  },
                  "summary": "DynamoDB Bridge"
                },
                "tdengine": {
                  "value": {
                    "name": "foo",
                    "type": "tdengine",
                    "pool_size": 8,
                    "server": "127.0.0.1:6041",
                    "enable": true,
                    "password": "******",
                    "username": "root",
                    "database": "mqtt",
                    "sql": "insert into t_mqtt_msg(ts, msgid, mqtt_topic, qos, payload, arrived) values (${ts}, '${id}', '${topic}', ${qos}, '${payload}', ${timestamp})",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 8,
                      "query_mode": "sync",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#"
                  },
                  "summary": "TDengine Bridge"
                },
                "mongodb_single": {
                  "value": {
                    "name": "mongodb_single_demo",
                    "type": "mongodb_single",
                    "pool_size": 8,
                    "server": "localhost:27017",
                    "enable": true,
                    "password": "******",
                    "username": "myuser",
                    "database": "mqtt",
                    "collection": "mycol",
                    "w_mode": "safe",
                    "srv_record": false,
                    "mongo_type": "single"
                  },
                  "summary": "MongoDB (Standalone) Bridge"
                },
                "greptimedb": {
                  "value": {
                    "name": "demo",
                    "type": "greptimedb",
                    "ssl": {
                      "enable": false
                    },
                    "server": "127.0.0.1:4001",
                    "enable": true,
                    "precision": "ms",
                    "password": "******",
                    "username": "example_username",
                    "resource_opts": {
                      "batch_size": 100,
                      "batch_time": "20ms"
                    },
                    "local_topic": "local/topic/#",
                    "dbname": "example_db",
                    "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,uint_value=${payload.uint_key}u,bool=${payload.bool}"
                  },
                  "summary": "Greptimedb HTTP API V2 Bridge"
                },
                "opents": {
                  "value": {
                    "name": "foo",
                    "type": "opents",
                    "pool_size": 8,
                    "server": "http://127.0.0.1:4242",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 1,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "enabledb": true
                  },
                  "summary": "OpenTSDB Bridge"
                },
                "mongodb_sharded": {
                  "value": {
                    "name": "mongodb_sharded_demo",
                    "type": "mongodb_sharded",
                    "pool_size": 8,
                    "enable": true,
                    "password": "******",
                    "username": "myuser",
                    "database": "mqtt",
                    "servers": "localhost:27017, localhost:27018",
                    "collection": "mycol",
                    "w_mode": "safe",
                    "srv_record": false,
                    "mongo_type": "sharded"
                  },
                  "summary": "MongoDB (Sharded) Bridge"
                },
                "mongodb_rs": {
                  "value": {
                    "name": "mongodb_rs_demo",
                    "type": "mongodb_rs",
                    "pool_size": 8,
                    "enable": true,
                    "password": "******",
                    "username": "myuser",
                    "database": "mqtt",
                    "servers": "localhost:27017, localhost:27018",
                    "collection": "mycol",
                    "r_mode": "safe",
                    "w_mode": "safe",
                    "replica_set_name": "rs",
                    "srv_record": false,
                    "mongo_type": "rs"
                  },
                  "summary": "MongoDB (Replica Set) Bridge"
                },
                "oracle": {
                  "value": {
                    "name": "foo",
                    "type": "oracle",
                    "pool_size": 8,
                    "server": "127.0.0.1:1521",
                    "enable": true,
                    "password": "******",
                    "username": "root",
                    "service_name": "ORCL",
                    "sql": "insert into t_mqtt_msgs(msgid, topic, qos, payload) values (${id}, ${topic}, ${qos}, ${payload})",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 8,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#",
                    "sid": "ORCL"
                  },
                  "summary": "Oracle Database Bridge"
                },
                "hstreamdb": {
                  "value": {
                    "name": "demo",
                    "stream": "stream",
                    "type": "hstreamdb",
                    "ssl": {
                      "enable": false
                    },
                    "pool_size": 8,
                    "direction": "egress",
                    "url": "http://127.0.0.1:6570",
                    "resource_opts": {
                      "batch_size": 100,
                      "query_mode": "sync",
                      "batch_time": "20ms"
                    },
                    "record_template": "{ \"temperature\": ${payload.temperature}, \"humidity\": ${payload.humidity} }"
                  },
                  "summary": "HStreamDB Bridge"
                },
                "influxdb_api_v1": {
                  "value": {
                    "name": "demo",
                    "type": "influxdb_api_v1",
                    "ssl": {
                      "enable": false
                    },
                    "server": "127.0.0.1:8086",
                    "enable": true,
                    "precision": "ms",
                    "password": "******",
                    "username": "example_username",
                    "database": "example_database",
                    "resource_opts": {
                      "batch_size": 100,
                      "batch_time": "20ms"
                    },
                    "local_topic": "local/topic/#",
                    "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,bool=${payload.bool}",
                    "influxdb_type": "influxdb_api_v1"
                  },
                  "summary": "InfluxDB HTTP API V1 Bridge"
                },
                "gcp_pubsub": {
                  "value": {
                    "service_account_json": {
                      "type": "service_account",
                      "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQI...",
                      "client_id": "123812831923812319190",
                      "project_id": "myproject",
                      "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                      "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                      "client_email": "test@myproject.iam.gserviceaccount.com",
                      "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/test%40myproject.iam.gserviceaccount.com",
                      "private_key_id": "kid",
                      "token_uri": "https://oauth2.googleapis.com/token"
                    },
                    "pubsub_topic": "mytopic"
                  },
                  "summary": "GCP PubSub Producer Bridge"
                },
                "redis_single": {
                  "value": {
                    "ssl": {
                      "enable": false
                    },
                    "pool_size": 8,
                    "server": "127.0.0.1:6379",
                    "enable": true,
                    "password": "******",
                    "database": 1,
                    "resource_opts": {
                      "batch_size": 1,
                      "batch_time": "20ms"
                    },
                    "redis_type": "single",
                    "local_topic": "local/topic/#",
                    "command_template": [
                      "LPUSH",
                      "MSGS",
                      "${payload}"
                    ]
                  },
                  "summary": "Redis Single Node Bridge"
                },
                "mqtt_example": {
                  "value": {
                    "keepalive": "300s",
                    "ssl": {
                      "enable": false
                    },
                    "server": "127.0.0.1:1883",
                    "enable": true,
                    "password": "******",
                    "username": "foo",
                    "proto_ver": "v4",
                    "clean_start": true,
                    "retry_interval": "15s",
                    "max_inflight": 100,
                    "resource_opts": {
                      "query_mode": "sync",
                      "max_buffer_bytes": 104857600,
                      "health_check_interval": "15s"
                    },
                    "ingress": {
                      "local": {
                        "retain": "${retain}",
                        "payload": "${payload}",
                        "topic": "from_aws/${topic}",
                        "qos": "${qos}"
                      },
                      "remote": {
                        "topic": "aws/#",
                        "qos": 1
                      }
                    },
                    "egress": {
                      "local": {
                        "topic": "emqx/#"
                      },
                      "remote": {
                        "retain": false,
                        "payload": "${payload}",
                        "topic": "from_emqx/${topic}",
                        "qos": "${qos}"
                      }
                    }
                  },
                  "summary": "MQTT Bridge"
                },
                "cassandra": {
                  "value": {
                    "name": "foo",
                    "type": "cassandra",
                    "pool_size": 8,
                    "enable": true,
                    "password": "******",
                    "username": "root",
                    "cql": "insert into mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic},  ${qos}, ${payload}, ${timestamp})",
                    "servers": "127.0.0.1:9042",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 8,
                      "query_mode": "sync",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#",
                    "keyspace": "mqtt"
                  },
                  "summary": "Cassandra Bridge"
                },
                "gcp_pubsub_consumer": {
                  "value": {
                    "connect_timeout": "15s",
                    "consumer": {
                      "topic_mapping": [
                        {
                          "qos": 1,
                          "mqtt_topic": "mqtt/topic/1",
                          "payload_template": "${.}",
                          "pubsub_topic": "pubsub-topic-1"
                        },
                        {
                          "qos": 2,
                          "mqtt_topic": "mqtt/topic/2",
                          "payload_template": "v = ${.value}, a = ${.attributes}, o = ${.ordering_key}",
                          "pubsub_topic": "pubsub-topic-2"
                        }
                      ],
                      "pull_max_messages": 100
                    },
                    "resource_opts": {
                      "request_ttl": "20s"
                    },
                    "service_account_json": {
                      "type": "service_account",
                      "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQI...",
                      "client_id": "123812831923812319190",
                      "project_id": "myproject",
                      "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                      "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                      "client_email": "test@myproject.iam.gserviceaccount.com",
                      "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/test%40myproject.iam.gserviceaccount.com",
                      "private_key_id": "kid",
                      "token_uri": "https://oauth2.googleapis.com/token"
                    }
                  },
                  "summary": "GCP PubSub Consumer Bridge"
                },
                "clickhouse": {
                  "value": {
                    "name": "foo",
                    "type": "clickhouse",
                    "pool_size": 8,
                    "server": "127.0.0.1:8123",
                    "enable": true,
                    "password": "******",
                    "username": "default",
                    "database": "mqtt",
                    "sql": "INSERT INTO messages(data, arrived) VALUES ('${payload}', ${timestamp})",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 8,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#",
                    "batch_value_separator": ", "
                  },
                  "summary": "Clickhouse Bridge"
                },
                "sqlserver": {
                  "value": {
                    "driver": "ms-sql",
                    "name": "bar",
                    "type": "sqlserver",
                    "pool_size": 8,
                    "server": "127.0.0.1:1433",
                    "enable": true,
                    "password": "******",
                    "username": "sa",
                    "database": "test",
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload) values ( ${id}, ${topic}, ${qos}, ${payload} )",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 1,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#"
                  },
                  "summary": "Microsoft SQL Server Bridge"
                },
                "matrix": {
                  "value": {
                    "name": "foo",
                    "type": "matrix",
                    "pool_size": 8,
                    "server": "127.0.0.1:5432",
                    "enable": true,
                    "password": "******",
                    "username": "root",
                    "database": "mqtt",
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 8,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#"
                  },
                  "summary": "Matrix Bridge"
                },
                "kafka_consumer": {
                  "value": {
                    "authentication": {
                      "mechanism": "plain",
                      "password": "******",
                      "username": "username"
                    },
                    "connect_timeout": "5s",
                    "enable": true,
                    "socket_opts": {
                      "nodelay": true,
                      "recbuf": "1024KB",
                      "sndbuf": "1024KB",
                      "tcp_keepalive": "none"
                    },
                    "kafka": {
                      "max_batch_bytes": "896KB",
                      "offset_reset_policy": "latest",
                      "offset_commit_interval_seconds": 5
                    },
                    "min_metadata_refresh_interval": "3s",
                    "topic_mapping": [
                      {
                        "qos": 1,
                        "mqtt_topic": "mqtt/topic/${.offset}",
                        "payload_template": "${.}",
                        "kafka_topic": "kafka-topic-1"
                      },
                      {
                        "qos": 2,
                        "mqtt_topic": "mqtt/topic/2",
                        "payload_template": "v = ${.value}",
                        "kafka_topic": "kafka-topic-2"
                      }
                    ],
                    "bootstrap_hosts": "localhost:9092",
                    "value_encoding_mode": "none",
                    "key_encoding_mode": "none",
                    "metadata_request_timeout": "4s"
                  },
                  "summary": "Kafka Consumer Bridge"
                },
                "rocketmq": {
                  "value": {
                    "name": "foo",
                    "type": "rocketmq",
                    "server": "127.0.0.1:9876",
                    "template": "",
                    "enable": true,
                    "topic": "TopicTest",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 1,
                      "query_mode": "sync",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#"
                  },
                  "summary": "RocketMQ Bridge"
                },
                "timescale": {
                  "value": {
                    "name": "foo",
                    "type": "timescale",
                    "pool_size": 8,
                    "server": "127.0.0.1:5432",
                    "enable": true,
                    "password": "******",
                    "username": "root",
                    "database": "mqtt",
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 8,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#"
                  },
                  "summary": "Timescale Bridge"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/bridge_kafka.put_producer"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_timescale.put"
                  },
                  {
                    "$ref": "#/components/schemas/rocketmq.put"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_kafka.put_consumer"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_matrix.put"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_sqlserver.put"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_clickhouse.put"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_gcp_pubsub.put_consumer"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_cassa.put"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_redis.put_single"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_gcp_pubsub.put_producer"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_influxdb.put_api_v1"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_hstreamdb.put"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_oracle.put"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mongodb.put_rs"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mongodb.put_sharded"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_opents.put"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_greptimedb.put_grpc_v1"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mongodb.put_single"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_tdengine.put"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_dynamo.put"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_rabbitmq.put"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mqtt.put"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_kinesis.put_producer"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mysql.put"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_redis.put_cluster"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_pgsql.put"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_pulsar.put_producer"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_redis.put_sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_azure_event_hub.put_producer"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_http.put"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_iotdb.put"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_influxdb.put_api_v2"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete a bridge by Id",
        "tags": [
          "Bridges"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge Id. Must be of format {type}:{name}",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:http_example"
          }
        ],
        "summary": "Delete bridge",
        "responses": {
          "204": {
            "description": "Bridge deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "rules": {
                      "type": "array",
                      "description": "Dependent Rule IDs",
                      "items": {
                        "type": "string"
                      }
                    },
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Cannot delete bridge while active rules are defined for this bridge"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bridge not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Service unavailable"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/configs/dashboard": {
      "get": {
        "description": "Get the sub-configurations under *dashboard*",
        "tags": [
          "Configs"
        ],
        "parameters": [],
        "summary": "Get the sub-configurations under *dashboard*",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/dashboard.dashboard"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "config not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update the sub-configurations under *dashboard*",
        "tags": [
          "Configs"
        ],
        "parameters": [],
        "summary": "Update the sub-configurations under *dashboard*",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/dashboard.dashboard"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UPDATE_FAILED",
                        "INVALID_CONFIG"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "403": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UPDATE_FAILED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/dashboard.dashboard"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/{name}/clients/{clientid}/subscriptions": {
      "get": {
        "description": "Get the gateway client subscriptions",
        "tags": [
          "Gateway Clients"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "description": "Client ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "gbt32960",
                "jt808",
                "lwm2m",
                "mqttsn",
                "ocpp",
                "stomp"
              ]
            }
          }
        ],
        "summary": "List client's subscription",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "general_subscription_list": {
                    "value": [
                      {
                        "nl": 0,
                        "topic": "test/topic",
                        "qos": 1,
                        "rap": 0,
                        "rh": 0
                      }
                    ],
                    "summary": "A general subscription list"
                  },
                  "stomp_subscription_list": {
                    "value": [
                      "example_stomp_subscription"
                    ],
                    "summary": "The STOMP subscription list"
                  }
                },
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/emqx_gateway_api_clients.subscription"
                  }
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Create a subscription membership",
        "tags": [
          "Gateway Clients"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "description": "Client ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "gbt32960",
                "jt808",
                "lwm2m",
                "mqttsn",
                "ocpp",
                "stomp"
              ]
            }
          }
        ],
        "summary": "Add subscription for client",
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "general_subscription": {
                    "value": {
                      "nl": 0,
                      "topic": "test/topic",
                      "qos": 1,
                      "rap": 0,
                      "rh": 0
                    },
                    "summary": "A general subscription"
                  },
                  "stomp_subscription": {
                    "value": {
                      "nl": 0,
                      "topic": "stomp/topic",
                      "qos": 1,
                      "sub_props": {
                        "subid": "10"
                      },
                      "rap": 0,
                      "rh": 0
                    },
                    "summary": "A STOMP subscription"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_gateway_api_clients.subscription"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "general_subscription": {
                  "value": {
                    "nl": 0,
                    "topic": "test/topic",
                    "qos": 1,
                    "rap": 0,
                    "rh": 0
                  },
                  "summary": "A general subscription"
                },
                "stomp_subscription": {
                  "value": {
                    "nl": 0,
                    "topic": "stomp/topic",
                    "qos": 1,
                    "sub_props": {
                      "subid": "10"
                    },
                    "rap": 0,
                    "rh": 0
                  },
                  "summary": "A STOMP subscription"
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_gateway_api_clients.subscription"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/cluster/{node}/invite": {
      "put": {
        "description": "Invite node to cluster",
        "tags": [
          "Cluster"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/cluster.node"
          }
        ],
        "responses": {
          "200": {
            "description": "ok"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/cluster.timeout"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/load_rebalance/{node}/stop": {
      "post": {
        "description": "Stop rebalance process",
        "tags": [
          "Load Rebalance"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "node",
            "description": "Node name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "summary": "Stop rebalancing coordinated by the node",
        "responses": {
          "200": {
            "description": "The response is empty",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "example": {}
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/message_transformations/transformation/{name}": {
      "get": {
        "description": "Lookup a transformation",
        "tags": [
          "Message Transformation"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Transformation name",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "my_transformation"
          }
        ],
        "summary": "Lookup a transformation",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "message_transformation": {
                    "value": {
                      "name": "my_transformation",
                      "description": "my transformation",
                      "tags": [
                        "transformation"
                      ],
                      "enable": true,
                      "topics": [
                        "t/+"
                      ],
                      "operations": [
                        {
                          "value": "concat([topic, '/', payload.t])",
                          "key": "topic"
                        }
                      ],
                      "failure_action": "drop",
                      "log_failure": {
                        "level": "info"
                      },
                      "payload_encoder": {
                        "type": "json"
                      },
                      "payload_decoder": {
                        "type": "json"
                      }
                    },
                    "summary": "Simple message transformation"
                  }
                },
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/message_transformation.transformation"
                  }
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Transformation not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete a transformation",
        "tags": [
          "Message Transformation"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Transformation name",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "my_transformation"
          }
        ],
        "summary": "Delete a transformation",
        "responses": {
          "204": {
            "description": "Transformation deleted"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Transformation not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/cluster/topology": {
      "get": {
        "description": "Get RLOG cluster topology: connections between core and replicant nodes.",
        "tags": [
          "Cluster"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Cluster topology",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/cluster.core_replicants"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/mqtt/retainer/messages": {
      "get": {
        "description": "List retained messages.",
        "tags": [
          "Retainer"
        ],
        "parameters": [
          {
            "in": "query",
            "name": "topic",
            "description": "Topic filter, supports wildcards, omit this to match all messages.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "page",
            "description": "Page number of the results to fetch.",
            "schema": {
              "default": 1,
              "type": "integer",
              "minimum": 1
            },
            "example": 1
          },
          {
            "in": "query",
            "name": "limit",
            "description": "Results per page(max 10000)",
            "schema": {
              "default": 100,
              "maximum": 10000,
              "type": "integer",
              "minimum": 1
            },
            "example": 50
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "data": {
                      "type": "array",
                      "description": "Retained messages list.",
                      "items": {
                        "$ref": "#/components/schemas/retainer.message_summary"
                      }
                    },
                    "meta": {
                      "$ref": "#/components/schemas/public.meta"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Unsupported backend."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete all retained messages",
        "tags": [
          "Retainer"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": ""
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/plugins/{name}/move": {
      "post": {
        "description": "Setting the boot order of plugins.",
        "tags": [
          "Plugins"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/plugins.name"
          }
        ],
        "summary": "Move plugin within plugin hierarchy",
        "responses": {
          "204": {
            "description": "Boot order changed successfully"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "MOVE_FAILED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Move failed"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "move_to_after": {
                  "value": {
                    "position": "after:emqx_plugin_demo-5.1-rc.2"
                  },
                  "summary": "move plugin after other plugins"
                },
                "move_to_before": {
                  "value": {
                    "position": "before:emqx_plugin_demo-5.1-rc.2"
                  },
                  "summary": "move plugin before other plugins"
                },
                "move_to_front": {
                  "value": {
                    "position": "front"
                  },
                  "summary": "move plugin on the front"
                },
                "move_to_rear": {
                  "value": {
                    "position": "rear"
                  },
                  "summary": "move plugin on the rear"
                }
              },
              "schema": {
                "$ref": "#/components/schemas/plugins.position"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/configs/broker": {
      "get": {
        "description": "Get the sub-configurations under *broker*",
        "tags": [
          "Configs"
        ],
        "parameters": [],
        "summary": "Get the sub-configurations under *broker*",
        "responses": {
          "200": {
            "description": "Message broker options.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx.broker"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "config not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update the sub-configurations under *broker*",
        "tags": [
          "Configs"
        ],
        "parameters": [],
        "summary": "Update the sub-configurations under *broker*",
        "responses": {
          "200": {
            "description": "Message broker options.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx.broker"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UPDATE_FAILED",
                        "INVALID_CONFIG"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "403": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UPDATE_FAILED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx.broker"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/alarms": {
      "get": {
        "description": "List currently activated alarms or historical alarms, determined by query parameters.",
        "tags": [
          "Alarms"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          },
          {
            "in": "query",
            "name": "activated",
            "description": "It is used to specify the alarm type of the query.<br/>When true, it returns the currently activated alarm,<br/>and when it is false, it returns the historical alarm.<br/>The default is false.",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "data": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/emqx_mgmt_api_alarms.alarm"
                      }
                    },
                    "meta": {
                      "$ref": "#/components/schemas/public.meta"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Remove all historical alarms.",
        "tags": [
          "Alarms"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": "Historical alarms have been cleared successfully."
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/authorization/sources/built_in_database/rules/users/{username}": {
      "get": {
        "description": "Get rule for 'username'",
        "tags": [
          "Authorization"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_authz_api_mnesia.username"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "password_based:built_in_database": {
                    "value": {
                      "rules": [
                        {
                          "action": "publish",
                          "permission": "allow",
                          "topic": "test/topic/1"
                        },
                        {
                          "action": "subscribe",
                          "permission": "allow",
                          "topic": "test/topic/2"
                        },
                        {
                          "action": "all",
                          "permission": "deny",
                          "topic": "eq test/#"
                        },
                        {
                          "action": "publish",
                          "retain": "true",
                          "permission": "allow",
                          "topic": "test/topic/3",
                          "qos": [
                            "1"
                          ]
                        },
                        {
                          "action": "publish",
                          "retain": "all",
                          "permission": "allow",
                          "topic": "test/topic/4",
                          "qos": [
                            "0",
                            "1",
                            "2"
                          ]
                        }
                      ],
                      "username": "user1"
                    },
                    "summary": "Username"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authz_api_mnesia.rules_for_username"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Set rule for 'username'",
        "tags": [
          "Authorization"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_authz_api_mnesia.username"
          }
        ],
        "responses": {
          "204": {
            "description": "Updated"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad username or bad rule schema"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "password_based:built_in_database": {
                  "value": {
                    "rules": [
                      {
                        "action": "publish",
                        "permission": "allow",
                        "topic": "test/topic/1"
                      },
                      {
                        "action": "subscribe",
                        "permission": "allow",
                        "topic": "test/topic/2"
                      },
                      {
                        "action": "all",
                        "permission": "deny",
                        "topic": "eq test/#"
                      },
                      {
                        "action": "publish",
                        "retain": "true",
                        "permission": "allow",
                        "topic": "test/topic/3",
                        "qos": [
                          "1"
                        ]
                      },
                      {
                        "action": "publish",
                        "retain": "all",
                        "permission": "allow",
                        "topic": "test/topic/4",
                        "qos": [
                          "0",
                          "1",
                          "2"
                        ]
                      }
                    ],
                    "username": "user1"
                  },
                  "summary": "Username"
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authz_api_mnesia.rules_for_username"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete rule for 'username'",
        "tags": [
          "Authorization"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_authz_api_mnesia.username"
          }
        ],
        "responses": {
          "204": {
            "description": "Deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad username"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Username Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/sso/saml/metadata": {
      "get": {
        "tags": [
          "Dashboard Single Sign-On"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "token": {
                      "type": "string",
                      "description": "Dashboard Auth Token"
                    },
                    "version": {
                      "type": "string",
                      "description": "EMQX Version",
                      "example": "5.0.0"
                    },
                    "license": {
                      "properties": {
                        "edition": {
                          "type": "string",
                          "enum": [
                            "opensource",
                            "enterprise"
                          ],
                          "description": "EMQX License. opensource or enterprise",
                          "example": "opensource"
                        }
                      },
                      "type": "object"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BACKEND_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "requestbody": {
          "content": {
            "application/xml": {
              "schema": {
                "type": "string",
                "format": "binary"
              }
            }
          }
        }
      }
    },
    "/sso/login/{backend}": {
      "post": {
        "tags": [
          "Dashboard Single Sign-On"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "backend",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "ldap",
                "oidc",
                "saml"
              ]
            },
            "example": "ldap"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "role": {
                      "default": "administrator",
                      "type": "string",
                      "description": "User role",
                      "example": "administrator"
                    },
                    "token": {
                      "type": "string",
                      "description": "Dashboard Auth Token"
                    },
                    "version": {
                      "type": "string",
                      "description": "EMQX Version",
                      "example": "5.0.0"
                    },
                    "license": {
                      "properties": {
                        "edition": {
                          "type": "string",
                          "enum": [
                            "opensource",
                            "enterprise"
                          ],
                          "description": "EMQX License. opensource or enterprise",
                          "example": "opensource"
                        }
                      },
                      "type": "object"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "302": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "REDIRECT"
                      ]
                    },
                    "message": {
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "401": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_USERNAME_OR_PWD"
                      ]
                    },
                    "message": {
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BACKEND_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/dashboard.login"
                  },
                  {
                    "$ref": "#/components/schemas/sso.login"
                  },
                  {
                    "$ref": "#/components/schemas/sso.login"
                  }
                ]
              }
            }
          }
        },
        "security": []
      }
    },
    "/ds/storages": {
      "get": {
        "description": "List durable storages",
        "tags": [
          "Durable storage"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "List durable storages",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Durable storage is disabled"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/subscriptions": {
      "get": {
        "description": "List subscriptions",
        "tags": [
          "Subscriptions"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          },
          {
            "in": "query",
            "name": "node",
            "description": "Node name",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "emqx@127.0.0.1"
          },
          {
            "in": "query",
            "name": "clientid",
            "description": "Client ID",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "qos",
            "description": "QoS",
            "required": false,
            "schema": {
              "maximum": 2,
              "type": "integer",
              "minimum": 0,
              "example": 0
            }
          },
          {
            "in": "query",
            "name": "topic",
            "description": "Topic, url encoding",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "match_topic",
            "description": "Match topic string, url encoding",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "share_group",
            "description": "Shared subscription group name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "durable",
            "description": "Filter subscriptions by durability",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/emqx_mgmt_api_subscriptions.subscription"
                  }
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "INVALID_PARAMETER"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Invalid parameter"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "500": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NODE_DOWN"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad RPC"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/ds/sites": {
      "get": {
        "description": "List sites",
        "tags": [
          "Durable storage"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "List sites",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Durable storage is disabled"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/error_codes": {
      "get": {
        "description": "API Error Codes",
        "tags": [
          "Error Codes"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/dashboard.error_code"
                  }
                }
              }
            }
          }
        },
        "security": []
      }
    },
    "/authorization/sources/built_in_database/rules": {
      "delete": {
        "description": "Delete all rules for all 'users', 'clients' and 'all'",
        "tags": [
          "Authorization"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": "Deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/authorization/sources/{type}/move": {
      "post": {
        "description": "Change the exection order of sources",
        "tags": [
          "Authorization"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "type",
            "description": "Authorization type",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "file",
                "built_in_database",
                "http",
                "redis",
                "mysql",
                "postgresql",
                "mongodb",
                "ldap"
              ]
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "front": {
                  "value": {
                    "position": "front"
                  },
                  "summary": "front example"
                },
                "rear": {
                  "value": {
                    "position": "rear"
                  },
                  "summary": "rear example"
                },
                "relative_after": {
                  "value": {
                    "position": "after:file"
                  },
                  "summary": "relative example"
                },
                "relative_before": {
                  "value": {
                    "position": "before:file"
                  },
                  "summary": "relative example"
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authz_api_sources.position"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/{name}/listeners/{id}/authentication/users/{uid}": {
      "get": {
        "description": "Get user info from the gateway authenticator (only supports built_in_database)",
        "tags": [
          "Gateway Listeners"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "gbt32960",
                "jt808",
                "lwm2m",
                "mqttsn",
                "ocpp",
                "stomp"
              ]
            },
            "example": "stomp"
          },
          {
            "in": "path",
            "name": "id",
            "description": "Listener ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": ""
          },
          {
            "in": "path",
            "name": "uid",
            "description": "User ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": ""
          }
        ],
        "summary": "Get user info",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "regular_user": {
                    "value": {
                      "user_id": "user1"
                    },
                    "summary": "Regular user"
                  },
                  "super_user": {
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    },
                    "summary": "Superuser"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update the user info for the gateway authenticator (only supports built_in_database)",
        "tags": [
          "Gateway Listeners"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "gbt32960",
                "jt808",
                "lwm2m",
                "mqttsn",
                "ocpp",
                "stomp"
              ]
            },
            "example": "stomp"
          },
          {
            "in": "path",
            "name": "id",
            "description": "Listener ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": ""
          },
          {
            "in": "path",
            "name": "uid",
            "description": "User ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": ""
          }
        ],
        "summary": "Update user info",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "regular_user": {
                    "value": {
                      "user_id": "user1"
                    },
                    "summary": "Regular user"
                  },
                  "super_user": {
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    },
                    "summary": "Superuser"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "regular_user": {
                  "value": {
                    "password": "******"
                  },
                  "summary": "Update regular user"
                },
                "super_user": {
                  "value": {
                    "password": "******",
                    "is_superuser": true
                  },
                  "summary": "Update user and promote to superuser"
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authn_api.request_user_update"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete the user for the gateway authenticator (only supports built_in_database)",
        "tags": [
          "Gateway Listeners"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "gbt32960",
                "jt808",
                "lwm2m",
                "mqttsn",
                "ocpp",
                "stomp"
              ]
            },
            "example": "stomp"
          },
          {
            "in": "path",
            "name": "id",
            "description": "Listener ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": ""
          },
          {
            "in": "path",
            "name": "uid",
            "description": "User ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": ""
          }
        ],
        "summary": "Delete user",
        "responses": {
          "204": {
            "description": "Deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/authentication": {
      "get": {
        "description": "List authenticators for global authentication.",
        "tags": [
          "Authentication"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": [
                  {
                    "mechanism": "jwt",
                    "secret": "mysecret",
                    "algorithm": "hmac-based",
                    "secret_base64_encoded": false,
                    "use_jwks": false,
                    "verify_claims": {
                      "username": "${username}"
                    }
                  },
                  {
                    "mechanism": "password_based",
                    "backend": "built_in_database",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "user_id_type": "username"
                  },
                  {
                    "ssl": {
                      "enable": false
                    },
                    "connect_timeout": "5s",
                    "mechanism": "password_based",
                    "pool_size": 8,
                    "body": {
                      "password": "${password}",
                      "username": "${username}"
                    },
                    "headers": {
                      "content-type": "application/json"
                    },
                    "url": "http://127.0.0.1:18083",
                    "method": "post",
                    "backend": "http",
                    "request_timeout": "5s",
                    "enable_pipelining": 100
                  },
                  {
                    "mechanism": "password_based",
                    "filter": {
                      "username": "${username}"
                    },
                    "server": "127.0.0.1:27017",
                    "database": "example",
                    "backend": "mongodb",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "collection": "users",
                    "is_superuser_field": "is_superuser",
                    "password_hash_field": "password_hash",
                    "salt_field": "salt"
                  },
                  {
                    "mechanism": "password_based",
                    "cmd": "HMGET ${username} password_hash salt",
                    "server": "127.0.0.1:6379",
                    "database": 0,
                    "backend": "redis",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "redis_type": "single"
                  }
                ],
                "schema": {
                  "type": "array",
                  "items": {
                    "oneOf": [
                      {
                        "$ref": "#/components/schemas/authn.kerberos"
                      },
                      {
                        "$ref": "#/components/schemas/authn.scram_restapi_post"
                      },
                      {
                        "$ref": "#/components/schemas/authn.scram_restapi_get"
                      },
                      {
                        "$ref": "#/components/schemas/authn.gcp_device"
                      },
                      {
                        "$ref": "#/components/schemas/authn.ldap_deprecated"
                      },
                      {
                        "$ref": "#/components/schemas/authn.ldap"
                      },
                      {
                        "$ref": "#/components/schemas/authn.scram"
                      },
                      {
                        "$ref": "#/components/schemas/authn.jwt_jwks"
                      },
                      {
                        "$ref": "#/components/schemas/authn.jwt_public_key"
                      },
                      {
                        "$ref": "#/components/schemas/authn.jwt_hmac"
                      },
                      {
                        "$ref": "#/components/schemas/authn.http_post"
                      },
                      {
                        "$ref": "#/components/schemas/authn.http_get"
                      },
                      {
                        "$ref": "#/components/schemas/authn.redis_sentinel"
                      },
                      {
                        "$ref": "#/components/schemas/authn.redis_cluster"
                      },
                      {
                        "$ref": "#/components/schemas/authn.redis_single"
                      },
                      {
                        "$ref": "#/components/schemas/authn.mongo_sharded"
                      },
                      {
                        "$ref": "#/components/schemas/authn.mongo_rs"
                      },
                      {
                        "$ref": "#/components/schemas/authn.mongo_single"
                      },
                      {
                        "$ref": "#/components/schemas/authn.postgresql"
                      },
                      {
                        "$ref": "#/components/schemas/authn.mysql"
                      },
                      {
                        "$ref": "#/components/schemas/authn.builtin_db"
                      }
                    ]
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Create authenticator for global authentication.",
        "tags": [
          "Authentication"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "jwt": {
                    "value": {
                      "mechanism": "jwt",
                      "secret": "mysecret",
                      "algorithm": "hmac-based",
                      "secret_base64_encoded": false,
                      "use_jwks": false,
                      "verify_claims": {
                        "username": "${username}"
                      }
                    },
                    "summary": "JWT authentication"
                  },
                  "password_based:built_in_database": {
                    "value": {
                      "mechanism": "password_based",
                      "backend": "built_in_database",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "user_id_type": "username"
                    },
                    "summary": "Built-in password_based authentication"
                  },
                  "password_based:http": {
                    "value": {
                      "ssl": {
                        "enable": false
                      },
                      "connect_timeout": "5s",
                      "mechanism": "password_based",
                      "pool_size": 8,
                      "body": {
                        "password": "${password}",
                        "username": "${username}"
                      },
                      "headers": {
                        "content-type": "application/json"
                      },
                      "url": "http://127.0.0.1:18083",
                      "method": "post",
                      "backend": "http",
                      "request_timeout": "5s",
                      "enable_pipelining": 100
                    },
                    "summary": "password_based authentication through external HTTP API"
                  },
                  "password_based:mongodb": {
                    "value": {
                      "mechanism": "password_based",
                      "filter": {
                        "username": "${username}"
                      },
                      "server": "127.0.0.1:27017",
                      "database": "example",
                      "backend": "mongodb",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "collection": "users",
                      "is_superuser_field": "is_superuser",
                      "password_hash_field": "password_hash",
                      "salt_field": "salt"
                    },
                    "summary": "password_based authentication with MongoDB backend"
                  },
                  "password_based:redis": {
                    "value": {
                      "mechanism": "password_based",
                      "cmd": "HMGET ${username} password_hash salt",
                      "server": "127.0.0.1:6379",
                      "database": 0,
                      "backend": "redis",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "redis_type": "single"
                    },
                    "summary": "password_based authentication with Redis backend"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authn.kerberos"
                    },
                    {
                      "$ref": "#/components/schemas/authn.scram_restapi_post"
                    },
                    {
                      "$ref": "#/components/schemas/authn.scram_restapi_get"
                    },
                    {
                      "$ref": "#/components/schemas/authn.gcp_device"
                    },
                    {
                      "$ref": "#/components/schemas/authn.ldap_deprecated"
                    },
                    {
                      "$ref": "#/components/schemas/authn.ldap"
                    },
                    {
                      "$ref": "#/components/schemas/authn.scram"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_jwks"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_public_key"
                    },
                    {
                      "$ref": "#/components/schemas/authn.jwt_hmac"
                    },
                    {
                      "$ref": "#/components/schemas/authn.http_post"
                    },
                    {
                      "$ref": "#/components/schemas/authn.http_get"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn.redis_single"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_sharded"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_rs"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mongo_single"
                    },
                    {
                      "$ref": "#/components/schemas/authn.postgresql"
                    },
                    {
                      "$ref": "#/components/schemas/authn.mysql"
                    },
                    {
                      "$ref": "#/components/schemas/authn.builtin_db"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "409": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "ALREADY_EXISTS"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "ALREADY_EXISTS"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "jwt": {
                  "value": {
                    "mechanism": "jwt",
                    "secret": "mysecret",
                    "algorithm": "hmac-based",
                    "secret_base64_encoded": false,
                    "use_jwks": false,
                    "verify_claims": {
                      "username": "${username}"
                    }
                  },
                  "summary": "JWT authentication"
                },
                "password_based:built_in_database": {
                  "value": {
                    "mechanism": "password_based",
                    "backend": "built_in_database",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "user_id_type": "username"
                  },
                  "summary": "Built-in password_based authentication"
                },
                "password_based:http": {
                  "value": {
                    "ssl": {
                      "enable": false
                    },
                    "connect_timeout": "5s",
                    "mechanism": "password_based",
                    "pool_size": 8,
                    "body": {
                      "password": "${password}",
                      "username": "${username}"
                    },
                    "headers": {
                      "content-type": "application/json"
                    },
                    "url": "http://127.0.0.1:18083",
                    "method": "post",
                    "backend": "http",
                    "request_timeout": "5s",
                    "enable_pipelining": 100
                  },
                  "summary": "password_based authentication through external HTTP API"
                },
                "password_based:mongodb": {
                  "value": {
                    "mechanism": "password_based",
                    "filter": {
                      "username": "${username}"
                    },
                    "server": "127.0.0.1:27017",
                    "database": "example",
                    "backend": "mongodb",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "collection": "users",
                    "is_superuser_field": "is_superuser",
                    "password_hash_field": "password_hash",
                    "salt_field": "salt"
                  },
                  "summary": "password_based authentication with MongoDB backend"
                },
                "password_based:redis": {
                  "value": {
                    "mechanism": "password_based",
                    "cmd": "HMGET ${username} password_hash salt",
                    "server": "127.0.0.1:6379",
                    "database": 0,
                    "backend": "redis",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "redis_type": "single"
                  },
                  "summary": "password_based authentication with Redis backend"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/authn.kerberos"
                  },
                  {
                    "$ref": "#/components/schemas/authn.scram_restapi_post"
                  },
                  {
                    "$ref": "#/components/schemas/authn.scram_restapi_get"
                  },
                  {
                    "$ref": "#/components/schemas/authn.gcp_device"
                  },
                  {
                    "$ref": "#/components/schemas/authn.ldap_deprecated"
                  },
                  {
                    "$ref": "#/components/schemas/authn.ldap"
                  },
                  {
                    "$ref": "#/components/schemas/authn.scram"
                  },
                  {
                    "$ref": "#/components/schemas/authn.jwt_jwks"
                  },
                  {
                    "$ref": "#/components/schemas/authn.jwt_public_key"
                  },
                  {
                    "$ref": "#/components/schemas/authn.jwt_hmac"
                  },
                  {
                    "$ref": "#/components/schemas/authn.http_post"
                  },
                  {
                    "$ref": "#/components/schemas/authn.http_get"
                  },
                  {
                    "$ref": "#/components/schemas/authn.redis_sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/authn.redis_cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn.redis_single"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mongo_sharded"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mongo_rs"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mongo_single"
                  },
                  {
                    "$ref": "#/components/schemas/authn.postgresql"
                  },
                  {
                    "$ref": "#/components/schemas/authn.mysql"
                  },
                  {
                    "$ref": "#/components/schemas/authn.builtin_db_api"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/clients/{clientid}/subscribe": {
      "post": {
        "description": "Subscribe",
        "tags": [
          "Clients"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_subscriptions.subscription"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "CLIENTID_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Client ID not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx_mgmt_api_clients.subscribe"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/trace": {
      "get": {
        "description": "List all trace",
        "tags": [
          "Trace"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/trace.trace"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Clear all traces",
        "tags": [
          "Trace"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": "No Content"
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Create new trace",
        "tags": [
          "Trace"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/trace.trace"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "INVALID_PARAMS"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "invalid trace params"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "409": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "ALREADY_EXISTS",
                        "DUPLICATE_CONDITION",
                        "BAD_TYPE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "trace already exists"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "required": [
                  "name",
                  "type"
                ],
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Unique name of the trace. Only ASCII letters in a-z, A-Z, 0-9 and underscore '_' are allowed.",
                    "example": "EMQX-TRACE-1"
                  },
                  "type": {
                    "type": "string",
                    "enum": [
                      "clientid",
                      "topic",
                      "ip_address",
                      "ruleid"
                    ],
                    "description": "Filter type",
                    "example": "clientid"
                  },
                  "topic": {
                    "type": "string",
                    "description": "Specify the topic or topic filter if the trace 'type' is 'topic'.",
                    "example": "/dev/#"
                  },
                  "clientid": {
                    "type": "string",
                    "description": "Specify the MQTT clientid if the trace 'type' is 'clientid'.",
                    "example": "dev-001"
                  },
                  "ip_address": {
                    "type": "string",
                    "description": "Specify the client's IP address if the trace type is 'ip_address'.",
                    "example": "127.0.0.1"
                  },
                  "ruleid": {
                    "type": "string",
                    "example": "my_rule"
                  },
                  "payload_encode": {
                    "default": "text",
                    "type": "string",
                    "enum": [
                      "hex",
                      "text",
                      "hidden"
                    ],
                    "description": "Determine the format of the payload format in the trace file.<br/><br/>`text`: Text-based protocol or plain text protocol.<br/> It is recommended when payload is JSON encoded.<br/><br/>`hex`: Binary hexadecimal encode.It is recommended when payload is a custom binary protocol.<br/><br/>`hidden`: payload is obfuscated as `******`"
                  },
                  "start_at": {
                    "description": "rfc3339 timestamp or epoch second",
                    "example": "2021-11-04T18:17:38+08:00",
                    "oneOf": [
                      {
                        "type": "integer",
                        "description": "epoch-second",
                        "example": 1640995200
                      },
                      {
                        "type": "string",
                        "format": "date-time",
                        "example": "2022-01-01T00:00:00.000Z"
                      }
                    ]
                  },
                  "end_at": {
                    "description": "rfc3339 timestamp or epoch second",
                    "example": "2021-11-05T18:17:38+08:00",
                    "oneOf": [
                      {
                        "type": "integer",
                        "description": "epoch-second",
                        "example": 1640995200
                      },
                      {
                        "type": "string",
                        "format": "date-time",
                        "example": "2022-01-01T00:00:00.000Z"
                      }
                    ]
                  },
                  "formatter": {
                    "description": "The formatter that will be used to format the trace log entries. Set this to text to format the log entries as plain text (default). Set it to json to format each log entry as a JSON object.",
                    "example": "text",
                    "oneOf": [
                      {
                        "type": "string",
                        "enum": [
                          "json"
                        ]
                      },
                      {
                        "type": "string",
                        "enum": [
                          "text"
                        ]
                      }
                    ]
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/nodes/{node}/connectors/{id}/{operation}": {
      "post": {
        "description": "Start connector on a specific node.",
        "tags": [
          "Connectors"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "node",
            "description": "The node name, e.g. 'emqx@127.0.0.1'.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "emqx@127.0.0.1"
          },
          {
            "in": "path",
            "name": "id",
            "description": "The connector id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_connector"
          },
          {
            "in": "path",
            "name": "operation",
            "description": "Operation can be one of: 'start'.",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "start"
              ]
            },
            "example": "start"
          }
        ],
        "summary": "Manually start a connector on a given node",
        "responses": {
          "204": {
            "description": "Operation success"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Problem with configuration of external service or connector not enabled"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Connector or node not found or invalid operation"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "501": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_IMPLEMENTED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Implemented"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Service unavailable"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/prometheus/message_transformation": {
      "get": {
        "description": "Get Prometheus Metrics for Message Validation",
        "tags": [
          "Monitor"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_prometheus_api.mode"
          }
        ],
        "responses": {
          "200": {
            "description": "Get Prometheus Data.",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          }
        },
        "security": []
      }
    },
    "/clients/{clientid}/mqueue_messages": {
      "get": {
        "description": "Get client mqueue messages",
        "tags": [
          "Clients"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "payload",
            "description": "Client's inflight/mqueue messages payload encoding. If set to `none`, no payload is returned in the response.",
            "schema": {
              "default": "base64",
              "type": "string",
              "enum": [
                "none",
                "base64",
                "plain"
              ]
            }
          },
          {
            "in": "query",
            "name": "max_payload_bytes",
            "description": "Client's inflight/mqueue messages payload limit. The total payload size of all messages in the response will not exceed this value. Messages beyond the limit will be silently omitted in the response. The only exception to this rule is when the first message payload is already larger than the limit. In this case, the first message will be returned in the response.",
            "schema": {
              "default": "1MB",
              "type": "string",
              "example": "32MB"
            }
          },
          {
            "$ref": "#/components/parameters/public.position"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "data": [
                    {
                      "from_clientid": "mqttx_59ac0a87",
                      "from_username": "test-user",
                      "mqueue_priority": 0,
                      "msgid": "000611F460D57FA9F44500000D360002",
                      "payload": "eyJmb28iOiAiYmFyIn0=",
                      "publish_at": 1709055346487,
                      "qos": 0,
                      "topic": "t/test"
                    }
                  ],
                  "meta": {
                    "count": 100,
                    "last": "1710785444656449826_10"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_clients.mqueue_messages"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "INVALID_PARAMETER"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Invalid parameters"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "CLIENTID_NOT_FOUND",
                        "CLIENT_SHUTDOWN"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Client ID not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "501": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_IMPLEMENTED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "API not implemented"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/actions_probe": {
      "post": {
        "description": "Test creating a new bridge.",
        "tags": [
          "Actions"
        ],
        "parameters": [],
        "summary": "Test creating bridge",
        "responses": {
          "204": {
            "description": "Test bridge OK"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "TEST_FAILED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "bridge test failed"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "http": {
                  "value": {
                    "name": "my_http_action",
                    "type": "http",
                    "enable": true,
                    "parameters": {
                      "path": "/room/${room_no}",
                      "body": "${.}",
                      "headers": {},
                      "method": "post"
                    },
                    "connector": "my_http_connector",
                    "resource_opts": {
                      "worker_pool_size": 16,
                      "query_mode": "async",
                      "health_check_interval": "15s"
                    }
                  },
                  "summary": "HTTP Action"
                },
                "confluent_producer": {
                  "value": {
                    "name": "my_confluent_producer_action",
                    "type": "confluent_producer",
                    "enable": true,
                    "parameters": {
                      "message": {
                        "value": "${.}",
                        "key": "${.clientid}"
                      },
                      "buffer": {
                        "mode": "hybrid",
                        "memory_overload_protection": true,
                        "segment_bytes": "100MB",
                        "per_partition_limit": "2GB"
                      },
                      "topic": "topic",
                      "max_inflight": 10,
                      "required_acks": "all_isr",
                      "max_batch_bytes": "896KB",
                      "partition_count_refresh_interval": "60s",
                      "kafka_header_value_encode_mode": "none",
                      "kafka_ext_headers": [
                        {
                          "kafka_ext_header_value": "${clientid}",
                          "kafka_ext_header_key": "clientid"
                        },
                        {
                          "kafka_ext_header_value": "${topic}",
                          "kafka_ext_header_key": "topic"
                        }
                      ],
                      "kafka_headers": "${.pub_props}",
                      "partition_strategy": "random"
                    },
                    "connector": "my_confluent_producer_connector",
                    "local_topic": "mqtt/local/topic"
                  },
                  "summary": "Confluent Action"
                },
                "iotdb": {
                  "value": {
                    "name": "iotdb_action",
                    "type": "iotdb",
                    "description": "My example iotdb action",
                    "enable": true,
                    "parameters": {
                      "data": [
                        {
                          "timestamp": "now",
                          "value": "${st}",
                          "data_type": "BOOLEAN",
                          "measurement": "status"
                        }
                      ],
                      "device_id": "my_device",
                      "is_aligned": false
                    },
                    "connector": "iotdb_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "Apache IoTDB Bridge"
                },
                "direct_azure_blob_storage": {
                  "value": {
                    "name": "my_action",
                    "type": "azure_blob_storage",
                    "description": "my action",
                    "enable": true,
                    "parameters": {
                      "mode": "direct",
                      "content": "${.payload}",
                      "blob": "${.payload.blob}",
                      "container": "${.payload.container}"
                    },
                    "connector": "my_connector",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 16,
                      "query_mode": "sync",
                      "batch_time": "0ms",
                      "inflight_window": 100,
                      "request_ttl": "45s",
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "Azure Blob Storage Direct Upload Action"
                },
                "couchbase": {
                  "value": {
                    "name": "my_action",
                    "type": "couchbase",
                    "description": "my action",
                    "enable": true,
                    "parameters": {
                      "sql": "insert into mqtt (key, value) values (${.id}, ${.payload})"
                    },
                    "connector": "my_connector",
                    "resource_opts": {
                      "worker_pool_size": 16,
                      "query_mode": "sync",
                      "inflight_window": 100,
                      "request_ttl": "45s",
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "Couchbase Action"
                },
                "datalayers": {
                  "value": {
                    "name": "datalayers_action",
                    "type": "datalayers",
                    "description": "My example datalayers action",
                    "enable": true,
                    "parameters": {
                      "precision": "ms",
                      "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,bool=${payload.bool}"
                    },
                    "connector": "datalayers_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "Datalayers Action"
                },
                "azure_event_hub_producer": {
                  "value": {
                    "name": "my_azure_event_hub_producer_action",
                    "type": "azure_event_hub_producer",
                    "enable": true,
                    "parameters": {
                      "message": {
                        "value": "${.}",
                        "key": "${.clientid}"
                      },
                      "buffer": {
                        "mode": "hybrid",
                        "memory_overload_protection": true,
                        "segment_bytes": "100MB",
                        "per_partition_limit": "2GB"
                      },
                      "topic": "topic",
                      "max_inflight": 10,
                      "required_acks": "all_isr",
                      "max_batch_bytes": "896KB",
                      "partition_count_refresh_interval": "60s",
                      "kafka_header_value_encode_mode": "none",
                      "kafka_ext_headers": [
                        {
                          "kafka_ext_header_value": "${clientid}",
                          "kafka_ext_header_key": "clientid"
                        },
                        {
                          "kafka_ext_header_value": "${topic}",
                          "kafka_ext_header_key": "topic"
                        }
                      ],
                      "kafka_headers": "${.pub_props}",
                      "partition_strategy": "random"
                    },
                    "connector": "my_azure_event_hub_producer_connector",
                    "local_topic": "mqtt/local/topic"
                  },
                  "summary": "Azure Event Hub Action"
                },
                "kafka_producer": {
                  "value": {
                    "name": "my_kafka_producer_action",
                    "type": "kafka_producer",
                    "enable": true,
                    "parameters": {
                      "message": {
                        "timestamp": "${.timestamp}",
                        "value": "${.}",
                        "key": "${.clientid}"
                      },
                      "buffer": {
                        "mode": "hybrid",
                        "memory_overload_protection": true,
                        "segment_bytes": "100MB",
                        "per_partition_limit": "2GB"
                      },
                      "compression": "no_compression",
                      "topic": "kafka-topic",
                      "max_inflight": 10,
                      "required_acks": "all_isr",
                      "max_batch_bytes": "896KB",
                      "partitions_limit": "all_partitions",
                      "partition_count_refresh_interval": "60s",
                      "kafka_header_value_encode_mode": "none",
                      "kafka_ext_headers": [
                        {
                          "kafka_ext_header_value": "${clientid}",
                          "kafka_ext_header_key": "clientid"
                        },
                        {
                          "kafka_ext_header_value": "${topic}",
                          "kafka_ext_header_key": "topic"
                        }
                      ],
                      "kafka_headers": "${pub_props}",
                      "partition_strategy": "random"
                    },
                    "connector": "my_kafka_producer_connector",
                    "resource_opts": {
                      "health_check_interval": "32s"
                    },
                    "local_topic": "mqtt/local/topic"
                  },
                  "summary": "Kafka Producer Action"
                },
                "kinesis": {
                  "value": {
                    "name": "kinesis_action",
                    "type": "kinesis",
                    "description": "My example kinesis action",
                    "enable": true,
                    "parameters": {
                      "partition_key": "any_key",
                      "payload_template": "${.}",
                      "stream_name": "my_stream"
                    },
                    "connector": "kinesis_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "Kinesis Action"
                },
                "pgsql": {
                  "value": {
                    "name": "my_action",
                    "type": "pgsql",
                    "enable": true,
                    "connector": "my_connector",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 16,
                      "max_buffer_bytes": "256MB",
                      "batch_time": "50ms",
                      "inflight_window": 100,
                      "request_ttl": "45s"
                    },
                    "parameters": {
                      "sql": "INSERT INTO client_events(clientid, event, created_at)VALUES (\n  ${clientid},\n  ${event},\n  TO_TIMESTAMP((${timestamp} :: bigint))\n)"
                    }
                  },
                  "summary": "PostgreSQL Action"
                },
                "mysql": {
                  "value": {
                    "name": "mysql_action",
                    "type": "mysql",
                    "description": "My example mysql action",
                    "enable": true,
                    "parameters": {
                      "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, FROM_UNIXTIME(${timestamp}/1000))"
                    },
                    "connector": "mysql_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "MySQL Action"
                },
                "mqtt": {
                  "value": {
                    "name": "mqtt_action",
                    "type": "mqtt",
                    "description": "My example mqtt action",
                    "enable": true,
                    "parameters": {
                      "retain": false,
                      "payload": "${.payload}",
                      "topic": "remote/topic",
                      "qos": 2
                    },
                    "connector": "mqtt_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "MQTT Producer Action"
                },
                "rabbitmq": {
                  "value": {
                    "name": "rabbitmq_action",
                    "type": "rabbitmq",
                    "description": "My example rabbitmq action",
                    "enable": true,
                    "parameters": {
                      "exchange": "test_exchange",
                      "payload_template": "${.payload}",
                      "routing_key": "/",
                      "wait_for_publish_confirmations": true,
                      "delivery_mode": "non_persistent",
                      "publish_confirmation_timeout": "30s"
                    },
                    "connector": "rabbitmq_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "RabbitMQ Producer Action"
                },
                "redis": {
                  "value": {
                    "name": "my_action",
                    "type": "redis",
                    "description": "My action",
                    "enable": true,
                    "parameters": {
                      "command_template": [
                        "LPUSH",
                        "MSGS",
                        "${payload}"
                      ]
                    },
                    "connector": "my_connector_name",
                    "resource_opts": {
                      "batch_size": 1
                    }
                  },
                  "summary": "Redis Action"
                },
                "dynamo": {
                  "value": {
                    "name": "dynamo_action",
                    "type": "dynamo",
                    "description": "My example dynamo action",
                    "enable": true,
                    "connector": "dynamo_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    },
                    "parameters": {
                      "hash_key": "clientid",
                      "table": "mqtt_msg",
                      "template": ""
                    }
                  },
                  "summary": "DynamoDB Action"
                },
                "tdengine": {
                  "value": {
                    "name": "tdengine_action",
                    "type": "tdengine",
                    "description": "My example tdengine action",
                    "enable": true,
                    "parameters": {
                      "database": "mqtt",
                      "sql": "insert into t_mqtt_msg(ts, msgid, mqtt_topic, qos, payload, arrived) values (${ts}, '${id}', '${topic}', ${qos}, '${payload}', ${timestamp})"
                    },
                    "connector": "tdengine_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "TDengine Action"
                },
                "s3": {
                  "value": {
                    "name": "my_s3_action",
                    "type": "s3",
                    "description": "My upload action",
                    "enable": true,
                    "parameters": {
                      "mode": "direct",
                      "key": "${topic}",
                      "content": "${payload}",
                      "bucket": "${clientid}",
                      "acl": "public_read"
                    },
                    "connector": "my_s3_connector",
                    "resource_opts": {
                      "query_mode": "sync",
                      "inflight_window": 10
                    }
                  },
                  "summary": "S3 Direct Upload"
                },
                "greptimedb": {
                  "value": {
                    "name": "greptimedb_action",
                    "type": "greptimedb",
                    "description": "My example greptimedb action",
                    "enable": true,
                    "parameters": {
                      "precision": "ms",
                      "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,uint_value=${payload.uint_key}u,bool=${payload.bool}"
                    },
                    "connector": "greptimedb_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "GreptimeDB Action"
                },
                "opents": {
                  "value": {
                    "name": "opents_action",
                    "type": "opents",
                    "description": "My example opents action",
                    "enable": true,
                    "parameters": {
                      "data": [
                        {
                          "value": "${value}",
                          "tags": "${tags}",
                          "metric": "${metric}"
                        }
                      ]
                    },
                    "connector": "opents_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "OpenTSDB Action"
                },
                "oracle": {
                  "value": {
                    "name": "oracle_action",
                    "type": "oracle",
                    "description": "My example oracle action",
                    "enable": true,
                    "parameters": {
                      "sql": "insert into t_mqtt_msgs(msgid, topic, qos, payload) values (${id}, ${topic}, ${qos}, ${payload})"
                    },
                    "connector": "oracle_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "Oracle Action"
                },
                "hstreamdb": {
                  "value": {
                    "name": "hstreamdb_action",
                    "type": "hstreamdb",
                    "description": "My example hstreamdb action",
                    "enable": true,
                    "connector": "hstreamdb_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    },
                    "parameters": {
                      "aggregation_pool_size": 8,
                      "partition_key": "hej",
                      "record_template": "${payload}",
                      "stream": "mqtt_message",
                      "writer_pool_size": 8
                    }
                  },
                  "summary": "HStreamDB Action"
                },
                "cassandra": {
                  "value": {
                    "name": "cassandra_action",
                    "type": "cassandra",
                    "description": "My example cassandra action",
                    "enable": true,
                    "parameters": {
                      "cql": "insert into mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic},  ${qos}, ${payload}, ${timestamp})"
                    },
                    "connector": "cassandra_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "Cassandra Action"
                },
                "clickhouse": {
                  "value": {
                    "name": "clickhouse_action",
                    "type": "clickhouse",
                    "description": "My example clickhouse action",
                    "enable": true,
                    "parameters": {
                      "sql": "INSERT INTO messages(data, arrived) VALUES ('${payload}', ${timestamp})",
                      "batch_value_separator": ", "
                    },
                    "connector": "clickhouse_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "ClickHouse Action"
                },
                "influxdb": {
                  "value": {
                    "name": "influxdb_action",
                    "type": "influxdb",
                    "description": "My example influxdb action",
                    "enable": true,
                    "parameters": {
                      "precision": "ms",
                      "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,bool=${payload.bool}"
                    },
                    "connector": "influxdb_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "InfluxDB Action"
                },
                "sqlserver": {
                  "value": {
                    "name": "sqlserver_action",
                    "type": "sqlserver",
                    "description": "My example sqlserver action",
                    "enable": true,
                    "connector": "sqlserver_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    },
                    "parameters": {
                      "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload) values ( ${id}, ${topic}, ${qos}, ${payload} )"
                    }
                  },
                  "summary": "Microsoft SQL Server Action"
                },
                "matrix": {
                  "value": {
                    "name": "my_action",
                    "type": "matrix",
                    "enable": true,
                    "connector": "my_connector",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 16,
                      "max_buffer_bytes": "256MB",
                      "batch_time": "50ms",
                      "inflight_window": 100,
                      "request_ttl": "45s"
                    },
                    "parameters": {
                      "sql": "INSERT INTO client_events(clientid, event, created_at)VALUES (\n  ${clientid},\n  ${event},\n  TO_TIMESTAMP((${timestamp} :: bigint))\n)"
                    }
                  },
                  "summary": "Matrix Action"
                },
                "aggregated_azure_blob_storage": {
                  "value": {
                    "name": "my_action",
                    "type": "azure_blob_storage",
                    "description": "my action",
                    "enable": true,
                    "parameters": {
                      "mode": "aggregated",
                      "blob": "${action}/${node}/${datetime.rfc3339}/${sequence}",
                      "container": "mycontainer",
                      "aggregation": {
                        "container": {
                          "type": "csv",
                          "column_order": [
                            "a",
                            "b"
                          ]
                        },
                        "max_records": 10000,
                        "time_interval": "4s"
                      }
                    },
                    "connector": "my_connector",
                    "resource_opts": {
                      "batch_size": 100,
                      "worker_pool_size": 16,
                      "query_mode": "sync",
                      "batch_time": "10ms",
                      "inflight_window": 100,
                      "request_ttl": "45s",
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "Azure Blob Storage Aggregated Upload Action"
                },
                "rocketmq": {
                  "value": {
                    "name": "rocketmq_action",
                    "type": "rocketmq",
                    "description": "My example rocketmq action",
                    "enable": true,
                    "connector": "rocketmq_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    },
                    "parameters": {
                      "refresh_interval": "3s",
                      "send_buffer": "1024KB",
                      "sync_timeout": "3s",
                      "template": "",
                      "topic": "TopicTest"
                    }
                  },
                  "summary": "RocketMQ Action"
                },
                "pulsar": {
                  "value": {
                    "name": "pulsar_action",
                    "type": "pulsar",
                    "description": "My example pulsar action",
                    "enable": true,
                    "parameters": {
                      "message": {
                        "value": "${.}",
                        "key": "${.clientid}"
                      },
                      "sync_timeout": "5s",
                      "pulsar_topic": "test_topic"
                    },
                    "connector": "pulsar_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "Pulsar Producer Action"
                },
                "syskeeper_forwarder": {
                  "value": {
                    "name": "syskeeper_forwarder",
                    "type": "syskeeper_forwarder",
                    "enable": true,
                    "parameters": {
                      "template": "${payload}",
                      "target_topic": "${topic}"
                    },
                    "connector": "syskeeper_forwarder",
                    "resource_opts": {
                      "worker_pool_size": 16
                    }
                  },
                  "summary": "Syskeeper Forwarder Bridge"
                },
                "s3_aggreg": {
                  "value": {
                    "name": "my_s3_action",
                    "type": "s3",
                    "description": "My aggregated upload action",
                    "enable": true,
                    "parameters": {
                      "mode": "aggregated",
                      "key": "${action}/${node}/${datetime.rfc3339utc}_N${sequence}.csv",
                      "bucket": "mqtt-aggregated",
                      "acl": "public_read",
                      "aggregation": {
                        "max_records": 100000,
                        "time_interval": "15m"
                      },
                      "container": {
                        "type": "csv",
                        "column_order": [
                          "clientid",
                          "topic",
                          "publish_received_at"
                        ]
                      }
                    },
                    "connector": "my_s3_connector",
                    "resource_opts": {
                      "query_mode": "async",
                      "inflight_window": 100,
                      "health_check_interval": "10s"
                    }
                  },
                  "summary": "S3 Aggregated Upload"
                },
                "elasticsearch": {
                  "value": {
                    "name": "elasticsearch_action",
                    "type": "elasticsearch",
                    "description": "My example elasticsearch action",
                    "enable": true,
                    "parameters": {
                      "index": "${payload.index}",
                      "action": "create",
                      "doc": "${payload.doc}",
                      "overwrite": true
                    },
                    "connector": "elasticsearch_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "Elastic Search Bridge"
                },
                "gcp_pubsub_producer": {
                  "value": {
                    "name": "my_action",
                    "type": "gcp_pubsub_producer",
                    "description": "My action",
                    "enable": true,
                    "parameters": {
                      "payload_template": "${payload}",
                      "pubsub_topic": "mytopic",
                      "ordering_key_template": "${payload.ok}",
                      "attributes_template": [
                        {
                          "value": "${payload.attrs.v}",
                          "key": "${payload.attrs.k}"
                        }
                      ]
                    },
                    "connector": "my_connector_name",
                    "resource_opts": {
                      "batch_size": 5
                    },
                    "local_topic": "local/topic"
                  },
                  "summary": "GCP PubSub Producer Action"
                },
                "mongodb": {
                  "value": {
                    "name": "mongodb_action",
                    "type": "mongodb",
                    "description": "My example mongodb action",
                    "enable": true,
                    "parameters": {
                      "collection": "mycol"
                    },
                    "connector": "mongodb_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "MongoDB Action"
                },
                "timescale": {
                  "value": {
                    "name": "my_action",
                    "type": "timescale",
                    "enable": true,
                    "connector": "my_connector",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 16,
                      "max_buffer_bytes": "256MB",
                      "batch_time": "50ms",
                      "inflight_window": 100,
                      "request_ttl": "45s"
                    },
                    "parameters": {
                      "sql": "INSERT INTO client_events(clientid, event, created_at)VALUES (\n  ${clientid},\n  ${event},\n  TO_TIMESTAMP((${timestamp} :: bigint))\n)"
                    }
                  },
                  "summary": "Timescale Action"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/bridge_timescale.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mongodb.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/gcp_pubsub_producer.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_elasticsearch.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/action_azure_blob_storage.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/syskeeper.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/pulsar.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/rocketmq.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_matrix.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_sqlserver.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_influxdb.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_clickhouse.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_cassa.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_hstreamdb.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_oracle.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_opents.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_greptimedb.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_s3.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_tdengine.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_dynamo.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/redis.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_rabbitmq.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mqtt_publisher.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mysql.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_pgsql.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_kinesis.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_kafka.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_azure_event_hub.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_datalayers.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/action_couchbase.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_iotdb.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/confluent.post_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_http.post_bridge_v2"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/clients/{clientid}/inflight_messages": {
      "get": {
        "description": "Get client in-flight messages",
        "tags": [
          "Clients"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "payload",
            "description": "Client's inflight/mqueue messages payload encoding. If set to `none`, no payload is returned in the response.",
            "schema": {
              "default": "base64",
              "type": "string",
              "enum": [
                "none",
                "base64",
                "plain"
              ]
            }
          },
          {
            "in": "query",
            "name": "max_payload_bytes",
            "description": "Client's inflight/mqueue messages payload limit. The total payload size of all messages in the response will not exceed this value. Messages beyond the limit will be silently omitted in the response. The only exception to this rule is when the first message payload is already larger than the limit. In this case, the first message will be returned in the response.",
            "schema": {
              "default": "1MB",
              "type": "string",
              "example": "32MB"
            }
          },
          {
            "$ref": "#/components/parameters/public.position"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "data": [
                    {
                      "from_clientid": "mqttx_59ac0a87",
                      "from_username": "test-user",
                      "msgid": "000611F460D57FA9F44500000D360002",
                      "payload": "eyJmb28iOiAiYmFyIn0=",
                      "publish_at": 1709055346487,
                      "qos": 0,
                      "topic": "t/test"
                    }
                  ],
                  "meta": {
                    "count": 100,
                    "last": "1710785444656449826"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_clients.inflight_messages"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "INVALID_PARAMETER"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Invalid parameters"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "CLIENTID_NOT_FOUND",
                        "CLIENT_SHUTDOWN"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Client ID not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "501": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_IMPLEMENTED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "API not implemented"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/relup/status": {
      "get": {
        "description": "Get the hot upgrade status of all nodes",
        "tags": [
          "Relup"
        ],
        "parameters": [],
        "summary": "Get the hot upgrade status of all nodes",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/relup.running_status"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/exhooks/{name}/move": {
      "post": {
        "description": "Move the server.<br/>NOTE: The position should be \"front | rear | before:{name} | after:{name}",
        "tags": [
          "ExHook"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "The Exhook server name",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "default"
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "500": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_RPC"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad RPC"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "front": {
                  "value": {
                    "position": "front"
                  },
                  "summary": "absolute position 'front'"
                },
                "rear": {
                  "value": {
                    "position": "rear"
                  },
                  "summary": "absolute position 'rear'"
                },
                "related_after": {
                  "value": {
                    "position": "after:default"
                  },
                  "summary": "relative position 'after'"
                },
                "related_before": {
                  "value": {
                    "position": "before:default"
                  },
                  "summary": "relative position 'before'"
                }
              },
              "schema": {
                "$ref": "#/components/schemas/exhook.move_req"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/slow_subscriptions/settings": {
      "get": {
        "description": "View slow subs settings",
        "tags": [
          "Slow Subscriptions"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/slow_subs.slow_subs"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update slow subs settings",
        "tags": [
          "Slow Subscriptions"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/slow_subs.slow_subs"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/slow_subs.slow_subs"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/message_transformations/transformation/{name}/enable/{enable}": {
      "post": {
        "description": "Enable or disable a particular transformation",
        "tags": [
          "Message Transformation"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Transformation name",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "my_transformation"
          },
          {
            "in": "path",
            "name": "enable",
            "description": "Enable or disable transformation",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "summary": "Enable or disable transformation",
        "responses": {
          "204": {
            "description": "No content"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad params"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Transformation not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/prometheus/auth": {
      "get": {
        "description": "Get Prometheus Metrics for AuthN, AuthZ and Banned",
        "tags": [
          "Monitor"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_prometheus_api.mode"
          }
        ],
        "responses": {
          "200": {
            "description": "Get Prometheus Data.",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          }
        },
        "security": []
      }
    },
    "/mqtt/topic_metrics": {
      "get": {
        "description": "List topic metrics",
        "tags": [
          "MQTT"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "List topic metrics",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/emqx_topic_metrics_api.topic_metrics"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Reset telemetry status",
        "tags": [
          "MQTT"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": "Reset telemetry status"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "TOPIC_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found. Topic metrics not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "reset_all_topic_metrics": {
                  "value": {
                    "action": "reset"
                  },
                  "summary": "reset_all_topic_metrics"
                },
                "reset_specific_one_topic_metrics": {
                  "value": {
                    "action": "reset",
                    "topic": "testtopic/1"
                  },
                  "summary": "reset_specific_one_topic_metrics"
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_topic_metrics_api.reset"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Create topic metrics",
        "tags": [
          "MQTT"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": "Create topic metrics"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST",
                        "BAD_TOPIC"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request. Already exists or bad topic name"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "409": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "EXCEED_LIMIT"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Conflict. Topic metrics exceeded max limit 512"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "required": [
                  "topic"
                ],
                "properties": {
                  "topic": {
                    "type": "string",
                    "description": "Raw topic string",
                    "example": "testtopic/1"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/durable_queues": {
      "get": {
        "description": "Get the list of durable queues.",
        "tags": [
          "Durable Queues"
        ],
        "parameters": [],
        "summary": "List declared durable queues",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": [
                  {
                    "id": "queue1"
                  },
                  {
                    "id": "queue2"
                  }
                ],
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/durable_queues.durable_queue_get"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/error_codes/{code}": {
      "get": {
        "description": "API Error Codes",
        "tags": [
          "Error Codes"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "code",
            "description": "API Error Codes",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "BAD_USERNAME_OR_PWD",
                "BAD_API_KEY_OR_SECRET",
                "BAD_REQUEST",
                "NOT_MATCH",
                "ALREADY_EXISTS",
                "BAD_CONFIG_SCHEMA",
                "BAD_LISTENER_ID",
                "BAD_NODE_NAME",
                "BAD_RPC",
                "BAD_TOPIC",
                "EXCEED_LIMIT",
                "INVALID_PARAMETER",
                "CONFLICT",
                "NO_DEFAULT_VALUE",
                "DEPENDENCY_EXISTS",
                "MESSAGE_ID_SCHEMA_ERROR",
                "INVALID_ID",
                "MESSAGE_ID_NOT_FOUND",
                "NOT_FOUND",
                "CLIENTID_NOT_FOUND",
                "CLIENT_NOT_FOUND",
                "RESOURCE_NOT_FOUND",
                "TOPIC_NOT_FOUND",
                "USER_NOT_FOUND",
                "INTERNAL_ERROR",
                "SERVICE_UNAVAILABLE",
                "SOURCE_ERROR",
                "UPDATE_FAILED",
                "REST_FAILED",
                "CLIENT_NOT_RESPONSE",
                "UNSUPPORTED_MEDIA_TYPE"
              ]
            },
            "example": "BAD_USERNAME_OR_PWD"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/dashboard.error_code"
                }
              }
            }
          }
        },
        "security": []
      }
    },
    "/bridges/{id}/{operation}": {
      "post": {
        "description": "Stop/Restart bridges on all nodes in the cluster.",
        "tags": [
          "Bridges"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge Id. Must be of format {type}:{name}",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:http_example"
          },
          {
            "in": "path",
            "name": "operation",
            "description": "Operations can be one of: stop, restart",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "start",
                "stop",
                "restart"
              ]
            },
            "example": "start"
          }
        ],
        "summary": "Stop or restart bridge",
        "responses": {
          "204": {
            "description": "Operation success"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Problem with configuration of external service"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bridge not found or invalid operation"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "501": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_IMPLEMENTED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Implemented"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Service unavailable"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/sso/running": {
      "get": {
        "tags": [
          "Dashboard Single Sign-On"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "enum": [
                      "ldap",
                      "oidc",
                      "saml"
                    ]
                  }
                }
              }
            }
          }
        },
        "security": []
      }
    },
    "/gateways/{name}/clients/{clientid}/subscriptions/{topic}": {
      "delete": {
        "description": "Delete a subscriptions membership",
        "tags": [
          "Gateway Clients"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "topic",
            "description": "Topic Filter/Name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "clientid",
            "description": "Client ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "gbt32960",
                "jt808",
                "lwm2m",
                "mqttsn",
                "ocpp",
                "stomp"
              ]
            }
          }
        ],
        "summary": "Delete client's subscription",
        "responses": {
          "204": {
            "description": "Unsubscribed"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/action_types": {
      "get": {
        "description": "Lists the available action types.",
        "tags": [
          "Actions"
        ],
        "parameters": [],
        "summary": "List available action types",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "types": {
                    "value": [
                      "http",
                      "cassandra",
                      "rocketmq",
                      "rabbitmq",
                      "kafka_producer",
                      "greptimedb",
                      "pulsar",
                      "influxdb",
                      "gcp_pubsub_producer",
                      "confluent_producer",
                      "iotdb",
                      "sqlserver",
                      "mongodb",
                      "azure_event_hub_producer",
                      "hstreamdb",
                      "syskeeper_forwarder",
                      "s3",
                      "redis",
                      "opents",
                      "datalayers",
                      "kinesis",
                      "mqtt",
                      "clickhouse",
                      "oracle",
                      "timescale",
                      "couchbase",
                      "azure_blob_storage",
                      "tdengine",
                      "elasticsearch",
                      "matrix",
                      "mysql",
                      "pgsql",
                      "dynamo"
                    ],
                    "summary": "Action types"
                  }
                },
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "enum": [
                      "http",
                      "cassandra",
                      "rocketmq",
                      "rabbitmq",
                      "kafka_producer",
                      "greptimedb",
                      "pulsar",
                      "influxdb",
                      "gcp_pubsub_producer",
                      "confluent_producer",
                      "iotdb",
                      "sqlserver",
                      "mongodb",
                      "azure_event_hub_producer",
                      "hstreamdb",
                      "syskeeper_forwarder",
                      "s3",
                      "redis",
                      "opents",
                      "datalayers",
                      "kinesis",
                      "mqtt",
                      "clickhouse",
                      "oracle",
                      "timescale",
                      "couchbase",
                      "azure_blob_storage",
                      "tdengine",
                      "elasticsearch",
                      "matrix",
                      "mysql",
                      "pgsql",
                      "dynamo"
                    ]
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/ds/storages/{ds}/replicas": {
      "get": {
        "description": "List replicas of the durable storage",
        "tags": [
          "Durable storage"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "ds",
            "description": "Durable storage ID",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "messages"
              ]
            },
            "example": "messages"
          }
        ],
        "responses": {
          "200": {
            "description": "List sites that contain replicas of the durable storage",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Durable storage not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Durable storage is disabled"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update replicas of the durable storage",
        "tags": [
          "Durable storage"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "ds",
            "description": "Durable storage ID",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "messages"
              ]
            },
            "example": "messages"
          }
        ],
        "responses": {
          "202": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Durable storage is disabled"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/mqtt/delayed/messages": {
      "get": {
        "description": "List delayed messages",
        "tags": [
          "MQTT"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "data": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/emqx_delayed_api.message"
                      }
                    },
                    "meta": {
                      "properties": {
                        "page": {
                          "type": "integer",
                          "description": "View page",
                          "minimum": 1
                        },
                        "limit": {
                          "type": "integer",
                          "description": "Page limit",
                          "minimum": 1
                        },
                        "count": {
                          "type": "integer",
                          "description": "Count of delayed messages",
                          "minimum": 0
                        }
                      },
                      "type": "object"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/users/{username}": {
      "put": {
        "description": "Update dashboard user description",
        "tags": [
          "Dashboard"
        ],
        "parameters": [
          {
            "in": "query",
            "name": "backend",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "local",
                "ldap",
                "oidc",
                "saml"
              ]
            },
            "example": "local"
          },
          {
            "in": "path",
            "name": "username",
            "description": "Dashboard Username",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "admin"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "username": {
                      "type": "string",
                      "description": "Dashboard Username",
                      "maxLength": 100,
                      "example": "admin"
                    },
                    "role": {
                      "default": "administrator",
                      "type": "string",
                      "description": "User role",
                      "example": "administrator"
                    },
                    "description": {
                      "type": "string",
                      "description": "Dashboard User Description",
                      "example": "administrator"
                    },
                    "backend": {
                      "type": "string",
                      "description": "User account source",
                      "example": "local"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "USER_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Dashboard user not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "role": {
                    "default": "administrator",
                    "type": "string",
                    "description": "User role",
                    "example": "administrator"
                  },
                  "description": {
                    "type": "string",
                    "description": "Dashboard User Description",
                    "example": "administrator"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete dashboard user",
        "tags": [
          "Dashboard"
        ],
        "parameters": [
          {
            "in": "query",
            "name": "backend",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "local",
                "ldap",
                "oidc",
                "saml"
              ]
            },
            "example": "local"
          },
          {
            "in": "path",
            "name": "username",
            "description": "Dashboard Username",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "admin"
          }
        ],
        "responses": {
          "204": {
            "description": "Delete User successfully"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST",
                        "NOT_ALLOWED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Login failed. Bad username or password"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "USER_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Dashboard user not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/exhooks": {
      "get": {
        "description": "List all servers",
        "tags": [
          "ExHook"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/exhook.detail_server_info"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Add a server",
        "tags": [
          "ExHook"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/exhook.detail_server_info"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Already exists"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "500": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_RPC"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad RPC"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "example": {
                "name": "default",
                "ssl": {
                  "cacertfile": "/etc/emqx/certs/cacert.pem",
                  "certfile": "/etc/emqx/certs/cert.pem",
                  "keyfile": "/etc/emqx/certs/key.pem",
                  "enable": false
                },
                "pool_size": 8,
                "enable": true,
                "url": "http://127.0.0.1:8081",
                "request_timeout": "5s",
                "auto_reconnect": "60s",
                "failed_action": "deny"
              },
              "schema": {
                "$ref": "#/components/schemas/exhook.server_config"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/message_transformations/transformation/{name}/metrics/reset": {
      "post": {
        "description": "Reset metrics for a particular transformation",
        "tags": [
          "Message Transformation"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Transformation name",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "my_transformation"
          }
        ],
        "summary": "Reset transformation metrics",
        "responses": {
          "204": {
            "description": "No content"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Transformation not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/ds/sites/{site}": {
      "get": {
        "description": "Get sites",
        "tags": [
          "Durable storage"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "site",
            "description": "Site ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "F9967F15E94B8C70"
          }
        ],
        "responses": {
          "200": {
            "description": "Get information about the site",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_ds.site"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Site not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/lwm2m/clients/{clientid}/lookup": {
      "get": {
        "description": "Look up a resource",
        "tags": [
          "LwM2M Gateways"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "urn:oma:lwm2m:oma:2"
          },
          {
            "in": "query",
            "name": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "/3/0/7"
          },
          {
            "in": "query",
            "name": "action",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "discover"
          }
        ],
        "summary": "List Client's Resources",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "clientid": {
                      "type": "string",
                      "example": "urn:oma:lwm2m:oma:2"
                    },
                    "path": {
                      "type": "string",
                      "example": "/3/0/7"
                    },
                    "action": {
                      "type": "string",
                      "example": "discover"
                    },
                    "codeMsg": {
                      "type": "string",
                      "example": "reply_not_received"
                    },
                    "content": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/lwm2m.resource"
                      }
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "CLIENT_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Client not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/file_transfer/files": {
      "get": {
        "description": "List all uploaded files.",
        "tags": [
          "File Transfer"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/file_transfer.following"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          }
        ],
        "summary": "List all uploaded files",
        "responses": {
          "200": {
            "description": "Operation success"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Invalid cursor"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Service unavailable"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/rules/{id}/metrics": {
      "get": {
        "description": "Get a rule's metrics by given Id",
        "tags": [
          "Rules"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "my_rule_id"
          }
        ],
        "summary": "Get rule metrics",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/rule_engine.rule_metrics"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Rule not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/file_transfer": {
      "get": {
        "description": "Show current File Transfer configuration.",
        "tags": [
          "File Transfer"
        ],
        "parameters": [],
        "summary": "Get current File Transfer configuration",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/file_transfer.file_transfer"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Replace File Transfer configuration.",
        "tags": [
          "File Transfer"
        ],
        "parameters": [],
        "summary": "Update File Transfer configuration",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/file_transfer.file_transfer"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UPDATE_FAILED",
                        "INVALID_CONFIG"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Provided configuration is invalid"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/file_transfer.file_transfer"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/slow_subscriptions": {
      "get": {
        "description": "View slow topics statistics record data",
        "tags": [
          "Slow Subscriptions"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "data": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/slow_subscribers_statistics.record"
                      }
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Clear current data and re count slow topic",
        "tags": [
          "Slow Subscriptions"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": "No Content"
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/durable_queues/{id}": {
      "get": {
        "description": "Get the information of a durable queue.",
        "tags": [
          "Durable Queues"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The ID of the durable queue.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "summary": "Get a declared durable queue",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "id": "queue1"
                },
                "schema": {
                  "$ref": "#/components/schemas/durable_queues.durable_queue_get"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Queue Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Create a durable queue.",
        "tags": [
          "Durable Queues"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The ID of the durable queue.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "summary": "Declare a durable queue",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "id": "queue1"
                },
                "schema": {
                  "$ref": "#/components/schemas/durable_queues.durable_queue_get"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "example": {}
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete a durable queue.",
        "tags": [
          "Durable Queues"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The ID of the durable queue.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "summary": "Delete a declared durable queue",
        "responses": {
          "200": {
            "description": "Queue deleted"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Queue Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/{name}": {
      "get": {
        "description": "Get the gateway configurations",
        "tags": [
          "Gateways"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "gbt32960",
                "jt808",
                "lwm2m",
                "mqttsn",
                "ocpp",
                "stomp"
              ]
            },
            "example": "stomp"
          }
        ],
        "summary": "Get gateway",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "coap_gateway": {
                    "value": {
                      "name": "coap",
                      "enable": true,
                      "heartbeat": "30s",
                      "listeners": [
                        {
                          "name": "default",
                          "type": "udp",
                          "bind": "5683",
                          "max_connections": 1024000,
                          "max_conn_rate": 1000
                        }
                      ],
                      "idle_timeout": "30s",
                      "mountpoint": "coap/",
                      "enable_stats": true,
                      "connection_required": false,
                      "notify_type": "qos",
                      "publish_qos": "coap",
                      "subscribe_qos": "coap"
                    },
                    "summary": "A simple CoAP gateway config"
                  },
                  "exproto_gateway": {
                    "value": {
                      "name": "exproto",
                      "handler": {
                        "address": "http://127.0.0.1:9001"
                      },
                      "server": {
                        "bind": "9100"
                      },
                      "enable": true,
                      "listeners": [
                        {
                          "name": "default",
                          "type": "tcp",
                          "bind": "7993",
                          "max_connections": 1024000,
                          "max_conn_rate": 1000
                        }
                      ],
                      "idle_timeout": "30s",
                      "mountpoint": "exproto/",
                      "enable_stats": true
                    },
                    "summary": "A simple ExProto gateway config"
                  },
                  "gbt32960_gateway": {
                    "value": {
                      "message_queue_len": 10,
                      "name": "gbt32960",
                      "enable": true,
                      "listeners": [
                        {
                          "name": "default",
                          "type": "tcp",
                          "bind": "7325",
                          "max_connections": 1024000,
                          "max_conn_rate": 1000
                        }
                      ],
                      "mountpoint": "gbt32960/${clientid}",
                      "retry_interval": "8s",
                      "enable_stats": true,
                      "max_retry_times": 3
                    },
                    "summary": "A simple GBT32960 gateway config"
                  },
                  "lwm2m_gateway": {
                    "value": {
                      "name": "lwm2m",
                      "enable": true,
                      "listeners": [
                        {
                          "name": "default",
                          "type": "udp",
                          "bind": "5783",
                          "max_connections": 1024000,
                          "max_conn_rate": 1000
                        }
                      ],
                      "idle_timeout": "30s",
                      "mountpoint": "lwm2m/",
                      "enable_stats": true,
                      "auto_observe": false,
                      "lifetime_max": "86400s",
                      "lifetime_min": "1s",
                      "qmode_time_window": "22s",
                      "translators": {
                        "command": {
                          "topic": "dn/#"
                        },
                        "notify": {
                          "topic": "up/notify"
                        },
                        "register": {
                          "topic": "up/resp"
                        },
                        "update": {
                          "topic": "up/resp"
                        },
                        "response": {
                          "topic": "up/resp"
                        }
                      },
                      "update_msg_publish_condition": "always",
                      "xml_dir": "/etc/emqx/lwm2m_xml"
                    },
                    "summary": "A simple LwM2M gateway config"
                  },
                  "mqttsn_gateway": {
                    "value": {
                      "name": "mqttsn",
                      "broadcast": true,
                      "enable": true,
                      "predefined": [
                        {
                          "id": "1001",
                          "topic": "pred/1001"
                        },
                        {
                          "id": "1002",
                          "topic": "pred/1002"
                        }
                      ],
                      "listeners": [
                        {
                          "name": "default",
                          "type": "udp",
                          "bind": "1884",
                          "max_connections": 1024000,
                          "max_conn_rate": 1000
                        }
                      ],
                      "idle_timeout": "30s",
                      "mountpoint": "mqttsn/",
                      "enable_stats": true,
                      "enable_qos3": true,
                      "gateway_id": 1
                    },
                    "summary": "A simple MQTT-SN gateway config"
                  },
                  "ocpp_gateway": {
                    "value": {
                      "name": "ocpp",
                      "enable": true,
                      "upstream": {
                        "topic": "cp/${cid}",
                        "error_topic": "cp/${cid}/error",
                        "reply_topic": "cp/${cid}/reply"
                      },
                      "listeners": [
                        {
                          "name": "default",
                          "type": "ws",
                          "bind": "33033",
                          "max_connections": 1024000
                        }
                      ],
                      "mountpoint": "ocpp/",
                      "enable_stats": true,
                      "default_heartbeat_interval": "60s",
                      "dnstream": {
                        "topic": "cp/${cid}"
                      },
                      "message_format_checking": "disable"
                    },
                    "summary": "A simple OCPP gateway config"
                  },
                  "stomp_gateway": {
                    "value": {
                      "name": "stomp",
                      "enable": true,
                      "frame": {
                        "max_headers": 10,
                        "max_body_length": 65535,
                        "max_headers_length": 1024
                      },
                      "listeners": [
                        {
                          "name": "default",
                          "type": "tcp",
                          "bind": "61613",
                          "max_connections": 1024000,
                          "max_conn_rate": 1000
                        }
                      ],
                      "idle_timeout": "30s",
                      "mountpoint": "stomp/",
                      "enable_stats": true
                    },
                    "summary": "A simple STOMP gateway config"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.stomp"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.ocpp"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.mqttsn"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.lwm2m"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.jt808"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.gbt32960"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.exproto"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.coap"
                    }
                  ]
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update the gateway basic configurations and running status.<br/><br/>Note: The Authentication and Listener configurations should be updated by other special APIs.",
        "tags": [
          "Gateways"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "gbt32960",
                "jt808",
                "lwm2m",
                "mqttsn",
                "ocpp",
                "stomp"
              ]
            },
            "example": "stomp"
          }
        ],
        "summary": "Load or update the gateway confs",
        "responses": {
          "204": {
            "description": "Gateway configuration updated"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "coap_gateway": {
                  "value": {
                    "enable": true,
                    "heartbeat": "30s",
                    "idle_timeout": "30s",
                    "mountpoint": "coap2/",
                    "enable_stats": true,
                    "connection_required": false,
                    "notify_type": "qos",
                    "publish_qos": "coap",
                    "subscribe_qos": "coap"
                  },
                  "summary": "A simple CoAP gateway config"
                },
                "exproto_gateway": {
                  "value": {
                    "handler": {
                      "address": "http://127.0.0.1:9001"
                    },
                    "server": {
                      "bind": "9100"
                    },
                    "enable": true,
                    "idle_timeout": "30s",
                    "mountpoint": "exproto2/",
                    "enable_stats": true
                  },
                  "summary": "A simple ExProto gateway config"
                },
                "gbt32960_gateway": {
                  "value": {
                    "message_queue_len": 10,
                    "enable": true,
                    "mountpoint": "gbt32960/${clientid}",
                    "retry_interval": "8s",
                    "enable_stats": true,
                    "max_retry_times": 3
                  },
                  "summary": "A simple GBT32960 gateway config"
                },
                "lwm2m_gateway": {
                  "value": {
                    "enable": true,
                    "idle_timeout": "30s",
                    "mountpoint": "lwm2m2/",
                    "enable_stats": true,
                    "auto_observe": false,
                    "lifetime_max": "86400s",
                    "lifetime_min": "1s",
                    "qmode_time_window": "22s",
                    "translators": {
                      "command": {
                        "topic": "dn/#"
                      },
                      "notify": {
                        "topic": "up/notify"
                      },
                      "register": {
                        "topic": "up/resp"
                      },
                      "update": {
                        "topic": "up/resp"
                      },
                      "response": {
                        "topic": "up/resp"
                      }
                    },
                    "update_msg_publish_condition": "always",
                    "xml_dir": "/etc/emqx/lwm2m_xml"
                  },
                  "summary": "A simple LwM2M gateway config"
                },
                "mqttsn_gateway": {
                  "value": {
                    "broadcast": true,
                    "enable": true,
                    "predefined": [
                      {
                        "id": "1003",
                        "topic": "pred/1003"
                      }
                    ],
                    "idle_timeout": "30s",
                    "mountpoint": "mqttsn2/",
                    "enable_stats": true,
                    "enable_qos3": false,
                    "gateway_id": 1
                  },
                  "summary": "A simple MQTT-SN gateway config"
                },
                "ocpp_gateway": {
                  "value": {
                    "enable": true,
                    "upstream": {
                      "topic": "cp/${cid}",
                      "error_topic": "cp/${cid}/error",
                      "reply_topic": "cp/${cid}/reply"
                    },
                    "mountpoint": "ocpp/",
                    "enable_stats": true,
                    "default_heartbeat_interval": "60s",
                    "dnstream": {
                      "topic": "cp/${cid}"
                    },
                    "message_format_checking": "disable"
                  },
                  "summary": "A simple OCPP gateway config"
                },
                "stomp_gateway": {
                  "value": {
                    "enable": true,
                    "frame": {
                      "max_headers": 100,
                      "max_body_length": 655350,
                      "max_headers_length": 10240
                    },
                    "idle_timeout": "30s",
                    "mountpoint": "stomp2/",
                    "enable_stats": true
                  },
                  "summary": "A simple STOMP gateway config"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.update_stomp"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.update_ocpp"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.update_mqttsn"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.update_lwm2m"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.update_jt808"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.update_gbt32960"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.update_exproto"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.update_coap"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.stomp"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.ocpp"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.mqttsn"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.lwm2m"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.jt808"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.gbt32960"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.exproto"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.coap"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/nodes": {
      "get": {
        "description": "List EMQX nodes",
        "tags": [
          "Nodes"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "List all EMQX nodes",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/emqx_mgmt_api_nodes.node_info"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/actions/{id}": {
      "get": {
        "description": "Get a bridge by id.",
        "tags": [
          "Actions"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_action"
          }
        ],
        "summary": "Get bridge",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "http": {
                    "value": {
                      "name": "my_http_action",
                      "status": "connected",
                      "type": "http",
                      "enable": true,
                      "parameters": {
                        "path": "/room/${room_no}",
                        "body": "${.}",
                        "headers": {},
                        "method": "post"
                      },
                      "connector": "my_http_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "worker_pool_size": 16,
                        "query_mode": "async",
                        "health_check_interval": "15s"
                      }
                    },
                    "summary": "HTTP Action"
                  },
                  "confluent_producer": {
                    "value": {
                      "name": "my_confluent_producer_action",
                      "status": "connected",
                      "type": "confluent_producer",
                      "enable": true,
                      "parameters": {
                        "message": {
                          "value": "${.}",
                          "key": "${.clientid}"
                        },
                        "buffer": {
                          "mode": "hybrid",
                          "memory_overload_protection": true,
                          "segment_bytes": "100MB",
                          "per_partition_limit": "2GB"
                        },
                        "topic": "topic",
                        "max_inflight": 10,
                        "required_acks": "all_isr",
                        "max_batch_bytes": "896KB",
                        "partition_count_refresh_interval": "60s",
                        "kafka_header_value_encode_mode": "none",
                        "kafka_ext_headers": [
                          {
                            "kafka_ext_header_value": "${clientid}",
                            "kafka_ext_header_key": "clientid"
                          },
                          {
                            "kafka_ext_header_value": "${topic}",
                            "kafka_ext_header_key": "topic"
                          }
                        ],
                        "kafka_headers": "${.pub_props}",
                        "partition_strategy": "random"
                      },
                      "connector": "my_confluent_producer_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "local_topic": "mqtt/local/topic"
                    },
                    "summary": "Confluent Action"
                  },
                  "iotdb": {
                    "value": {
                      "name": "iotdb_action",
                      "status": "connected",
                      "type": "iotdb",
                      "description": "My example iotdb action",
                      "enable": true,
                      "parameters": {
                        "data": [
                          {
                            "timestamp": "now",
                            "value": "${st}",
                            "data_type": "BOOLEAN",
                            "measurement": "status"
                          }
                        ],
                        "device_id": "my_device",
                        "is_aligned": false
                      },
                      "connector": "iotdb_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "Apache IoTDB Bridge"
                  },
                  "direct_azure_blob_storage": {
                    "value": {
                      "status": "connected",
                      "description": "my action",
                      "enable": true,
                      "parameters": {
                        "mode": "direct",
                        "content": "${.payload}",
                        "blob": "${.payload.blob}",
                        "container": "${.payload.container}"
                      },
                      "connector": "my_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 16,
                        "query_mode": "sync",
                        "batch_time": "0ms",
                        "inflight_window": 100,
                        "request_ttl": "45s",
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "Azure Blob Storage Direct Upload Action"
                  },
                  "couchbase": {
                    "value": {
                      "status": "connected",
                      "description": "my action",
                      "enable": true,
                      "parameters": {
                        "sql": "insert into mqtt (key, value) values (${.id}, ${.payload})"
                      },
                      "connector": "my_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "worker_pool_size": 16,
                        "query_mode": "sync",
                        "inflight_window": 100,
                        "request_ttl": "45s",
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "Couchbase Action"
                  },
                  "datalayers": {
                    "value": {
                      "name": "datalayers_action",
                      "status": "connected",
                      "type": "datalayers",
                      "description": "My example datalayers action",
                      "enable": true,
                      "parameters": {
                        "precision": "ms",
                        "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,bool=${payload.bool}"
                      },
                      "connector": "datalayers_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "Datalayers Action"
                  },
                  "azure_event_hub_producer": {
                    "value": {
                      "name": "my_azure_event_hub_producer_action",
                      "status": "connected",
                      "type": "azure_event_hub_producer",
                      "enable": true,
                      "parameters": {
                        "message": {
                          "value": "${.}",
                          "key": "${.clientid}"
                        },
                        "buffer": {
                          "mode": "hybrid",
                          "memory_overload_protection": true,
                          "segment_bytes": "100MB",
                          "per_partition_limit": "2GB"
                        },
                        "topic": "topic",
                        "max_inflight": 10,
                        "required_acks": "all_isr",
                        "max_batch_bytes": "896KB",
                        "partition_count_refresh_interval": "60s",
                        "kafka_header_value_encode_mode": "none",
                        "kafka_ext_headers": [
                          {
                            "kafka_ext_header_value": "${clientid}",
                            "kafka_ext_header_key": "clientid"
                          },
                          {
                            "kafka_ext_header_value": "${topic}",
                            "kafka_ext_header_key": "topic"
                          }
                        ],
                        "kafka_headers": "${.pub_props}",
                        "partition_strategy": "random"
                      },
                      "connector": "my_azure_event_hub_producer_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "local_topic": "mqtt/local/topic"
                    },
                    "summary": "Azure Event Hub Action"
                  },
                  "kafka_producer": {
                    "value": {
                      "name": "my_kafka_producer_action",
                      "status": "connected",
                      "type": "kafka_producer",
                      "enable": true,
                      "parameters": {
                        "message": {
                          "timestamp": "${.timestamp}",
                          "value": "${.}",
                          "key": "${.clientid}"
                        },
                        "buffer": {
                          "mode": "hybrid",
                          "memory_overload_protection": true,
                          "segment_bytes": "100MB",
                          "per_partition_limit": "2GB"
                        },
                        "compression": "no_compression",
                        "topic": "kafka-topic",
                        "max_inflight": 10,
                        "required_acks": "all_isr",
                        "max_batch_bytes": "896KB",
                        "partitions_limit": "all_partitions",
                        "partition_count_refresh_interval": "60s",
                        "kafka_header_value_encode_mode": "none",
                        "kafka_ext_headers": [
                          {
                            "kafka_ext_header_value": "${clientid}",
                            "kafka_ext_header_key": "clientid"
                          },
                          {
                            "kafka_ext_header_value": "${topic}",
                            "kafka_ext_header_key": "topic"
                          }
                        ],
                        "kafka_headers": "${pub_props}",
                        "partition_strategy": "random"
                      },
                      "connector": "my_kafka_producer_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "32s"
                      },
                      "local_topic": "mqtt/local/topic"
                    },
                    "summary": "Kafka Producer Action"
                  },
                  "kinesis": {
                    "value": {
                      "name": "kinesis_action",
                      "status": "connected",
                      "type": "kinesis",
                      "description": "My example kinesis action",
                      "enable": true,
                      "parameters": {
                        "partition_key": "any_key",
                        "payload_template": "${.}",
                        "stream_name": "my_stream"
                      },
                      "connector": "kinesis_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "Kinesis Action"
                  },
                  "pgsql": {
                    "value": {
                      "name": "my_action",
                      "status": "connected",
                      "type": "pgsql",
                      "enable": true,
                      "connector": "my_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 16,
                        "max_buffer_bytes": "256MB",
                        "batch_time": "50ms",
                        "inflight_window": 100,
                        "request_ttl": "45s"
                      },
                      "parameters": {
                        "sql": "INSERT INTO client_events(clientid, event, created_at)VALUES (\n  ${clientid},\n  ${event},\n  TO_TIMESTAMP((${timestamp} :: bigint))\n)"
                      }
                    },
                    "summary": "PostgreSQL Action"
                  },
                  "mysql": {
                    "value": {
                      "name": "mysql_action",
                      "status": "connected",
                      "type": "mysql",
                      "description": "My example mysql action",
                      "enable": true,
                      "parameters": {
                        "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, FROM_UNIXTIME(${timestamp}/1000))"
                      },
                      "connector": "mysql_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "MySQL Action"
                  },
                  "mqtt": {
                    "value": {
                      "name": "mqtt_action",
                      "status": "connected",
                      "type": "mqtt",
                      "description": "My example mqtt action",
                      "enable": true,
                      "parameters": {
                        "retain": false,
                        "payload": "${.payload}",
                        "topic": "remote/topic",
                        "qos": 2
                      },
                      "connector": "mqtt_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "MQTT Producer Action"
                  },
                  "rabbitmq": {
                    "value": {
                      "name": "rabbitmq_action",
                      "status": "connected",
                      "type": "rabbitmq",
                      "description": "My example rabbitmq action",
                      "enable": true,
                      "parameters": {
                        "exchange": "test_exchange",
                        "payload_template": "${.payload}",
                        "routing_key": "/",
                        "wait_for_publish_confirmations": true,
                        "delivery_mode": "non_persistent",
                        "publish_confirmation_timeout": "30s"
                      },
                      "connector": "rabbitmq_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "RabbitMQ Producer Action"
                  },
                  "redis": {
                    "value": {
                      "status": "connected",
                      "description": "My action",
                      "enable": true,
                      "parameters": {
                        "command_template": [
                          "LPUSH",
                          "MSGS",
                          "${payload}"
                        ]
                      },
                      "connector": "my_connector_name",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "batch_size": 1
                      }
                    },
                    "summary": "Redis Action"
                  },
                  "dynamo": {
                    "value": {
                      "name": "dynamo_action",
                      "status": "connected",
                      "type": "dynamo",
                      "description": "My example dynamo action",
                      "enable": true,
                      "connector": "dynamo_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      },
                      "parameters": {
                        "hash_key": "clientid",
                        "table": "mqtt_msg",
                        "template": ""
                      }
                    },
                    "summary": "DynamoDB Action"
                  },
                  "tdengine": {
                    "value": {
                      "name": "tdengine_action",
                      "status": "connected",
                      "type": "tdengine",
                      "description": "My example tdengine action",
                      "enable": true,
                      "parameters": {
                        "database": "mqtt",
                        "sql": "insert into t_mqtt_msg(ts, msgid, mqtt_topic, qos, payload, arrived) values (${ts}, '${id}', '${topic}', ${qos}, '${payload}', ${timestamp})"
                      },
                      "connector": "tdengine_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "TDengine Action"
                  },
                  "s3": {
                    "value": {
                      "status": "connected",
                      "description": "My upload action",
                      "enable": true,
                      "parameters": {
                        "mode": "direct",
                        "key": "${topic}",
                        "content": "${payload}",
                        "bucket": "${clientid}",
                        "acl": "public_read"
                      },
                      "connector": "my_s3_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "query_mode": "sync",
                        "inflight_window": 10
                      }
                    },
                    "summary": "S3 Direct Upload"
                  },
                  "greptimedb": {
                    "value": {
                      "name": "greptimedb_action",
                      "status": "connected",
                      "type": "greptimedb",
                      "description": "My example greptimedb action",
                      "enable": true,
                      "parameters": {
                        "precision": "ms",
                        "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,uint_value=${payload.uint_key}u,bool=${payload.bool}"
                      },
                      "connector": "greptimedb_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "GreptimeDB Action"
                  },
                  "opents": {
                    "value": {
                      "name": "opents_action",
                      "status": "connected",
                      "type": "opents",
                      "description": "My example opents action",
                      "enable": true,
                      "parameters": {
                        "data": [
                          {
                            "value": "${value}",
                            "tags": "${tags}",
                            "metric": "${metric}"
                          }
                        ]
                      },
                      "connector": "opents_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "OpenTSDB Action"
                  },
                  "oracle": {
                    "value": {
                      "name": "oracle_action",
                      "status": "connected",
                      "type": "oracle",
                      "description": "My example oracle action",
                      "enable": true,
                      "parameters": {
                        "sql": "insert into t_mqtt_msgs(msgid, topic, qos, payload) values (${id}, ${topic}, ${qos}, ${payload})"
                      },
                      "connector": "oracle_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "Oracle Action"
                  },
                  "hstreamdb": {
                    "value": {
                      "name": "hstreamdb_action",
                      "status": "connected",
                      "type": "hstreamdb",
                      "description": "My example hstreamdb action",
                      "enable": true,
                      "connector": "hstreamdb_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      },
                      "parameters": {
                        "aggregation_pool_size": 8,
                        "partition_key": "hej",
                        "record_template": "${payload}",
                        "stream": "mqtt_message",
                        "writer_pool_size": 8
                      }
                    },
                    "summary": "HStreamDB Action"
                  },
                  "cassandra": {
                    "value": {
                      "name": "cassandra_action",
                      "status": "connected",
                      "type": "cassandra",
                      "description": "My example cassandra action",
                      "enable": true,
                      "parameters": {
                        "cql": "insert into mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic},  ${qos}, ${payload}, ${timestamp})"
                      },
                      "connector": "cassandra_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "Cassandra Action"
                  },
                  "clickhouse": {
                    "value": {
                      "name": "clickhouse_action",
                      "status": "connected",
                      "type": "clickhouse",
                      "description": "My example clickhouse action",
                      "enable": true,
                      "parameters": {
                        "sql": "INSERT INTO messages(data, arrived) VALUES ('${payload}', ${timestamp})",
                        "batch_value_separator": ", "
                      },
                      "connector": "clickhouse_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "ClickHouse Action"
                  },
                  "influxdb": {
                    "value": {
                      "name": "influxdb_action",
                      "status": "connected",
                      "type": "influxdb",
                      "description": "My example influxdb action",
                      "enable": true,
                      "parameters": {
                        "precision": "ms",
                        "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,bool=${payload.bool}"
                      },
                      "connector": "influxdb_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "InfluxDB Action"
                  },
                  "sqlserver": {
                    "value": {
                      "name": "sqlserver_action",
                      "status": "connected",
                      "type": "sqlserver",
                      "description": "My example sqlserver action",
                      "enable": true,
                      "connector": "sqlserver_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      },
                      "parameters": {
                        "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload) values ( ${id}, ${topic}, ${qos}, ${payload} )"
                      }
                    },
                    "summary": "Microsoft SQL Server Action"
                  },
                  "matrix": {
                    "value": {
                      "name": "my_action",
                      "status": "connected",
                      "type": "matrix",
                      "enable": true,
                      "connector": "my_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 16,
                        "max_buffer_bytes": "256MB",
                        "batch_time": "50ms",
                        "inflight_window": 100,
                        "request_ttl": "45s"
                      },
                      "parameters": {
                        "sql": "INSERT INTO client_events(clientid, event, created_at)VALUES (\n  ${clientid},\n  ${event},\n  TO_TIMESTAMP((${timestamp} :: bigint))\n)"
                      }
                    },
                    "summary": "Matrix Action"
                  },
                  "aggregated_azure_blob_storage": {
                    "value": {
                      "status": "connected",
                      "description": "my action",
                      "enable": true,
                      "parameters": {
                        "mode": "aggregated",
                        "blob": "${action}/${node}/${datetime.rfc3339}/${sequence}",
                        "container": "mycontainer",
                        "aggregation": {
                          "container": {
                            "type": "csv",
                            "column_order": [
                              "a",
                              "b"
                            ]
                          },
                          "max_records": 10000,
                          "time_interval": "4s"
                        }
                      },
                      "connector": "my_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "batch_size": 100,
                        "worker_pool_size": 16,
                        "query_mode": "sync",
                        "batch_time": "10ms",
                        "inflight_window": 100,
                        "request_ttl": "45s",
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "Azure Blob Storage Aggregated Upload Action"
                  },
                  "rocketmq": {
                    "value": {
                      "name": "rocketmq_action",
                      "status": "connected",
                      "type": "rocketmq",
                      "description": "My example rocketmq action",
                      "enable": true,
                      "connector": "rocketmq_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      },
                      "parameters": {
                        "refresh_interval": "3s",
                        "send_buffer": "1024KB",
                        "sync_timeout": "3s",
                        "template": "",
                        "topic": "TopicTest"
                      }
                    },
                    "summary": "RocketMQ Action"
                  },
                  "pulsar": {
                    "value": {
                      "name": "pulsar_action",
                      "status": "connected",
                      "type": "pulsar",
                      "description": "My example pulsar action",
                      "enable": true,
                      "parameters": {
                        "message": {
                          "value": "${.}",
                          "key": "${.clientid}"
                        },
                        "sync_timeout": "5s",
                        "pulsar_topic": "test_topic"
                      },
                      "connector": "pulsar_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "Pulsar Producer Action"
                  },
                  "syskeeper_forwarder": {
                    "value": {
                      "name": "syskeeper_forwarder",
                      "status": "connected",
                      "type": "syskeeper_forwarder",
                      "enable": true,
                      "parameters": {
                        "template": "${payload}",
                        "target_topic": "${topic}"
                      },
                      "connector": "syskeeper_forwarder",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "worker_pool_size": 16
                      }
                    },
                    "summary": "Syskeeper Forwarder Bridge"
                  },
                  "s3_aggreg": {
                    "value": {
                      "status": "connected",
                      "description": "My aggregated upload action",
                      "enable": true,
                      "parameters": {
                        "mode": "aggregated",
                        "key": "${action}/${node}/${datetime.rfc3339utc}_N${sequence}.csv",
                        "bucket": "mqtt-aggregated",
                        "acl": "public_read",
                        "aggregation": {
                          "max_records": 100000,
                          "time_interval": "15m"
                        },
                        "container": {
                          "type": "csv",
                          "column_order": [
                            "clientid",
                            "topic",
                            "publish_received_at"
                          ]
                        }
                      },
                      "connector": "my_s3_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "query_mode": "async",
                        "inflight_window": 100,
                        "health_check_interval": "10s"
                      }
                    },
                    "summary": "S3 Aggregated Upload"
                  },
                  "elasticsearch": {
                    "value": {
                      "name": "elasticsearch_action",
                      "status": "connected",
                      "type": "elasticsearch",
                      "description": "My example elasticsearch action",
                      "enable": true,
                      "parameters": {
                        "index": "${payload.index}",
                        "action": "create",
                        "doc": "${payload.doc}",
                        "overwrite": true
                      },
                      "connector": "elasticsearch_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "Elastic Search Bridge"
                  },
                  "gcp_pubsub_producer": {
                    "value": {
                      "status": "connected",
                      "description": "My action",
                      "enable": true,
                      "parameters": {
                        "payload_template": "${payload}",
                        "pubsub_topic": "mytopic",
                        "ordering_key_template": "${payload.ok}",
                        "attributes_template": [
                          {
                            "value": "${payload.attrs.v}",
                            "key": "${payload.attrs.k}"
                          }
                        ]
                      },
                      "connector": "my_connector_name",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "batch_size": 5
                      },
                      "local_topic": "local/topic"
                    },
                    "summary": "GCP PubSub Producer Action"
                  },
                  "mongodb": {
                    "value": {
                      "name": "mongodb_action",
                      "status": "connected",
                      "type": "mongodb",
                      "description": "My example mongodb action",
                      "enable": true,
                      "parameters": {
                        "collection": "mycol"
                      },
                      "connector": "mongodb_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "MongoDB Action"
                  },
                  "timescale": {
                    "value": {
                      "name": "my_action",
                      "status": "connected",
                      "type": "timescale",
                      "enable": true,
                      "connector": "my_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 16,
                        "max_buffer_bytes": "256MB",
                        "batch_time": "50ms",
                        "inflight_window": 100,
                        "request_ttl": "45s"
                      },
                      "parameters": {
                        "sql": "INSERT INTO client_events(clientid, event, created_at)VALUES (\n  ${clientid},\n  ${event},\n  TO_TIMESTAMP((${timestamp} :: bigint))\n)"
                      }
                    },
                    "summary": "Timescale Action"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/bridge_timescale.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mongodb.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/gcp_pubsub_producer.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_elasticsearch.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/action_azure_blob_storage.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/syskeeper.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/pulsar.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/rocketmq.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_matrix.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_sqlserver.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_influxdb.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_clickhouse.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_cassa.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_hstreamdb.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_oracle.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_opents.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_greptimedb.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_s3.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_tdengine.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_dynamo.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/redis.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_rabbitmq.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mqtt_publisher.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mysql.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_pgsql.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_kinesis.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_kafka.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_azure_event_hub.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_datalayers.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/action_couchbase.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_iotdb.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/confluent.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_http.get_bridge_v2"
                    }
                  ]
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bridge not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update a bridge by id.",
        "tags": [
          "Actions"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_action"
          }
        ],
        "summary": "Update bridge",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "http": {
                    "value": {
                      "name": "my_http_action",
                      "status": "connected",
                      "type": "http",
                      "enable": true,
                      "parameters": {
                        "path": "/room/${room_no}",
                        "body": "${.}",
                        "headers": {},
                        "method": "post"
                      },
                      "connector": "my_http_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "worker_pool_size": 16,
                        "query_mode": "async",
                        "health_check_interval": "15s"
                      }
                    },
                    "summary": "HTTP Action"
                  },
                  "confluent_producer": {
                    "value": {
                      "name": "my_confluent_producer_action",
                      "status": "connected",
                      "type": "confluent_producer",
                      "enable": true,
                      "parameters": {
                        "message": {
                          "value": "${.}",
                          "key": "${.clientid}"
                        },
                        "buffer": {
                          "mode": "hybrid",
                          "memory_overload_protection": true,
                          "segment_bytes": "100MB",
                          "per_partition_limit": "2GB"
                        },
                        "topic": "topic",
                        "max_inflight": 10,
                        "required_acks": "all_isr",
                        "max_batch_bytes": "896KB",
                        "partition_count_refresh_interval": "60s",
                        "kafka_header_value_encode_mode": "none",
                        "kafka_ext_headers": [
                          {
                            "kafka_ext_header_value": "${clientid}",
                            "kafka_ext_header_key": "clientid"
                          },
                          {
                            "kafka_ext_header_value": "${topic}",
                            "kafka_ext_header_key": "topic"
                          }
                        ],
                        "kafka_headers": "${.pub_props}",
                        "partition_strategy": "random"
                      },
                      "connector": "my_confluent_producer_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "local_topic": "mqtt/local/topic"
                    },
                    "summary": "Confluent Action"
                  },
                  "iotdb": {
                    "value": {
                      "name": "iotdb_action",
                      "status": "connected",
                      "type": "iotdb",
                      "description": "My example iotdb action",
                      "enable": true,
                      "parameters": {
                        "data": [
                          {
                            "timestamp": "now",
                            "value": "${st}",
                            "data_type": "BOOLEAN",
                            "measurement": "status"
                          }
                        ],
                        "device_id": "my_device",
                        "is_aligned": false
                      },
                      "connector": "iotdb_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "Apache IoTDB Bridge"
                  },
                  "direct_azure_blob_storage": {
                    "value": {
                      "status": "connected",
                      "description": "my action",
                      "enable": true,
                      "parameters": {
                        "mode": "direct",
                        "content": "${.payload}",
                        "blob": "${.payload.blob}",
                        "container": "${.payload.container}"
                      },
                      "connector": "my_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 16,
                        "query_mode": "sync",
                        "batch_time": "0ms",
                        "inflight_window": 100,
                        "request_ttl": "45s",
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "Azure Blob Storage Direct Upload Action"
                  },
                  "couchbase": {
                    "value": {
                      "status": "connected",
                      "description": "my action",
                      "enable": true,
                      "parameters": {
                        "sql": "insert into mqtt (key, value) values (${.id}, ${.payload})"
                      },
                      "connector": "my_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "worker_pool_size": 16,
                        "query_mode": "sync",
                        "inflight_window": 100,
                        "request_ttl": "45s",
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "Couchbase Action"
                  },
                  "datalayers": {
                    "value": {
                      "name": "datalayers_action",
                      "status": "connected",
                      "type": "datalayers",
                      "description": "My example datalayers action",
                      "enable": true,
                      "parameters": {
                        "precision": "ms",
                        "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,bool=${payload.bool}"
                      },
                      "connector": "datalayers_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "Datalayers Action"
                  },
                  "azure_event_hub_producer": {
                    "value": {
                      "name": "my_azure_event_hub_producer_action",
                      "status": "connected",
                      "type": "azure_event_hub_producer",
                      "enable": true,
                      "parameters": {
                        "message": {
                          "value": "${.}",
                          "key": "${.clientid}"
                        },
                        "buffer": {
                          "mode": "hybrid",
                          "memory_overload_protection": true,
                          "segment_bytes": "100MB",
                          "per_partition_limit": "2GB"
                        },
                        "topic": "topic",
                        "max_inflight": 10,
                        "required_acks": "all_isr",
                        "max_batch_bytes": "896KB",
                        "partition_count_refresh_interval": "60s",
                        "kafka_header_value_encode_mode": "none",
                        "kafka_ext_headers": [
                          {
                            "kafka_ext_header_value": "${clientid}",
                            "kafka_ext_header_key": "clientid"
                          },
                          {
                            "kafka_ext_header_value": "${topic}",
                            "kafka_ext_header_key": "topic"
                          }
                        ],
                        "kafka_headers": "${.pub_props}",
                        "partition_strategy": "random"
                      },
                      "connector": "my_azure_event_hub_producer_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "local_topic": "mqtt/local/topic"
                    },
                    "summary": "Azure Event Hub Action"
                  },
                  "kafka_producer": {
                    "value": {
                      "name": "my_kafka_producer_action",
                      "status": "connected",
                      "type": "kafka_producer",
                      "enable": true,
                      "parameters": {
                        "message": {
                          "timestamp": "${.timestamp}",
                          "value": "${.}",
                          "key": "${.clientid}"
                        },
                        "buffer": {
                          "mode": "hybrid",
                          "memory_overload_protection": true,
                          "segment_bytes": "100MB",
                          "per_partition_limit": "2GB"
                        },
                        "compression": "no_compression",
                        "topic": "kafka-topic",
                        "max_inflight": 10,
                        "required_acks": "all_isr",
                        "max_batch_bytes": "896KB",
                        "partitions_limit": "all_partitions",
                        "partition_count_refresh_interval": "60s",
                        "kafka_header_value_encode_mode": "none",
                        "kafka_ext_headers": [
                          {
                            "kafka_ext_header_value": "${clientid}",
                            "kafka_ext_header_key": "clientid"
                          },
                          {
                            "kafka_ext_header_value": "${topic}",
                            "kafka_ext_header_key": "topic"
                          }
                        ],
                        "kafka_headers": "${pub_props}",
                        "partition_strategy": "random"
                      },
                      "connector": "my_kafka_producer_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "32s"
                      },
                      "local_topic": "mqtt/local/topic"
                    },
                    "summary": "Kafka Producer Action"
                  },
                  "kinesis": {
                    "value": {
                      "name": "kinesis_action",
                      "status": "connected",
                      "type": "kinesis",
                      "description": "My example kinesis action",
                      "enable": true,
                      "parameters": {
                        "partition_key": "any_key",
                        "payload_template": "${.}",
                        "stream_name": "my_stream"
                      },
                      "connector": "kinesis_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "Kinesis Action"
                  },
                  "pgsql": {
                    "value": {
                      "name": "my_action",
                      "status": "connected",
                      "type": "pgsql",
                      "enable": true,
                      "connector": "my_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 16,
                        "max_buffer_bytes": "256MB",
                        "batch_time": "50ms",
                        "inflight_window": 100,
                        "request_ttl": "45s"
                      },
                      "parameters": {
                        "sql": "INSERT INTO client_events(clientid, event, created_at)VALUES (\n  ${clientid},\n  ${event},\n  TO_TIMESTAMP((${timestamp} :: bigint))\n)"
                      }
                    },
                    "summary": "PostgreSQL Action"
                  },
                  "mysql": {
                    "value": {
                      "name": "mysql_action",
                      "status": "connected",
                      "type": "mysql",
                      "description": "My example mysql action",
                      "enable": true,
                      "parameters": {
                        "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, FROM_UNIXTIME(${timestamp}/1000))"
                      },
                      "connector": "mysql_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "MySQL Action"
                  },
                  "mqtt": {
                    "value": {
                      "name": "mqtt_action",
                      "status": "connected",
                      "type": "mqtt",
                      "description": "My example mqtt action",
                      "enable": true,
                      "parameters": {
                        "retain": false,
                        "payload": "${.payload}",
                        "topic": "remote/topic",
                        "qos": 2
                      },
                      "connector": "mqtt_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "MQTT Producer Action"
                  },
                  "rabbitmq": {
                    "value": {
                      "name": "rabbitmq_action",
                      "status": "connected",
                      "type": "rabbitmq",
                      "description": "My example rabbitmq action",
                      "enable": true,
                      "parameters": {
                        "exchange": "test_exchange",
                        "payload_template": "${.payload}",
                        "routing_key": "/",
                        "wait_for_publish_confirmations": true,
                        "delivery_mode": "non_persistent",
                        "publish_confirmation_timeout": "30s"
                      },
                      "connector": "rabbitmq_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "RabbitMQ Producer Action"
                  },
                  "redis": {
                    "value": {
                      "status": "connected",
                      "description": "My action",
                      "enable": true,
                      "parameters": {
                        "command_template": [
                          "LPUSH",
                          "MSGS",
                          "${payload}"
                        ]
                      },
                      "connector": "my_connector_name",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "batch_size": 1
                      }
                    },
                    "summary": "Redis Action"
                  },
                  "dynamo": {
                    "value": {
                      "name": "dynamo_action",
                      "status": "connected",
                      "type": "dynamo",
                      "description": "My example dynamo action",
                      "enable": true,
                      "connector": "dynamo_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      },
                      "parameters": {
                        "hash_key": "clientid",
                        "table": "mqtt_msg",
                        "template": ""
                      }
                    },
                    "summary": "DynamoDB Action"
                  },
                  "tdengine": {
                    "value": {
                      "name": "tdengine_action",
                      "status": "connected",
                      "type": "tdengine",
                      "description": "My example tdengine action",
                      "enable": true,
                      "parameters": {
                        "database": "mqtt",
                        "sql": "insert into t_mqtt_msg(ts, msgid, mqtt_topic, qos, payload, arrived) values (${ts}, '${id}', '${topic}', ${qos}, '${payload}', ${timestamp})"
                      },
                      "connector": "tdengine_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "TDengine Action"
                  },
                  "s3": {
                    "value": {
                      "status": "connected",
                      "description": "My upload action",
                      "enable": true,
                      "parameters": {
                        "mode": "direct",
                        "key": "${topic}",
                        "content": "${payload}",
                        "bucket": "${clientid}",
                        "acl": "public_read"
                      },
                      "connector": "my_s3_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "query_mode": "sync",
                        "inflight_window": 10
                      }
                    },
                    "summary": "S3 Direct Upload"
                  },
                  "greptimedb": {
                    "value": {
                      "name": "greptimedb_action",
                      "status": "connected",
                      "type": "greptimedb",
                      "description": "My example greptimedb action",
                      "enable": true,
                      "parameters": {
                        "precision": "ms",
                        "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,uint_value=${payload.uint_key}u,bool=${payload.bool}"
                      },
                      "connector": "greptimedb_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "GreptimeDB Action"
                  },
                  "opents": {
                    "value": {
                      "name": "opents_action",
                      "status": "connected",
                      "type": "opents",
                      "description": "My example opents action",
                      "enable": true,
                      "parameters": {
                        "data": [
                          {
                            "value": "${value}",
                            "tags": "${tags}",
                            "metric": "${metric}"
                          }
                        ]
                      },
                      "connector": "opents_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "OpenTSDB Action"
                  },
                  "oracle": {
                    "value": {
                      "name": "oracle_action",
                      "status": "connected",
                      "type": "oracle",
                      "description": "My example oracle action",
                      "enable": true,
                      "parameters": {
                        "sql": "insert into t_mqtt_msgs(msgid, topic, qos, payload) values (${id}, ${topic}, ${qos}, ${payload})"
                      },
                      "connector": "oracle_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "Oracle Action"
                  },
                  "hstreamdb": {
                    "value": {
                      "name": "hstreamdb_action",
                      "status": "connected",
                      "type": "hstreamdb",
                      "description": "My example hstreamdb action",
                      "enable": true,
                      "connector": "hstreamdb_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      },
                      "parameters": {
                        "aggregation_pool_size": 8,
                        "partition_key": "hej",
                        "record_template": "${payload}",
                        "stream": "mqtt_message",
                        "writer_pool_size": 8
                      }
                    },
                    "summary": "HStreamDB Action"
                  },
                  "cassandra": {
                    "value": {
                      "name": "cassandra_action",
                      "status": "connected",
                      "type": "cassandra",
                      "description": "My example cassandra action",
                      "enable": true,
                      "parameters": {
                        "cql": "insert into mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic},  ${qos}, ${payload}, ${timestamp})"
                      },
                      "connector": "cassandra_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "Cassandra Action"
                  },
                  "clickhouse": {
                    "value": {
                      "name": "clickhouse_action",
                      "status": "connected",
                      "type": "clickhouse",
                      "description": "My example clickhouse action",
                      "enable": true,
                      "parameters": {
                        "sql": "INSERT INTO messages(data, arrived) VALUES ('${payload}', ${timestamp})",
                        "batch_value_separator": ", "
                      },
                      "connector": "clickhouse_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "ClickHouse Action"
                  },
                  "influxdb": {
                    "value": {
                      "name": "influxdb_action",
                      "status": "connected",
                      "type": "influxdb",
                      "description": "My example influxdb action",
                      "enable": true,
                      "parameters": {
                        "precision": "ms",
                        "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,bool=${payload.bool}"
                      },
                      "connector": "influxdb_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "InfluxDB Action"
                  },
                  "sqlserver": {
                    "value": {
                      "name": "sqlserver_action",
                      "status": "connected",
                      "type": "sqlserver",
                      "description": "My example sqlserver action",
                      "enable": true,
                      "connector": "sqlserver_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      },
                      "parameters": {
                        "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload) values ( ${id}, ${topic}, ${qos}, ${payload} )"
                      }
                    },
                    "summary": "Microsoft SQL Server Action"
                  },
                  "matrix": {
                    "value": {
                      "name": "my_action",
                      "status": "connected",
                      "type": "matrix",
                      "enable": true,
                      "connector": "my_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 16,
                        "max_buffer_bytes": "256MB",
                        "batch_time": "50ms",
                        "inflight_window": 100,
                        "request_ttl": "45s"
                      },
                      "parameters": {
                        "sql": "INSERT INTO client_events(clientid, event, created_at)VALUES (\n  ${clientid},\n  ${event},\n  TO_TIMESTAMP((${timestamp} :: bigint))\n)"
                      }
                    },
                    "summary": "Matrix Action"
                  },
                  "aggregated_azure_blob_storage": {
                    "value": {
                      "status": "connected",
                      "description": "my action",
                      "enable": true,
                      "parameters": {
                        "mode": "aggregated",
                        "blob": "${action}/${node}/${datetime.rfc3339}/${sequence}",
                        "container": "mycontainer",
                        "aggregation": {
                          "container": {
                            "type": "csv",
                            "column_order": [
                              "a",
                              "b"
                            ]
                          },
                          "max_records": 10000,
                          "time_interval": "4s"
                        }
                      },
                      "connector": "my_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "batch_size": 100,
                        "worker_pool_size": 16,
                        "query_mode": "sync",
                        "batch_time": "10ms",
                        "inflight_window": 100,
                        "request_ttl": "45s",
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "Azure Blob Storage Aggregated Upload Action"
                  },
                  "rocketmq": {
                    "value": {
                      "name": "rocketmq_action",
                      "status": "connected",
                      "type": "rocketmq",
                      "description": "My example rocketmq action",
                      "enable": true,
                      "connector": "rocketmq_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      },
                      "parameters": {
                        "refresh_interval": "3s",
                        "send_buffer": "1024KB",
                        "sync_timeout": "3s",
                        "template": "",
                        "topic": "TopicTest"
                      }
                    },
                    "summary": "RocketMQ Action"
                  },
                  "pulsar": {
                    "value": {
                      "name": "pulsar_action",
                      "status": "connected",
                      "type": "pulsar",
                      "description": "My example pulsar action",
                      "enable": true,
                      "parameters": {
                        "message": {
                          "value": "${.}",
                          "key": "${.clientid}"
                        },
                        "sync_timeout": "5s",
                        "pulsar_topic": "test_topic"
                      },
                      "connector": "pulsar_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "Pulsar Producer Action"
                  },
                  "syskeeper_forwarder": {
                    "value": {
                      "name": "syskeeper_forwarder",
                      "status": "connected",
                      "type": "syskeeper_forwarder",
                      "enable": true,
                      "parameters": {
                        "template": "${payload}",
                        "target_topic": "${topic}"
                      },
                      "connector": "syskeeper_forwarder",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "worker_pool_size": 16
                      }
                    },
                    "summary": "Syskeeper Forwarder Bridge"
                  },
                  "s3_aggreg": {
                    "value": {
                      "status": "connected",
                      "description": "My aggregated upload action",
                      "enable": true,
                      "parameters": {
                        "mode": "aggregated",
                        "key": "${action}/${node}/${datetime.rfc3339utc}_N${sequence}.csv",
                        "bucket": "mqtt-aggregated",
                        "acl": "public_read",
                        "aggregation": {
                          "max_records": 100000,
                          "time_interval": "15m"
                        },
                        "container": {
                          "type": "csv",
                          "column_order": [
                            "clientid",
                            "topic",
                            "publish_received_at"
                          ]
                        }
                      },
                      "connector": "my_s3_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "query_mode": "async",
                        "inflight_window": 100,
                        "health_check_interval": "10s"
                      }
                    },
                    "summary": "S3 Aggregated Upload"
                  },
                  "elasticsearch": {
                    "value": {
                      "name": "elasticsearch_action",
                      "status": "connected",
                      "type": "elasticsearch",
                      "description": "My example elasticsearch action",
                      "enable": true,
                      "parameters": {
                        "index": "${payload.index}",
                        "action": "create",
                        "doc": "${payload.doc}",
                        "overwrite": true
                      },
                      "connector": "elasticsearch_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "Elastic Search Bridge"
                  },
                  "gcp_pubsub_producer": {
                    "value": {
                      "status": "connected",
                      "description": "My action",
                      "enable": true,
                      "parameters": {
                        "payload_template": "${payload}",
                        "pubsub_topic": "mytopic",
                        "ordering_key_template": "${payload.ok}",
                        "attributes_template": [
                          {
                            "value": "${payload.attrs.v}",
                            "key": "${payload.attrs.k}"
                          }
                        ]
                      },
                      "connector": "my_connector_name",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "batch_size": 5
                      },
                      "local_topic": "local/topic"
                    },
                    "summary": "GCP PubSub Producer Action"
                  },
                  "mongodb": {
                    "value": {
                      "name": "mongodb_action",
                      "status": "connected",
                      "type": "mongodb",
                      "description": "My example mongodb action",
                      "enable": true,
                      "parameters": {
                        "collection": "mycol"
                      },
                      "connector": "mongodb_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "health_check_interval": "30s"
                      }
                    },
                    "summary": "MongoDB Action"
                  },
                  "timescale": {
                    "value": {
                      "name": "my_action",
                      "status": "connected",
                      "type": "timescale",
                      "enable": true,
                      "connector": "my_connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 16,
                        "max_buffer_bytes": "256MB",
                        "batch_time": "50ms",
                        "inflight_window": 100,
                        "request_ttl": "45s"
                      },
                      "parameters": {
                        "sql": "INSERT INTO client_events(clientid, event, created_at)VALUES (\n  ${clientid},\n  ${event},\n  TO_TIMESTAMP((${timestamp} :: bigint))\n)"
                      }
                    },
                    "summary": "Timescale Action"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/bridge_timescale.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mongodb.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/gcp_pubsub_producer.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_elasticsearch.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/action_azure_blob_storage.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/syskeeper.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/pulsar.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/rocketmq.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_matrix.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_sqlserver.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_influxdb.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_clickhouse.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_cassa.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_hstreamdb.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_oracle.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_opents.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_greptimedb.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_s3.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_tdengine.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_dynamo.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/redis.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_rabbitmq.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mqtt_publisher.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mysql.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_pgsql.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_kinesis.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_kafka.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_azure_event_hub.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_datalayers.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/action_couchbase.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_iotdb.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/confluent.get_bridge_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_http.get_bridge_v2"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Update bridge failed"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bridge not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "http": {
                  "value": {
                    "enable": true,
                    "parameters": {
                      "path": "/room/${room_no}",
                      "body": "${.}",
                      "headers": {},
                      "method": "post"
                    },
                    "connector": "my_http_connector",
                    "resource_opts": {
                      "worker_pool_size": 16,
                      "query_mode": "async",
                      "health_check_interval": "15s"
                    }
                  },
                  "summary": "HTTP Action"
                },
                "confluent_producer": {
                  "value": {
                    "enable": true,
                    "parameters": {
                      "message": {
                        "value": "${.}",
                        "key": "${.clientid}"
                      },
                      "buffer": {
                        "mode": "hybrid",
                        "memory_overload_protection": true,
                        "segment_bytes": "100MB",
                        "per_partition_limit": "2GB"
                      },
                      "topic": "topic",
                      "max_inflight": 10,
                      "required_acks": "all_isr",
                      "max_batch_bytes": "896KB",
                      "partition_count_refresh_interval": "60s",
                      "kafka_header_value_encode_mode": "none",
                      "kafka_ext_headers": [
                        {
                          "kafka_ext_header_value": "${clientid}",
                          "kafka_ext_header_key": "clientid"
                        },
                        {
                          "kafka_ext_header_value": "${topic}",
                          "kafka_ext_header_key": "topic"
                        }
                      ],
                      "kafka_headers": "${.pub_props}",
                      "partition_strategy": "random"
                    },
                    "connector": "my_confluent_producer_connector",
                    "local_topic": "mqtt/local/topic"
                  },
                  "summary": "Confluent Action"
                },
                "iotdb": {
                  "value": {
                    "description": "My example iotdb action",
                    "enable": true,
                    "parameters": {
                      "data": [
                        {
                          "timestamp": "now",
                          "value": "${st}",
                          "data_type": "BOOLEAN",
                          "measurement": "status"
                        }
                      ],
                      "device_id": "my_device",
                      "is_aligned": false
                    },
                    "connector": "iotdb_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "Apache IoTDB Bridge"
                },
                "direct_azure_blob_storage": {
                  "value": {
                    "description": "my action",
                    "enable": true,
                    "parameters": {
                      "mode": "direct",
                      "content": "${.payload}",
                      "blob": "${.payload.blob}",
                      "container": "${.payload.container}"
                    },
                    "connector": "my_connector",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 16,
                      "query_mode": "sync",
                      "batch_time": "0ms",
                      "inflight_window": 100,
                      "request_ttl": "45s",
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "Azure Blob Storage Direct Upload Action"
                },
                "couchbase": {
                  "value": {
                    "description": "my action",
                    "enable": true,
                    "parameters": {
                      "sql": "insert into mqtt (key, value) values (${.id}, ${.payload})"
                    },
                    "connector": "my_connector",
                    "resource_opts": {
                      "worker_pool_size": 16,
                      "query_mode": "sync",
                      "inflight_window": 100,
                      "request_ttl": "45s",
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "Couchbase Action"
                },
                "datalayers": {
                  "value": {
                    "description": "My example datalayers action",
                    "enable": true,
                    "parameters": {
                      "precision": "ms",
                      "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,bool=${payload.bool}"
                    },
                    "connector": "datalayers_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "Datalayers Action"
                },
                "azure_event_hub_producer": {
                  "value": {
                    "enable": true,
                    "parameters": {
                      "message": {
                        "value": "${.}",
                        "key": "${.clientid}"
                      },
                      "buffer": {
                        "mode": "hybrid",
                        "memory_overload_protection": true,
                        "segment_bytes": "100MB",
                        "per_partition_limit": "2GB"
                      },
                      "topic": "topic",
                      "max_inflight": 10,
                      "required_acks": "all_isr",
                      "max_batch_bytes": "896KB",
                      "partition_count_refresh_interval": "60s",
                      "kafka_header_value_encode_mode": "none",
                      "kafka_ext_headers": [
                        {
                          "kafka_ext_header_value": "${clientid}",
                          "kafka_ext_header_key": "clientid"
                        },
                        {
                          "kafka_ext_header_value": "${topic}",
                          "kafka_ext_header_key": "topic"
                        }
                      ],
                      "kafka_headers": "${.pub_props}",
                      "partition_strategy": "random"
                    },
                    "connector": "my_azure_event_hub_producer_connector",
                    "local_topic": "mqtt/local/topic"
                  },
                  "summary": "Azure Event Hub Action"
                },
                "kafka_producer": {
                  "value": {
                    "enable": true,
                    "parameters": {
                      "message": {
                        "timestamp": "${.timestamp}",
                        "value": "${.}",
                        "key": "${.clientid}"
                      },
                      "buffer": {
                        "mode": "hybrid",
                        "memory_overload_protection": true,
                        "segment_bytes": "100MB",
                        "per_partition_limit": "2GB"
                      },
                      "compression": "no_compression",
                      "topic": "kafka-topic",
                      "max_inflight": 10,
                      "required_acks": "all_isr",
                      "max_batch_bytes": "896KB",
                      "partitions_limit": "all_partitions",
                      "partition_count_refresh_interval": "60s",
                      "kafka_header_value_encode_mode": "none",
                      "kafka_ext_headers": [
                        {
                          "kafka_ext_header_value": "${clientid}",
                          "kafka_ext_header_key": "clientid"
                        },
                        {
                          "kafka_ext_header_value": "${topic}",
                          "kafka_ext_header_key": "topic"
                        }
                      ],
                      "kafka_headers": "${pub_props}",
                      "partition_strategy": "random"
                    },
                    "connector": "my_kafka_producer_connector",
                    "resource_opts": {
                      "health_check_interval": "32s"
                    },
                    "local_topic": "mqtt/local/topic"
                  },
                  "summary": "Kafka Producer Action"
                },
                "kinesis": {
                  "value": {
                    "description": "My example kinesis action",
                    "enable": true,
                    "parameters": {
                      "partition_key": "any_key",
                      "payload_template": "${.}",
                      "stream_name": "my_stream"
                    },
                    "connector": "kinesis_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "Kinesis Action"
                },
                "pgsql": {
                  "value": {
                    "name": "my_action",
                    "type": "pgsql",
                    "enable": true,
                    "connector": "my_connector",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 16,
                      "max_buffer_bytes": "256MB",
                      "batch_time": "50ms",
                      "inflight_window": 100,
                      "request_ttl": "45s"
                    },
                    "parameters": {
                      "sql": "INSERT INTO client_events(clientid, event, created_at)VALUES (\n  ${clientid},\n  ${event},\n  TO_TIMESTAMP((${timestamp} :: bigint))\n)"
                    }
                  },
                  "summary": "PostgreSQL Action"
                },
                "mysql": {
                  "value": {
                    "description": "My example mysql action",
                    "enable": true,
                    "parameters": {
                      "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, FROM_UNIXTIME(${timestamp}/1000))"
                    },
                    "connector": "mysql_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "MySQL Action"
                },
                "mqtt": {
                  "value": {
                    "description": "My example mqtt action",
                    "enable": true,
                    "parameters": {
                      "retain": false,
                      "payload": "${.payload}",
                      "topic": "remote/topic",
                      "qos": 2
                    },
                    "connector": "mqtt_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "MQTT Producer Action"
                },
                "rabbitmq": {
                  "value": {
                    "description": "My example rabbitmq action",
                    "enable": true,
                    "parameters": {
                      "exchange": "test_exchange",
                      "payload_template": "${.payload}",
                      "routing_key": "/",
                      "wait_for_publish_confirmations": true,
                      "delivery_mode": "non_persistent",
                      "publish_confirmation_timeout": "30s"
                    },
                    "connector": "rabbitmq_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "RabbitMQ Producer Action"
                },
                "redis": {
                  "value": {
                    "description": "My action",
                    "enable": true,
                    "parameters": {
                      "command_template": [
                        "LPUSH",
                        "MSGS",
                        "${payload}"
                      ]
                    },
                    "connector": "my_connector_name",
                    "resource_opts": {
                      "batch_size": 1
                    }
                  },
                  "summary": "Redis Action"
                },
                "dynamo": {
                  "value": {
                    "description": "My example dynamo action",
                    "enable": true,
                    "connector": "dynamo_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    },
                    "parameters": {
                      "hash_key": "clientid",
                      "table": "mqtt_msg",
                      "template": ""
                    }
                  },
                  "summary": "DynamoDB Action"
                },
                "tdengine": {
                  "value": {
                    "description": "My example tdengine action",
                    "enable": true,
                    "parameters": {
                      "database": "mqtt",
                      "sql": "insert into t_mqtt_msg(ts, msgid, mqtt_topic, qos, payload, arrived) values (${ts}, '${id}', '${topic}', ${qos}, '${payload}', ${timestamp})"
                    },
                    "connector": "tdengine_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "TDengine Action"
                },
                "s3": {
                  "value": {
                    "description": "My upload action",
                    "parameters": {
                      "mode": "direct",
                      "key": "${topic}",
                      "content": "${payload}",
                      "bucket": "${clientid}",
                      "acl": "public_read"
                    },
                    "resource_opts": {
                      "query_mode": "sync",
                      "inflight_window": 10
                    }
                  },
                  "summary": "S3 Direct Upload"
                },
                "greptimedb": {
                  "value": {
                    "description": "My example greptimedb action",
                    "enable": true,
                    "parameters": {
                      "precision": "ms",
                      "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,uint_value=${payload.uint_key}u,bool=${payload.bool}"
                    },
                    "connector": "greptimedb_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "GreptimeDB Action"
                },
                "opents": {
                  "value": {
                    "description": "My example opents action",
                    "enable": true,
                    "parameters": {
                      "data": [
                        {
                          "value": "${value}",
                          "tags": "${tags}",
                          "metric": "${metric}"
                        }
                      ]
                    },
                    "connector": "opents_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "OpenTSDB Action"
                },
                "oracle": {
                  "value": {
                    "description": "My example oracle action",
                    "enable": true,
                    "parameters": {
                      "sql": "insert into t_mqtt_msgs(msgid, topic, qos, payload) values (${id}, ${topic}, ${qos}, ${payload})"
                    },
                    "connector": "oracle_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "Oracle Action"
                },
                "hstreamdb": {
                  "value": {
                    "description": "My example hstreamdb action",
                    "enable": true,
                    "connector": "hstreamdb_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    },
                    "parameters": {
                      "aggregation_pool_size": 8,
                      "partition_key": "hej",
                      "record_template": "${payload}",
                      "stream": "mqtt_message",
                      "writer_pool_size": 8
                    }
                  },
                  "summary": "HStreamDB Action"
                },
                "cassandra": {
                  "value": {
                    "description": "My example cassandra action",
                    "enable": true,
                    "parameters": {
                      "cql": "insert into mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic},  ${qos}, ${payload}, ${timestamp})"
                    },
                    "connector": "cassandra_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "Cassandra Action"
                },
                "clickhouse": {
                  "value": {
                    "description": "My example clickhouse action",
                    "enable": true,
                    "parameters": {
                      "sql": "INSERT INTO messages(data, arrived) VALUES ('${payload}', ${timestamp})",
                      "batch_value_separator": ", "
                    },
                    "connector": "clickhouse_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "ClickHouse Action"
                },
                "influxdb": {
                  "value": {
                    "description": "My example influxdb action",
                    "enable": true,
                    "parameters": {
                      "precision": "ms",
                      "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,bool=${payload.bool}"
                    },
                    "connector": "influxdb_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "InfluxDB Action"
                },
                "sqlserver": {
                  "value": {
                    "description": "My example sqlserver action",
                    "enable": true,
                    "connector": "sqlserver_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    },
                    "parameters": {
                      "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload) values ( ${id}, ${topic}, ${qos}, ${payload} )"
                    }
                  },
                  "summary": "Microsoft SQL Server Action"
                },
                "matrix": {
                  "value": {
                    "name": "my_action",
                    "type": "matrix",
                    "enable": true,
                    "connector": "my_connector",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 16,
                      "max_buffer_bytes": "256MB",
                      "batch_time": "50ms",
                      "inflight_window": 100,
                      "request_ttl": "45s"
                    },
                    "parameters": {
                      "sql": "INSERT INTO client_events(clientid, event, created_at)VALUES (\n  ${clientid},\n  ${event},\n  TO_TIMESTAMP((${timestamp} :: bigint))\n)"
                    }
                  },
                  "summary": "Matrix Action"
                },
                "aggregated_azure_blob_storage": {
                  "value": {
                    "description": "my action",
                    "enable": true,
                    "parameters": {
                      "mode": "aggregated",
                      "blob": "${action}/${node}/${datetime.rfc3339}/${sequence}",
                      "container": "mycontainer",
                      "aggregation": {
                        "container": {
                          "type": "csv",
                          "column_order": [
                            "a",
                            "b"
                          ]
                        },
                        "max_records": 10000,
                        "time_interval": "4s"
                      }
                    },
                    "connector": "my_connector",
                    "resource_opts": {
                      "batch_size": 100,
                      "worker_pool_size": 16,
                      "query_mode": "sync",
                      "batch_time": "10ms",
                      "inflight_window": 100,
                      "request_ttl": "45s",
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "Azure Blob Storage Aggregated Upload Action"
                },
                "rocketmq": {
                  "value": {
                    "description": "My example rocketmq action",
                    "enable": true,
                    "connector": "rocketmq_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    },
                    "parameters": {
                      "refresh_interval": "3s",
                      "send_buffer": "1024KB",
                      "sync_timeout": "3s",
                      "template": "",
                      "topic": "TopicTest"
                    }
                  },
                  "summary": "RocketMQ Action"
                },
                "pulsar": {
                  "value": {
                    "description": "My example pulsar action",
                    "enable": true,
                    "parameters": {
                      "message": {
                        "value": "${.}",
                        "key": "${.clientid}"
                      },
                      "sync_timeout": "5s",
                      "pulsar_topic": "test_topic"
                    },
                    "connector": "pulsar_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "Pulsar Producer Action"
                },
                "syskeeper_forwarder": {
                  "value": {
                    "enable": true,
                    "parameters": {
                      "template": "${payload}",
                      "target_topic": "${topic}"
                    },
                    "connector": "syskeeper_forwarder",
                    "resource_opts": {
                      "worker_pool_size": 16
                    }
                  },
                  "summary": "Syskeeper Forwarder Bridge"
                },
                "s3_aggreg": {
                  "value": {
                    "description": "My aggregated upload action",
                    "parameters": {
                      "mode": "aggregated",
                      "key": "${action}/${node}/${datetime.rfc3339utc}_N${sequence}.csv",
                      "bucket": "mqtt-aggregated",
                      "acl": "public_read",
                      "aggregation": {
                        "max_records": 100000,
                        "time_interval": "15m"
                      },
                      "container": {
                        "type": "csv",
                        "column_order": [
                          "clientid",
                          "topic",
                          "publish_received_at"
                        ]
                      }
                    },
                    "resource_opts": {
                      "query_mode": "async",
                      "inflight_window": 100,
                      "health_check_interval": "10s"
                    }
                  },
                  "summary": "S3 Aggregated Upload"
                },
                "elasticsearch": {
                  "value": {
                    "description": "My example elasticsearch action",
                    "enable": true,
                    "parameters": {
                      "index": "${payload.index}",
                      "action": "create",
                      "doc": "${payload.doc}",
                      "overwrite": true
                    },
                    "connector": "elasticsearch_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "Elastic Search Bridge"
                },
                "gcp_pubsub_producer": {
                  "value": {
                    "description": "My action",
                    "enable": true,
                    "parameters": {
                      "payload_template": "${payload}",
                      "pubsub_topic": "mytopic",
                      "ordering_key_template": "${payload.ok}",
                      "attributes_template": [
                        {
                          "value": "${payload.attrs.v}",
                          "key": "${payload.attrs.k}"
                        }
                      ]
                    },
                    "connector": "my_connector_name",
                    "resource_opts": {
                      "batch_size": 5
                    },
                    "local_topic": "local/topic"
                  },
                  "summary": "GCP PubSub Producer Action"
                },
                "mongodb": {
                  "value": {
                    "description": "My example mongodb action",
                    "enable": true,
                    "parameters": {
                      "collection": "mycol"
                    },
                    "connector": "mongodb_connector",
                    "resource_opts": {
                      "health_check_interval": "30s"
                    }
                  },
                  "summary": "MongoDB Action"
                },
                "timescale": {
                  "value": {
                    "name": "my_action",
                    "type": "timescale",
                    "enable": true,
                    "connector": "my_connector",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 16,
                      "max_buffer_bytes": "256MB",
                      "batch_time": "50ms",
                      "inflight_window": 100,
                      "request_ttl": "45s"
                    },
                    "parameters": {
                      "sql": "INSERT INTO client_events(clientid, event, created_at)VALUES (\n  ${clientid},\n  ${event},\n  TO_TIMESTAMP((${timestamp} :: bigint))\n)"
                    }
                  },
                  "summary": "Timescale Action"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/bridge_timescale.put_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mongodb.put_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/gcp_pubsub_producer.put_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_elasticsearch.put_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/action_azure_blob_storage.put_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/syskeeper.put_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/pulsar.put_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/rocketmq.put_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_matrix.put_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_sqlserver.put_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_influxdb.put_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_clickhouse.put_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_cassa.put_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_hstreamdb.put_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_oracle.put_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_opents.put_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_greptimedb.put_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_s3.put_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_tdengine.put_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_dynamo.put_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/redis.put_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_rabbitmq.put_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mqtt_publisher.put_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mysql.put_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_pgsql.put_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_kinesis.put_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_kafka.put_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_azure_event_hub.put_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_datalayers.put_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/action_couchbase.put_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_iotdb.put_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/confluent.put_bridge_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_http.put_bridge_v2"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete a bridge by id.",
        "tags": [
          "Actions"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_action"
          },
          {
            "in": "query",
            "name": "also_delete_dep_actions",
            "description": "Whether to cascade delete dependent actions.",
            "required": false,
            "schema": {
              "default": false,
              "type": "boolean"
            }
          }
        ],
        "summary": "Delete bridge",
        "responses": {
          "204": {
            "description": "Bridge deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "rules": {
                      "type": "array",
                      "description": "Dependent Rule IDs",
                      "items": {
                        "type": "string"
                      }
                    },
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Cannot delete bridge while active rules are defined for this bridge"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bridge not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Service unavailable"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/license/setting": {
      "get": {
        "description": "Update license setting",
        "tags": [
          "License"
        ],
        "parameters": [],
        "summary": "Get license setting",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "connection_low_watermark": {
                      "default": "75%",
                      "type": "string",
                      "description": "Low watermark limit below which license connection quota usage alarms are deactivated",
                      "example": "75%"
                    },
                    "connection_high_watermark": {
                      "default": "80%",
                      "type": "string",
                      "description": "High watermark limit above which license connection quota usage alarms are activated",
                      "example": "80%"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update license setting",
        "tags": [
          "License"
        ],
        "parameters": [],
        "summary": "Update license setting",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "connection_low_watermark": {
                      "default": "75%",
                      "type": "string",
                      "description": "Low watermark limit below which license connection quota usage alarms are deactivated",
                      "example": "75%"
                    },
                    "connection_high_watermark": {
                      "default": "80%",
                      "type": "string",
                      "description": "High watermark limit above which license connection quota usage alarms are activated",
                      "example": "80%"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad setting value"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "connection_low_watermark": {
                    "default": "75%",
                    "type": "string",
                    "description": "Low watermark limit below which license connection quota usage alarms are deactivated",
                    "example": "75%"
                  },
                  "connection_high_watermark": {
                    "default": "80%",
                    "type": "string",
                    "description": "High watermark limit above which license connection quota usage alarms are activated",
                    "example": "80%"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/authorization/sources/{type}": {
      "get": {
        "description": "Get a authorization source",
        "tags": [
          "Authorization"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "type",
            "description": "Authorization type",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "file",
                "built_in_database",
                "http",
                "redis",
                "mysql",
                "postgresql",
                "mongodb",
                "ldap"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Authorization source",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authz.ldap"
                    },
                    {
                      "$ref": "#/components/schemas/authz.mongo_sharded"
                    },
                    {
                      "$ref": "#/components/schemas/authz.mongo_rs"
                    },
                    {
                      "$ref": "#/components/schemas/authz.mongo_single"
                    },
                    {
                      "$ref": "#/components/schemas/authz.postgresql"
                    },
                    {
                      "$ref": "#/components/schemas/authz.mysql"
                    },
                    {
                      "$ref": "#/components/schemas/authz.redis_cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authz.redis_sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authz.redis_single"
                    },
                    {
                      "$ref": "#/components/schemas/authz.http_post"
                    },
                    {
                      "$ref": "#/components/schemas/authz.http_get"
                    },
                    {
                      "$ref": "#/components/schemas/authz.builtin_db"
                    },
                    {
                      "$ref": "#/components/schemas/authz.api_file"
                    }
                  ]
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update source",
        "tags": [
          "Authorization"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "type",
            "description": "Authorization type",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "file",
                "built_in_database",
                "http",
                "redis",
                "mysql",
                "postgresql",
                "mongodb",
                "ldap"
              ]
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Authorization source updated successfully"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/authz.ldap"
                  },
                  {
                    "$ref": "#/components/schemas/authz.mongo_sharded"
                  },
                  {
                    "$ref": "#/components/schemas/authz.mongo_rs"
                  },
                  {
                    "$ref": "#/components/schemas/authz.mongo_single"
                  },
                  {
                    "$ref": "#/components/schemas/authz.postgresql"
                  },
                  {
                    "$ref": "#/components/schemas/authz.mysql"
                  },
                  {
                    "$ref": "#/components/schemas/authz.redis_cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authz.redis_sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/authz.redis_single"
                  },
                  {
                    "$ref": "#/components/schemas/authz.http_post"
                  },
                  {
                    "$ref": "#/components/schemas/authz.http_get"
                  },
                  {
                    "$ref": "#/components/schemas/authz.builtin_db"
                  },
                  {
                    "$ref": "#/components/schemas/authz.api_file"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete source",
        "tags": [
          "Authorization"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "type",
            "description": "Authorization type",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "file",
                "built_in_database",
                "http",
                "redis",
                "mysql",
                "postgresql",
                "mongodb",
                "ldap"
              ]
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Deleted successfully"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/{name}/authentication/import_users": {
      "post": {
        "description": "Import users into the gateway authenticator (only supports built_in_database)",
        "tags": [
          "Gateway Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "gbt32960",
                "jt808",
                "lwm2m",
                "mqttsn",
                "ocpp",
                "stomp"
              ]
            },
            "example": "stomp"
          }
        ],
        "summary": "Import users",
        "responses": {
          "204": {
            "description": "Imported"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "multipart/form-data": {
              "schema": {
                "type": "object",
                "properties": {
                  "filename": {
                    "type": "string",
                    "format": "binary"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/schema_validations/validation/{name}/metrics/reset": {
      "post": {
        "description": "Reset metrics for a particular validation",
        "tags": [
          "Schema Validation"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Validation name",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "my_validation"
          }
        ],
        "summary": "Reset validation metrics",
        "responses": {
          "204": {
            "description": "No content"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Validation not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/api_key": {
      "get": {
        "description": "Return api_key list. This API can only be requested using a bearer token.",
        "tags": [
          "API Keys"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "name": {
                      "type": "string",
                      "description": "Unique and format by [a-zA-Z0-9-_]",
                      "example": "EMQX-API-KEY-1"
                    },
                    "api_key": {
                      "type": "string",
                      "description": "TODO:uses HMAC-SHA256 for signing.",
                      "example": "a4697a5c75a769f6"
                    },
                    "expired_at": {
                      "default": "infinity",
                      "description": "No longer valid datetime",
                      "example": "2021-12-05T02:01:34.186Z",
                      "oneOf": [
                        {
                          "oneOf": [
                            {
                              "type": "integer",
                              "description": "epoch-second",
                              "example": 1640995200
                            },
                            {
                              "type": "string",
                              "format": "date-time",
                              "example": "2022-01-01T00:00:00.000Z"
                            }
                          ]
                        },
                        {
                          "type": "string",
                          "enum": [
                            "infinity"
                          ]
                        }
                      ]
                    },
                    "created_at": {
                      "description": "ApiKey create datetime",
                      "example": "2021-12-01T00:00:00.000Z",
                      "oneOf": [
                        {
                          "type": "integer",
                          "description": "epoch-second",
                          "example": 1640995200
                        },
                        {
                          "type": "string",
                          "format": "date-time",
                          "example": "2022-01-01T00:00:00.000Z"
                        }
                      ]
                    },
                    "desc": {
                      "type": "string",
                      "example": "Note"
                    },
                    "enable": {
                      "type": "boolean",
                      "description": "Enable/Disable"
                    },
                    "expired": {
                      "type": "boolean",
                      "description": "Expired"
                    },
                    "role": {
                      "default": "administrator",
                      "type": "string",
                      "description": "Role for this API",
                      "example": "administrator"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Create new api_key. This API can only be requested using a bearer token.",
        "tags": [
          "API Keys"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/api_key.app"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Unique and format by [a-zA-Z0-9-_]",
                    "example": "EMQX-API-KEY-1"
                  },
                  "expired_at": {
                    "default": "infinity",
                    "description": "No longer valid datetime",
                    "example": "2021-12-05T02:01:34.186Z",
                    "oneOf": [
                      {
                        "oneOf": [
                          {
                            "type": "integer",
                            "description": "epoch-second",
                            "example": 1640995200
                          },
                          {
                            "type": "string",
                            "format": "date-time",
                            "example": "2022-01-01T00:00:00.000Z"
                          }
                        ]
                      },
                      {
                        "type": "string",
                        "enum": [
                          "infinity"
                        ]
                      }
                    ]
                  },
                  "desc": {
                    "type": "string",
                    "example": "Note"
                  },
                  "enable": {
                    "type": "boolean",
                    "description": "Enable/Disable"
                  },
                  "expired": {
                    "type": "boolean",
                    "description": "Expired"
                  },
                  "role": {
                    "default": "administrator",
                    "type": "string",
                    "description": "Role for this API",
                    "example": "administrator"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "security": [
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/listeners/{id}/start": {
      "post": {
        "description": "Start the listener on all nodes.",
        "tags": [
          "Listeners"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/listeners.listener_id"
          }
        ],
        "responses": {
          "200": {
            "description": "Updated"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST",
                        "BAD_LISTENER_ID"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/banned": {
      "get": {
        "description": "List all currently banned client IDs, usernames and IP addresses.",
        "tags": [
          "Banned"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "data": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/emqx_mgmt_api_banned.ban"
                      }
                    },
                    "meta": {
                      "$ref": "#/components/schemas/public.meta"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Clear all banned data.",
        "tags": [
          "Banned"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": "No Content"
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Add a client ID, username or IP address to the blacklist.",
        "tags": [
          "Banned"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "data": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/emqx_mgmt_api_banned.ban"
                      }
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "ALREADY_EXISTS",
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request, possibly due to wrong parameters or the existence of a banned object."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx_mgmt_api_banned.ban"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/connectors/{id}/enable/{enable}": {
      "put": {
        "description": "Enable or Disable connector on all nodes in the cluster.",
        "tags": [
          "Connectors"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The connector id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_connector"
          },
          {
            "in": "path",
            "name": "enable",
            "description": "Whether to enable this connector.",
            "required": true,
            "schema": {
              "type": "boolean"
            },
            "example": true
          }
        ],
        "summary": "Enable or disable connector",
        "responses": {
          "204": {
            "description": "Success"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Connector not found or invalid operation"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Service unavailable"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/actions/{id}/metrics": {
      "get": {
        "description": "Get bridge metrics by id.",
        "tags": [
          "Actions"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The bridge id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_action"
          }
        ],
        "summary": "Get action metrics",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "metrics": {
                      "description": "Bridge metrics.",
                      "$ref": "#/components/schemas/bridge.metrics"
                    },
                    "node_metrics": {
                      "type": "array",
                      "description": "Node metrics.",
                      "items": {
                        "$ref": "#/components/schemas/bridge.node_metrics"
                      }
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Action not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/authorization/sources/order": {
      "put": {
        "description": "Reorder all authorization sources.",
        "tags": [
          "Authorization"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": "Authorization sources order updated"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/emqx_authz_api_sources.request_sources_order"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/trace/{name}/log": {
      "get": {
        "description": "view trace log",
        "tags": [
          "Trace"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/trace.name"
          },
          {
            "$ref": "#/components/parameters/trace.bytes"
          },
          {
            "$ref": "#/components/parameters/trace.position"
          },
          {
            "$ref": "#/components/parameters/trace.node"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "items": {
                      "type": "string",
                      "example": "TEXT-LOG-ITEMS"
                    },
                    "meta": {
                      "properties": {
                        "bytes": {
                          "default": 1000,
                          "maximum": 2147483647,
                          "type": "integer",
                          "description": "Maximum number of bytes to send in response",
                          "minimum": 0
                        },
                        "position": {
                          "default": 0,
                          "type": "integer",
                          "description": "Offset from the current trace position."
                        }
                      },
                      "type": "object"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad input parameter"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "NODE_ERROR"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Trace Name or Node Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Requested chunk size too big"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/connectors": {
      "get": {
        "description": "List all created connectors.",
        "tags": [
          "Connectors"
        ],
        "parameters": [],
        "summary": "List connectors",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": [
                  {
                    "name": "influxdb_connector",
                    "status": "connected",
                    "type": "influxdb",
                    "ssl": {
                      "enable": false
                    },
                    "description": "My example influxdb connector",
                    "server": "127.0.0.1:8086",
                    "enable": true,
                    "parameters": {
                      "org": "examlpe_org",
                      "token": "example_token",
                      "bucket": "example_bucket",
                      "influxdb_type": "influxdb_api_v2"
                    },
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "actions": [
                      "my_action"
                    ]
                  },
                  {
                    "name": "my_http_connector",
                    "status": "connected",
                    "type": "http",
                    "connect_timeout": "15s",
                    "pool_size": 1,
                    "enable": true,
                    "headers": {
                      "content-type": "application/json"
                    },
                    "url": "http://localhost:8080/api/v1",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "pool_type": "hash",
                    "enable_pipelining": 100
                  },
                  {
                    "name": "my_confluent_producer_connector",
                    "status": "connected",
                    "type": "confluent_producer",
                    "ssl": {
                      "verify": "verify_none",
                      "enable": true,
                      "versions": [
                        "tlsv1.3",
                        "tlsv1.2"
                      ],
                      "server_name_indication": "auto"
                    },
                    "authentication": {
                      "password": "******"
                    },
                    "connect_timeout": "5s",
                    "enable": true,
                    "socket_opts": {
                      "nodelay": true,
                      "recbuf": "1024KB",
                      "sndbuf": "1024KB",
                      "tcp_keepalive": "none"
                    },
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "actions": [
                      "my_action"
                    ],
                    "min_metadata_refresh_interval": "3s",
                    "bootstrap_hosts": "xyz.sa-east1.gcp.confluent.cloud:9092",
                    "metadata_request_timeout": "4s"
                  },
                  {
                    "name": "iotdb_connector",
                    "status": "connected",
                    "type": "iotdb",
                    "ssl": {
                      "enable": false
                    },
                    "authentication": {
                      "password": "******",
                      "username": "root"
                    },
                    "description": "My example iotdb connector",
                    "connect_timeout": "15s",
                    "pool_size": 8,
                    "enable": true,
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "base_url": "http://iotdb.local:18080/",
                    "actions": [
                      "my_action"
                    ],
                    "pool_type": "random",
                    "enable_pipelining": 100,
                    "iotdb_version": "v1.3.x"
                  },
                  {
                    "status": "connected",
                    "ssl": {
                      "enable": true
                    },
                    "description": "My connector",
                    "server": "couchbase:8093",
                    "enable": true,
                    "password": "******",
                    "username": "admin",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "start_timeout": "5s",
                      "start_after_created": true,
                      "health_check_interval": "45s"
                    }
                  },
                  {
                    "name": "datalayers_connector",
                    "status": "connected",
                    "type": "datalayers",
                    "ssl": {
                      "enable": false
                    },
                    "description": "My example datalayers connector",
                    "server": "127.0.0.1:8361",
                    "enable": true,
                    "parameters": {
                      "password": "******",
                      "username": "example_username",
                      "database": "example_database"
                    },
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "actions": [
                      "my_action"
                    ]
                  },
                  {
                    "name": "my_azure_event_hub_producer_connector",
                    "status": "connected",
                    "type": "azure_event_hub_producer",
                    "ssl": {
                      "verify": "verify_none",
                      "enable": true,
                      "versions": [
                        "tlsv1.3",
                        "tlsv1.2"
                      ],
                      "server_name_indication": "auto"
                    },
                    "authentication": {
                      "password": "******"
                    },
                    "connect_timeout": "5s",
                    "enable": true,
                    "socket_opts": {
                      "nodelay": true,
                      "recbuf": "1024KB",
                      "sndbuf": "1024KB",
                      "tcp_keepalive": "none"
                    },
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "actions": [
                      "my_action"
                    ],
                    "min_metadata_refresh_interval": "3s",
                    "bootstrap_hosts": "namespace.servicebus.windows.net:9093",
                    "metadata_request_timeout": "4s"
                  },
                  {
                    "name": "my_kafka_producer_connector",
                    "status": "connected",
                    "type": "kafka_producer",
                    "authentication": {
                      "mechanism": "plain",
                      "password": "******",
                      "username": "username"
                    },
                    "connect_timeout": "5s",
                    "enable": true,
                    "socket_opts": {
                      "nodelay": true,
                      "recbuf": "1024KB",
                      "sndbuf": "1024KB",
                      "tcp_keepalive": "none"
                    },
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "actions": [
                      "my_action"
                    ],
                    "min_metadata_refresh_interval": "3s",
                    "bootstrap_hosts": "localhost:9092",
                    "metadata_request_timeout": "4s"
                  },
                  {
                    "name": "kinesis_connector",
                    "status": "connected",
                    "type": "kinesis",
                    "description": "My example kinesis connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "actions": [
                      "my_action"
                    ],
                    "aws_access_key_id": "your_access_key",
                    "aws_secret_access_key": "aws_secret_key",
                    "endpoint": "http://localhost:4566",
                    "max_retries": 2,
                    "pool_size": 8
                  },
                  {
                    "name": "syskeeper_proxy",
                    "status": "connected",
                    "type": "syskeeper_proxy",
                    "listen": "127.0.0.1:9092",
                    "enable": true,
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "acceptors": 16,
                    "handshake_timeout": "16s",
                    "actions": [
                      "my_action"
                    ]
                  },
                  {
                    "name": "my_pgsql_connector",
                    "status": "connected",
                    "type": "pgsql",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "actions": [
                      "my_action"
                    ],
                    "database": "emqx_data",
                    "enable": true,
                    "password": "public",
                    "pool_size": 8,
                    "server": "127.0.0.1:5432",
                    "ssl": {
                      "ciphers": [],
                      "depth": 10,
                      "enable": false,
                      "hibernate_after": "5s",
                      "log_level": "notice",
                      "reuse_sessions": true,
                      "secure_renegotiate": true,
                      "verify": "verify_peer",
                      "versions": [
                        "tlsv1.3",
                        "tlsv1.2"
                      ]
                    },
                    "username": "postgres"
                  },
                  {
                    "name": "mysql_connector",
                    "status": "connected",
                    "type": "mysql",
                    "description": "My example mysql connector",
                    "pool_size": 8,
                    "server": "127.0.0.1:3306",
                    "password": "******",
                    "username": "root",
                    "database": "test",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "actions": [
                      "my_action"
                    ],
                    "resource_opts": {
                      "health_check_interval": "20s"
                    }
                  },
                  {
                    "timeout": "5s",
                    "name": "rabbitmq_connector",
                    "port": 5672,
                    "status": "connected",
                    "type": "rabbitmq",
                    "ssl": {
                      "enable": false
                    },
                    "description": "My example rabbitmq connector",
                    "pool_size": 8,
                    "server": "127.0.0.1",
                    "enable": true,
                    "password": "******",
                    "username": "guest",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "heartbeat": "30s",
                    "actions": [
                      "my_action"
                    ],
                    "virtual_host": "/"
                  },
                  {
                    "name": "dynamo_connector",
                    "status": "connected",
                    "type": "dynamo",
                    "description": "My example dynamo connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "actions": [
                      "my_action"
                    ],
                    "aws_access_key_id": "root",
                    "aws_secret_access_key": "******",
                    "enable": true,
                    "pool_size": 8,
                    "region": "us-west-2",
                    "resource_opts": {
                      "health_check_interval": "15s",
                      "start_timeout": "5s"
                    },
                    "url": "http://127.0.0.1:8000"
                  },
                  {
                    "name": "tdengine_connector",
                    "status": "connected",
                    "type": "tdengine",
                    "description": "My example tdengine connector",
                    "pool_size": 8,
                    "server": "127.0.0.1:6041",
                    "enable": true,
                    "password": "******",
                    "username": "root",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "actions": [
                      "my_action"
                    ]
                  },
                  {
                    "name": "mongodb_single_connector",
                    "status": "connected",
                    "type": "mongodb_single",
                    "description": "My example mongodb_single connector",
                    "parameters": {
                      "pool_size": 8,
                      "enable": true,
                      "password": "******",
                      "username": "myuser",
                      "database": "mqtt",
                      "srv_record": false
                    },
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "actions": [
                      "my_action"
                    ]
                  },
                  {
                    "name": "demo",
                    "status": "connected",
                    "type": "greptimedb",
                    "ssl": {
                      "enable": false
                    },
                    "description": "My example greptimedb connector",
                    "server": "127.0.0.1:4001",
                    "enable": true,
                    "password": "******",
                    "username": "example_username",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "actions": [
                      "my_action"
                    ],
                    "resource_opts": {
                      "batch_size": 100,
                      "batch_time": "20ms"
                    },
                    "local_topic": "local/topic/#",
                    "dbname": "example_db"
                  },
                  {
                    "name": "opents_connector",
                    "status": "connected",
                    "type": "opents",
                    "description": "My example opents connector",
                    "pool_size": 8,
                    "server": "http://localhost:4242/",
                    "enable": true,
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "actions": [
                      "my_action"
                    ]
                  },
                  {
                    "status": "connected",
                    "description": "My connector",
                    "enable": true,
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "start_timeout": "5s",
                      "start_after_created": true,
                      "health_check_interval": "45s"
                    },
                    "account_key": "******",
                    "account_name": "my_account_name"
                  },
                  {
                    "name": "mongodb_sharded_connector",
                    "status": "connected",
                    "type": "mongodb_sharded",
                    "description": "My example mongodb_sharded connector",
                    "parameters": {
                      "pool_size": 8,
                      "enable": true,
                      "password": "******",
                      "username": "myuser",
                      "database": "mqtt",
                      "srv_record": false
                    },
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "actions": [
                      "my_action"
                    ]
                  },
                  {
                    "name": "mongodb_rs_connector",
                    "status": "connected",
                    "type": "mongodb_rs",
                    "description": "My example mongodb_rs connector",
                    "parameters": {
                      "pool_size": 8,
                      "enable": true,
                      "password": "******",
                      "username": "myuser",
                      "database": "mqtt",
                      "srv_record": false
                    },
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "actions": [
                      "my_action"
                    ]
                  },
                  {
                    "status": "connected",
                    "ssl": {
                      "enable": false
                    },
                    "description": "My redis single connector",
                    "enable": true,
                    "parameters": {
                      "pool_size": 8,
                      "server": "127.0.0.1:6379",
                      "password": "******",
                      "username": "test",
                      "database": 1,
                      "redis_type": "single"
                    },
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ]
                  },
                  {
                    "name": "oracle_connector",
                    "status": "connected",
                    "type": "oracle",
                    "description": "My example oracle connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "actions": [
                      "my_action"
                    ],
                    "password": "oracle",
                    "pool_size": 8,
                    "resource_opts": {
                      "health_check_interval": "15s",
                      "start_timeout": "5s"
                    },
                    "server": "127.0.0.1:1521",
                    "service_name": "XE",
                    "sid": "XE",
                    "username": "system"
                  },
                  {
                    "name": "hstreamdb_connector",
                    "status": "connected",
                    "type": "hstreamdb",
                    "description": "My example hstreamdb connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "actions": [
                      "my_action"
                    ],
                    "grpc_timeout": "30s",
                    "resource_opts": {
                      "health_check_interval": "15s",
                      "start_timeout": "5s"
                    },
                    "ssl": {
                      "enable": false,
                      "verify": "verify_peer"
                    },
                    "url": "http://127.0.0.1:6570"
                  },
                  {
                    "name": "influxdb_connector",
                    "status": "connected",
                    "type": "influxdb",
                    "ssl": {
                      "enable": false
                    },
                    "description": "My example influxdb connector",
                    "server": "127.0.0.1:8086",
                    "enable": true,
                    "parameters": {
                      "password": "******",
                      "username": "example_username",
                      "database": "example_database",
                      "influxdb_type": "influxdb_api_v1"
                    },
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "actions": [
                      "my_action"
                    ]
                  },
                  {
                    "port": 443,
                    "status": "connected",
                    "host": "s3.eu-east-1.amazonaws.com",
                    "description": "My S3 connector",
                    "enable": true,
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "transport_options": {
                      "ssl": {
                        "verify": "verify_peer",
                        "enable": true
                      },
                      "connect_timeout": "1s",
                      "pool_size": 4,
                      "max_retries": 1,
                      "request_timeout": "60s",
                      "enable_pipelining": 1
                    },
                    "secret_access_key": "SECRET",
                    "access_key_id": "ACCESS"
                  },
                  {
                    "name": "cassandra_connector",
                    "status": "connected",
                    "type": "cassandra",
                    "description": "My example cassandra connector",
                    "pool_size": 8,
                    "password": "******",
                    "username": "root",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "servers": "127.0.0.1:9042",
                    "actions": [
                      "my_action"
                    ],
                    "keyspace": "mqtt"
                  },
                  {
                    "name": "my_connector",
                    "status": "connected",
                    "type": "gcp_pubsub_producer",
                    "description": "my connector",
                    "connect_timeout": "15s",
                    "pool_size": 8,
                    "enable": true,
                    "max_retries": 2,
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "actions": [
                      "my_action"
                    ],
                    "resource_opts": {
                      "start_timeout": "5s",
                      "start_after_created": true,
                      "health_check_interval": "30s"
                    },
                    "service_account_json": {
                      "type": "service_account",
                      "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQI...",
                      "client_id": "123812831923812319190",
                      "project_id": "myproject",
                      "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                      "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                      "client_email": "test@myproject.iam.gserviceaccount.com",
                      "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/test%40myproject.iam.gserviceaccount.com",
                      "private_key_id": "kid",
                      "token_uri": "https://oauth2.googleapis.com/token"
                    },
                    "pipelining": 100
                  },
                  {
                    "name": "clickhouse_connector",
                    "status": "connected",
                    "type": "clickhouse",
                    "description": "My example clickhouse connector",
                    "pool_size": 8,
                    "password": "******",
                    "url": "http://localhost:8123",
                    "username": "default",
                    "database": "mqtt",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "actions": [
                      "my_action"
                    ]
                  },
                  {
                    "driver": "ms-sql",
                    "name": "sqlserver_connector",
                    "status": "connected",
                    "type": "sqlserver",
                    "description": "My example sqlserver connector",
                    "pool_size": 8,
                    "server": "127.0.0.1:1433",
                    "password": "******",
                    "username": "sa",
                    "database": "test",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "actions": [
                      "my_action"
                    ],
                    "resource_opts": {
                      "health_check_interval": "20s"
                    }
                  },
                  {
                    "status": "connected",
                    "ssl": {
                      "enable": false
                    },
                    "description": "My redis cluster connector",
                    "enable": true,
                    "parameters": {
                      "pool_size": 8,
                      "password": "******",
                      "username": "test",
                      "servers": "127.0.0.1:6379,127.0.0.2:6379",
                      "redis_type": "cluster"
                    },
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ]
                  },
                  {
                    "name": "my_matrix_connector",
                    "status": "connected",
                    "type": "matrix",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "actions": [
                      "my_action"
                    ],
                    "database": "emqx_data",
                    "enable": true,
                    "password": "public",
                    "pool_size": 8,
                    "server": "127.0.0.1:5432",
                    "ssl": {
                      "ciphers": [],
                      "depth": 10,
                      "enable": false,
                      "hibernate_after": "5s",
                      "log_level": "notice",
                      "reuse_sessions": true,
                      "secure_renegotiate": true,
                      "verify": "verify_peer",
                      "versions": [
                        "tlsv1.3",
                        "tlsv1.2"
                      ]
                    },
                    "username": "postgres"
                  },
                  {
                    "name": "my_connector",
                    "status": "connected",
                    "type": "kafka_consumer",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "resource_opts": {
                      "start_timeout": "5s",
                      "start_after_created": true,
                      "health_check_interval": "30s"
                    },
                    "bootstrap_hosts": "kafka.emqx.net:9092"
                  },
                  {
                    "name": "rocketmq_connector",
                    "status": "connected",
                    "type": "rocketmq",
                    "description": "My example rocketmq connector",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "actions": [
                      "my_action"
                    ],
                    "enable": true,
                    "pool_size": 8,
                    "resource_opts": {
                      "health_check_interval": "15s",
                      "start_after_created": true,
                      "start_timeout": "5s"
                    },
                    "servers": "127.0.0.1:9876"
                  },
                  {
                    "name": "pulsar_connector",
                    "status": "connected",
                    "type": "pulsar",
                    "ssl": {
                      "enable": false
                    },
                    "authentication": "none",
                    "description": "My example pulsar connector",
                    "connect_timeout": "5s",
                    "enable": true,
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "servers": "pulsar://127.0.0.1:6650",
                    "actions": [
                      "my_action"
                    ]
                  },
                  {
                    "name": "syskeeper_forwarder",
                    "status": "connected",
                    "type": "syskeeper_forwarder",
                    "pool_size": 16,
                    "server": "127.0.0.1:9092",
                    "enable": true,
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "ack_timeout": "10s",
                    "actions": [
                      "my_action"
                    ],
                    "ack_mode": "no_ack"
                  },
                  {
                    "name": "elasticsearch_connector",
                    "status": "connected",
                    "type": "elasticsearch",
                    "ssl": {
                      "enable": false
                    },
                    "authentication": {
                      "password": "******",
                      "username": "root"
                    },
                    "description": "My example elasticsearch connector",
                    "connect_timeout": "15s",
                    "pool_size": 8,
                    "server": "127.0.0.1:9200",
                    "enable": true,
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "actions": [
                      "my_action"
                    ],
                    "pool_type": "random",
                    "enable_pipelining": 100
                  },
                  {
                    "name": "my_connector",
                    "status": "connected",
                    "type": "gcp_pubsub_producer",
                    "connect_timeout": "10s",
                    "pool_size": 8,
                    "enable": true,
                    "max_retries": 2,
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "actions": [
                      "my_action"
                    ],
                    "resource_opts": {
                      "request_ttl": "60s"
                    },
                    "service_account_json": {
                      "type": "service_account",
                      "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQI...",
                      "client_id": "123812831923812319190",
                      "project_id": "myproject",
                      "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                      "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                      "client_email": "test@myproject.iam.gserviceaccount.com",
                      "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/test%40myproject.iam.gserviceaccount.com",
                      "private_key_id": "kid",
                      "token_uri": "https://oauth2.googleapis.com/token"
                    },
                    "pipelining": 100
                  },
                  {
                    "name": "my_timescale_connector",
                    "status": "connected",
                    "type": "timescale",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "actions": [
                      "my_action"
                    ],
                    "database": "emqx_data",
                    "enable": true,
                    "password": "public",
                    "pool_size": 8,
                    "server": "127.0.0.1:5432",
                    "ssl": {
                      "ciphers": [],
                      "depth": 10,
                      "enable": false,
                      "hibernate_after": "5s",
                      "log_level": "notice",
                      "reuse_sessions": true,
                      "secure_renegotiate": true,
                      "verify": "verify_peer",
                      "versions": [
                        "tlsv1.3",
                        "tlsv1.2"
                      ]
                    },
                    "username": "postgres"
                  },
                  {
                    "status": "connected",
                    "ssl": {
                      "enable": false
                    },
                    "description": "My redis sentinel connector",
                    "enable": true,
                    "parameters": {
                      "pool_size": 8,
                      "password": "******",
                      "username": "test",
                      "database": 1,
                      "servers": "127.0.0.1:6379,127.0.0.2:6379",
                      "sentinel": "myredismaster",
                      "redis_type": "sentinel"
                    },
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ]
                  }
                ],
                "schema": {
                  "type": "array",
                  "items": {
                    "oneOf": [
                      {
                        "$ref": "#/components/schemas/bridge_timescale.get_connector"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_mongodb.get_connector"
                      },
                      {
                        "$ref": "#/components/schemas/gcp_pubsub_producer.get_connector"
                      },
                      {
                        "$ref": "#/components/schemas/elasticsearch.get"
                      },
                      {
                        "$ref": "#/components/schemas/connector_azure_blob_storage.get_connector"
                      },
                      {
                        "$ref": "#/components/schemas/syskeeper_forwarder.get"
                      },
                      {
                        "$ref": "#/components/schemas/pulsar.get"
                      },
                      {
                        "$ref": "#/components/schemas/rocketmq.get_connector"
                      },
                      {
                        "$ref": "#/components/schemas/kafka_consumer.get_connector"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_matrix.get_connector"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_sqlserver.get_connector"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_influxdb.get_connector"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_clickhouse.get_connector"
                      },
                      {
                        "$ref": "#/components/schemas/gcp_pubsub_consumer.get_connector"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_cassa.get_connector"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_hstreamdb.get_connector"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_oracle.get_connector"
                      },
                      {
                        "$ref": "#/components/schemas/opents_connector.get"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_greptimedb.get_connector"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_s3.get_connector"
                      },
                      {
                        "$ref": "#/components/schemas/tdengine_connector.get"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_dynamo.get_connector"
                      },
                      {
                        "$ref": "#/components/schemas/redis.get_connector"
                      },
                      {
                        "$ref": "#/components/schemas/rabbitmq.get"
                      },
                      {
                        "$ref": "#/components/schemas/connector_mqtt.get_connector"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_mysql.get_connector"
                      },
                      {
                        "$ref": "#/components/schemas/connector_postgres.get_connector"
                      },
                      {
                        "$ref": "#/components/schemas/connector_syskeeper_proxy.get"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_kinesis.get_connector"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_kafka.get_connector"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_azure_event_hub.get_connector"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_datalayers.get_connector"
                      },
                      {
                        "$ref": "#/components/schemas/connector_couchbase.get_connector"
                      },
                      {
                        "$ref": "#/components/schemas/iotdb.get"
                      },
                      {
                        "$ref": "#/components/schemas/confluent.get_connector"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_http.get_connector"
                      }
                    ]
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Create a new connector by type and name.",
        "tags": [
          "Connectors"
        ],
        "parameters": [],
        "summary": "Create connector",
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "influxdb_api_v2": {
                    "value": {
                      "name": "influxdb_connector",
                      "status": "connected",
                      "type": "influxdb",
                      "ssl": {
                        "enable": false
                      },
                      "description": "My example influxdb connector",
                      "server": "127.0.0.1:8086",
                      "enable": true,
                      "parameters": {
                        "org": "examlpe_org",
                        "token": "example_token",
                        "bucket": "example_bucket",
                        "influxdb_type": "influxdb_api_v2"
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ]
                    },
                    "summary": "InfluxDB HTTP API V2 Connector"
                  },
                  "http": {
                    "value": {
                      "name": "my_http_connector",
                      "status": "connected",
                      "type": "http",
                      "connect_timeout": "15s",
                      "pool_size": 1,
                      "enable": true,
                      "headers": {
                        "content-type": "application/json"
                      },
                      "url": "http://localhost:8080/api/v1",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "pool_type": "hash",
                      "enable_pipelining": 100
                    },
                    "summary": "HTTP Connector"
                  },
                  "confluent_producer": {
                    "value": {
                      "name": "my_confluent_producer_connector",
                      "status": "connected",
                      "type": "confluent_producer",
                      "ssl": {
                        "verify": "verify_none",
                        "enable": true,
                        "versions": [
                          "tlsv1.3",
                          "tlsv1.2"
                        ],
                        "server_name_indication": "auto"
                      },
                      "authentication": {
                        "password": "******"
                      },
                      "connect_timeout": "5s",
                      "enable": true,
                      "socket_opts": {
                        "nodelay": true,
                        "recbuf": "1024KB",
                        "sndbuf": "1024KB",
                        "tcp_keepalive": "none"
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "min_metadata_refresh_interval": "3s",
                      "bootstrap_hosts": "xyz.sa-east1.gcp.confluent.cloud:9092",
                      "metadata_request_timeout": "4s"
                    },
                    "summary": "Confluent Connector"
                  },
                  "iotdb": {
                    "value": {
                      "name": "iotdb_connector",
                      "status": "connected",
                      "type": "iotdb",
                      "ssl": {
                        "enable": false
                      },
                      "authentication": {
                        "password": "******",
                        "username": "root"
                      },
                      "description": "My example iotdb connector",
                      "connect_timeout": "15s",
                      "pool_size": 8,
                      "enable": true,
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "base_url": "http://iotdb.local:18080/",
                      "actions": [
                        "my_action"
                      ],
                      "pool_type": "random",
                      "enable_pipelining": 100,
                      "iotdb_version": "v1.3.x"
                    },
                    "summary": "Apache IoTDB Connector"
                  },
                  "couchbase": {
                    "value": {
                      "status": "connected",
                      "ssl": {
                        "enable": true
                      },
                      "description": "My connector",
                      "server": "couchbase:8093",
                      "enable": true,
                      "password": "******",
                      "username": "admin",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "start_timeout": "5s",
                        "start_after_created": true,
                        "health_check_interval": "45s"
                      }
                    },
                    "summary": "Couchbase Connector"
                  },
                  "datalayers": {
                    "value": {
                      "name": "datalayers_connector",
                      "status": "connected",
                      "type": "datalayers",
                      "ssl": {
                        "enable": false
                      },
                      "description": "My example datalayers connector",
                      "server": "127.0.0.1:8361",
                      "enable": true,
                      "parameters": {
                        "password": "******",
                        "username": "example_username",
                        "database": "example_database"
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ]
                    },
                    "summary": "Datalayers Connector"
                  },
                  "azure_event_hub_producer": {
                    "value": {
                      "name": "my_azure_event_hub_producer_connector",
                      "status": "connected",
                      "type": "azure_event_hub_producer",
                      "ssl": {
                        "verify": "verify_none",
                        "enable": true,
                        "versions": [
                          "tlsv1.3",
                          "tlsv1.2"
                        ],
                        "server_name_indication": "auto"
                      },
                      "authentication": {
                        "password": "******"
                      },
                      "connect_timeout": "5s",
                      "enable": true,
                      "socket_opts": {
                        "nodelay": true,
                        "recbuf": "1024KB",
                        "sndbuf": "1024KB",
                        "tcp_keepalive": "none"
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "min_metadata_refresh_interval": "3s",
                      "bootstrap_hosts": "namespace.servicebus.windows.net:9093",
                      "metadata_request_timeout": "4s"
                    },
                    "summary": "Azure Event Hub Connector"
                  },
                  "kafka_producer": {
                    "value": {
                      "name": "my_kafka_producer_connector",
                      "status": "connected",
                      "type": "kafka_producer",
                      "authentication": {
                        "mechanism": "plain",
                        "password": "******",
                        "username": "username"
                      },
                      "connect_timeout": "5s",
                      "enable": true,
                      "socket_opts": {
                        "nodelay": true,
                        "recbuf": "1024KB",
                        "sndbuf": "1024KB",
                        "tcp_keepalive": "none"
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "min_metadata_refresh_interval": "3s",
                      "bootstrap_hosts": "localhost:9092",
                      "metadata_request_timeout": "4s"
                    },
                    "summary": "Kafka Producer Connector"
                  },
                  "kinesis": {
                    "value": {
                      "name": "kinesis_connector",
                      "status": "connected",
                      "type": "kinesis",
                      "description": "My example kinesis connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "aws_access_key_id": "your_access_key",
                      "aws_secret_access_key": "aws_secret_key",
                      "endpoint": "http://localhost:4566",
                      "max_retries": 2,
                      "pool_size": 8
                    },
                    "summary": "Kinesis Connector"
                  },
                  "syskeeper_proxy": {
                    "value": {
                      "name": "syskeeper_proxy",
                      "status": "connected",
                      "type": "syskeeper_proxy",
                      "listen": "127.0.0.1:9092",
                      "enable": true,
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "acceptors": 16,
                      "handshake_timeout": "16s",
                      "actions": [
                        "my_action"
                      ]
                    },
                    "summary": "Syskeeper Proxy Connector"
                  },
                  "pgsql": {
                    "value": {
                      "name": "my_pgsql_connector",
                      "status": "connected",
                      "type": "pgsql",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "database": "emqx_data",
                      "enable": true,
                      "password": "public",
                      "pool_size": 8,
                      "server": "127.0.0.1:5432",
                      "ssl": {
                        "ciphers": [],
                        "depth": 10,
                        "enable": false,
                        "hibernate_after": "5s",
                        "log_level": "notice",
                        "reuse_sessions": true,
                        "secure_renegotiate": true,
                        "verify": "verify_peer",
                        "versions": [
                          "tlsv1.3",
                          "tlsv1.2"
                        ]
                      },
                      "username": "postgres"
                    },
                    "summary": "PostgreSQL Connector"
                  },
                  "mysql": {
                    "value": {
                      "name": "mysql_connector",
                      "status": "connected",
                      "type": "mysql",
                      "description": "My example mysql connector",
                      "pool_size": 8,
                      "server": "127.0.0.1:3306",
                      "password": "******",
                      "username": "root",
                      "database": "test",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "resource_opts": {
                        "health_check_interval": "20s"
                      }
                    },
                    "summary": "MySQL Connector"
                  },
                  "rabbitmq": {
                    "value": {
                      "timeout": "5s",
                      "name": "rabbitmq_connector",
                      "port": 5672,
                      "status": "connected",
                      "type": "rabbitmq",
                      "ssl": {
                        "enable": false
                      },
                      "description": "My example rabbitmq connector",
                      "pool_size": 8,
                      "server": "127.0.0.1",
                      "enable": true,
                      "password": "******",
                      "username": "guest",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "heartbeat": "30s",
                      "actions": [
                        "my_action"
                      ],
                      "virtual_host": "/"
                    },
                    "summary": "Rabbitmq Connector"
                  },
                  "dynamo": {
                    "value": {
                      "name": "dynamo_connector",
                      "status": "connected",
                      "type": "dynamo",
                      "description": "My example dynamo connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "aws_access_key_id": "root",
                      "aws_secret_access_key": "******",
                      "enable": true,
                      "pool_size": 8,
                      "region": "us-west-2",
                      "resource_opts": {
                        "health_check_interval": "15s",
                        "start_timeout": "5s"
                      },
                      "url": "http://127.0.0.1:8000"
                    },
                    "summary": "DynamoDB Connector"
                  },
                  "tdengine": {
                    "value": {
                      "name": "tdengine_connector",
                      "status": "connected",
                      "type": "tdengine",
                      "description": "My example tdengine connector",
                      "pool_size": 8,
                      "server": "127.0.0.1:6041",
                      "enable": true,
                      "password": "******",
                      "username": "root",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ]
                    },
                    "summary": "TDengine Connector"
                  },
                  "mongodb_single": {
                    "value": {
                      "name": "mongodb_single_connector",
                      "status": "connected",
                      "type": "mongodb_single",
                      "description": "My example mongodb_single connector",
                      "parameters": {
                        "pool_size": 8,
                        "enable": true,
                        "password": "******",
                        "username": "myuser",
                        "database": "mqtt",
                        "srv_record": false
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ]
                    },
                    "summary": "MongoDB Standalone Connector"
                  },
                  "greptimedb": {
                    "value": {
                      "name": "demo",
                      "status": "connected",
                      "type": "greptimedb",
                      "ssl": {
                        "enable": false
                      },
                      "description": "My example greptimedb connector",
                      "server": "127.0.0.1:4001",
                      "enable": true,
                      "password": "******",
                      "username": "example_username",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "resource_opts": {
                        "batch_size": 100,
                        "batch_time": "20ms"
                      },
                      "local_topic": "local/topic/#",
                      "dbname": "example_db"
                    },
                    "summary": "GreptimeDB Connector"
                  },
                  "opents": {
                    "value": {
                      "name": "opents_connector",
                      "status": "connected",
                      "type": "opents",
                      "description": "My example opents connector",
                      "pool_size": 8,
                      "server": "http://localhost:4242/",
                      "enable": true,
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ]
                    },
                    "summary": "OpenTSDB Connector"
                  },
                  "abs": {
                    "value": {
                      "status": "connected",
                      "description": "My connector",
                      "enable": true,
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "start_timeout": "5s",
                        "start_after_created": true,
                        "health_check_interval": "45s"
                      },
                      "account_key": "******",
                      "account_name": "my_account_name"
                    },
                    "summary": "Azure Blob Storage Connector"
                  },
                  "mongodb_sharded": {
                    "value": {
                      "name": "mongodb_sharded_connector",
                      "status": "connected",
                      "type": "mongodb_sharded",
                      "description": "My example mongodb_sharded connector",
                      "parameters": {
                        "pool_size": 8,
                        "enable": true,
                        "password": "******",
                        "username": "myuser",
                        "database": "mqtt",
                        "srv_record": false
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ]
                    },
                    "summary": "MongoDB Sharded Connector"
                  },
                  "mongodb_rs": {
                    "value": {
                      "name": "mongodb_rs_connector",
                      "status": "connected",
                      "type": "mongodb_rs",
                      "description": "My example mongodb_rs connector",
                      "parameters": {
                        "pool_size": 8,
                        "enable": true,
                        "password": "******",
                        "username": "myuser",
                        "database": "mqtt",
                        "srv_record": false
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ]
                    },
                    "summary": "MongoDB Replica Set Connector"
                  },
                  "redis_single_producer": {
                    "value": {
                      "status": "connected",
                      "ssl": {
                        "enable": false
                      },
                      "description": "My redis single connector",
                      "enable": true,
                      "parameters": {
                        "pool_size": 8,
                        "server": "127.0.0.1:6379",
                        "password": "******",
                        "username": "test",
                        "database": 1,
                        "redis_type": "single"
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ]
                    },
                    "summary": "Redis Single Producer Connector"
                  },
                  "oracle": {
                    "value": {
                      "name": "oracle_connector",
                      "status": "connected",
                      "type": "oracle",
                      "description": "My example oracle connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "password": "oracle",
                      "pool_size": 8,
                      "resource_opts": {
                        "health_check_interval": "15s",
                        "start_timeout": "5s"
                      },
                      "server": "127.0.0.1:1521",
                      "service_name": "XE",
                      "sid": "XE",
                      "username": "system"
                    },
                    "summary": "Oracle Connector"
                  },
                  "hstreamdb": {
                    "value": {
                      "name": "hstreamdb_connector",
                      "status": "connected",
                      "type": "hstreamdb",
                      "description": "My example hstreamdb connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "grpc_timeout": "30s",
                      "resource_opts": {
                        "health_check_interval": "15s",
                        "start_timeout": "5s"
                      },
                      "ssl": {
                        "enable": false,
                        "verify": "verify_peer"
                      },
                      "url": "http://127.0.0.1:6570"
                    },
                    "summary": "HStreamDB Connector"
                  },
                  "influxdb_api_v1": {
                    "value": {
                      "name": "influxdb_connector",
                      "status": "connected",
                      "type": "influxdb",
                      "ssl": {
                        "enable": false
                      },
                      "description": "My example influxdb connector",
                      "server": "127.0.0.1:8086",
                      "enable": true,
                      "parameters": {
                        "password": "******",
                        "username": "example_username",
                        "database": "example_database",
                        "influxdb_type": "influxdb_api_v1"
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ]
                    },
                    "summary": "InfluxDB HTTP API V1 Connector"
                  },
                  "s3_aws": {
                    "value": {
                      "port": 443,
                      "status": "connected",
                      "host": "s3.eu-east-1.amazonaws.com",
                      "description": "My S3 connector",
                      "enable": true,
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "transport_options": {
                        "ssl": {
                          "verify": "verify_peer",
                          "enable": true
                        },
                        "connect_timeout": "1s",
                        "pool_size": 4,
                        "max_retries": 1,
                        "request_timeout": "60s",
                        "enable_pipelining": 1
                      },
                      "secret_access_key": "SECRET",
                      "access_key_id": "ACCESS"
                    },
                    "summary": "S3 Connector"
                  },
                  "cassandra": {
                    "value": {
                      "name": "cassandra_connector",
                      "status": "connected",
                      "type": "cassandra",
                      "description": "My example cassandra connector",
                      "pool_size": 8,
                      "password": "******",
                      "username": "root",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "servers": "127.0.0.1:9042",
                      "actions": [
                        "my_action"
                      ],
                      "keyspace": "mqtt"
                    },
                    "summary": "Cassandra Connector"
                  },
                  "gcp_pubsub_consumer": {
                    "value": {
                      "name": "my_connector",
                      "status": "connected",
                      "type": "gcp_pubsub_producer",
                      "description": "my connector",
                      "connect_timeout": "15s",
                      "pool_size": 8,
                      "enable": true,
                      "max_retries": 2,
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "resource_opts": {
                        "start_timeout": "5s",
                        "start_after_created": true,
                        "health_check_interval": "30s"
                      },
                      "service_account_json": {
                        "type": "service_account",
                        "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQI...",
                        "client_id": "123812831923812319190",
                        "project_id": "myproject",
                        "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                        "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                        "client_email": "test@myproject.iam.gserviceaccount.com",
                        "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/test%40myproject.iam.gserviceaccount.com",
                        "private_key_id": "kid",
                        "token_uri": "https://oauth2.googleapis.com/token"
                      },
                      "pipelining": 100
                    },
                    "summary": "GCP PubSub Consumer Connector"
                  },
                  "clickhouse": {
                    "value": {
                      "name": "clickhouse_connector",
                      "status": "connected",
                      "type": "clickhouse",
                      "description": "My example clickhouse connector",
                      "pool_size": 8,
                      "password": "******",
                      "url": "http://localhost:8123",
                      "username": "default",
                      "database": "mqtt",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ]
                    },
                    "summary": "ClickHouse Connector"
                  },
                  "sqlserver": {
                    "value": {
                      "driver": "ms-sql",
                      "name": "sqlserver_connector",
                      "status": "connected",
                      "type": "sqlserver",
                      "description": "My example sqlserver connector",
                      "pool_size": 8,
                      "server": "127.0.0.1:1433",
                      "password": "******",
                      "username": "sa",
                      "database": "test",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "resource_opts": {
                        "health_check_interval": "20s"
                      }
                    },
                    "summary": "Microsoft SQL Server Connector"
                  },
                  "redis_cluster_producer": {
                    "value": {
                      "status": "connected",
                      "ssl": {
                        "enable": false
                      },
                      "description": "My redis cluster connector",
                      "enable": true,
                      "parameters": {
                        "pool_size": 8,
                        "password": "******",
                        "username": "test",
                        "servers": "127.0.0.1:6379,127.0.0.2:6379",
                        "redis_type": "cluster"
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ]
                    },
                    "summary": "Redis Cluster Producer Connector"
                  },
                  "matrix": {
                    "value": {
                      "name": "my_matrix_connector",
                      "status": "connected",
                      "type": "matrix",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "database": "emqx_data",
                      "enable": true,
                      "password": "public",
                      "pool_size": 8,
                      "server": "127.0.0.1:5432",
                      "ssl": {
                        "ciphers": [],
                        "depth": 10,
                        "enable": false,
                        "hibernate_after": "5s",
                        "log_level": "notice",
                        "reuse_sessions": true,
                        "secure_renegotiate": true,
                        "verify": "verify_peer",
                        "versions": [
                          "tlsv1.3",
                          "tlsv1.2"
                        ]
                      },
                      "username": "postgres"
                    },
                    "summary": "Matrix Connector"
                  },
                  "kafka_consumer": {
                    "value": {
                      "name": "my_connector",
                      "status": "connected",
                      "type": "kafka_consumer",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "resource_opts": {
                        "start_timeout": "5s",
                        "start_after_created": true,
                        "health_check_interval": "30s"
                      },
                      "bootstrap_hosts": "kafka.emqx.net:9092"
                    },
                    "summary": "Kafka Consumer Connector"
                  },
                  "rocketmq": {
                    "value": {
                      "name": "rocketmq_connector",
                      "status": "connected",
                      "type": "rocketmq",
                      "description": "My example rocketmq connector",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "enable": true,
                      "pool_size": 8,
                      "resource_opts": {
                        "health_check_interval": "15s",
                        "start_after_created": true,
                        "start_timeout": "5s"
                      },
                      "servers": "127.0.0.1:9876"
                    },
                    "summary": "RocketMQ Connector"
                  },
                  "pulsar": {
                    "value": {
                      "name": "pulsar_connector",
                      "status": "connected",
                      "type": "pulsar",
                      "ssl": {
                        "enable": false
                      },
                      "authentication": "none",
                      "description": "My example pulsar connector",
                      "connect_timeout": "5s",
                      "enable": true,
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "servers": "pulsar://127.0.0.1:6650",
                      "actions": [
                        "my_action"
                      ]
                    },
                    "summary": "Pulsar Connector"
                  },
                  "syskeeper_forwarder": {
                    "value": {
                      "name": "syskeeper_forwarder",
                      "status": "connected",
                      "type": "syskeeper_forwarder",
                      "pool_size": 16,
                      "server": "127.0.0.1:9092",
                      "enable": true,
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "ack_timeout": "10s",
                      "actions": [
                        "my_action"
                      ],
                      "ack_mode": "no_ack"
                    },
                    "summary": "Syskeeper Forwarder Connector"
                  },
                  "elasticsearch": {
                    "value": {
                      "name": "elasticsearch_connector",
                      "status": "connected",
                      "type": "elasticsearch",
                      "ssl": {
                        "enable": false
                      },
                      "authentication": {
                        "password": "******",
                        "username": "root"
                      },
                      "description": "My example elasticsearch connector",
                      "connect_timeout": "15s",
                      "pool_size": 8,
                      "server": "127.0.0.1:9200",
                      "enable": true,
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "pool_type": "random",
                      "enable_pipelining": 100
                    },
                    "summary": "Elastic Search Connector"
                  },
                  "gcp_pubsub_producer": {
                    "value": {
                      "name": "my_connector",
                      "status": "connected",
                      "type": "gcp_pubsub_producer",
                      "connect_timeout": "10s",
                      "pool_size": 8,
                      "enable": true,
                      "max_retries": 2,
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "resource_opts": {
                        "request_ttl": "60s"
                      },
                      "service_account_json": {
                        "type": "service_account",
                        "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQI...",
                        "client_id": "123812831923812319190",
                        "project_id": "myproject",
                        "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                        "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                        "client_email": "test@myproject.iam.gserviceaccount.com",
                        "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/test%40myproject.iam.gserviceaccount.com",
                        "private_key_id": "kid",
                        "token_uri": "https://oauth2.googleapis.com/token"
                      },
                      "pipelining": 100
                    },
                    "summary": "GCP PubSub Producer Connector"
                  },
                  "timescale": {
                    "value": {
                      "name": "my_timescale_connector",
                      "status": "connected",
                      "type": "timescale",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "actions": [
                        "my_action"
                      ],
                      "database": "emqx_data",
                      "enable": true,
                      "password": "public",
                      "pool_size": 8,
                      "server": "127.0.0.1:5432",
                      "ssl": {
                        "ciphers": [],
                        "depth": 10,
                        "enable": false,
                        "hibernate_after": "5s",
                        "log_level": "notice",
                        "reuse_sessions": true,
                        "secure_renegotiate": true,
                        "verify": "verify_peer",
                        "versions": [
                          "tlsv1.3",
                          "tlsv1.2"
                        ]
                      },
                      "username": "postgres"
                    },
                    "summary": "Timescale Connector"
                  },
                  "redis_sentinel_producer": {
                    "value": {
                      "status": "connected",
                      "ssl": {
                        "enable": false
                      },
                      "description": "My redis sentinel connector",
                      "enable": true,
                      "parameters": {
                        "pool_size": 8,
                        "password": "******",
                        "username": "test",
                        "database": 1,
                        "servers": "127.0.0.1:6379,127.0.0.2:6379",
                        "sentinel": "myredismaster",
                        "redis_type": "sentinel"
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ]
                    },
                    "summary": "Redis Sentinel Producer Connector"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/bridge_timescale.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mongodb.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/gcp_pubsub_producer.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/elasticsearch.get"
                    },
                    {
                      "$ref": "#/components/schemas/connector_azure_blob_storage.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/syskeeper_forwarder.get"
                    },
                    {
                      "$ref": "#/components/schemas/pulsar.get"
                    },
                    {
                      "$ref": "#/components/schemas/rocketmq.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/kafka_consumer.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_matrix.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_sqlserver.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_influxdb.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_clickhouse.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/gcp_pubsub_consumer.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_cassa.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_hstreamdb.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_oracle.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/opents_connector.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_greptimedb.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_s3.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/tdengine_connector.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_dynamo.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/redis.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/rabbitmq.get"
                    },
                    {
                      "$ref": "#/components/schemas/connector_mqtt.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mysql.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/connector_postgres.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/connector_syskeeper_proxy.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_kinesis.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_kafka.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_azure_event_hub.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_datalayers.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/connector_couchbase.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/iotdb.get"
                    },
                    {
                      "$ref": "#/components/schemas/confluent.get_connector"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_http.get_connector"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "ALREADY_EXISTS"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Connector already exists"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "influxdb_api_v2": {
                  "value": {
                    "name": "influxdb_connector",
                    "type": "influxdb",
                    "ssl": {
                      "enable": false
                    },
                    "description": "My example influxdb connector",
                    "server": "127.0.0.1:8086",
                    "enable": true,
                    "parameters": {
                      "org": "examlpe_org",
                      "token": "example_token",
                      "bucket": "example_bucket",
                      "influxdb_type": "influxdb_api_v2"
                    }
                  },
                  "summary": "InfluxDB HTTP API V2 Connector"
                },
                "http": {
                  "value": {
                    "name": "my_http_connector",
                    "type": "http",
                    "connect_timeout": "15s",
                    "pool_size": 1,
                    "enable": true,
                    "headers": {
                      "content-type": "application/json"
                    },
                    "url": "http://localhost:8080/api/v1",
                    "pool_type": "hash",
                    "enable_pipelining": 100
                  },
                  "summary": "HTTP Connector"
                },
                "confluent_producer": {
                  "value": {
                    "name": "my_confluent_producer_connector",
                    "type": "confluent_producer",
                    "ssl": {
                      "verify": "verify_none",
                      "enable": true,
                      "versions": [
                        "tlsv1.3",
                        "tlsv1.2"
                      ],
                      "server_name_indication": "auto"
                    },
                    "authentication": {
                      "password": "******"
                    },
                    "connect_timeout": "5s",
                    "enable": true,
                    "socket_opts": {
                      "nodelay": true,
                      "recbuf": "1024KB",
                      "sndbuf": "1024KB",
                      "tcp_keepalive": "none"
                    },
                    "min_metadata_refresh_interval": "3s",
                    "bootstrap_hosts": "xyz.sa-east1.gcp.confluent.cloud:9092",
                    "metadata_request_timeout": "4s"
                  },
                  "summary": "Confluent Connector"
                },
                "iotdb": {
                  "value": {
                    "name": "iotdb_connector",
                    "type": "iotdb",
                    "ssl": {
                      "enable": false
                    },
                    "authentication": {
                      "password": "******",
                      "username": "root"
                    },
                    "description": "My example iotdb connector",
                    "connect_timeout": "15s",
                    "pool_size": 8,
                    "enable": true,
                    "base_url": "http://iotdb.local:18080/",
                    "pool_type": "random",
                    "enable_pipelining": 100,
                    "iotdb_version": "v1.3.x"
                  },
                  "summary": "Apache IoTDB Connector"
                },
                "couchbase": {
                  "value": {
                    "name": "my_connector",
                    "type": "couchbase",
                    "ssl": {
                      "enable": true
                    },
                    "description": "My connector",
                    "server": "couchbase:8093",
                    "enable": true,
                    "password": "******",
                    "username": "admin",
                    "resource_opts": {
                      "start_timeout": "5s",
                      "start_after_created": true,
                      "health_check_interval": "45s"
                    }
                  },
                  "summary": "Couchbase Connector"
                },
                "datalayers": {
                  "value": {
                    "name": "datalayers_connector",
                    "type": "datalayers",
                    "ssl": {
                      "enable": false
                    },
                    "description": "My example datalayers connector",
                    "server": "127.0.0.1:8361",
                    "enable": true,
                    "parameters": {
                      "password": "******",
                      "username": "example_username",
                      "database": "example_database"
                    }
                  },
                  "summary": "Datalayers Connector"
                },
                "azure_event_hub_producer": {
                  "value": {
                    "name": "my_azure_event_hub_producer_connector",
                    "type": "azure_event_hub_producer",
                    "ssl": {
                      "verify": "verify_none",
                      "enable": true,
                      "versions": [
                        "tlsv1.3",
                        "tlsv1.2"
                      ],
                      "server_name_indication": "auto"
                    },
                    "authentication": {
                      "password": "******"
                    },
                    "connect_timeout": "5s",
                    "enable": true,
                    "socket_opts": {
                      "nodelay": true,
                      "recbuf": "1024KB",
                      "sndbuf": "1024KB",
                      "tcp_keepalive": "none"
                    },
                    "min_metadata_refresh_interval": "3s",
                    "bootstrap_hosts": "namespace.servicebus.windows.net:9093",
                    "metadata_request_timeout": "4s"
                  },
                  "summary": "Azure Event Hub Connector"
                },
                "kafka_producer": {
                  "value": {
                    "name": "my_kafka_producer_connector",
                    "type": "kafka_producer",
                    "authentication": {
                      "mechanism": "plain",
                      "password": "******",
                      "username": "username"
                    },
                    "connect_timeout": "5s",
                    "enable": true,
                    "socket_opts": {
                      "nodelay": true,
                      "recbuf": "1024KB",
                      "sndbuf": "1024KB",
                      "tcp_keepalive": "none"
                    },
                    "min_metadata_refresh_interval": "3s",
                    "bootstrap_hosts": "localhost:9092",
                    "metadata_request_timeout": "4s"
                  },
                  "summary": "Kafka Producer Connector"
                },
                "kinesis": {
                  "value": {
                    "name": "kinesis_connector",
                    "type": "kinesis",
                    "description": "My example kinesis connector",
                    "aws_access_key_id": "your_access_key",
                    "aws_secret_access_key": "aws_secret_key",
                    "endpoint": "http://localhost:4566",
                    "max_retries": 2,
                    "pool_size": 8
                  },
                  "summary": "Kinesis Connector"
                },
                "syskeeper_proxy": {
                  "value": {
                    "name": "syskeeper_proxy",
                    "type": "syskeeper_proxy",
                    "listen": "127.0.0.1:9092",
                    "enable": true,
                    "acceptors": 16,
                    "handshake_timeout": "16s"
                  },
                  "summary": "Syskeeper Proxy Connector"
                },
                "pgsql": {
                  "value": {
                    "name": "my_pgsql_connector",
                    "type": "pgsql",
                    "database": "emqx_data",
                    "enable": true,
                    "password": "public",
                    "pool_size": 8,
                    "server": "127.0.0.1:5432",
                    "ssl": {
                      "ciphers": [],
                      "depth": 10,
                      "enable": false,
                      "hibernate_after": "5s",
                      "log_level": "notice",
                      "reuse_sessions": true,
                      "secure_renegotiate": true,
                      "verify": "verify_peer",
                      "versions": [
                        "tlsv1.3",
                        "tlsv1.2"
                      ]
                    },
                    "username": "postgres"
                  },
                  "summary": "PostgreSQL Connector"
                },
                "mysql": {
                  "value": {
                    "name": "mysql_connector",
                    "type": "mysql",
                    "description": "My example mysql connector",
                    "pool_size": 8,
                    "server": "127.0.0.1:3306",
                    "password": "******",
                    "username": "root",
                    "database": "test",
                    "resource_opts": {
                      "health_check_interval": "20s"
                    }
                  },
                  "summary": "MySQL Connector"
                },
                "rabbitmq": {
                  "value": {
                    "timeout": "5s",
                    "name": "rabbitmq_connector",
                    "port": 5672,
                    "type": "rabbitmq",
                    "ssl": {
                      "enable": false
                    },
                    "description": "My example rabbitmq connector",
                    "pool_size": 8,
                    "server": "127.0.0.1",
                    "enable": true,
                    "password": "******",
                    "username": "guest",
                    "heartbeat": "30s",
                    "virtual_host": "/"
                  },
                  "summary": "Rabbitmq Connector"
                },
                "dynamo": {
                  "value": {
                    "name": "dynamo_connector",
                    "type": "dynamo",
                    "description": "My example dynamo connector",
                    "aws_access_key_id": "root",
                    "aws_secret_access_key": "******",
                    "enable": true,
                    "pool_size": 8,
                    "region": "us-west-2",
                    "resource_opts": {
                      "health_check_interval": "15s",
                      "start_timeout": "5s"
                    },
                    "url": "http://127.0.0.1:8000"
                  },
                  "summary": "DynamoDB Connector"
                },
                "tdengine": {
                  "value": {
                    "name": "tdengine_connector",
                    "type": "tdengine",
                    "description": "My example tdengine connector",
                    "pool_size": 8,
                    "server": "127.0.0.1:6041",
                    "enable": true,
                    "password": "******",
                    "username": "root"
                  },
                  "summary": "TDengine Connector"
                },
                "mongodb_single": {
                  "value": {
                    "name": "mongodb_single_connector",
                    "type": "mongodb_single",
                    "description": "My example mongodb_single connector",
                    "parameters": {
                      "pool_size": 8,
                      "enable": true,
                      "password": "******",
                      "username": "myuser",
                      "database": "mqtt",
                      "srv_record": false
                    }
                  },
                  "summary": "MongoDB Standalone Connector"
                },
                "greptimedb": {
                  "value": {
                    "name": "demo",
                    "type": "greptimedb",
                    "ssl": {
                      "enable": false
                    },
                    "description": "My example greptimedb connector",
                    "server": "127.0.0.1:4001",
                    "enable": true,
                    "password": "******",
                    "username": "example_username",
                    "resource_opts": {
                      "batch_size": 100,
                      "batch_time": "20ms"
                    },
                    "local_topic": "local/topic/#",
                    "dbname": "example_db"
                  },
                  "summary": "GreptimeDB Connector"
                },
                "opents": {
                  "value": {
                    "name": "opents_connector",
                    "type": "opents",
                    "description": "My example opents connector",
                    "pool_size": 8,
                    "server": "http://localhost:4242/",
                    "enable": true
                  },
                  "summary": "OpenTSDB Connector"
                },
                "abs": {
                  "value": {
                    "name": "my_connector",
                    "type": "azure_blob_storage",
                    "description": "My connector",
                    "enable": true,
                    "resource_opts": {
                      "start_timeout": "5s",
                      "start_after_created": true,
                      "health_check_interval": "45s"
                    },
                    "account_key": "******",
                    "account_name": "my_account_name"
                  },
                  "summary": "Azure Blob Storage Connector"
                },
                "mongodb_sharded": {
                  "value": {
                    "name": "mongodb_sharded_connector",
                    "type": "mongodb_sharded",
                    "description": "My example mongodb_sharded connector",
                    "parameters": {
                      "pool_size": 8,
                      "enable": true,
                      "password": "******",
                      "username": "myuser",
                      "database": "mqtt",
                      "srv_record": false
                    }
                  },
                  "summary": "MongoDB Sharded Connector"
                },
                "mongodb_rs": {
                  "value": {
                    "name": "mongodb_rs_connector",
                    "type": "mongodb_rs",
                    "description": "My example mongodb_rs connector",
                    "parameters": {
                      "pool_size": 8,
                      "enable": true,
                      "password": "******",
                      "username": "myuser",
                      "database": "mqtt",
                      "srv_record": false
                    }
                  },
                  "summary": "MongoDB Replica Set Connector"
                },
                "redis_single_producer": {
                  "value": {
                    "name": "my_connector",
                    "type": "redis",
                    "ssl": {
                      "enable": false
                    },
                    "description": "My redis single connector",
                    "enable": true,
                    "parameters": {
                      "pool_size": 8,
                      "server": "127.0.0.1:6379",
                      "password": "******",
                      "username": "test",
                      "database": 1,
                      "redis_type": "single"
                    }
                  },
                  "summary": "Redis Single Producer Connector"
                },
                "oracle": {
                  "value": {
                    "name": "oracle_connector",
                    "type": "oracle",
                    "description": "My example oracle connector",
                    "password": "oracle",
                    "pool_size": 8,
                    "resource_opts": {
                      "health_check_interval": "15s",
                      "start_timeout": "5s"
                    },
                    "server": "127.0.0.1:1521",
                    "service_name": "XE",
                    "sid": "XE",
                    "username": "system"
                  },
                  "summary": "Oracle Connector"
                },
                "hstreamdb": {
                  "value": {
                    "name": "hstreamdb_connector",
                    "type": "hstreamdb",
                    "description": "My example hstreamdb connector",
                    "grpc_timeout": "30s",
                    "resource_opts": {
                      "health_check_interval": "15s",
                      "start_timeout": "5s"
                    },
                    "ssl": {
                      "enable": false,
                      "verify": "verify_peer"
                    },
                    "url": "http://127.0.0.1:6570"
                  },
                  "summary": "HStreamDB Connector"
                },
                "influxdb_api_v1": {
                  "value": {
                    "name": "influxdb_connector",
                    "type": "influxdb",
                    "ssl": {
                      "enable": false
                    },
                    "description": "My example influxdb connector",
                    "server": "127.0.0.1:8086",
                    "enable": true,
                    "parameters": {
                      "password": "******",
                      "username": "example_username",
                      "database": "example_database",
                      "influxdb_type": "influxdb_api_v1"
                    }
                  },
                  "summary": "InfluxDB HTTP API V1 Connector"
                },
                "s3_aws": {
                  "value": {
                    "name": "my_s3_connector",
                    "port": 443,
                    "type": "s3",
                    "host": "s3.eu-east-1.amazonaws.com",
                    "description": "My S3 connector",
                    "enable": true,
                    "transport_options": {
                      "ssl": {
                        "verify": "verify_peer",
                        "enable": true
                      },
                      "connect_timeout": "1s",
                      "pool_size": 4,
                      "max_retries": 1,
                      "request_timeout": "60s",
                      "enable_pipelining": 1
                    },
                    "secret_access_key": "SECRET",
                    "access_key_id": "ACCESS"
                  },
                  "summary": "S3 Connector"
                },
                "cassandra": {
                  "value": {
                    "name": "cassandra_connector",
                    "type": "cassandra",
                    "description": "My example cassandra connector",
                    "pool_size": 8,
                    "password": "******",
                    "username": "root",
                    "servers": "127.0.0.1:9042",
                    "keyspace": "mqtt"
                  },
                  "summary": "Cassandra Connector"
                },
                "gcp_pubsub_consumer": {
                  "value": {
                    "name": "my_connector",
                    "type": "gcp_pubsub_producer",
                    "description": "my connector",
                    "connect_timeout": "15s",
                    "pool_size": 8,
                    "enable": true,
                    "max_retries": 2,
                    "resource_opts": {
                      "start_timeout": "5s",
                      "start_after_created": true,
                      "health_check_interval": "30s"
                    },
                    "service_account_json": {
                      "type": "service_account",
                      "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQI...",
                      "client_id": "123812831923812319190",
                      "project_id": "myproject",
                      "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                      "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                      "client_email": "test@myproject.iam.gserviceaccount.com",
                      "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/test%40myproject.iam.gserviceaccount.com",
                      "private_key_id": "kid",
                      "token_uri": "https://oauth2.googleapis.com/token"
                    },
                    "pipelining": 100
                  },
                  "summary": "GCP PubSub Consumer Connector"
                },
                "clickhouse": {
                  "value": {
                    "name": "clickhouse_connector",
                    "type": "clickhouse",
                    "description": "My example clickhouse connector",
                    "pool_size": 8,
                    "password": "******",
                    "url": "http://localhost:8123",
                    "username": "default",
                    "database": "mqtt"
                  },
                  "summary": "ClickHouse Connector"
                },
                "sqlserver": {
                  "value": {
                    "driver": "ms-sql",
                    "name": "sqlserver_connector",
                    "type": "sqlserver",
                    "description": "My example sqlserver connector",
                    "pool_size": 8,
                    "server": "127.0.0.1:1433",
                    "password": "******",
                    "username": "sa",
                    "database": "test",
                    "resource_opts": {
                      "health_check_interval": "20s"
                    }
                  },
                  "summary": "Microsoft SQL Server Connector"
                },
                "redis_cluster_producer": {
                  "value": {
                    "name": "my_connector",
                    "type": "redis",
                    "ssl": {
                      "enable": false
                    },
                    "description": "My redis cluster connector",
                    "enable": true,
                    "parameters": {
                      "pool_size": 8,
                      "password": "******",
                      "username": "test",
                      "servers": "127.0.0.1:6379,127.0.0.2:6379",
                      "redis_type": "cluster"
                    }
                  },
                  "summary": "Redis Cluster Producer Connector"
                },
                "matrix": {
                  "value": {
                    "name": "my_matrix_connector",
                    "type": "matrix",
                    "database": "emqx_data",
                    "enable": true,
                    "password": "public",
                    "pool_size": 8,
                    "server": "127.0.0.1:5432",
                    "ssl": {
                      "ciphers": [],
                      "depth": 10,
                      "enable": false,
                      "hibernate_after": "5s",
                      "log_level": "notice",
                      "reuse_sessions": true,
                      "secure_renegotiate": true,
                      "verify": "verify_peer",
                      "versions": [
                        "tlsv1.3",
                        "tlsv1.2"
                      ]
                    },
                    "username": "postgres"
                  },
                  "summary": "Matrix Connector"
                },
                "kafka_consumer": {
                  "value": {
                    "name": "my_connector",
                    "type": "kafka_consumer",
                    "resource_opts": {
                      "start_timeout": "5s",
                      "start_after_created": true,
                      "health_check_interval": "30s"
                    },
                    "bootstrap_hosts": "kafka.emqx.net:9092"
                  },
                  "summary": "Kafka Consumer Connector"
                },
                "rocketmq": {
                  "value": {
                    "name": "rocketmq_connector",
                    "type": "rocketmq",
                    "description": "My example rocketmq connector",
                    "enable": true,
                    "pool_size": 8,
                    "resource_opts": {
                      "health_check_interval": "15s",
                      "start_after_created": true,
                      "start_timeout": "5s"
                    },
                    "servers": "127.0.0.1:9876"
                  },
                  "summary": "RocketMQ Connector"
                },
                "pulsar": {
                  "value": {
                    "name": "pulsar_connector",
                    "type": "pulsar",
                    "ssl": {
                      "enable": false
                    },
                    "authentication": "none",
                    "description": "My example pulsar connector",
                    "connect_timeout": "5s",
                    "enable": true,
                    "servers": "pulsar://127.0.0.1:6650"
                  },
                  "summary": "Pulsar Connector"
                },
                "syskeeper_forwarder": {
                  "value": {
                    "name": "syskeeper_forwarder",
                    "type": "syskeeper_forwarder",
                    "pool_size": 16,
                    "server": "127.0.0.1:9092",
                    "enable": true,
                    "ack_timeout": "10s",
                    "ack_mode": "no_ack"
                  },
                  "summary": "Syskeeper Forwarder Connector"
                },
                "elasticsearch": {
                  "value": {
                    "name": "elasticsearch_connector",
                    "type": "elasticsearch",
                    "ssl": {
                      "enable": false
                    },
                    "authentication": {
                      "password": "******",
                      "username": "root"
                    },
                    "description": "My example elasticsearch connector",
                    "connect_timeout": "15s",
                    "pool_size": 8,
                    "server": "127.0.0.1:9200",
                    "enable": true,
                    "pool_type": "random",
                    "enable_pipelining": 100
                  },
                  "summary": "Elastic Search Connector"
                },
                "gcp_pubsub_producer": {
                  "value": {
                    "name": "my_connector",
                    "type": "gcp_pubsub_producer",
                    "connect_timeout": "10s",
                    "pool_size": 8,
                    "enable": true,
                    "max_retries": 2,
                    "resource_opts": {
                      "request_ttl": "60s"
                    },
                    "service_account_json": {
                      "type": "service_account",
                      "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQI...",
                      "client_id": "123812831923812319190",
                      "project_id": "myproject",
                      "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                      "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                      "client_email": "test@myproject.iam.gserviceaccount.com",
                      "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/test%40myproject.iam.gserviceaccount.com",
                      "private_key_id": "kid",
                      "token_uri": "https://oauth2.googleapis.com/token"
                    },
                    "pipelining": 100
                  },
                  "summary": "GCP PubSub Producer Connector"
                },
                "timescale": {
                  "value": {
                    "name": "my_timescale_connector",
                    "type": "timescale",
                    "database": "emqx_data",
                    "enable": true,
                    "password": "public",
                    "pool_size": 8,
                    "server": "127.0.0.1:5432",
                    "ssl": {
                      "ciphers": [],
                      "depth": 10,
                      "enable": false,
                      "hibernate_after": "5s",
                      "log_level": "notice",
                      "reuse_sessions": true,
                      "secure_renegotiate": true,
                      "verify": "verify_peer",
                      "versions": [
                        "tlsv1.3",
                        "tlsv1.2"
                      ]
                    },
                    "username": "postgres"
                  },
                  "summary": "Timescale Connector"
                },
                "redis_sentinel_producer": {
                  "value": {
                    "name": "my_connector",
                    "type": "redis",
                    "ssl": {
                      "enable": false
                    },
                    "description": "My redis sentinel connector",
                    "enable": true,
                    "parameters": {
                      "pool_size": 8,
                      "password": "******",
                      "username": "test",
                      "database": 1,
                      "servers": "127.0.0.1:6379,127.0.0.2:6379",
                      "sentinel": "myredismaster",
                      "redis_type": "sentinel"
                    }
                  },
                  "summary": "Redis Sentinel Producer Connector"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/bridge_timescale.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mongodb.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/gcp_pubsub_producer.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/elasticsearch.post"
                  },
                  {
                    "$ref": "#/components/schemas/connector_azure_blob_storage.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/syskeeper_forwarder.post"
                  },
                  {
                    "$ref": "#/components/schemas/pulsar.post"
                  },
                  {
                    "$ref": "#/components/schemas/rocketmq.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/kafka_consumer.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_matrix.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_sqlserver.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_influxdb.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_clickhouse.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/gcp_pubsub_consumer.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_cassa.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_hstreamdb.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_oracle.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/opents_connector.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_greptimedb.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_s3.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/tdengine_connector.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_dynamo.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/redis.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/rabbitmq.post"
                  },
                  {
                    "$ref": "#/components/schemas/connector_mqtt.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mysql.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/connector_postgres.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/connector_syskeeper_proxy.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_kinesis.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_kafka.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_azure_event_hub.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_datalayers.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/connector_couchbase.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/iotdb.post"
                  },
                  {
                    "$ref": "#/components/schemas/confluent.post_connector"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_http.post_connector"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/authentication/order": {
      "put": {
        "description": "Reorder all authenticators in global authentication chain.",
        "tags": [
          "Authentication"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": "Authenticators order updated"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/emqx_authn_api.request_authn_order"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/schema_validations/validation/{name}": {
      "get": {
        "description": "Lookup a validation",
        "tags": [
          "Schema Validation"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Validation name",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "my_validation"
          }
        ],
        "summary": "Lookup a validation",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "avro_check": {
                    "value": {
                      "name": "my_validation",
                      "description": "my validation",
                      "tags": [
                        "validation"
                      ],
                      "strategy": "all_pass",
                      "enable": true,
                      "topics": [
                        "t/+"
                      ],
                      "checks": [
                        {
                          "type": "avro",
                          "schema": "my_avro_schema"
                        }
                      ],
                      "failure_action": "drop",
                      "log_failure": {
                        "level": "info"
                      }
                    },
                    "summary": "Using an Avro schema check"
                  },
                  "sql_check": {
                    "value": {
                      "name": "my_validation",
                      "description": "my validation",
                      "tags": [
                        "validation"
                      ],
                      "strategy": "all_pass",
                      "enable": true,
                      "topics": [
                        "t/+"
                      ],
                      "checks": [
                        {
                          "type": "sql",
                          "sql": "select payload.temp as t where t > 10"
                        }
                      ],
                      "failure_action": "drop",
                      "log_failure": {
                        "level": "info"
                      }
                    },
                    "summary": "Using a SQL check"
                  }
                },
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/schema_validation.validation"
                  }
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Validation not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete a validation",
        "tags": [
          "Schema Validation"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Validation name",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "my_validation"
          }
        ],
        "summary": "Delete a validation",
        "responses": {
          "204": {
            "description": "Validation deleted"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Validation not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/trace/{name}": {
      "delete": {
        "description": "Delete specified trace",
        "tags": [
          "Trace"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/trace.name"
          }
        ],
        "responses": {
          "204": {
            "description": "Delete successfully"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Trace Name Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/nodes/{node}/actions/{id}/{operation}": {
      "post": {
        "description": "Start bridge on a specific node.",
        "tags": [
          "Actions"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "node",
            "description": "The node name, e.g. 'emqx@127.0.0.1'.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "emqx@127.0.0.1"
          },
          {
            "in": "path",
            "name": "id",
            "description": "The bridge id. Must be of format {type}:{name}.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "http:my_http_action"
          },
          {
            "in": "path",
            "name": "operation",
            "description": "Operation can be one of: 'start'.",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "start"
              ]
            },
            "example": "start"
          }
        ],
        "summary": "Manually start a bridge on a given node",
        "responses": {
          "204": {
            "description": "Operation success"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Problem with configuration of external service or bridge not enabled"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bridge or node not found or invalid operation"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "501": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_IMPLEMENTED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Implemented"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Service unavailable"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/trace/{name}/stop": {
      "put": {
        "description": "Stop trace by name",
        "tags": [
          "Trace"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/trace.name"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/trace.trace"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Trace Name Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/opentelemetry": {
      "get": {
        "description": "Get opentelmetry configuration",
        "tags": [
          "Monitor"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "metrics": {
                    "enable": true
                  },
                  "exporter": {
                    "ssl_options": {},
                    "endpoint": "http://localhost:4317"
                  },
                  "traces": {
                    "filter": {
                      "trace_all": false
                    },
                    "enable": true
                  },
                  "logs": {
                    "level": "warning",
                    "enable": true
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/opentelemetry.opentelemetry"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update opentelmetry configuration",
        "tags": [
          "Monitor"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "metrics": {
                    "enable": true
                  },
                  "exporter": {
                    "ssl_options": {},
                    "endpoint": "http://localhost:4317"
                  },
                  "traces": {
                    "filter": {
                      "trace_all": false
                    },
                    "enable": true
                  },
                  "logs": {
                    "level": "warning",
                    "enable": true
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/opentelemetry.opentelemetry"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Update Config Failed"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "example": {
                "metrics": {
                  "enable": true
                },
                "exporter": {
                  "ssl_options": {},
                  "endpoint": "http://localhost:4317"
                },
                "traces": {
                  "filter": {
                    "trace_all": false
                  },
                  "enable": true
                },
                "logs": {
                  "level": "warning",
                  "enable": true
                }
              },
              "schema": {
                "$ref": "#/components/schemas/opentelemetry.opentelemetry"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/sso/{backend}": {
      "get": {
        "tags": [
          "Dashboard Single Sign-On"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "backend",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "ldap",
                "oidc",
                "saml"
              ]
            },
            "example": "ldap"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/dashboard.saml"
                    },
                    {
                      "$ref": "#/components/schemas/sso.oidc"
                    },
                    {
                      "$ref": "#/components/schemas/sso.ldap"
                    }
                  ]
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BACKEND_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "tags": [
          "Dashboard Single Sign-On"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "backend",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "ldap",
                "oidc",
                "saml"
              ]
            },
            "example": "ldap"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/dashboard.saml"
                    },
                    {
                      "$ref": "#/components/schemas/sso.oidc"
                    },
                    {
                      "$ref": "#/components/schemas/sso.ldap"
                    }
                  ]
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BACKEND_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/dashboard.saml"
                  },
                  {
                    "$ref": "#/components/schemas/sso.oidc"
                  },
                  {
                    "$ref": "#/components/schemas/sso.ldap"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "tags": [
          "Dashboard Single Sign-On"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "backend",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "ldap",
                "oidc",
                "saml"
              ]
            },
            "example": "ldap"
          }
        ],
        "responses": {
          "204": {
            "description": "Delete successfully"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BACKEND_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/listeners/{id}/restart": {
      "post": {
        "description": "Restart listeners on all nodes.",
        "tags": [
          "Listeners"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/listeners.listener_id"
          }
        ],
        "responses": {
          "200": {
            "description": "Updated"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST",
                        "BAD_LISTENER_ID"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/cluster/links/link/{name}": {
      "get": {
        "description": "Get a cluster link configuration",
        "tags": [
          "Cluster"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "my_link"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "enable": true,
                  "name": "emqxcl_b",
                  "node_status": [
                    {
                      "node": "emqx1@emqx.net",
                      "status": "connected"
                    }
                  ],
                  "pool_size": 10,
                  "server": "emqxcl_b.host:1883",
                  "ssl": {
                    "enable": false
                  },
                  "status": "connected",
                  "topics": [
                    "t/topic-example",
                    "t/topic-filter-example/1/#"
                  ]
                },
                "schema": {
                  "$ref": "#/components/schemas/cluster_link.link_config_response"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Cluster link not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update a cluster link configuration",
        "tags": [
          "Cluster"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "my_link"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "enable": true,
                  "name": "emqxcl_b",
                  "node_status": [
                    {
                      "node": "emqx1@emqx.net",
                      "status": "connected"
                    }
                  ],
                  "pool_size": 10,
                  "server": "emqxcl_b.host:1883",
                  "ssl": {
                    "enable": false
                  },
                  "status": "connected",
                  "topics": [
                    "t/topic-example",
                    "t/topic-filter-example/1/#"
                  ]
                },
                "schema": {
                  "$ref": "#/components/schemas/cluster_link.link_config_response"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Update Config Failed"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Cluster link not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "required": [
                  "server",
                  "topics"
                ],
                "properties": {
                  "enable": {
                    "default": true,
                    "type": "boolean",
                    "description": "Enable or disable a cluster link. The link is enabled by default, disabling it allows stopping the link without removing its configuration. The link must be enabled on both sides to be operational. Disabling the link should also be done on both clusters in order to free up all associated resources."
                  },
                  "server": {
                    "type": "string",
                    "description": "MQTT host and port of the remote EMQX broker."
                  },
                  "clientid": {
                    "type": "string",
                    "description": "Optional Base MQTT client ID for connecting to the remote EMQX cluster. If omitted, local `cluster.name` is used. EMQX maintains several connections between linked clusters, so distinct suffixes are automatically appended to the base client ID."
                  },
                  "username": {
                    "type": "string",
                    "description": "Optional MQTT username for connecting to the remote EMQX cluster."
                  },
                  "password": {
                    "type": "string",
                    "format": "password",
                    "description": "Optional MQTT username for connecting to the remote EMQX cluster.",
                    "example": "R4ND0M/S∃CЯ∃T"
                  },
                  "ssl": {
                    "default": {
                      "enable": false
                    },
                    "description": "SSL configuration for connecting to the remote EMQX cluster.",
                    "$ref": "#/components/schemas/emqx.ssl_client_opts"
                  },
                  "topics": {
                    "type": "array",
                    "description": "MQTT topics to be forwarded by the linked remote EMQX broker to the local broker. Messages are only forwarded if the local EMQX broker has matching subscriber(s).<br/>Wildcards are supported. Setting empty topics list on one side of the link can be used to establish unidirectional links: the side with the empty topics won't receive remote messages, but it can forward relevant messages to its linked counterpart (according to the topics configured on that side of the link).",
                    "items": {
                      "type": "string"
                    }
                  },
                  "pool_size": {
                    "default": 8,
                    "type": "integer",
                    "description": "Size of the pool of MQTT clients that will publish messages to the linked EMQX broker.",
                    "minimum": 1
                  },
                  "retry_interval": {
                    "default": "15s",
                    "type": "string",
                    "description": "MQTT Message retry interval. Delay for the link to retry sending the QoS1/QoS2 messages in case of ACK not received. Time interval is a string that contains a number followed by time unit:<br/>- `ms` for milliseconds,<br/>- `s` for seconds,<br/>- `m` for minutes,<br/>- `h` for hours;<br/><br/>or combination of whereof: `1h5m0s`"
                  },
                  "max_inflight": {
                    "default": 32,
                    "type": "integer",
                    "description": "Max inflight (sent, but un-acked) messages of the MQTT protocol",
                    "minimum": 0
                  },
                  "resource_opts": {
                    "default": {},
                    "description": "Resource options.",
                    "$ref": "#/components/schemas/cluster.creation_opts"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete a cluster link",
        "tags": [
          "Cluster"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "my_link"
          }
        ],
        "responses": {
          "204": {
            "description": "Link deleted"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Cluster link not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/mqtt/retainer/message/{topic}": {
      "get": {
        "description": "Lookup a message by a topic without wildcards.",
        "tags": [
          "Retainer"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "topic",
            "description": "Topic.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Details of the message.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/retainer.message"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Unsupported backend."
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Viewed message doesn't exist."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete matching messages.",
        "tags": [
          "Retainer"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "topic",
            "description": "Topic.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": ""
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Unsupported backend."
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Viewed message doesn't exist."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/rule_events": {
      "get": {
        "description": "List all events can be used in rules",
        "tags": [
          "Rules"
        ],
        "parameters": [],
        "summary": "List rule events",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/rule_engine.rule_events"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/file_transfer/files/{clientid}/{fileid}": {
      "get": {
        "description": "List a file uploaded during specified transfer, identified by client id and file id.",
        "tags": [
          "File Transfer"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/file_transfer.client_id"
          },
          {
            "$ref": "#/components/parameters/file_transfer.file_id"
          }
        ],
        "summary": "List files uploaded in a specific transfer",
        "responses": {
          "200": {
            "description": "Operation success"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "FILES_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Files requested for this transfer could not be found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Service unavailable"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/audit": {
      "get": {
        "description": "Get audit logs with filtering parameters. This feature enables users to efficiently<br/>access the desired audit trail data and facilitates auditing, compliance,<br/>troubleshooting, and security analysis.",
        "tags": [
          "Audit"
        ],
        "parameters": [
          {
            "in": "query",
            "name": "node",
            "description": "Filter logs by the node name where the logs were generated.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "emqx@127.0.0.1"
          },
          {
            "in": "query",
            "name": "from",
            "description": "Filter logs by source type. Possible values are:<br/><br/>- `dashboard`: Dashboard request logs.<br/>- `rest_api`: API KEY request logs.<br/>- `cli`: The emqx command line logs.<br/>- `erlang_console`: The emqx remote_console run function logs.",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "dashboard",
                "rest_api",
                "cli",
                "erlang_console"
              ]
            },
            "example": "dashboard"
          },
          {
            "in": "query",
            "name": "source",
            "description": "Filter logs by source. Possible values are:<br/><br/>- The login username to filter logs generated from Dashboard for this specific user.<br/>- The API Key to filter logs generated from the REST API for this specific API key.<br/>- An empty string to filter logs generated from CLI or Erlang console.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "admin"
          },
          {
            "in": "query",
            "name": "source_ip",
            "description": "Filter logs by source IP when logs, applicable for logs generated from Dashboard or REST API operations.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "127.0.0.1"
          },
          {
            "in": "query",
            "name": "operation_id",
            "description": "Filter logs by swagger's operation_id, applicable for logs generated from Dashboard or REST API operations.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "/rules/{id}"
          },
          {
            "in": "query",
            "name": "operation_type",
            "description": "Filter logs by operation type.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "rules"
          },
          {
            "in": "query",
            "name": "operation_result",
            "description": "Filter logs by operation result.",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "success",
                "failure"
              ]
            },
            "example": "failure"
          },
          {
            "in": "query",
            "name": "http_status_code",
            "description": "Filter The HTTP API logs by response code, applicable for logs generated from Dashboard or REST API operations.",
            "required": false,
            "schema": {
              "type": "integer"
            },
            "example": 200
          },
          {
            "in": "query",
            "name": "http_method",
            "description": "Filter The HTTP API logs by method, applicable for logs generated from Dashboard or REST API operations.",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "post",
                "put",
                "delete"
              ]
            },
            "example": "post"
          },
          {
            "in": "query",
            "name": "gte_duration_ms",
            "description": "Filter logs by age duration, selecting those created no earlier than then given duration time ago.",
            "required": false,
            "schema": {
              "type": "integer"
            },
            "example": 0
          },
          {
            "in": "query",
            "name": "lte_duration_ms",
            "description": "Filter logs by age duration, selecting those created no later than then given duration time ago.",
            "required": false,
            "schema": {
              "type": "integer"
            },
            "example": 1000
          },
          {
            "in": "query",
            "name": "gte_created_at",
            "description": "Filter logs by creation time, selecting logs created no earlier than the given timestamp.<br/>The timestamp can be provided either in rfc3339 string format or as a millisecond epoch timestamp.",
            "required": false,
            "schema": {
              "oneOf": [
                {
                  "type": "integer",
                  "description": "epoch-microsecond",
                  "example": 1640995200000000
                },
                {
                  "type": "string",
                  "format": "date-time",
                  "example": "2022-01-01T00:00:00.000000Z"
                }
              ]
            },
            "example": "2023-10-15T00:00:00.820384+08:00"
          },
          {
            "in": "query",
            "name": "lte_created_at",
            "description": "Filter logs by creation time, selecting logs created no later than the given timestamp.<br/>The timestamp can be provided either in rfc3339 string format or as a millisecond epoch timestamp.",
            "required": false,
            "schema": {
              "oneOf": [
                {
                  "type": "integer",
                  "description": "epoch-microsecond",
                  "example": 1640995200000000
                },
                {
                  "type": "string",
                  "format": "date-time",
                  "example": "2022-01-01T00:00:00.000000Z"
                }
              ]
            },
            "example": "2023-10-16T00:00:00.820384+08:00"
          },
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          }
        ],
        "summary": "List audit logs",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "data": [
                    {
                      "args": [],
                      "created_at": "2023-10-17T10:41:20.383993+08:00",
                      "duration_ms": 0,
                      "failure": [],
                      "from": "dashboard",
                      "http_method": "post",
                      "http_request": {
                        "bindings": {},
                        "body": {
                          "password": "******",
                          "username": "admin"
                        },
                        "headers": {
                          "accept": "*/*",
                          "authorization": "******",
                          "connection": "keep-alive",
                          "content-length": "45",
                          "content-type": "application/json"
                        },
                        "method": "post"
                      },
                      "http_status_code": 200,
                      "node": "emqx@127.0.0.1",
                      "operation_id": "/login",
                      "operation_result": "success",
                      "operation_type": "login",
                      "source": "admin",
                      "source_ip": "127.0.0.1"
                    },
                    {
                      "args": [
                        "show",
                        "log"
                      ],
                      "created_at": "2023-10-17T10:45:13.100426+08:00",
                      "duration_ms": 7,
                      "failure": [],
                      "from": "cli",
                      "http_method": [],
                      "http_request": [],
                      "http_status_code": [],
                      "node": "emqx@127.0.0.1",
                      "operation_id": [],
                      "operation_result": [],
                      "operation_type": "conf",
                      "source": [],
                      "source_ip": []
                    }
                  ],
                  "meta": {
                    "count": 2,
                    "hasnext": false,
                    "limit": 50,
                    "page": 1
                  }
                },
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/audit.audit_list"
                  }
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Audit is disabled"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/clients/{clientid}/unsubscribe": {
      "post": {
        "description": "Unsubscribe",
        "tags": [
          "Clients"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Unsubscribe OK"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "CLIENTID_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Client ID not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx_mgmt_api_clients.unsubscribe"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/plugins/install": {
      "post": {
        "description": "Upload a plugin tarball (plugin-vsn.tar.gz).Follow [emqx-plugin-template](https://github.com/emqx/emqx-plugin-template) to develop plugin.",
        "tags": [
          "Plugins"
        ],
        "parameters": [],
        "summary": "Install a new plugin",
        "responses": {
          "204": {
            "description": "Install plugin successfully"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UNEXPECTED_ERROR",
                        "ALREADY_INSTALLED",
                        "BAD_PLUGIN_INFO"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "multipart/form-data": {
              "encoding": {
                "plugin": {
                  "contentType": "application/gzip"
                }
              },
              "schema": {
                "type": "object",
                "properties": {
                  "plugin": {
                    "type": "string",
                    "format": "binary"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/lwm2m/clients/{clientid}/read": {
      "post": {
        "description": "Send a read command to a resource",
        "tags": [
          "LwM2M Gateways"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "urn:oma:lwm2m:oma:2"
          },
          {
            "in": "query",
            "name": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "/3/0/7"
          }
        ],
        "summary": "Read Value from a Resource Path",
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "CLIENT_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "clientid not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/banned/{as}/{who}": {
      "delete": {
        "description": "Remove a client ID, username or IP address from the blacklist.",
        "tags": [
          "Banned"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "as",
            "description": "Ban method, which can be exact client ID, client ID regular expression, exact username, username regular expression,<br/>IP address or an IP address range.",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "clientid",
                "username",
                "peerhost",
                "clientid_re",
                "username_re",
                "peerhost_net"
              ]
            },
            "example": "username"
          },
          {
            "in": "path",
            "name": "who",
            "description": "Ban object, specific client ID, username or IP address.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "Badass"
          }
        ],
        "responses": {
          "204": {
            "description": "Delete banned success"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "The banned object was not found in the blacklist."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/schema_validations": {
      "get": {
        "description": "List validations",
        "tags": [
          "Schema Validation"
        ],
        "parameters": [],
        "summary": "List validations",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "list": {
                    "value": [
                      {
                        "name": "my_validation",
                        "description": "my validation",
                        "tags": [
                          "validation"
                        ],
                        "strategy": "all_pass",
                        "enable": true,
                        "topics": [
                          "t/+"
                        ],
                        "checks": [
                          {
                            "type": "sql",
                            "sql": "select payload.temp as t where t > 10"
                          }
                        ],
                        "failure_action": "drop",
                        "log_failure": {
                          "level": "info"
                        }
                      },
                      {
                        "name": "other_validation",
                        "description": "my validation",
                        "tags": [
                          "validation"
                        ],
                        "strategy": "all_pass",
                        "enable": true,
                        "topics": [
                          "t/+"
                        ],
                        "checks": [
                          {
                            "type": "avro",
                            "schema": "my_avro_schema"
                          }
                        ],
                        "failure_action": "drop",
                        "log_failure": {
                          "level": "info"
                        }
                      }
                    ],
                    "summary": "List"
                  }
                },
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/schema_validation.validation"
                    }
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update a validation",
        "tags": [
          "Schema Validation"
        ],
        "parameters": [],
        "summary": "Update a validation",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "update": {
                    "value": {
                      "name": "my_validation",
                      "description": "my validation",
                      "tags": [
                        "validation"
                      ],
                      "strategy": "all_pass",
                      "enable": true,
                      "topics": [
                        "t/+"
                      ],
                      "checks": [
                        {
                          "type": "sql",
                          "sql": "select payload.temp as t where t > 10"
                        }
                      ],
                      "failure_action": "drop",
                      "log_failure": {
                        "level": "info"
                      }
                    },
                    "summary": "Update"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/schema_validation.validation"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad params"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Validation not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "update": {
                  "value": {
                    "name": "my_validation",
                    "description": "my validation",
                    "tags": [
                      "validation"
                    ],
                    "strategy": "all_pass",
                    "enable": true,
                    "topics": [
                      "t/+"
                    ],
                    "checks": [
                      {
                        "type": "sql",
                        "sql": "select payload.temp as t where t > 10"
                      }
                    ],
                    "failure_action": "drop",
                    "log_failure": {
                      "level": "info"
                    }
                  },
                  "summary": "Update"
                }
              },
              "schema": {
                "$ref": "#/components/schemas/schema_validation.validation"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Append a new validation to the list of validations",
        "tags": [
          "Schema Validation"
        ],
        "parameters": [],
        "summary": "Append a new validation",
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "avro_check": {
                    "value": {
                      "name": "my_validation",
                      "description": "my validation",
                      "tags": [
                        "validation"
                      ],
                      "strategy": "all_pass",
                      "enable": true,
                      "topics": [
                        "t/+"
                      ],
                      "checks": [
                        {
                          "type": "avro",
                          "schema": "my_avro_schema"
                        }
                      ],
                      "failure_action": "drop",
                      "log_failure": {
                        "level": "info"
                      }
                    },
                    "summary": "Using an Avro schema check"
                  },
                  "sql_check": {
                    "value": {
                      "name": "my_validation",
                      "description": "my validation",
                      "tags": [
                        "validation"
                      ],
                      "strategy": "all_pass",
                      "enable": true,
                      "topics": [
                        "t/+"
                      ],
                      "checks": [
                        {
                          "type": "sql",
                          "sql": "select payload.temp as t where t > 10"
                        }
                      ],
                      "failure_action": "drop",
                      "log_failure": {
                        "level": "info"
                      }
                    },
                    "summary": "Using a SQL check"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/schema_validation.validation"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "ALREADY_EXISTS"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Validation already exists"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "avro_check": {
                  "value": {
                    "name": "my_validation",
                    "description": "my validation",
                    "tags": [
                      "validation"
                    ],
                    "strategy": "all_pass",
                    "enable": true,
                    "topics": [
                      "t/+"
                    ],
                    "checks": [
                      {
                        "type": "avro",
                        "schema": "my_avro_schema"
                      }
                    ],
                    "failure_action": "drop",
                    "log_failure": {
                      "level": "info"
                    }
                  },
                  "summary": "Using an Avro schema check"
                },
                "sql_check": {
                  "value": {
                    "name": "my_validation",
                    "description": "my validation",
                    "tags": [
                      "validation"
                    ],
                    "strategy": "all_pass",
                    "enable": true,
                    "topics": [
                      "t/+"
                    ],
                    "checks": [
                      {
                        "type": "sql",
                        "sql": "select payload.temp as t where t > 10"
                      }
                    ],
                    "failure_action": "drop",
                    "log_failure": {
                      "level": "info"
                    }
                  },
                  "summary": "Using a SQL check"
                }
              },
              "schema": {
                "$ref": "#/components/schemas/schema_validation.validation"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/configs_reset/{rootname}": {
      "post": {
        "description": "Reset the config entry specified by the query string parameter `conf_path`.<br/><br/>- For a config entry that has default value, this resets it to the default value;<br/>- For a config entry that has no default value, an error 400 will be returned",
        "tags": [
          "Configs"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "rootname",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "file_transfer",
                "broker",
                "log",
                "sysmon",
                "sys_topics",
                "alarm",
                "dashboard"
              ]
            },
            "example": "sysmon"
          },
          {
            "in": "query",
            "name": "conf_path",
            "description": "The config path separated by '.' character",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "os.sysmem_high_watermark"
          }
        ],
        "responses": {
          "200": {
            "description": "Rest config successfully"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NO_DEFAULT_VALUE",
                        "REST_FAILED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "403": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "REST_FAILED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/mqtt/retainer": {
      "get": {
        "description": "View config",
        "tags": [
          "Retainer"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "The config content",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/retainer.retainer"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Config not found."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update retainer config.",
        "tags": [
          "Retainer"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Update configs successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/retainer.retainer"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UPDATE_FAILED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Update config failed"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/retainer.retainer"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/authorization/cache": {
      "delete": {
        "description": "Clean all authorization cache in the cluster.",
        "tags": [
          "Authorization"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/api_key/{name}": {
      "get": {
        "description": "Return the specific api_key. This API can only be requested using a bearer token.",
        "tags": [
          "API Keys"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/api_key.name"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "name": {
                      "type": "string",
                      "description": "Unique and format by [a-zA-Z0-9-_]",
                      "example": "EMQX-API-KEY-1"
                    },
                    "api_key": {
                      "type": "string",
                      "description": "TODO:uses HMAC-SHA256 for signing.",
                      "example": "a4697a5c75a769f6"
                    },
                    "expired_at": {
                      "default": "infinity",
                      "description": "No longer valid datetime",
                      "example": "2021-12-05T02:01:34.186Z",
                      "oneOf": [
                        {
                          "oneOf": [
                            {
                              "type": "integer",
                              "description": "epoch-second",
                              "example": 1640995200
                            },
                            {
                              "type": "string",
                              "format": "date-time",
                              "example": "2022-01-01T00:00:00.000Z"
                            }
                          ]
                        },
                        {
                          "type": "string",
                          "enum": [
                            "infinity"
                          ]
                        }
                      ]
                    },
                    "created_at": {
                      "description": "ApiKey create datetime",
                      "example": "2021-12-01T00:00:00.000Z",
                      "oneOf": [
                        {
                          "type": "integer",
                          "description": "epoch-second",
                          "example": 1640995200
                        },
                        {
                          "type": "string",
                          "format": "date-time",
                          "example": "2022-01-01T00:00:00.000Z"
                        }
                      ]
                    },
                    "desc": {
                      "type": "string",
                      "example": "Note"
                    },
                    "enable": {
                      "type": "boolean",
                      "description": "Enable/Disable"
                    },
                    "expired": {
                      "type": "boolean",
                      "description": "Expired"
                    },
                    "role": {
                      "default": "administrator",
                      "type": "string",
                      "description": "Role for this API",
                      "example": "administrator"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update the specific api_key. This API can only be requested using a bearer token.",
        "tags": [
          "API Keys"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/api_key.name"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "name": {
                      "type": "string",
                      "description": "Unique and format by [a-zA-Z0-9-_]",
                      "example": "EMQX-API-KEY-1"
                    },
                    "api_key": {
                      "type": "string",
                      "description": "TODO:uses HMAC-SHA256 for signing.",
                      "example": "a4697a5c75a769f6"
                    },
                    "expired_at": {
                      "default": "infinity",
                      "description": "No longer valid datetime",
                      "example": "2021-12-05T02:01:34.186Z",
                      "oneOf": [
                        {
                          "oneOf": [
                            {
                              "type": "integer",
                              "description": "epoch-second",
                              "example": 1640995200
                            },
                            {
                              "type": "string",
                              "format": "date-time",
                              "example": "2022-01-01T00:00:00.000Z"
                            }
                          ]
                        },
                        {
                          "type": "string",
                          "enum": [
                            "infinity"
                          ]
                        }
                      ]
                    },
                    "created_at": {
                      "description": "ApiKey create datetime",
                      "example": "2021-12-01T00:00:00.000Z",
                      "oneOf": [
                        {
                          "type": "integer",
                          "description": "epoch-second",
                          "example": 1640995200
                        },
                        {
                          "type": "string",
                          "format": "date-time",
                          "example": "2022-01-01T00:00:00.000Z"
                        }
                      ]
                    },
                    "desc": {
                      "type": "string",
                      "example": "Note"
                    },
                    "enable": {
                      "type": "boolean",
                      "description": "Enable/Disable"
                    },
                    "expired": {
                      "type": "boolean",
                      "description": "Expired"
                    },
                    "role": {
                      "default": "administrator",
                      "type": "string",
                      "description": "Role for this API",
                      "example": "administrator"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "expired_at": {
                    "default": "infinity",
                    "description": "No longer valid datetime",
                    "example": "2021-12-05T02:01:34.186Z",
                    "oneOf": [
                      {
                        "oneOf": [
                          {
                            "type": "integer",
                            "description": "epoch-second",
                            "example": 1640995200
                          },
                          {
                            "type": "string",
                            "format": "date-time",
                            "example": "2022-01-01T00:00:00.000Z"
                          }
                        ]
                      },
                      {
                        "type": "string",
                        "enum": [
                          "infinity"
                        ]
                      }
                    ]
                  },
                  "desc": {
                    "type": "string",
                    "example": "Note"
                  },
                  "enable": {
                    "type": "boolean",
                    "description": "Enable/Disable"
                  },
                  "expired": {
                    "type": "boolean",
                    "description": "Expired"
                  },
                  "role": {
                    "default": "administrator",
                    "type": "string",
                    "description": "Role for this API",
                    "example": "administrator"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete the specific api_key. This API can only be requested using a bearer token.",
        "tags": [
          "API Keys"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/api_key.name"
          }
        ],
        "responses": {
          "204": {
            "description": "Delete successfully"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/clients/{clientid}/subscriptions": {
      "get": {
        "description": "Get client subscriptions",
        "tags": [
          "Clients"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/emqx_mgmt_api_subscriptions.subscription"
                  }
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "CLIENTID_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Client ID not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/cluster/invitation": {
      "get": {
        "description": "Get the execution status of all asynchronous invite status per node",
        "tags": [
          "Cluster"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Get invitation progress created by async operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/cluster.invitation_status"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/configs": {
      "get": {
        "description": "Get all the configurations of the specified keys, including hot and non-hot updatable items.",
        "tags": [
          "Configs"
        ],
        "parameters": [
          {
            "in": "query",
            "name": "key",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "actions",
                "alarm",
                "api_key",
                "authentication",
                "authorization",
                "auto_subscribe",
                "banned",
                "bridges",
                "cluster",
                "conn_congestion",
                "connectors",
                "crl_cache",
                "dashboard",
                "delayed",
                "durable_queues",
                "durable_sessions",
                "durable_storage",
                "exhook",
                "file_transfer",
                "flapping_detect",
                "force_gc",
                "force_shutdown",
                "gateway",
                "license",
                "limiter",
                "listeners",
                "log",
                "message_transformation",
                "mqtt",
                "node",
                "opentelemetry",
                "overload_protection",
                "prometheus",
                "psk_authentication",
                "retainer",
                "rewrite",
                "rpc",
                "rule_engine",
                "schema_registry",
                "schema_validation",
                "slow_subs",
                "sources",
                "sys_topics",
                "sysmon",
                "topic_metrics"
              ]
            },
            "example": "sysmon"
          },
          {
            "in": "query",
            "name": "node",
            "description": "Node's name. Will deprecated in 5.2.0.",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string",
                  "example": "\n    sysmon {\n      os {\n        cpu_check_interval = 60s\n        cpu_high_watermark = 80%\n        cpu_low_watermark = 60%\n        mem_check_interval = 60s\n        procmem_high_watermark = 5%\n        sysmem_high_watermark = 70%\n        }\n        vm {\n        busy_dist_port = true\n        busy_port = true\n        large_heap = 32MB\n        long_gc = disabled\n        long_schedule = 240ms\n        process_check_interval = 30s\n        process_high_watermark = 80%\n        process_low_watermark = 60%\n        }\n    }\n    "
                }
              },
              "application/json": {
                "schema": {
                  "type": "object",
                  "example": {
                    "deprecated": true
                  }
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "INVALID_ACCEPT"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "500": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_NODE"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update the configurations of the specified keys.",
        "tags": [
          "Configs"
        ],
        "parameters": [
          {
            "in": "query",
            "name": "mode",
            "required": false,
            "schema": {
              "default": "merge",
              "type": "string",
              "enum": [
                "replace",
                "merge"
              ]
            }
          },
          {
            "in": "query",
            "name": "ignore_readonly",
            "required": false,
            "schema": {
              "default": false,
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Configurations updated"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UPDATE_FAILED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "text/plain": {
              "schema": {
                "type": "string",
                "example": "\n    sysmon {\n      os {\n        cpu_check_interval = 60s\n        cpu_high_watermark = 80%\n        cpu_low_watermark = 60%\n        mem_check_interval = 60s\n        procmem_high_watermark = 5%\n        sysmem_high_watermark = 70%\n        }\n        vm {\n        busy_dist_port = true\n        busy_port = true\n        large_heap = 32MB\n        long_gc = disabled\n        long_schedule = 240ms\n        process_check_interval = 30s\n        process_high_watermark = 80%\n        process_low_watermark = 60%\n        }\n    }\n    "
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/clients": {
      "get": {
        "description": "List clients",
        "tags": [
          "Clients"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "in": "query",
            "name": "node",
            "description": "Node name",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "emqx@127.0.0.1"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          },
          {
            "in": "query",
            "name": "username",
            "description": "User name, multiple values can be specified by repeating the parameter: username=u1&username=u2",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "in": "query",
            "name": "ip_address",
            "description": "Client's IP address",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "127.0.0.1"
          },
          {
            "in": "query",
            "name": "conn_state",
            "description": "The current connection status of the client, the possible values are connected,idle,disconnected",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "connected",
                "idle",
                "disconnected"
              ]
            }
          },
          {
            "in": "query",
            "name": "clean_start",
            "description": "Whether the client uses a new session",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "in": "query",
            "name": "proto_ver",
            "description": "Client protocol version",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "like_clientid",
            "description": "Fuzzy search `clientid` as substring",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "like_username",
            "description": "Fuzzy search `username` as substring",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "gte_created_at",
            "description": "Search client session creation time by greater than or equal method, rfc3339 or timestamp(millisecond)",
            "required": false,
            "schema": {
              "oneOf": [
                {
                  "type": "integer",
                  "description": "epoch-millisecond",
                  "example": 1640995200000
                },
                {
                  "type": "string",
                  "format": "date-time",
                  "example": "2022-01-01T00:00:00.000Z"
                }
              ]
            }
          },
          {
            "in": "query",
            "name": "lte_created_at",
            "description": "Search client session creation time by less than or equal method, rfc3339 or timestamp(millisecond)",
            "required": false,
            "schema": {
              "oneOf": [
                {
                  "type": "integer",
                  "description": "epoch-millisecond",
                  "example": 1640995200000
                },
                {
                  "type": "string",
                  "format": "date-time",
                  "example": "2022-01-01T00:00:00.000Z"
                }
              ]
            }
          },
          {
            "in": "query",
            "name": "gte_connected_at",
            "description": "Search client connection creation time by greater than or equal method, rfc3339 or timestamp(epoch millisecond)",
            "required": false,
            "schema": {
              "oneOf": [
                {
                  "type": "integer",
                  "description": "epoch-millisecond",
                  "example": 1640995200000
                },
                {
                  "type": "string",
                  "format": "date-time",
                  "example": "2022-01-01T00:00:00.000Z"
                }
              ]
            }
          },
          {
            "in": "query",
            "name": "lte_connected_at",
            "description": "Search client connection creation time by less than or equal method, rfc3339 or timestamp(millisecond)",
            "required": false,
            "schema": {
              "oneOf": [
                {
                  "type": "integer",
                  "description": "epoch-millisecond",
                  "example": 1640995200000
                },
                {
                  "type": "string",
                  "format": "date-time",
                  "example": "2022-01-01T00:00:00.000Z"
                }
              ]
            }
          },
          {
            "in": "query",
            "name": "clientid",
            "description": "Client ID, multiple values can be specified by repeating the parameter: clientid=c1&clientid=c2",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "$ref": "#/components/parameters/emqx_mgmt_api_clients.requested_client_fields"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "data": [
                    {
                      "heap_size": 610,
                      "send_msg.dropped.expired": 0,
                      "send_oct": 31,
                      "recv_msg.qos1": 0,
                      "is_persistent": false,
                      "send_pkt": 4,
                      "clean_start": true,
                      "inflight_cnt": 0,
                      "node": "emqx@127.0.0.1",
                      "send_msg.dropped.queue_full": 0,
                      "awaiting_rel_cnt": 0,
                      "inflight_max": 32,
                      "created_at": "2024-01-01T12:34:56.789+08:00",
                      "subscriptions_cnt": 1,
                      "mailbox_len": 0,
                      "send_cnt": 4,
                      "connected": true,
                      "ip_address": "127.0.0.1",
                      "awaiting_rel_max": 100,
                      "recv_msg.qos2": 0,
                      "proto_ver": 5,
                      "mountpoint": "null",
                      "proto_name": "MQTT",
                      "durable": false,
                      "port": 52571,
                      "connected_at": "2024-01-01T12:34:56.789+08:00",
                      "enable_authn": true,
                      "expiry_interval": 0,
                      "username": null,
                      "recv_msg": 0,
                      "recv_oct": 49,
                      "send_msg.dropped.too_large": 0,
                      "keepalive": 60,
                      "send_msg.qos1": 0,
                      "send_msg.qos2": 0,
                      "recv_msg.qos0": 0,
                      "send_msg.qos0": 0,
                      "subscriptions_max": "infinity",
                      "mqueue_max": 1000,
                      "mqueue_dropped": 0,
                      "clientid": "01",
                      "is_bridge": false,
                      "peerport": 52571,
                      "send_msg": 0,
                      "listener": "tcp:default",
                      "recv_cnt": 4,
                      "recv_pkt": 4,
                      "recv_msg.dropped": 0,
                      "send_msg.dropped": 0,
                      "recv_msg.dropped.await_pubrel_timeout": 0,
                      "reductions": 6836,
                      "mqueue_len": 0
                    }
                  ],
                  "meta": {
                    "count": 1,
                    "hasnext": false,
                    "limit": 50,
                    "page": 1
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_clients.clients"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "INVALID_PARAMETER"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Invalid parameters"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/{name}/authentication/users": {
      "get": {
        "description": "Get the users for the authenticator (only supported by <code>built_in_database</code>).",
        "tags": [
          "Gateway Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "gbt32960",
                "jt808",
                "lwm2m",
                "mqttsn",
                "ocpp",
                "stomp"
              ]
            },
            "example": "stomp"
          },
          {
            "in": "query",
            "name": "page",
            "description": "Page number of the results to fetch.",
            "schema": {
              "default": 1,
              "type": "integer",
              "minimum": 1
            },
            "example": 1
          },
          {
            "in": "query",
            "name": "limit",
            "description": "Results per page(max 10000)",
            "schema": {
              "default": 100,
              "maximum": 10000,
              "type": "integer",
              "minimum": 1
            },
            "example": 50
          },
          {
            "in": "query",
            "name": "like_user_id",
            "description": "Fuzzy search using user ID (username or clientid), only supports search by substring.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "test_"
          },
          {
            "in": "query",
            "name": "is_superuser",
            "description": "Is superuser",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "summary": "List users for gateway authenticator",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "data": [
                    {
                      "user_id": "user1"
                    },
                    {
                      "is_superuser": true,
                      "user_id": "user2"
                    }
                  ],
                  "meta": {
                    "count": 300,
                    "limit": 20,
                    "page": 0
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_users"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Add user for the authenticator (only supports built_in_database).",
        "tags": [
          "Gateway Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "gbt32960",
                "jt808",
                "lwm2m",
                "mqttsn",
                "ocpp",
                "stomp"
              ]
            },
            "example": "stomp"
          }
        ],
        "summary": "Add user for gateway authenticator",
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "regular_user": {
                    "value": {
                      "user_id": "user1"
                    },
                    "summary": "Regular user"
                  },
                  "super_user": {
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    },
                    "summary": "Superuser"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "regular_user": {
                  "value": {
                    "password": "******",
                    "user_id": "user1"
                  },
                  "summary": "Regular user"
                },
                "super_user": {
                  "value": {
                    "password": "******",
                    "is_superuser": true,
                    "user_id": "user2"
                  },
                  "summary": "Superuser"
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authn_api.request_user_create"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/listeners/{id}": {
      "get": {
        "description": "List all running node's listeners for the specified id.",
        "tags": [
          "Listeners"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/listeners.listener_id"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "id": "tcp:demo",
                  "running": true,
                  "type": "tcp",
                  "bind": "0.0.0.0:1884",
                  "tcp_options": {
                    "buffer": "4KB",
                    "high_watermark": "1MB",
                    "nodelay": false,
                    "reuseaddr": true,
                    "send_timeout": "15s",
                    "send_timeout_close": true,
                    "backlog": 1024,
                    "active_n": 100
                  },
                  "max_connections": 204800,
                  "acceptors": 16,
                  "proxy_protocol": false,
                  "access_rules": [
                    "allow all"
                  ],
                  "proxy_protocol_timeout": "3s",
                  "zone": "default",
                  "mountpoint": "/",
                  "current_connections": 10240
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/listeners.wss_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.ws_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.tcp_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.ssl_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.quic_required_bind"
                    }
                  ]
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_LISTENER_ID",
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Listener id not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update the specified listener on all nodes.",
        "tags": [
          "Listeners"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/listeners.listener_id"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "id": "tcp:demo",
                  "running": true,
                  "type": "tcp",
                  "bind": "0.0.0.0:1884",
                  "tcp_options": {
                    "buffer": "4KB",
                    "high_watermark": "1MB",
                    "nodelay": false,
                    "reuseaddr": true,
                    "send_timeout": "15s",
                    "send_timeout_close": true,
                    "backlog": 1024,
                    "active_n": 100
                  },
                  "max_connections": 204800,
                  "acceptors": 16,
                  "proxy_protocol": false,
                  "access_rules": [
                    "allow all"
                  ],
                  "proxy_protocol_timeout": "3s",
                  "zone": "default",
                  "mountpoint": "/",
                  "current_connections": 10240
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/listeners.wss_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.ws_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.tcp_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.ssl_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.quic_required_bind"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_LISTENER_ID",
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Listener id not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "example": {
                "id": "tcp:demo",
                "running": true,
                "type": "tcp",
                "bind": "0.0.0.0:1884",
                "tcp_options": {
                  "buffer": "4KB",
                  "high_watermark": "1MB",
                  "nodelay": false,
                  "reuseaddr": true,
                  "send_timeout": "15s",
                  "send_timeout_close": true,
                  "backlog": 1024,
                  "active_n": 100
                },
                "max_connections": 204800,
                "acceptors": 16,
                "proxy_protocol": false,
                "access_rules": [
                  "allow all"
                ],
                "proxy_protocol_timeout": "3s",
                "zone": "default",
                "mountpoint": "/",
                "current_connections": 10240
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/listeners.wss_not_required_bind"
                  },
                  {
                    "$ref": "#/components/schemas/listeners.ws_not_required_bind"
                  },
                  {
                    "$ref": "#/components/schemas/listeners.tcp_not_required_bind"
                  },
                  {
                    "$ref": "#/components/schemas/listeners.ssl_not_required_bind"
                  },
                  {
                    "$ref": "#/components/schemas/listeners.quic_not_required_bind"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete the specified listener on all nodes.",
        "tags": [
          "Listeners"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/listeners.listener_id"
          }
        ],
        "responses": {
          "204": {
            "description": "Listener deleted"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_LISTENER_ID"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/users/{username}/change_pwd": {
      "post": {
        "description": "Change dashboard user password",
        "tags": [
          "Dashboard"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "username",
            "description": "Dashboard Username",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "admin"
          }
        ],
        "responses": {
          "204": {
            "description": "Update user password successfully"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST",
                        "ERROR_PWD_NOT_MATCH"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Login failed. Bad username or password"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "USER_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Dashboard user not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "old_pwd": {
                    "type": "string",
                    "description": "Old password"
                  },
                  "new_pwd": {
                    "type": "string",
                    "description": "New password"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/{name}/clients": {
      "get": {
        "description": "Get the gateway client list",
        "tags": [
          "Gateway Clients"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "gbt32960",
                "jt808",
                "lwm2m",
                "mqttsn",
                "ocpp",
                "stomp"
              ]
            }
          },
          {
            "in": "query",
            "name": "node",
            "description": "Match the client's node name",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": ""
          },
          {
            "in": "query",
            "name": "clientid",
            "description": "Match the client's ID",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": ""
          },
          {
            "in": "query",
            "name": "username",
            "description": "Match the client's Username",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": ""
          },
          {
            "in": "query",
            "name": "ip_address",
            "description": "Match the client's ip address",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": ""
          },
          {
            "in": "query",
            "name": "conn_state",
            "description": "Match the client's connection state",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": ""
          },
          {
            "in": "query",
            "name": "proto_ver",
            "description": "Match the client's protocol version",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": ""
          },
          {
            "in": "query",
            "name": "clean_start",
            "description": "Match the client's clean start flag",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "example": ""
          },
          {
            "in": "query",
            "name": "like_clientid",
            "description": "Use sub-string to match client's ID",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": ""
          },
          {
            "in": "query",
            "name": "like_username",
            "description": "Use sub-string to match client's username",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": ""
          },
          {
            "in": "query",
            "name": "gte_created_at",
            "description": "Match the session created datetime greater than a certain value",
            "required": false,
            "schema": {
              "oneOf": [
                {
                  "type": "integer",
                  "description": "epoch-millisecond",
                  "example": 1640995200000
                },
                {
                  "type": "string",
                  "format": "date-time",
                  "example": "2022-01-01T00:00:00.000Z"
                }
              ]
            },
            "example": ""
          },
          {
            "in": "query",
            "name": "lte_created_at",
            "description": "Match the session created datetime less than a certain value",
            "required": false,
            "schema": {
              "oneOf": [
                {
                  "type": "integer",
                  "description": "epoch-millisecond",
                  "example": 1640995200000
                },
                {
                  "type": "string",
                  "format": "date-time",
                  "example": "2022-01-01T00:00:00.000Z"
                }
              ]
            },
            "example": ""
          },
          {
            "in": "query",
            "name": "gte_connected_at",
            "description": "Match the client socket connected datetime greater than a certain value",
            "required": false,
            "schema": {
              "oneOf": [
                {
                  "type": "integer",
                  "description": "epoch-millisecond",
                  "example": 1640995200000
                },
                {
                  "type": "string",
                  "format": "date-time",
                  "example": "2022-01-01T00:00:00.000Z"
                }
              ]
            },
            "example": ""
          },
          {
            "in": "query",
            "name": "lte_connected_at",
            "description": "Match the client socket connected datatime less than a certain value",
            "required": false,
            "schema": {
              "oneOf": [
                {
                  "type": "integer",
                  "description": "epoch-millisecond",
                  "example": 1640995200000
                },
                {
                  "type": "string",
                  "format": "date-time",
                  "example": "2022-01-01T00:00:00.000Z"
                }
              ]
            },
            "example": ""
          },
          {
            "in": "query",
            "name": "endpoint_name",
            "description": "Match the lwm2m client's endpoint name",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": ""
          },
          {
            "in": "query",
            "name": "like_endpoint_name",
            "description": "Use sub-string to match lwm2m client's endpoint name",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": ""
          },
          {
            "in": "query",
            "name": "gte_lifetime",
            "description": "Match the lwm2m client registered lifetime greater than a certain value",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": ""
          },
          {
            "in": "query",
            "name": "lte_lifetime",
            "description": "Match the lwm2m client registered lifetime less than a certain value",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": ""
          },
          {
            "in": "query",
            "name": "page",
            "description": "Page number of the results to fetch.",
            "schema": {
              "default": 1,
              "type": "integer",
              "minimum": 1
            },
            "example": 1
          },
          {
            "in": "query",
            "name": "limit",
            "description": "Results per page(max 10000)",
            "schema": {
              "default": 100,
              "maximum": 10000,
              "type": "integer",
              "minimum": 1
            },
            "example": 50
          }
        ],
        "summary": "List gateway's clients",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "data": {
                      "oneOf": [
                        {
                          "type": "array",
                          "items": {
                            "$ref": "#/components/schemas/emqx_gateway_api_clients.exproto_client"
                          }
                        },
                        {
                          "type": "array",
                          "items": {
                            "$ref": "#/components/schemas/emqx_gateway_api_clients.lwm2m_client"
                          }
                        },
                        {
                          "type": "array",
                          "items": {
                            "$ref": "#/components/schemas/emqx_gateway_api_clients.coap_client"
                          }
                        },
                        {
                          "type": "array",
                          "items": {
                            "$ref": "#/components/schemas/emqx_gateway_api_clients.mqttsn_client"
                          }
                        },
                        {
                          "type": "array",
                          "items": {
                            "$ref": "#/components/schemas/emqx_gateway_api_clients.stomp_client"
                          }
                        }
                      ]
                    },
                    "meta": {
                      "$ref": "#/components/schemas/public.meta"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/schema_validations/validation/{name}/enable/{enable}": {
      "post": {
        "description": "Enable or disable a particular validation",
        "tags": [
          "Schema Validation"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Validation name",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "my_validation"
          },
          {
            "in": "path",
            "name": "enable",
            "description": "Enable or disable validation",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "summary": "Enable or disable validation",
        "responses": {
          "204": {
            "description": "No content"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad params"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Validation not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/{name}/authentication/users/{uid}": {
      "get": {
        "description": "Get user info from the gateway authenticator (only supports built_in_database)",
        "tags": [
          "Gateway Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "gbt32960",
                "jt808",
                "lwm2m",
                "mqttsn",
                "ocpp",
                "stomp"
              ]
            },
            "example": "stomp"
          },
          {
            "in": "path",
            "name": "uid",
            "description": "User ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "test_username"
          }
        ],
        "summary": "Get user info for gateway authenticator",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "regular_user": {
                    "value": {
                      "user_id": "user1"
                    },
                    "summary": "Regular user"
                  },
                  "super_user": {
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    },
                    "summary": "Superuser"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update the user info for the gateway authenticator (only supports built_in_database)",
        "tags": [
          "Gateway Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "gbt32960",
                "jt808",
                "lwm2m",
                "mqttsn",
                "ocpp",
                "stomp"
              ]
            },
            "example": "stomp"
          },
          {
            "in": "path",
            "name": "uid",
            "description": "User ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "test_username"
          }
        ],
        "summary": "Update user info for gateway authenticator",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "regular_user": {
                    "value": {
                      "user_id": "user1"
                    },
                    "summary": "Regular user"
                  },
                  "super_user": {
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    },
                    "summary": "Superuser"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "regular_user": {
                  "value": {
                    "password": "******"
                  },
                  "summary": "Update regular user"
                },
                "super_user": {
                  "value": {
                    "password": "******",
                    "is_superuser": true
                  },
                  "summary": "Update user and promote to superuser"
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authn_api.request_user_update"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete the user for the gateway authenticator (only supports built_in_database)",
        "tags": [
          "Gateway Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "gbt32960",
                "jt808",
                "lwm2m",
                "mqttsn",
                "ocpp",
                "stomp"
              ]
            },
            "example": "stomp"
          },
          {
            "in": "path",
            "name": "uid",
            "description": "User ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "test_username"
          }
        ],
        "summary": "Delete user for gateway authenticator",
        "responses": {
          "204": {
            "description": "User Deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/{name}/listeners/{id}/authentication/import_users": {
      "post": {
        "description": "Import users into the gateway authenticator (only supports built_in_database)",
        "tags": [
          "Gateway Authentication"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "gbt32960",
                "jt808",
                "lwm2m",
                "mqttsn",
                "ocpp",
                "stomp"
              ]
            },
            "example": "stomp"
          },
          {
            "in": "path",
            "name": "id",
            "description": "Listener ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "stomp:tcp:def"
          }
        ],
        "summary": "Import users",
        "responses": {
          "204": {
            "description": "Imported"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "multipart/form-data": {
              "schema": {
                "type": "object",
                "properties": {
                  "filename": {
                    "type": "string",
                    "format": "binary"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/rules/{id}/metrics/reset": {
      "put": {
        "description": "Reset a rule metrics",
        "tags": [
          "Rules"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "my_rule_id"
          }
        ],
        "summary": "Reset rule metrics",
        "responses": {
          "204": {
            "description": "Reset Success"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Rule not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/{name}/listeners/{id}/authentication/users": {
      "get": {
        "description": "Get the users for the authenticator (only supported by <code>built_in_database</code>)",
        "tags": [
          "Gateway Listeners"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "gbt32960",
                "jt808",
                "lwm2m",
                "mqttsn",
                "ocpp",
                "stomp"
              ]
            },
            "example": "stomp"
          },
          {
            "in": "path",
            "name": "id",
            "description": "Listener ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": ""
          },
          {
            "in": "query",
            "name": "page",
            "description": "Page number of the results to fetch.",
            "schema": {
              "default": 1,
              "type": "integer",
              "minimum": 1
            },
            "example": 1
          },
          {
            "in": "query",
            "name": "limit",
            "description": "Results per page(max 10000)",
            "schema": {
              "default": 100,
              "maximum": 10000,
              "type": "integer",
              "minimum": 1
            },
            "example": 50
          }
        ],
        "summary": "List authenticator's users",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "regular_user": {
                    "value": {
                      "user_id": "user1"
                    },
                    "summary": "Regular user"
                  },
                  "super_user": {
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    },
                    "summary": "Superuser"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Add user for the authenticator (only supports built_in_database)",
        "tags": [
          "Gateway Listeners"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Gateway Name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "coap",
                "exproto",
                "gbt32960",
                "jt808",
                "lwm2m",
                "mqttsn",
                "ocpp",
                "stomp"
              ]
            },
            "example": "stomp"
          },
          {
            "in": "path",
            "name": "id",
            "description": "Listener ID",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": ""
          }
        ],
        "summary": "Add user for an authenticator",
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "regular_user": {
                    "value": {
                      "user_id": "user1"
                    },
                    "summary": "Regular user"
                  },
                  "super_user": {
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    },
                    "summary": "Superuser"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Not Found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "regular_user": {
                  "value": {
                    "password": "******",
                    "user_id": "user1"
                  },
                  "summary": "Regular user"
                },
                "super_user": {
                  "value": {
                    "password": "******",
                    "is_superuser": true,
                    "user_id": "user2"
                  },
                  "summary": "Superuser"
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authn_api.request_user_create"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/license": {
      "get": {
        "description": "Get license info",
        "tags": [
          "License"
        ],
        "parameters": [],
        "summary": "Get license info",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "sample_license_info": {
                    "value": {
                      "type": "trial",
                      "max_connections": 10,
                      "email": "contact@foo.com",
                      "start_at": "2022-01-11",
                      "expiry": false,
                      "customer_type": 10,
                      "deployment": "bar-deployment",
                      "customer": "Foo",
                      "expiry_at": "2295-10-27"
                    }
                  }
                },
                "schema": {
                  "type": "object",
                  "example": {}
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Update a license key",
        "tags": [
          "License"
        ],
        "parameters": [],
        "summary": "Update license key",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "sample_license_info": {
                    "value": {
                      "type": "trial",
                      "max_connections": 10,
                      "email": "contact@foo.com",
                      "start_at": "2022-01-11",
                      "expiry": false,
                      "customer_type": 10,
                      "deployment": "bar-deployment",
                      "customer": "Foo",
                      "expiry_at": "2295-10-27"
                    }
                  }
                },
                "schema": {
                  "type": "object",
                  "example": {}
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad license key"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "license_key": {
                  "value": {
                    "key": "xxx"
                  },
                  "summary": "License key string"
                }
              },
              "schema": {
                "$ref": "#/components/schemas/license_http_api.key_license"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/schemas/{name}": {
      "get": {
        "description": "Get the schema JSON of the specified name. NOTE: only intended for EMQX Dashboard.",
        "tags": [
          "Dashboard"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "hotconf",
                "bridges",
                "actions",
                "connectors"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The JSON schema of the specified name.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          }
        },
        "security": []
      }
    },
    "/authorization/settings": {
      "get": {
        "description": "Get authorization settings",
        "tags": [
          "Authorization"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "deny_action",
                    "no_match"
                  ],
                  "properties": {
                    "no_match": {
                      "default": "allow",
                      "type": "string",
                      "enum": [
                        "allow",
                        "deny"
                      ],
                      "description": "Default access control action if the user or client matches no ACL rules,<br/>or if no such user or client is found by the configurable authorization<br/>sources such as built_in_database, an HTTP API, or a query against PostgreSQL.<br/>Find more details in 'authorization.sources' config."
                    },
                    "deny_action": {
                      "default": "ignore",
                      "type": "string",
                      "enum": [
                        "ignore",
                        "disconnect"
                      ],
                      "description": "The action when the authorization check rejects an operation."
                    },
                    "cache": {
                      "$ref": "#/components/schemas/emqx.authz_cache"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update authorization settings",
        "tags": [
          "Authorization"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "deny_action",
                    "no_match"
                  ],
                  "properties": {
                    "no_match": {
                      "default": "allow",
                      "type": "string",
                      "enum": [
                        "allow",
                        "deny"
                      ],
                      "description": "Default access control action if the user or client matches no ACL rules,<br/>or if no such user or client is found by the configurable authorization<br/>sources such as built_in_database, an HTTP API, or a query against PostgreSQL.<br/>Find more details in 'authorization.sources' config."
                    },
                    "deny_action": {
                      "default": "ignore",
                      "type": "string",
                      "enum": [
                        "ignore",
                        "disconnect"
                      ],
                      "description": "The action when the authorization check rejects an operation."
                    },
                    "cache": {
                      "$ref": "#/components/schemas/emqx.authz_cache"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "required": [
                  "deny_action",
                  "no_match"
                ],
                "properties": {
                  "no_match": {
                    "default": "allow",
                    "type": "string",
                    "enum": [
                      "allow",
                      "deny"
                    ],
                    "description": "Default access control action if the user or client matches no ACL rules,<br/>or if no such user or client is found by the configurable authorization<br/>sources such as built_in_database, an HTTP API, or a query against PostgreSQL.<br/>Find more details in 'authorization.sources' config."
                  },
                  "deny_action": {
                    "default": "ignore",
                    "type": "string",
                    "enum": [
                      "ignore",
                      "disconnect"
                    ],
                    "description": "The action when the authorization check rejects an operation."
                  },
                  "cache": {
                    "$ref": "#/components/schemas/emqx.authz_cache"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/gateways/lwm2m/clients/{clientid}/write": {
      "post": {
        "description": "Send a write command to a resource",
        "tags": [
          "LwM2M Gateways"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "urn:oma:lwm2m:oma:2"
          },
          {
            "in": "query",
            "name": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "/3/0/7"
          },
          {
            "in": "query",
            "name": "type",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "Integer",
                "Float",
                "Time",
                "String",
                "Boolean",
                "Opaque",
                "Objlnk"
              ]
            },
            "example": "Integer"
          },
          {
            "in": "query",
            "name": "value",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": 123
          }
        ],
        "summary": "Write a Value to Resource Path",
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "CLIENT_NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Clientid not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/configs/log": {
      "get": {
        "description": "Get the sub-configurations under *log*",
        "tags": [
          "Configs"
        ],
        "parameters": [],
        "summary": "Get the sub-configurations under *log*",
        "responses": {
          "200": {
            "description": "EMQX provides support for two primary log handlers: `file` and `console`, with an additional `audit` handler specifically designed to always direct logs to files.<br/>The system's default log handling behavior can be configured via the environment variable `EMQX_DEFAULT_LOG_HANDLER`, which accepts the following settings:<br/><br/>- `file`: Directs log output exclusively to files.<br/>- `console`: Channels log output solely to the console.<br/><br/>It's noteworthy that `EMQX_DEFAULT_LOG_HANDLER` is set to `file` when EMQX is initiated via systemd's `emqx.service` file.<br/>In scenarios outside systemd initiation, `console` serves as the default log handler.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx.log"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "config not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update the sub-configurations under *log*",
        "tags": [
          "Configs"
        ],
        "parameters": [],
        "summary": "Update the sub-configurations under *log*",
        "responses": {
          "200": {
            "description": "EMQX provides support for two primary log handlers: `file` and `console`, with an additional `audit` handler specifically designed to always direct logs to files.<br/>The system's default log handling behavior can be configured via the environment variable `EMQX_DEFAULT_LOG_HANDLER`, which accepts the following settings:<br/><br/>- `file`: Directs log output exclusively to files.<br/>- `console`: Channels log output solely to the console.<br/><br/>It's noteworthy that `EMQX_DEFAULT_LOG_HANDLER` is set to `file` when EMQX is initiated via systemd's `emqx.service` file.<br/>In scenarios outside systemd initiation, `console` serves as the default log handler.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx.log"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UPDATE_FAILED",
                        "INVALID_CONFIG"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "403": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "UPDATE_FAILED"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Error code to troubleshoot problems."
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx.log"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/rules/{id}": {
      "get": {
        "description": "Get a rule by given Id",
        "tags": [
          "Rules"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "my_rule_id"
          }
        ],
        "summary": "Get rule",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/rule_engine.rule_info"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Rule not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update a rule by given Id to all nodes in the cluster",
        "tags": [
          "Rules"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "my_rule_id"
          }
        ],
        "summary": "Update rule",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/rule_engine.rule_info"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Invalid Parameters"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/rule_engine.rule_creation"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete a rule by given Id from all nodes in the cluster",
        "tags": [
          "Rules"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "my_rule_id"
          }
        ],
        "summary": "Delete rule",
        "responses": {
          "204": {
            "description": "Delete rule successfully"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Rule not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/exhooks/{name}/hooks": {
      "get": {
        "description": "Get the hooks information of server",
        "tags": [
          "ExHook"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "The Exhook server name",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "default"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/exhook.list_hook_info"
                  }
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad Request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/bridges": {
      "get": {
        "description": "List all created bridges",
        "tags": [
          "Bridges"
        ],
        "parameters": [],
        "summary": "List bridges",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": [
                  {
                    "name": "demo",
                    "type": "influxdb_api_v2",
                    "ssl": {
                      "enable": false
                    },
                    "server": "127.0.0.1:8086",
                    "enable": true,
                    "precision": "ms",
                    "org": "examlpe_org",
                    "token": "example_token",
                    "bucket": "example_bucket",
                    "resource_opts": {
                      "batch_size": 100,
                      "batch_time": "20ms"
                    },
                    "local_topic": "local/topic/#",
                    "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,uint_value=${payload.uint_key}u,bool=${payload.bool}",
                    "influxdb_type": "influxdb_api_v2"
                  },
                  {
                    "name": "My IoTDB Bridge",
                    "type": "iotdb",
                    "ssl": {
                      "enable": false
                    },
                    "authentication": {
                      "password": "*****",
                      "username": "root"
                    },
                    "connect_timeout": "15s",
                    "pool_size": 8,
                    "enable": true,
                    "base_url": "http://iotdb.local:18080/",
                    "pool_type": "random",
                    "resource_opts": {
                      "worker_pool_size": 8,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "health_check_interval": "15s"
                    },
                    "enable_pipelining": 100,
                    "iotdb_version": "v1.1.x",
                    "device_id": "my_device",
                    "is_aligned": false
                  },
                  {
                    "name": "my_azure_event_hub_producer",
                    "status": "connected",
                    "type": "azure_event_hub_producer",
                    "authentication": {
                      "password": "******"
                    },
                    "connect_timeout": "5s",
                    "enable": true,
                    "parameters": {
                      "message": {
                        "value": "${.}",
                        "key": "${.clientid}"
                      },
                      "buffer": {
                        "mode": "hybrid",
                        "memory_overload_protection": true,
                        "segment_bytes": "100MB",
                        "per_partition_limit": "2GB"
                      },
                      "topic": "topic",
                      "max_inflight": 10,
                      "required_acks": "all_isr",
                      "max_batch_bytes": "896KB",
                      "partition_count_refresh_interval": "60s",
                      "kafka_header_value_encode_mode": "none",
                      "kafka_ext_headers": [
                        {
                          "kafka_ext_header_value": "${clientid}",
                          "kafka_ext_header_key": "clientid"
                        },
                        {
                          "kafka_ext_header_value": "${topic}",
                          "kafka_ext_header_key": "topic"
                        }
                      ],
                      "kafka_headers": "${.pub_props}",
                      "partition_strategy": "random"
                    },
                    "socket_opts": {
                      "nodelay": true,
                      "recbuf": "1024KB",
                      "sndbuf": "1024KB",
                      "tcp_keepalive": "none"
                    },
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "local_topic": "mqtt/local/topic",
                    "min_metadata_refresh_interval": "3s",
                    "bootstrap_hosts": "namespace.servicebus.windows.net:9093",
                    "metadata_request_timeout": "4s"
                  },
                  {
                    "name": "my_kafka_producer_action",
                    "status": "connected",
                    "type": "kafka_producer",
                    "authentication": {
                      "mechanism": "plain",
                      "password": "******",
                      "username": "username"
                    },
                    "connect_timeout": "5s",
                    "enable": true,
                    "socket_opts": {
                      "nodelay": true,
                      "recbuf": "1024KB",
                      "sndbuf": "1024KB",
                      "tcp_keepalive": "none"
                    },
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "local_topic": "mqtt/local/topic",
                    "kafka": {
                      "message": {
                        "timestamp": "${.timestamp}",
                        "value": "${.}",
                        "key": "${.clientid}"
                      },
                      "buffer": {
                        "mode": "hybrid",
                        "memory_overload_protection": true,
                        "segment_bytes": "100MB",
                        "per_partition_limit": "2GB"
                      },
                      "compression": "no_compression",
                      "topic": "kafka-topic",
                      "max_inflight": 10,
                      "required_acks": "all_isr",
                      "max_batch_bytes": "896KB",
                      "partitions_limit": "all_partitions",
                      "partition_count_refresh_interval": "60s",
                      "kafka_header_value_encode_mode": "none",
                      "kafka_ext_headers": [
                        {
                          "kafka_ext_header_value": "${clientid}",
                          "kafka_ext_header_key": "clientid"
                        },
                        {
                          "kafka_ext_header_value": "${topic}",
                          "kafka_ext_header_key": "topic"
                        }
                      ],
                      "kafka_headers": "${pub_props}",
                      "partition_strategy": "random"
                    },
                    "min_metadata_refresh_interval": "3s",
                    "bootstrap_hosts": "localhost:9092",
                    "metadata_request_timeout": "4s"
                  },
                  {
                    "name": "redis_bridge",
                    "type": "redis_sentinel",
                    "ssl": {
                      "enable": false
                    },
                    "pool_size": 8,
                    "enable": true,
                    "password": "******",
                    "database": 1,
                    "servers": [
                      "127.0.0.1:26379"
                    ],
                    "resource_opts": {
                      "batch_size": 1,
                      "batch_time": "20ms"
                    },
                    "sentinel": "mymaster",
                    "redis_type": "sentinel",
                    "local_topic": "local/topic/#",
                    "command_template": [
                      "LPUSH",
                      "MSGS",
                      "${payload}"
                    ]
                  },
                  {
                    "authentication": "none",
                    "batch_size": 1,
                    "buffer": {
                      "memory_overload_protection": true,
                      "mode": "memory",
                      "per_partition_limit": "10MB",
                      "segment_bytes": "5MB"
                    },
                    "compression": "no_compression",
                    "enable": true,
                    "local_topic": "mqtt/topic/-576460752303423482",
                    "max_batch_bytes": "900KB",
                    "message": {
                      "key": "${.clientid}",
                      "value": "${.}"
                    },
                    "name": "pulsar_example_name",
                    "pulsar_topic": "pulsar_example_topic",
                    "retention_period": "infinity",
                    "send_buffer": "1MB",
                    "servers": "pulsar://127.0.0.1:6650",
                    "ssl": {
                      "enable": false,
                      "server_name_indication": "auto",
                      "verify": "verify_none"
                    },
                    "strategy": "key_dispatch",
                    "sync_timeout": "5s",
                    "type": "pulsar_producer"
                  },
                  {
                    "name": "foo",
                    "status": "connected",
                    "type": "pgsql",
                    "pool_size": 8,
                    "server": "127.0.0.1:5432",
                    "enable": true,
                    "password": "******",
                    "username": "root",
                    "database": "mqtt",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 8,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#"
                  },
                  {
                    "name": "redis_bridge",
                    "type": "redis_cluster",
                    "ssl": {
                      "enable": false
                    },
                    "pool_size": 8,
                    "enable": true,
                    "password": "******",
                    "servers": [
                      "127.0.0.1:6379"
                    ],
                    "resource_opts": {},
                    "redis_type": "cluster",
                    "local_topic": "local/topic/#",
                    "command_template": [
                      "LPUSH",
                      "MSGS",
                      "${payload}"
                    ]
                  },
                  {
                    "name": "foo",
                    "type": "mysql",
                    "pool_size": 8,
                    "server": "127.0.0.1:3306",
                    "enable": true,
                    "password": "******",
                    "username": "root",
                    "database": "test",
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, FROM_UNIXTIME(${timestamp}/1000))",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 1,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#"
                  },
                  {
                    "name": "foo",
                    "type": "kinesis_producer",
                    "enable": true,
                    "max_retries": 3,
                    "aws_secret_access_key": "******",
                    "resource_opts": {
                      "worker_pool_size": 1,
                      "query_mode": "async",
                      "max_buffer_bytes": 104857600,
                      "inflight_window": 100,
                      "health_check_interval": 15000
                    },
                    "endpoint": "https://kinesis.us-east-1.amazonaws.com",
                    "partition_key": "key",
                    "aws_access_key_id": "aws_access_key_id",
                    "stream_name": "stream_name"
                  },
                  {
                    "name": "http_example",
                    "type": "http",
                    "ssl": {
                      "enable": false
                    },
                    "connect_timeout": "15s",
                    "pool_size": 4,
                    "enable": true,
                    "body": "${payload}",
                    "url": "http://localhost:9901/messages/${topic}",
                    "method": "post",
                    "max_retries": 3,
                    "request_timeout": "15s",
                    "pool_type": "random",
                    "resource_opts": {
                      "worker_pool_size": 1,
                      "query_mode": "async",
                      "max_buffer_bytes": 104857600,
                      "inflight_window": 100,
                      "health_check_interval": 15000
                    },
                    "enable_pipelining": 100,
                    "local_topic": "emqx_http/#"
                  },
                  {
                    "timeout": 5,
                    "name": "foo",
                    "port": 5672,
                    "type": "rabbitmq",
                    "exchange": "messages",
                    "pool_size": 8,
                    "server": "localhost",
                    "enable": true,
                    "password": "******",
                    "username": "guest",
                    "heartbeat": "30s",
                    "durable": false,
                    "auto_reconnect": "2s",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 8,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "payload_template": "",
                    "routing_key": "my_routing_key",
                    "virtual_host": "/",
                    "exchange_type": "topic"
                  },
                  {
                    "name": "foo",
                    "table": "mqtt",
                    "type": "dynamo",
                    "pool_size": 8,
                    "template": "",
                    "enable": true,
                    "url": "http://127.0.0.1:8000",
                    "aws_secret_access_key": "******",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 8,
                      "query_mode": "sync",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#",
                    "aws_access_key_id": "root"
                  },
                  {
                    "name": "foo",
                    "type": "tdengine",
                    "pool_size": 8,
                    "server": "127.0.0.1:6041",
                    "enable": true,
                    "password": "******",
                    "username": "root",
                    "database": "mqtt",
                    "sql": "insert into t_mqtt_msg(ts, msgid, mqtt_topic, qos, payload, arrived) values (${ts}, '${id}', '${topic}', ${qos}, '${payload}', ${timestamp})",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 8,
                      "query_mode": "sync",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#"
                  },
                  {
                    "name": "mongodb_single_demo",
                    "type": "mongodb_single",
                    "pool_size": 8,
                    "server": "localhost:27017",
                    "enable": true,
                    "password": "******",
                    "username": "myuser",
                    "database": "mqtt",
                    "collection": "mycol",
                    "w_mode": "safe",
                    "srv_record": false,
                    "mongo_type": "single"
                  },
                  {
                    "name": "demo",
                    "type": "greptimedb",
                    "ssl": {
                      "enable": false
                    },
                    "server": "127.0.0.1:4001",
                    "enable": true,
                    "precision": "ms",
                    "password": "******",
                    "username": "example_username",
                    "resource_opts": {
                      "batch_size": 100,
                      "batch_time": "20ms"
                    },
                    "local_topic": "local/topic/#",
                    "dbname": "example_db",
                    "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,uint_value=${payload.uint_key}u,bool=${payload.bool}"
                  },
                  {
                    "name": "foo",
                    "type": "opents",
                    "pool_size": 8,
                    "server": "http://127.0.0.1:4242",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 1,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "enabledb": true
                  },
                  {
                    "name": "mongodb_sharded_demo",
                    "type": "mongodb_sharded",
                    "pool_size": 8,
                    "enable": true,
                    "password": "******",
                    "username": "myuser",
                    "database": "mqtt",
                    "servers": "localhost:27017, localhost:27018",
                    "collection": "mycol",
                    "w_mode": "safe",
                    "srv_record": false,
                    "mongo_type": "sharded"
                  },
                  {
                    "name": "mongodb_rs_demo",
                    "type": "mongodb_rs",
                    "pool_size": 8,
                    "enable": true,
                    "password": "******",
                    "username": "myuser",
                    "database": "mqtt",
                    "servers": "localhost:27017, localhost:27018",
                    "collection": "mycol",
                    "r_mode": "safe",
                    "w_mode": "safe",
                    "replica_set_name": "rs",
                    "srv_record": false,
                    "mongo_type": "rs"
                  },
                  {
                    "name": "foo",
                    "type": "oracle",
                    "pool_size": 8,
                    "server": "127.0.0.1:1521",
                    "enable": true,
                    "password": "******",
                    "username": "root",
                    "service_name": "ORCL",
                    "sql": "insert into t_mqtt_msgs(msgid, topic, qos, payload) values (${id}, ${topic}, ${qos}, ${payload})",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 8,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#",
                    "sid": "ORCL"
                  },
                  {
                    "name": "demo",
                    "stream": "stream",
                    "type": "hstreamdb",
                    "ssl": {
                      "enable": false
                    },
                    "pool_size": 8,
                    "direction": "egress",
                    "url": "http://127.0.0.1:6570",
                    "resource_opts": {
                      "batch_size": 100,
                      "query_mode": "sync",
                      "batch_time": "20ms"
                    },
                    "record_template": "{ \"temperature\": ${payload.temperature}, \"humidity\": ${payload.humidity} }"
                  },
                  {
                    "name": "demo",
                    "type": "influxdb_api_v1",
                    "ssl": {
                      "enable": false
                    },
                    "server": "127.0.0.1:8086",
                    "enable": true,
                    "precision": "ms",
                    "password": "******",
                    "username": "example_username",
                    "database": "example_database",
                    "resource_opts": {
                      "batch_size": 100,
                      "batch_time": "20ms"
                    },
                    "local_topic": "local/topic/#",
                    "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,bool=${payload.bool}",
                    "influxdb_type": "influxdb_api_v1"
                  },
                  {
                    "service_account_json": {
                      "type": "service_account",
                      "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQI...",
                      "client_id": "123812831923812319190",
                      "project_id": "myproject",
                      "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                      "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                      "client_email": "test@myproject.iam.gserviceaccount.com",
                      "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/test%40myproject.iam.gserviceaccount.com",
                      "private_key_id": "kid",
                      "token_uri": "https://oauth2.googleapis.com/token"
                    },
                    "pubsub_topic": "mytopic"
                  },
                  {
                    "name": "redis_bridge",
                    "type": "redis_single",
                    "ssl": {
                      "enable": false
                    },
                    "pool_size": 8,
                    "server": "127.0.0.1:6379",
                    "enable": true,
                    "password": "******",
                    "database": 1,
                    "resource_opts": {
                      "batch_size": 1,
                      "batch_time": "20ms"
                    },
                    "redis_type": "single",
                    "local_topic": "local/topic/#",
                    "command_template": [
                      "LPUSH",
                      "MSGS",
                      "${payload}"
                    ]
                  },
                  {
                    "name": "mqtt_example",
                    "type": "mqtt",
                    "keepalive": "300s",
                    "ssl": {
                      "enable": false
                    },
                    "server": "127.0.0.1:1883",
                    "enable": true,
                    "password": "******",
                    "username": "foo",
                    "proto_ver": "v4",
                    "clean_start": true,
                    "retry_interval": "15s",
                    "max_inflight": 100,
                    "resource_opts": {
                      "query_mode": "sync",
                      "max_buffer_bytes": 104857600,
                      "health_check_interval": "15s"
                    },
                    "ingress": {
                      "local": {
                        "retain": "${retain}",
                        "payload": "${payload}",
                        "topic": "from_aws/${topic}",
                        "qos": "${qos}"
                      },
                      "remote": {
                        "topic": "aws/#",
                        "qos": 1
                      }
                    },
                    "egress": {
                      "local": {
                        "topic": "emqx/#"
                      },
                      "remote": {
                        "retain": false,
                        "payload": "${payload}",
                        "topic": "from_emqx/${topic}",
                        "qos": "${qos}"
                      }
                    }
                  },
                  {
                    "name": "foo",
                    "type": "cassandra",
                    "pool_size": 8,
                    "enable": true,
                    "password": "******",
                    "username": "root",
                    "cql": "insert into mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic},  ${qos}, ${payload}, ${timestamp})",
                    "servers": "127.0.0.1:9042",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 8,
                      "query_mode": "sync",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#",
                    "keyspace": "mqtt"
                  },
                  {
                    "connect_timeout": "15s",
                    "consumer": {
                      "topic_mapping": [
                        {
                          "qos": 1,
                          "mqtt_topic": "mqtt/topic/1",
                          "payload_template": "${.}",
                          "pubsub_topic": "pubsub-topic-1"
                        },
                        {
                          "qos": 2,
                          "mqtt_topic": "mqtt/topic/2",
                          "payload_template": "v = ${.value}, a = ${.attributes}, o = ${.ordering_key}",
                          "pubsub_topic": "pubsub-topic-2"
                        }
                      ],
                      "pull_max_messages": 100
                    },
                    "resource_opts": {
                      "request_ttl": "20s"
                    },
                    "service_account_json": {
                      "type": "service_account",
                      "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQI...",
                      "client_id": "123812831923812319190",
                      "project_id": "myproject",
                      "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                      "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                      "client_email": "test@myproject.iam.gserviceaccount.com",
                      "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/test%40myproject.iam.gserviceaccount.com",
                      "private_key_id": "kid",
                      "token_uri": "https://oauth2.googleapis.com/token"
                    }
                  },
                  {
                    "name": "foo",
                    "type": "clickhouse",
                    "pool_size": 8,
                    "server": "127.0.0.1:8123",
                    "enable": true,
                    "password": "******",
                    "username": "default",
                    "database": "mqtt",
                    "sql": "INSERT INTO messages(data, arrived) VALUES ('${payload}', ${timestamp})",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 8,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#",
                    "batch_value_separator": ", "
                  },
                  {
                    "driver": "ms-sql",
                    "name": "bar",
                    "type": "sqlserver",
                    "pool_size": 8,
                    "server": "127.0.0.1:1433",
                    "enable": true,
                    "password": "******",
                    "username": "sa",
                    "database": "test",
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload) values ( ${id}, ${topic}, ${qos}, ${payload} )",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 1,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#"
                  },
                  {
                    "name": "foo",
                    "status": "connected",
                    "type": "matrix",
                    "pool_size": 8,
                    "server": "127.0.0.1:5432",
                    "enable": true,
                    "password": "******",
                    "username": "root",
                    "database": "mqtt",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 8,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#"
                  },
                  {
                    "name": "my_kafka_producer_action",
                    "status": "connected",
                    "type": "kafka_producer",
                    "authentication": {
                      "mechanism": "plain",
                      "password": "******",
                      "username": "username"
                    },
                    "connect_timeout": "5s",
                    "enable": true,
                    "socket_opts": {
                      "nodelay": true,
                      "recbuf": "1024KB",
                      "sndbuf": "1024KB",
                      "tcp_keepalive": "none"
                    },
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "kafka": {
                      "max_batch_bytes": "896KB",
                      "offset_reset_policy": "latest",
                      "offset_commit_interval_seconds": 5
                    },
                    "min_metadata_refresh_interval": "3s",
                    "topic_mapping": [
                      {
                        "qos": 1,
                        "mqtt_topic": "mqtt/topic/${.offset}",
                        "payload_template": "${.}",
                        "kafka_topic": "kafka-topic-1"
                      },
                      {
                        "qos": 2,
                        "mqtt_topic": "mqtt/topic/2",
                        "payload_template": "v = ${.value}",
                        "kafka_topic": "kafka-topic-2"
                      }
                    ],
                    "bootstrap_hosts": "localhost:9092",
                    "value_encoding_mode": "none",
                    "key_encoding_mode": "none",
                    "metadata_request_timeout": "4s"
                  },
                  {
                    "name": "foo",
                    "type": "rocketmq",
                    "server": "127.0.0.1:9876",
                    "template": "",
                    "enable": true,
                    "topic": "TopicTest",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 1,
                      "query_mode": "sync",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#"
                  },
                  {
                    "name": "foo",
                    "status": "connected",
                    "type": "timescale",
                    "pool_size": 8,
                    "server": "127.0.0.1:5432",
                    "enable": true,
                    "password": "******",
                    "username": "root",
                    "database": "mqtt",
                    "node_status": [
                      {
                        "node": "emqx@localhost",
                        "status": "connected"
                      }
                    ],
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 8,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#"
                  }
                ],
                "schema": {
                  "type": "array",
                  "items": {
                    "oneOf": [
                      {
                        "$ref": "#/components/schemas/bridge_kafka.get_producer"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_timescale.get"
                      },
                      {
                        "$ref": "#/components/schemas/rocketmq.get"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_kafka.get_consumer"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_matrix.get"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_sqlserver.get"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_clickhouse.get"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_gcp_pubsub.get_consumer"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_cassa.get"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_redis.get_single"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_gcp_pubsub.get_producer"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_influxdb.get_api_v1"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_hstreamdb.get"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_oracle.get"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_mongodb.get_rs"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_mongodb.get_sharded"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_opents.get"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_greptimedb.get_grpc_v1"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_mongodb.get_single"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_tdengine.get"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_dynamo.get"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_rabbitmq.get"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_mqtt.get"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_kinesis.get_producer"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_mysql.get"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_redis.get_cluster"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_pgsql.get"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_pulsar.get_producer"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_redis.get_sentinel"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_azure_event_hub.get_producer"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_http.get"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_iotdb.get"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_influxdb.get_api_v2"
                      }
                    ]
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Create a new bridge by type and name",
        "tags": [
          "Bridges"
        ],
        "parameters": [],
        "summary": "Create bridge",
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "influxdb_api_v2": {
                    "value": {
                      "name": "demo",
                      "type": "influxdb_api_v2",
                      "ssl": {
                        "enable": false
                      },
                      "server": "127.0.0.1:8086",
                      "enable": true,
                      "precision": "ms",
                      "org": "examlpe_org",
                      "token": "example_token",
                      "bucket": "example_bucket",
                      "resource_opts": {
                        "batch_size": 100,
                        "batch_time": "20ms"
                      },
                      "local_topic": "local/topic/#",
                      "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,uint_value=${payload.uint_key}u,bool=${payload.bool}",
                      "influxdb_type": "influxdb_api_v2"
                    },
                    "summary": "InfluxDB HTTP API V2 Bridge"
                  },
                  "iotdb": {
                    "value": {
                      "name": "My IoTDB Bridge",
                      "type": "iotdb",
                      "ssl": {
                        "enable": false
                      },
                      "authentication": {
                        "password": "*****",
                        "username": "root"
                      },
                      "connect_timeout": "15s",
                      "pool_size": 8,
                      "enable": true,
                      "base_url": "http://iotdb.local:18080/",
                      "pool_type": "random",
                      "resource_opts": {
                        "worker_pool_size": 8,
                        "query_mode": "async",
                        "max_buffer_bytes": 268435456,
                        "health_check_interval": "15s"
                      },
                      "enable_pipelining": 100,
                      "iotdb_version": "v1.1.x",
                      "device_id": "my_device",
                      "is_aligned": false
                    },
                    "summary": "Apache IoTDB Bridge"
                  },
                  "azure_event_hub_producer": {
                    "value": {
                      "name": "my_azure_event_hub_producer",
                      "status": "connected",
                      "type": "azure_event_hub_producer",
                      "authentication": {
                        "password": "******"
                      },
                      "connect_timeout": "5s",
                      "enable": true,
                      "parameters": {
                        "message": {
                          "value": "${.}",
                          "key": "${.clientid}"
                        },
                        "buffer": {
                          "mode": "hybrid",
                          "memory_overload_protection": true,
                          "segment_bytes": "100MB",
                          "per_partition_limit": "2GB"
                        },
                        "topic": "topic",
                        "max_inflight": 10,
                        "required_acks": "all_isr",
                        "max_batch_bytes": "896KB",
                        "partition_count_refresh_interval": "60s",
                        "kafka_header_value_encode_mode": "none",
                        "kafka_ext_headers": [
                          {
                            "kafka_ext_header_value": "${clientid}",
                            "kafka_ext_header_key": "clientid"
                          },
                          {
                            "kafka_ext_header_value": "${topic}",
                            "kafka_ext_header_key": "topic"
                          }
                        ],
                        "kafka_headers": "${.pub_props}",
                        "partition_strategy": "random"
                      },
                      "socket_opts": {
                        "nodelay": true,
                        "recbuf": "1024KB",
                        "sndbuf": "1024KB",
                        "tcp_keepalive": "none"
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "local_topic": "mqtt/local/topic",
                      "min_metadata_refresh_interval": "3s",
                      "bootstrap_hosts": "namespace.servicebus.windows.net:9093",
                      "metadata_request_timeout": "4s"
                    },
                    "summary": "Azure Event Hub Producer Bridge"
                  },
                  "kafka_producer": {
                    "value": {
                      "name": "my_kafka_producer_action",
                      "status": "connected",
                      "type": "kafka_producer",
                      "authentication": {
                        "mechanism": "plain",
                        "password": "******",
                        "username": "username"
                      },
                      "connect_timeout": "5s",
                      "enable": true,
                      "socket_opts": {
                        "nodelay": true,
                        "recbuf": "1024KB",
                        "sndbuf": "1024KB",
                        "tcp_keepalive": "none"
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "local_topic": "mqtt/local/topic",
                      "kafka": {
                        "message": {
                          "timestamp": "${.timestamp}",
                          "value": "${.}",
                          "key": "${.clientid}"
                        },
                        "buffer": {
                          "mode": "hybrid",
                          "memory_overload_protection": true,
                          "segment_bytes": "100MB",
                          "per_partition_limit": "2GB"
                        },
                        "compression": "no_compression",
                        "topic": "kafka-topic",
                        "max_inflight": 10,
                        "required_acks": "all_isr",
                        "max_batch_bytes": "896KB",
                        "partitions_limit": "all_partitions",
                        "partition_count_refresh_interval": "60s",
                        "kafka_header_value_encode_mode": "none",
                        "kafka_ext_headers": [
                          {
                            "kafka_ext_header_value": "${clientid}",
                            "kafka_ext_header_key": "clientid"
                          },
                          {
                            "kafka_ext_header_value": "${topic}",
                            "kafka_ext_header_key": "topic"
                          }
                        ],
                        "kafka_headers": "${pub_props}",
                        "partition_strategy": "random"
                      },
                      "min_metadata_refresh_interval": "3s",
                      "bootstrap_hosts": "localhost:9092",
                      "metadata_request_timeout": "4s"
                    },
                    "summary": "Kafka Producer Bridge"
                  },
                  "redis_sentinel": {
                    "value": {
                      "name": "redis_bridge",
                      "type": "redis_sentinel",
                      "ssl": {
                        "enable": false
                      },
                      "pool_size": 8,
                      "enable": true,
                      "password": "******",
                      "database": 1,
                      "servers": [
                        "127.0.0.1:26379"
                      ],
                      "resource_opts": {
                        "batch_size": 1,
                        "batch_time": "20ms"
                      },
                      "sentinel": "mymaster",
                      "redis_type": "sentinel",
                      "local_topic": "local/topic/#",
                      "command_template": [
                        "LPUSH",
                        "MSGS",
                        "${payload}"
                      ]
                    },
                    "summary": "Redis Sentinel Bridge"
                  },
                  "pulsar_producer": {
                    "value": {
                      "authentication": "none",
                      "batch_size": 1,
                      "buffer": {
                        "memory_overload_protection": true,
                        "mode": "memory",
                        "per_partition_limit": "10MB",
                        "segment_bytes": "5MB"
                      },
                      "compression": "no_compression",
                      "enable": true,
                      "local_topic": "mqtt/topic/-576460752303423482",
                      "max_batch_bytes": "900KB",
                      "message": {
                        "key": "${.clientid}",
                        "value": "${.}"
                      },
                      "name": "pulsar_example_name",
                      "pulsar_topic": "pulsar_example_topic",
                      "retention_period": "infinity",
                      "send_buffer": "1MB",
                      "servers": "pulsar://127.0.0.1:6650",
                      "ssl": {
                        "enable": false,
                        "server_name_indication": "auto",
                        "verify": "verify_none"
                      },
                      "strategy": "key_dispatch",
                      "sync_timeout": "5s",
                      "type": "pulsar_producer"
                    },
                    "summary": "Pulsar Producer Bridge"
                  },
                  "pgsql": {
                    "value": {
                      "name": "foo",
                      "status": "connected",
                      "type": "pgsql",
                      "pool_size": 8,
                      "server": "127.0.0.1:5432",
                      "enable": true,
                      "password": "******",
                      "username": "root",
                      "database": "mqtt",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 8,
                        "query_mode": "async",
                        "max_buffer_bytes": 268435456,
                        "batch_time": 0,
                        "health_check_interval": "15s"
                      },
                      "local_topic": "local/topic/#"
                    },
                    "summary": "PostgreSQL Bridge"
                  },
                  "redis_cluster": {
                    "value": {
                      "name": "redis_bridge",
                      "type": "redis_cluster",
                      "ssl": {
                        "enable": false
                      },
                      "pool_size": 8,
                      "enable": true,
                      "password": "******",
                      "servers": [
                        "127.0.0.1:6379"
                      ],
                      "resource_opts": {},
                      "redis_type": "cluster",
                      "local_topic": "local/topic/#",
                      "command_template": [
                        "LPUSH",
                        "MSGS",
                        "${payload}"
                      ]
                    },
                    "summary": "Redis Cluster Bridge"
                  },
                  "mysql": {
                    "value": {
                      "name": "foo",
                      "type": "mysql",
                      "pool_size": 8,
                      "server": "127.0.0.1:3306",
                      "enable": true,
                      "password": "******",
                      "username": "root",
                      "database": "test",
                      "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, FROM_UNIXTIME(${timestamp}/1000))",
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 1,
                        "query_mode": "async",
                        "max_buffer_bytes": 268435456,
                        "batch_time": 0,
                        "health_check_interval": "15s"
                      },
                      "local_topic": "local/topic/#"
                    },
                    "summary": "MySQL Bridge"
                  },
                  "kinesis_producer": {
                    "value": {
                      "name": "foo",
                      "type": "kinesis_producer",
                      "enable": true,
                      "max_retries": 3,
                      "aws_secret_access_key": "******",
                      "resource_opts": {
                        "worker_pool_size": 1,
                        "query_mode": "async",
                        "max_buffer_bytes": 104857600,
                        "inflight_window": 100,
                        "health_check_interval": 15000
                      },
                      "endpoint": "https://kinesis.us-east-1.amazonaws.com",
                      "partition_key": "key",
                      "aws_access_key_id": "aws_access_key_id",
                      "stream_name": "stream_name"
                    },
                    "summary": "Amazon Kinesis Producer Bridge"
                  },
                  "http_example": {
                    "value": {
                      "name": "http_example",
                      "type": "http",
                      "ssl": {
                        "enable": false
                      },
                      "connect_timeout": "15s",
                      "pool_size": 4,
                      "enable": true,
                      "body": "${payload}",
                      "url": "http://localhost:9901/messages/${topic}",
                      "method": "post",
                      "max_retries": 3,
                      "request_timeout": "15s",
                      "pool_type": "random",
                      "resource_opts": {
                        "worker_pool_size": 1,
                        "query_mode": "async",
                        "max_buffer_bytes": 104857600,
                        "inflight_window": 100,
                        "health_check_interval": 15000
                      },
                      "enable_pipelining": 100,
                      "local_topic": "emqx_http/#"
                    },
                    "summary": "HTTP"
                  },
                  "rabbitmq": {
                    "value": {
                      "timeout": 5,
                      "name": "foo",
                      "port": 5672,
                      "type": "rabbitmq",
                      "exchange": "messages",
                      "pool_size": 8,
                      "server": "localhost",
                      "enable": true,
                      "password": "******",
                      "username": "guest",
                      "heartbeat": "30s",
                      "durable": false,
                      "auto_reconnect": "2s",
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 8,
                        "query_mode": "async",
                        "max_buffer_bytes": 268435456,
                        "batch_time": 0,
                        "health_check_interval": "15s"
                      },
                      "payload_template": "",
                      "routing_key": "my_routing_key",
                      "virtual_host": "/",
                      "exchange_type": "topic"
                    },
                    "summary": "RabbitMQ Bridge"
                  },
                  "dynamo": {
                    "value": {
                      "name": "foo",
                      "table": "mqtt",
                      "type": "dynamo",
                      "pool_size": 8,
                      "template": "",
                      "enable": true,
                      "url": "http://127.0.0.1:8000",
                      "aws_secret_access_key": "******",
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 8,
                        "query_mode": "sync",
                        "max_buffer_bytes": 268435456,
                        "batch_time": 0,
                        "health_check_interval": "15s"
                      },
                      "local_topic": "local/topic/#",
                      "aws_access_key_id": "root"
                    },
                    "summary": "DynamoDB Bridge"
                  },
                  "tdengine": {
                    "value": {
                      "name": "foo",
                      "type": "tdengine",
                      "pool_size": 8,
                      "server": "127.0.0.1:6041",
                      "enable": true,
                      "password": "******",
                      "username": "root",
                      "database": "mqtt",
                      "sql": "insert into t_mqtt_msg(ts, msgid, mqtt_topic, qos, payload, arrived) values (${ts}, '${id}', '${topic}', ${qos}, '${payload}', ${timestamp})",
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 8,
                        "query_mode": "sync",
                        "max_buffer_bytes": 268435456,
                        "batch_time": 0,
                        "health_check_interval": "15s"
                      },
                      "local_topic": "local/topic/#"
                    },
                    "summary": "TDengine Bridge"
                  },
                  "mongodb_single": {
                    "value": {
                      "name": "mongodb_single_demo",
                      "type": "mongodb_single",
                      "pool_size": 8,
                      "server": "localhost:27017",
                      "enable": true,
                      "password": "******",
                      "username": "myuser",
                      "database": "mqtt",
                      "collection": "mycol",
                      "w_mode": "safe",
                      "srv_record": false,
                      "mongo_type": "single"
                    },
                    "summary": "MongoDB (Standalone) Bridge"
                  },
                  "greptimedb": {
                    "value": {
                      "name": "demo",
                      "type": "greptimedb",
                      "ssl": {
                        "enable": false
                      },
                      "server": "127.0.0.1:4001",
                      "enable": true,
                      "precision": "ms",
                      "password": "******",
                      "username": "example_username",
                      "resource_opts": {
                        "batch_size": 100,
                        "batch_time": "20ms"
                      },
                      "local_topic": "local/topic/#",
                      "dbname": "example_db",
                      "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,uint_value=${payload.uint_key}u,bool=${payload.bool}"
                    },
                    "summary": "Greptimedb HTTP API V2 Bridge"
                  },
                  "opents": {
                    "value": {
                      "name": "foo",
                      "type": "opents",
                      "pool_size": 8,
                      "server": "http://127.0.0.1:4242",
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 1,
                        "query_mode": "async",
                        "max_buffer_bytes": 268435456,
                        "batch_time": 0,
                        "health_check_interval": "15s"
                      },
                      "enabledb": true
                    },
                    "summary": "OpenTSDB Bridge"
                  },
                  "mongodb_sharded": {
                    "value": {
                      "name": "mongodb_sharded_demo",
                      "type": "mongodb_sharded",
                      "pool_size": 8,
                      "enable": true,
                      "password": "******",
                      "username": "myuser",
                      "database": "mqtt",
                      "servers": "localhost:27017, localhost:27018",
                      "collection": "mycol",
                      "w_mode": "safe",
                      "srv_record": false,
                      "mongo_type": "sharded"
                    },
                    "summary": "MongoDB (Sharded) Bridge"
                  },
                  "mongodb_rs": {
                    "value": {
                      "name": "mongodb_rs_demo",
                      "type": "mongodb_rs",
                      "pool_size": 8,
                      "enable": true,
                      "password": "******",
                      "username": "myuser",
                      "database": "mqtt",
                      "servers": "localhost:27017, localhost:27018",
                      "collection": "mycol",
                      "r_mode": "safe",
                      "w_mode": "safe",
                      "replica_set_name": "rs",
                      "srv_record": false,
                      "mongo_type": "rs"
                    },
                    "summary": "MongoDB (Replica Set) Bridge"
                  },
                  "oracle": {
                    "value": {
                      "name": "foo",
                      "type": "oracle",
                      "pool_size": 8,
                      "server": "127.0.0.1:1521",
                      "enable": true,
                      "password": "******",
                      "username": "root",
                      "service_name": "ORCL",
                      "sql": "insert into t_mqtt_msgs(msgid, topic, qos, payload) values (${id}, ${topic}, ${qos}, ${payload})",
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 8,
                        "query_mode": "async",
                        "max_buffer_bytes": 268435456,
                        "batch_time": 0,
                        "health_check_interval": "15s"
                      },
                      "local_topic": "local/topic/#",
                      "sid": "ORCL"
                    },
                    "summary": "Oracle Database Bridge"
                  },
                  "hstreamdb": {
                    "value": {
                      "name": "demo",
                      "stream": "stream",
                      "type": "hstreamdb",
                      "ssl": {
                        "enable": false
                      },
                      "pool_size": 8,
                      "direction": "egress",
                      "url": "http://127.0.0.1:6570",
                      "resource_opts": {
                        "batch_size": 100,
                        "query_mode": "sync",
                        "batch_time": "20ms"
                      },
                      "record_template": "{ \"temperature\": ${payload.temperature}, \"humidity\": ${payload.humidity} }"
                    },
                    "summary": "HStreamDB Bridge"
                  },
                  "influxdb_api_v1": {
                    "value": {
                      "name": "demo",
                      "type": "influxdb_api_v1",
                      "ssl": {
                        "enable": false
                      },
                      "server": "127.0.0.1:8086",
                      "enable": true,
                      "precision": "ms",
                      "password": "******",
                      "username": "example_username",
                      "database": "example_database",
                      "resource_opts": {
                        "batch_size": 100,
                        "batch_time": "20ms"
                      },
                      "local_topic": "local/topic/#",
                      "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,bool=${payload.bool}",
                      "influxdb_type": "influxdb_api_v1"
                    },
                    "summary": "InfluxDB HTTP API V1 Bridge"
                  },
                  "gcp_pubsub": {
                    "value": {
                      "service_account_json": {
                        "type": "service_account",
                        "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQI...",
                        "client_id": "123812831923812319190",
                        "project_id": "myproject",
                        "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                        "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                        "client_email": "test@myproject.iam.gserviceaccount.com",
                        "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/test%40myproject.iam.gserviceaccount.com",
                        "private_key_id": "kid",
                        "token_uri": "https://oauth2.googleapis.com/token"
                      },
                      "pubsub_topic": "mytopic"
                    },
                    "summary": "GCP PubSub Producer Bridge"
                  },
                  "redis_single": {
                    "value": {
                      "name": "redis_bridge",
                      "type": "redis_single",
                      "ssl": {
                        "enable": false
                      },
                      "pool_size": 8,
                      "server": "127.0.0.1:6379",
                      "enable": true,
                      "password": "******",
                      "database": 1,
                      "resource_opts": {
                        "batch_size": 1,
                        "batch_time": "20ms"
                      },
                      "redis_type": "single",
                      "local_topic": "local/topic/#",
                      "command_template": [
                        "LPUSH",
                        "MSGS",
                        "${payload}"
                      ]
                    },
                    "summary": "Redis Single Node Bridge"
                  },
                  "mqtt_example": {
                    "value": {
                      "name": "mqtt_example",
                      "type": "mqtt",
                      "keepalive": "300s",
                      "ssl": {
                        "enable": false
                      },
                      "server": "127.0.0.1:1883",
                      "enable": true,
                      "password": "******",
                      "username": "foo",
                      "proto_ver": "v4",
                      "clean_start": true,
                      "retry_interval": "15s",
                      "max_inflight": 100,
                      "resource_opts": {
                        "query_mode": "sync",
                        "max_buffer_bytes": 104857600,
                        "health_check_interval": "15s"
                      },
                      "ingress": {
                        "local": {
                          "retain": "${retain}",
                          "payload": "${payload}",
                          "topic": "from_aws/${topic}",
                          "qos": "${qos}"
                        },
                        "remote": {
                          "topic": "aws/#",
                          "qos": 1
                        }
                      },
                      "egress": {
                        "local": {
                          "topic": "emqx/#"
                        },
                        "remote": {
                          "retain": false,
                          "payload": "${payload}",
                          "topic": "from_emqx/${topic}",
                          "qos": "${qos}"
                        }
                      }
                    },
                    "summary": "MQTT Bridge"
                  },
                  "cassandra": {
                    "value": {
                      "name": "foo",
                      "type": "cassandra",
                      "pool_size": 8,
                      "enable": true,
                      "password": "******",
                      "username": "root",
                      "cql": "insert into mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic},  ${qos}, ${payload}, ${timestamp})",
                      "servers": "127.0.0.1:9042",
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 8,
                        "query_mode": "sync",
                        "max_buffer_bytes": 268435456,
                        "batch_time": 0,
                        "health_check_interval": "15s"
                      },
                      "local_topic": "local/topic/#",
                      "keyspace": "mqtt"
                    },
                    "summary": "Cassandra Bridge"
                  },
                  "gcp_pubsub_consumer": {
                    "value": {
                      "connect_timeout": "15s",
                      "consumer": {
                        "topic_mapping": [
                          {
                            "qos": 1,
                            "mqtt_topic": "mqtt/topic/1",
                            "payload_template": "${.}",
                            "pubsub_topic": "pubsub-topic-1"
                          },
                          {
                            "qos": 2,
                            "mqtt_topic": "mqtt/topic/2",
                            "payload_template": "v = ${.value}, a = ${.attributes}, o = ${.ordering_key}",
                            "pubsub_topic": "pubsub-topic-2"
                          }
                        ],
                        "pull_max_messages": 100
                      },
                      "resource_opts": {
                        "request_ttl": "20s"
                      },
                      "service_account_json": {
                        "type": "service_account",
                        "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQI...",
                        "client_id": "123812831923812319190",
                        "project_id": "myproject",
                        "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                        "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                        "client_email": "test@myproject.iam.gserviceaccount.com",
                        "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/test%40myproject.iam.gserviceaccount.com",
                        "private_key_id": "kid",
                        "token_uri": "https://oauth2.googleapis.com/token"
                      }
                    },
                    "summary": "GCP PubSub Consumer Bridge"
                  },
                  "clickhouse": {
                    "value": {
                      "name": "foo",
                      "type": "clickhouse",
                      "pool_size": 8,
                      "server": "127.0.0.1:8123",
                      "enable": true,
                      "password": "******",
                      "username": "default",
                      "database": "mqtt",
                      "sql": "INSERT INTO messages(data, arrived) VALUES ('${payload}', ${timestamp})",
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 8,
                        "query_mode": "async",
                        "max_buffer_bytes": 268435456,
                        "batch_time": 0,
                        "health_check_interval": "15s"
                      },
                      "local_topic": "local/topic/#",
                      "batch_value_separator": ", "
                    },
                    "summary": "Clickhouse Bridge"
                  },
                  "sqlserver": {
                    "value": {
                      "driver": "ms-sql",
                      "name": "bar",
                      "type": "sqlserver",
                      "pool_size": 8,
                      "server": "127.0.0.1:1433",
                      "enable": true,
                      "password": "******",
                      "username": "sa",
                      "database": "test",
                      "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload) values ( ${id}, ${topic}, ${qos}, ${payload} )",
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 1,
                        "query_mode": "async",
                        "max_buffer_bytes": 268435456,
                        "batch_time": 0,
                        "health_check_interval": "15s"
                      },
                      "local_topic": "local/topic/#"
                    },
                    "summary": "Microsoft SQL Server Bridge"
                  },
                  "matrix": {
                    "value": {
                      "name": "foo",
                      "status": "connected",
                      "type": "matrix",
                      "pool_size": 8,
                      "server": "127.0.0.1:5432",
                      "enable": true,
                      "password": "******",
                      "username": "root",
                      "database": "mqtt",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 8,
                        "query_mode": "async",
                        "max_buffer_bytes": 268435456,
                        "batch_time": 0,
                        "health_check_interval": "15s"
                      },
                      "local_topic": "local/topic/#"
                    },
                    "summary": "Matrix Bridge"
                  },
                  "kafka_consumer": {
                    "value": {
                      "name": "my_kafka_producer_action",
                      "status": "connected",
                      "type": "kafka_producer",
                      "authentication": {
                        "mechanism": "plain",
                        "password": "******",
                        "username": "username"
                      },
                      "connect_timeout": "5s",
                      "enable": true,
                      "socket_opts": {
                        "nodelay": true,
                        "recbuf": "1024KB",
                        "sndbuf": "1024KB",
                        "tcp_keepalive": "none"
                      },
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "kafka": {
                        "max_batch_bytes": "896KB",
                        "offset_reset_policy": "latest",
                        "offset_commit_interval_seconds": 5
                      },
                      "min_metadata_refresh_interval": "3s",
                      "topic_mapping": [
                        {
                          "qos": 1,
                          "mqtt_topic": "mqtt/topic/${.offset}",
                          "payload_template": "${.}",
                          "kafka_topic": "kafka-topic-1"
                        },
                        {
                          "qos": 2,
                          "mqtt_topic": "mqtt/topic/2",
                          "payload_template": "v = ${.value}",
                          "kafka_topic": "kafka-topic-2"
                        }
                      ],
                      "bootstrap_hosts": "localhost:9092",
                      "value_encoding_mode": "none",
                      "key_encoding_mode": "none",
                      "metadata_request_timeout": "4s"
                    },
                    "summary": "Kafka Consumer Bridge"
                  },
                  "rocketmq": {
                    "value": {
                      "name": "foo",
                      "type": "rocketmq",
                      "server": "127.0.0.1:9876",
                      "template": "",
                      "enable": true,
                      "topic": "TopicTest",
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 1,
                        "query_mode": "sync",
                        "max_buffer_bytes": 268435456,
                        "batch_time": 0,
                        "health_check_interval": "15s"
                      },
                      "local_topic": "local/topic/#"
                    },
                    "summary": "RocketMQ Bridge"
                  },
                  "timescale": {
                    "value": {
                      "name": "foo",
                      "status": "connected",
                      "type": "timescale",
                      "pool_size": 8,
                      "server": "127.0.0.1:5432",
                      "enable": true,
                      "password": "******",
                      "username": "root",
                      "database": "mqtt",
                      "node_status": [
                        {
                          "node": "emqx@localhost",
                          "status": "connected"
                        }
                      ],
                      "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                      "resource_opts": {
                        "batch_size": 1,
                        "worker_pool_size": 8,
                        "query_mode": "async",
                        "max_buffer_bytes": 268435456,
                        "batch_time": 0,
                        "health_check_interval": "15s"
                      },
                      "local_topic": "local/topic/#"
                    },
                    "summary": "Timescale Bridge"
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/bridge_kafka.get_producer"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_timescale.get"
                    },
                    {
                      "$ref": "#/components/schemas/rocketmq.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_kafka.get_consumer"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_matrix.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_sqlserver.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_clickhouse.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_gcp_pubsub.get_consumer"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_cassa.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_redis.get_single"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_gcp_pubsub.get_producer"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_influxdb.get_api_v1"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_hstreamdb.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_oracle.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mongodb.get_rs"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mongodb.get_sharded"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_opents.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_greptimedb.get_grpc_v1"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mongodb.get_single"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_tdengine.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_dynamo.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_rabbitmq.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mqtt.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_kinesis.get_producer"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mysql.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_redis.get_cluster"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_pgsql.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_pulsar.get_producer"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_redis.get_sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_azure_event_hub.get_producer"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_http.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_iotdb.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_influxdb.get_api_v2"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "ALREADY_EXISTS"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bridge already exists"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "influxdb_api_v2": {
                  "value": {
                    "name": "demo",
                    "type": "influxdb_api_v2",
                    "ssl": {
                      "enable": false
                    },
                    "server": "127.0.0.1:8086",
                    "enable": true,
                    "precision": "ms",
                    "org": "examlpe_org",
                    "token": "example_token",
                    "bucket": "example_bucket",
                    "resource_opts": {
                      "batch_size": 100,
                      "batch_time": "20ms"
                    },
                    "local_topic": "local/topic/#",
                    "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,uint_value=${payload.uint_key}u,bool=${payload.bool}",
                    "influxdb_type": "influxdb_api_v2"
                  },
                  "summary": "InfluxDB HTTP API V2 Bridge"
                },
                "iotdb": {
                  "value": {
                    "name": "My IoTDB Bridge",
                    "type": "iotdb",
                    "ssl": {
                      "enable": false
                    },
                    "authentication": {
                      "password": "*****",
                      "username": "root"
                    },
                    "connect_timeout": "15s",
                    "pool_size": 8,
                    "enable": true,
                    "base_url": "http://iotdb.local:18080/",
                    "pool_type": "random",
                    "resource_opts": {
                      "worker_pool_size": 8,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "health_check_interval": "15s"
                    },
                    "enable_pipelining": 100,
                    "iotdb_version": "v1.1.x",
                    "device_id": "my_device",
                    "is_aligned": false
                  },
                  "summary": "Apache IoTDB Bridge"
                },
                "azure_event_hub_producer": {
                  "value": {
                    "name": "my_azure_event_hub_producer",
                    "type": "azure_event_hub_producer",
                    "authentication": {
                      "password": "******"
                    },
                    "connect_timeout": "5s",
                    "enable": true,
                    "parameters": {
                      "message": {
                        "value": "${.}",
                        "key": "${.clientid}"
                      },
                      "buffer": {
                        "mode": "hybrid",
                        "memory_overload_protection": true,
                        "segment_bytes": "100MB",
                        "per_partition_limit": "2GB"
                      },
                      "topic": "topic",
                      "max_inflight": 10,
                      "required_acks": "all_isr",
                      "max_batch_bytes": "896KB",
                      "partition_count_refresh_interval": "60s",
                      "kafka_header_value_encode_mode": "none",
                      "kafka_ext_headers": [
                        {
                          "kafka_ext_header_value": "${clientid}",
                          "kafka_ext_header_key": "clientid"
                        },
                        {
                          "kafka_ext_header_value": "${topic}",
                          "kafka_ext_header_key": "topic"
                        }
                      ],
                      "kafka_headers": "${.pub_props}",
                      "partition_strategy": "random"
                    },
                    "socket_opts": {
                      "nodelay": true,
                      "recbuf": "1024KB",
                      "sndbuf": "1024KB",
                      "tcp_keepalive": "none"
                    },
                    "local_topic": "mqtt/local/topic",
                    "min_metadata_refresh_interval": "3s",
                    "bootstrap_hosts": "namespace.servicebus.windows.net:9093",
                    "metadata_request_timeout": "4s"
                  },
                  "summary": "Azure Event Hub Producer Bridge"
                },
                "kafka_producer": {
                  "value": {
                    "name": "my_kafka_producer_action",
                    "type": "kafka_producer",
                    "authentication": {
                      "mechanism": "plain",
                      "password": "******",
                      "username": "username"
                    },
                    "connect_timeout": "5s",
                    "enable": true,
                    "socket_opts": {
                      "nodelay": true,
                      "recbuf": "1024KB",
                      "sndbuf": "1024KB",
                      "tcp_keepalive": "none"
                    },
                    "local_topic": "mqtt/local/topic",
                    "kafka": {
                      "message": {
                        "timestamp": "${.timestamp}",
                        "value": "${.}",
                        "key": "${.clientid}"
                      },
                      "buffer": {
                        "mode": "hybrid",
                        "memory_overload_protection": true,
                        "segment_bytes": "100MB",
                        "per_partition_limit": "2GB"
                      },
                      "compression": "no_compression",
                      "topic": "kafka-topic",
                      "max_inflight": 10,
                      "required_acks": "all_isr",
                      "max_batch_bytes": "896KB",
                      "partitions_limit": "all_partitions",
                      "partition_count_refresh_interval": "60s",
                      "kafka_header_value_encode_mode": "none",
                      "kafka_ext_headers": [
                        {
                          "kafka_ext_header_value": "${clientid}",
                          "kafka_ext_header_key": "clientid"
                        },
                        {
                          "kafka_ext_header_value": "${topic}",
                          "kafka_ext_header_key": "topic"
                        }
                      ],
                      "kafka_headers": "${pub_props}",
                      "partition_strategy": "random"
                    },
                    "min_metadata_refresh_interval": "3s",
                    "bootstrap_hosts": "localhost:9092",
                    "metadata_request_timeout": "4s"
                  },
                  "summary": "Kafka Producer Bridge"
                },
                "redis_sentinel": {
                  "value": {
                    "name": "redis_bridge",
                    "type": "redis_sentinel",
                    "ssl": {
                      "enable": false
                    },
                    "pool_size": 8,
                    "enable": true,
                    "password": "******",
                    "database": 1,
                    "servers": [
                      "127.0.0.1:26379"
                    ],
                    "resource_opts": {
                      "batch_size": 1,
                      "batch_time": "20ms"
                    },
                    "sentinel": "mymaster",
                    "redis_type": "sentinel",
                    "local_topic": "local/topic/#",
                    "command_template": [
                      "LPUSH",
                      "MSGS",
                      "${payload}"
                    ]
                  },
                  "summary": "Redis Sentinel Bridge"
                },
                "pulsar_producer": {
                  "value": {
                    "authentication": "none",
                    "batch_size": 1,
                    "buffer": {
                      "memory_overload_protection": true,
                      "mode": "memory",
                      "per_partition_limit": "10MB",
                      "segment_bytes": "5MB"
                    },
                    "compression": "no_compression",
                    "enable": true,
                    "local_topic": "mqtt/topic/-576460752303423482",
                    "max_batch_bytes": "900KB",
                    "message": {
                      "key": "${.clientid}",
                      "value": "${.}"
                    },
                    "name": "pulsar_example_name",
                    "pulsar_topic": "pulsar_example_topic",
                    "retention_period": "infinity",
                    "send_buffer": "1MB",
                    "servers": "pulsar://127.0.0.1:6650",
                    "ssl": {
                      "enable": false,
                      "server_name_indication": "auto",
                      "verify": "verify_none"
                    },
                    "strategy": "key_dispatch",
                    "sync_timeout": "5s",
                    "type": "pulsar_producer"
                  },
                  "summary": "Pulsar Producer Bridge"
                },
                "pgsql": {
                  "value": {
                    "name": "foo",
                    "type": "pgsql",
                    "pool_size": 8,
                    "server": "127.0.0.1:5432",
                    "enable": true,
                    "password": "******",
                    "username": "root",
                    "database": "mqtt",
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 8,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#"
                  },
                  "summary": "PostgreSQL Bridge"
                },
                "redis_cluster": {
                  "value": {
                    "name": "redis_bridge",
                    "type": "redis_cluster",
                    "ssl": {
                      "enable": false
                    },
                    "pool_size": 8,
                    "enable": true,
                    "password": "******",
                    "servers": [
                      "127.0.0.1:6379"
                    ],
                    "resource_opts": {},
                    "redis_type": "cluster",
                    "local_topic": "local/topic/#",
                    "command_template": [
                      "LPUSH",
                      "MSGS",
                      "${payload}"
                    ]
                  },
                  "summary": "Redis Cluster Bridge"
                },
                "mysql": {
                  "value": {
                    "name": "foo",
                    "type": "mysql",
                    "pool_size": 8,
                    "server": "127.0.0.1:3306",
                    "enable": true,
                    "password": "******",
                    "username": "root",
                    "database": "test",
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, FROM_UNIXTIME(${timestamp}/1000))",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 1,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#"
                  },
                  "summary": "MySQL Bridge"
                },
                "kinesis_producer": {
                  "value": {
                    "name": "foo",
                    "type": "kinesis_producer",
                    "enable": true,
                    "max_retries": 3,
                    "aws_secret_access_key": "******",
                    "resource_opts": {
                      "worker_pool_size": 1,
                      "query_mode": "async",
                      "max_buffer_bytes": 104857600,
                      "inflight_window": 100,
                      "health_check_interval": 15000
                    },
                    "endpoint": "https://kinesis.us-east-1.amazonaws.com",
                    "partition_key": "key",
                    "aws_access_key_id": "aws_access_key_id",
                    "stream_name": "stream_name"
                  },
                  "summary": "Amazon Kinesis Producer Bridge"
                },
                "http_example": {
                  "value": {
                    "name": "http_example",
                    "type": "http",
                    "ssl": {
                      "enable": false
                    },
                    "connect_timeout": "15s",
                    "pool_size": 4,
                    "enable": true,
                    "body": "${payload}",
                    "url": "http://localhost:9901/messages/${topic}",
                    "method": "post",
                    "max_retries": 3,
                    "request_timeout": "15s",
                    "pool_type": "random",
                    "resource_opts": {
                      "worker_pool_size": 1,
                      "query_mode": "async",
                      "max_buffer_bytes": 104857600,
                      "inflight_window": 100,
                      "health_check_interval": 15000
                    },
                    "enable_pipelining": 100,
                    "local_topic": "emqx_http/#"
                  },
                  "summary": "HTTP"
                },
                "rabbitmq": {
                  "value": {
                    "timeout": 5,
                    "name": "foo",
                    "port": 5672,
                    "type": "rabbitmq",
                    "exchange": "messages",
                    "pool_size": 8,
                    "server": "localhost",
                    "enable": true,
                    "password": "******",
                    "username": "guest",
                    "heartbeat": "30s",
                    "durable": false,
                    "auto_reconnect": "2s",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 8,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "payload_template": "",
                    "routing_key": "my_routing_key",
                    "virtual_host": "/",
                    "exchange_type": "topic"
                  },
                  "summary": "RabbitMQ Bridge"
                },
                "dynamo": {
                  "value": {
                    "name": "foo",
                    "table": "mqtt",
                    "type": "dynamo",
                    "pool_size": 8,
                    "template": "",
                    "enable": true,
                    "url": "http://127.0.0.1:8000",
                    "aws_secret_access_key": "******",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 8,
                      "query_mode": "sync",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#",
                    "aws_access_key_id": "root"
                  },
                  "summary": "DynamoDB Bridge"
                },
                "tdengine": {
                  "value": {
                    "name": "foo",
                    "type": "tdengine",
                    "pool_size": 8,
                    "server": "127.0.0.1:6041",
                    "enable": true,
                    "password": "******",
                    "username": "root",
                    "database": "mqtt",
                    "sql": "insert into t_mqtt_msg(ts, msgid, mqtt_topic, qos, payload, arrived) values (${ts}, '${id}', '${topic}', ${qos}, '${payload}', ${timestamp})",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 8,
                      "query_mode": "sync",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#"
                  },
                  "summary": "TDengine Bridge"
                },
                "mongodb_single": {
                  "value": {
                    "name": "mongodb_single_demo",
                    "type": "mongodb_single",
                    "pool_size": 8,
                    "server": "localhost:27017",
                    "enable": true,
                    "password": "******",
                    "username": "myuser",
                    "database": "mqtt",
                    "collection": "mycol",
                    "w_mode": "safe",
                    "srv_record": false,
                    "mongo_type": "single"
                  },
                  "summary": "MongoDB (Standalone) Bridge"
                },
                "greptimedb": {
                  "value": {
                    "name": "demo",
                    "type": "greptimedb",
                    "ssl": {
                      "enable": false
                    },
                    "server": "127.0.0.1:4001",
                    "enable": true,
                    "precision": "ms",
                    "password": "******",
                    "username": "example_username",
                    "resource_opts": {
                      "batch_size": 100,
                      "batch_time": "20ms"
                    },
                    "local_topic": "local/topic/#",
                    "dbname": "example_db",
                    "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,uint_value=${payload.uint_key}u,bool=${payload.bool}"
                  },
                  "summary": "Greptimedb HTTP API V2 Bridge"
                },
                "opents": {
                  "value": {
                    "name": "foo",
                    "type": "opents",
                    "pool_size": 8,
                    "server": "http://127.0.0.1:4242",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 1,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "enabledb": true
                  },
                  "summary": "OpenTSDB Bridge"
                },
                "mongodb_sharded": {
                  "value": {
                    "name": "mongodb_sharded_demo",
                    "type": "mongodb_sharded",
                    "pool_size": 8,
                    "enable": true,
                    "password": "******",
                    "username": "myuser",
                    "database": "mqtt",
                    "servers": "localhost:27017, localhost:27018",
                    "collection": "mycol",
                    "w_mode": "safe",
                    "srv_record": false,
                    "mongo_type": "sharded"
                  },
                  "summary": "MongoDB (Sharded) Bridge"
                },
                "mongodb_rs": {
                  "value": {
                    "name": "mongodb_rs_demo",
                    "type": "mongodb_rs",
                    "pool_size": 8,
                    "enable": true,
                    "password": "******",
                    "username": "myuser",
                    "database": "mqtt",
                    "servers": "localhost:27017, localhost:27018",
                    "collection": "mycol",
                    "r_mode": "safe",
                    "w_mode": "safe",
                    "replica_set_name": "rs",
                    "srv_record": false,
                    "mongo_type": "rs"
                  },
                  "summary": "MongoDB (Replica Set) Bridge"
                },
                "oracle": {
                  "value": {
                    "name": "foo",
                    "type": "oracle",
                    "pool_size": 8,
                    "server": "127.0.0.1:1521",
                    "enable": true,
                    "password": "******",
                    "username": "root",
                    "service_name": "ORCL",
                    "sql": "insert into t_mqtt_msgs(msgid, topic, qos, payload) values (${id}, ${topic}, ${qos}, ${payload})",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 8,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#",
                    "sid": "ORCL"
                  },
                  "summary": "Oracle Database Bridge"
                },
                "hstreamdb": {
                  "value": {
                    "name": "demo",
                    "stream": "stream",
                    "type": "hstreamdb",
                    "ssl": {
                      "enable": false
                    },
                    "pool_size": 8,
                    "direction": "egress",
                    "url": "http://127.0.0.1:6570",
                    "resource_opts": {
                      "batch_size": 100,
                      "query_mode": "sync",
                      "batch_time": "20ms"
                    },
                    "record_template": "{ \"temperature\": ${payload.temperature}, \"humidity\": ${payload.humidity} }"
                  },
                  "summary": "HStreamDB Bridge"
                },
                "influxdb_api_v1": {
                  "value": {
                    "name": "demo",
                    "type": "influxdb_api_v1",
                    "ssl": {
                      "enable": false
                    },
                    "server": "127.0.0.1:8086",
                    "enable": true,
                    "precision": "ms",
                    "password": "******",
                    "username": "example_username",
                    "database": "example_database",
                    "resource_opts": {
                      "batch_size": 100,
                      "batch_time": "20ms"
                    },
                    "local_topic": "local/topic/#",
                    "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,bool=${payload.bool}",
                    "influxdb_type": "influxdb_api_v1"
                  },
                  "summary": "InfluxDB HTTP API V1 Bridge"
                },
                "gcp_pubsub": {
                  "value": {
                    "service_account_json": {
                      "type": "service_account",
                      "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQI...",
                      "client_id": "123812831923812319190",
                      "project_id": "myproject",
                      "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                      "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                      "client_email": "test@myproject.iam.gserviceaccount.com",
                      "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/test%40myproject.iam.gserviceaccount.com",
                      "private_key_id": "kid",
                      "token_uri": "https://oauth2.googleapis.com/token"
                    },
                    "pubsub_topic": "mytopic"
                  },
                  "summary": "GCP PubSub Producer Bridge"
                },
                "redis_single": {
                  "value": {
                    "name": "redis_bridge",
                    "type": "redis_single",
                    "ssl": {
                      "enable": false
                    },
                    "pool_size": 8,
                    "server": "127.0.0.1:6379",
                    "enable": true,
                    "password": "******",
                    "database": 1,
                    "resource_opts": {
                      "batch_size": 1,
                      "batch_time": "20ms"
                    },
                    "redis_type": "single",
                    "local_topic": "local/topic/#",
                    "command_template": [
                      "LPUSH",
                      "MSGS",
                      "${payload}"
                    ]
                  },
                  "summary": "Redis Single Node Bridge"
                },
                "mqtt_example": {
                  "value": {
                    "name": "mqtt_example",
                    "type": "mqtt",
                    "keepalive": "300s",
                    "ssl": {
                      "enable": false
                    },
                    "server": "127.0.0.1:1883",
                    "enable": true,
                    "password": "******",
                    "username": "foo",
                    "proto_ver": "v4",
                    "clean_start": true,
                    "retry_interval": "15s",
                    "max_inflight": 100,
                    "resource_opts": {
                      "query_mode": "sync",
                      "max_buffer_bytes": 104857600,
                      "health_check_interval": "15s"
                    },
                    "ingress": {
                      "local": {
                        "retain": "${retain}",
                        "payload": "${payload}",
                        "topic": "from_aws/${topic}",
                        "qos": "${qos}"
                      },
                      "remote": {
                        "topic": "aws/#",
                        "qos": 1
                      }
                    },
                    "egress": {
                      "local": {
                        "topic": "emqx/#"
                      },
                      "remote": {
                        "retain": false,
                        "payload": "${payload}",
                        "topic": "from_emqx/${topic}",
                        "qos": "${qos}"
                      }
                    }
                  },
                  "summary": "MQTT Bridge"
                },
                "cassandra": {
                  "value": {
                    "name": "foo",
                    "type": "cassandra",
                    "pool_size": 8,
                    "enable": true,
                    "password": "******",
                    "username": "root",
                    "cql": "insert into mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic},  ${qos}, ${payload}, ${timestamp})",
                    "servers": "127.0.0.1:9042",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 8,
                      "query_mode": "sync",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#",
                    "keyspace": "mqtt"
                  },
                  "summary": "Cassandra Bridge"
                },
                "gcp_pubsub_consumer": {
                  "value": {
                    "connect_timeout": "15s",
                    "consumer": {
                      "topic_mapping": [
                        {
                          "qos": 1,
                          "mqtt_topic": "mqtt/topic/1",
                          "payload_template": "${.}",
                          "pubsub_topic": "pubsub-topic-1"
                        },
                        {
                          "qos": 2,
                          "mqtt_topic": "mqtt/topic/2",
                          "payload_template": "v = ${.value}, a = ${.attributes}, o = ${.ordering_key}",
                          "pubsub_topic": "pubsub-topic-2"
                        }
                      ],
                      "pull_max_messages": 100
                    },
                    "resource_opts": {
                      "request_ttl": "20s"
                    },
                    "service_account_json": {
                      "type": "service_account",
                      "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQI...",
                      "client_id": "123812831923812319190",
                      "project_id": "myproject",
                      "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                      "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                      "client_email": "test@myproject.iam.gserviceaccount.com",
                      "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/test%40myproject.iam.gserviceaccount.com",
                      "private_key_id": "kid",
                      "token_uri": "https://oauth2.googleapis.com/token"
                    }
                  },
                  "summary": "GCP PubSub Consumer Bridge"
                },
                "clickhouse": {
                  "value": {
                    "name": "foo",
                    "type": "clickhouse",
                    "pool_size": 8,
                    "server": "127.0.0.1:8123",
                    "enable": true,
                    "password": "******",
                    "username": "default",
                    "database": "mqtt",
                    "sql": "INSERT INTO messages(data, arrived) VALUES ('${payload}', ${timestamp})",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 8,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#",
                    "batch_value_separator": ", "
                  },
                  "summary": "Clickhouse Bridge"
                },
                "sqlserver": {
                  "value": {
                    "driver": "ms-sql",
                    "name": "bar",
                    "type": "sqlserver",
                    "pool_size": 8,
                    "server": "127.0.0.1:1433",
                    "enable": true,
                    "password": "******",
                    "username": "sa",
                    "database": "test",
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload) values ( ${id}, ${topic}, ${qos}, ${payload} )",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 1,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#"
                  },
                  "summary": "Microsoft SQL Server Bridge"
                },
                "matrix": {
                  "value": {
                    "name": "foo",
                    "type": "matrix",
                    "pool_size": 8,
                    "server": "127.0.0.1:5432",
                    "enable": true,
                    "password": "******",
                    "username": "root",
                    "database": "mqtt",
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 8,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#"
                  },
                  "summary": "Matrix Bridge"
                },
                "kafka_consumer": {
                  "value": {
                    "name": "my_kafka_producer_action",
                    "type": "kafka_producer",
                    "authentication": {
                      "mechanism": "plain",
                      "password": "******",
                      "username": "username"
                    },
                    "connect_timeout": "5s",
                    "enable": true,
                    "socket_opts": {
                      "nodelay": true,
                      "recbuf": "1024KB",
                      "sndbuf": "1024KB",
                      "tcp_keepalive": "none"
                    },
                    "kafka": {
                      "max_batch_bytes": "896KB",
                      "offset_reset_policy": "latest",
                      "offset_commit_interval_seconds": 5
                    },
                    "min_metadata_refresh_interval": "3s",
                    "topic_mapping": [
                      {
                        "qos": 1,
                        "mqtt_topic": "mqtt/topic/${.offset}",
                        "payload_template": "${.}",
                        "kafka_topic": "kafka-topic-1"
                      },
                      {
                        "qos": 2,
                        "mqtt_topic": "mqtt/topic/2",
                        "payload_template": "v = ${.value}",
                        "kafka_topic": "kafka-topic-2"
                      }
                    ],
                    "bootstrap_hosts": "localhost:9092",
                    "value_encoding_mode": "none",
                    "key_encoding_mode": "none",
                    "metadata_request_timeout": "4s"
                  },
                  "summary": "Kafka Consumer Bridge"
                },
                "rocketmq": {
                  "value": {
                    "name": "foo",
                    "type": "rocketmq",
                    "server": "127.0.0.1:9876",
                    "template": "",
                    "enable": true,
                    "topic": "TopicTest",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 1,
                      "query_mode": "sync",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#"
                  },
                  "summary": "RocketMQ Bridge"
                },
                "timescale": {
                  "value": {
                    "name": "foo",
                    "type": "timescale",
                    "pool_size": 8,
                    "server": "127.0.0.1:5432",
                    "enable": true,
                    "password": "******",
                    "username": "root",
                    "database": "mqtt",
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                    "resource_opts": {
                      "batch_size": 1,
                      "worker_pool_size": 8,
                      "query_mode": "async",
                      "max_buffer_bytes": 268435456,
                      "batch_time": 0,
                      "health_check_interval": "15s"
                    },
                    "local_topic": "local/topic/#"
                  },
                  "summary": "Timescale Bridge"
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/bridge_kafka.post_producer"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_timescale.post"
                  },
                  {
                    "$ref": "#/components/schemas/rocketmq.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_kafka.post_consumer"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_matrix.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_sqlserver.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_clickhouse.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_gcp_pubsub.post_consumer"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_cassa.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_redis.post_single"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_gcp_pubsub.post_producer"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_influxdb.post_api_v1"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_hstreamdb.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_oracle.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mongodb.post_rs"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mongodb.post_sharded"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_opents.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_greptimedb.post_grpc_v1"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mongodb.post_single"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_tdengine.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_dynamo.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_rabbitmq.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mqtt.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_kinesis.post_producer"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mysql.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_redis.post_cluster"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_pgsql.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_pulsar.post_producer"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_redis.post_sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_azure_event_hub.post_producer"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_http.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_iotdb.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_influxdb.post_api_v2"
                  }
                ]
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/node_eviction/status": {
      "get": {
        "description": "Get the node eviction status",
        "tags": [
          "Node Eviction"
        ],
        "parameters": [],
        "summary": "Get node eviction status",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/node_eviction.status_disabled"
                    },
                    {
                      "$ref": "#/components/schemas/node_eviction.status_enabled"
                    }
                  ]
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/listeners_status": {
      "get": {
        "description": "List all running node's listeners live status. group by listener type",
        "tags": [
          "Listeners"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": [
                  {
                    "status": {
                      "running": true,
                      "max_connections": 2048000,
                      "current_connections": 21
                    },
                    "type": "tcp",
                    "enable": false,
                    "node_status": [
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "running": true,
                          "max_connections": 1024000,
                          "current_connections": 11
                        }
                      },
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "running": true,
                          "max_connections": 1024000,
                          "current_connections": 10
                        }
                      }
                    ],
                    "ids": [
                      "tcp:demo"
                    ]
                  },
                  {
                    "status": {
                      "running": true,
                      "max_connections": "infinity",
                      "current_connections": 71
                    },
                    "type": "ssl",
                    "enable": false,
                    "node_status": [
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "running": true,
                          "max_connections": "infinity",
                          "current_connections": 31
                        }
                      },
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "running": true,
                          "max_connections": "infinity",
                          "current_connections": 40
                        }
                      }
                    ],
                    "ids": [
                      "ssl:default"
                    ]
                  }
                ],
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/listeners.listener_type_status"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/monitor": {
      "get": {
        "description": "List monitor (statistics) data for the whole cluster.",
        "tags": [
          "Metrics"
        ],
        "parameters": [
          {
            "in": "query",
            "name": "latest",
            "description": "The latest N seconds data. Like 300 for 5 min.",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 1
            },
            "example": 300
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/emqx_dashboard_monitor_api.sampler"
                  }
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_RPC"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad RPC"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/relup/package": {
      "get": {
        "description": "Get information of the installed hot upgrade package.<br/>",
        "tags": [
          "Relup"
        ],
        "parameters": [],
        "summary": "Get the installed hot upgrade package",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/relup.package"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "No relup package is installed"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete the installed hot upgrade package.<br/>",
        "tags": [
          "Relup"
        ],
        "parameters": [],
        "summary": "Delete the installed hot upgrade package",
        "responses": {
          "204": {
            "description": "Packages are deleted successfully"
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/logout": {
      "post": {
        "description": "Dashboard user logout.<br/>This endpoint is only for the Dashboard, not the `API Key`.<br/>The token from the `/login` endpoint must be a bearer authorization in the headers.",
        "tags": [
          "Dashboard"
        ],
        "parameters": [
          {
            "in": "query",
            "name": "backend",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "local",
                "ldap",
                "oidc",
                "saml"
              ]
            },
            "example": "local"
          }
        ],
        "responses": {
          "204": {
            "description": "Dashboard logout successfully"
          },
          "401": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_USERNAME_OR_PWD"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Login failed. Bad username or password"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "username": {
                    "type": "string",
                    "description": "Dashboard Username",
                    "maxLength": 100,
                    "example": "admin"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "security": [
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/authorization/sources/built_in_database/rules/all": {
      "get": {
        "description": "Show the list of rules for 'all'",
        "tags": [
          "Authorization"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "password_based:built_in_database": {
                    "value": {
                      "rules": [
                        {
                          "action": "publish",
                          "permission": "allow",
                          "topic": "test/topic/1"
                        },
                        {
                          "action": "subscribe",
                          "permission": "allow",
                          "topic": "test/topic/2"
                        },
                        {
                          "action": "all",
                          "permission": "deny",
                          "topic": "eq test/#"
                        },
                        {
                          "action": "publish",
                          "retain": "true",
                          "permission": "allow",
                          "topic": "test/topic/3",
                          "qos": [
                            "1"
                          ]
                        },
                        {
                          "action": "publish",
                          "retain": "all",
                          "permission": "allow",
                          "topic": "test/topic/4",
                          "qos": [
                            "0",
                            "1",
                            "2"
                          ]
                        }
                      ]
                    },
                    "summary": "All"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authz_api_mnesia.rules"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "description": "Delete rules for 'all'",
        "tags": [
          "Authorization"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "post": {
        "description": "Create/Update the list of rules for 'all'.",
        "tags": [
          "Authorization"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": "Updated"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Bad rule schema"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "password_based:built_in_database": {
                  "value": {
                    "rules": [
                      {
                        "action": "publish",
                        "permission": "allow",
                        "topic": "test/topic/1"
                      },
                      {
                        "action": "subscribe",
                        "permission": "allow",
                        "topic": "test/topic/2"
                      },
                      {
                        "action": "all",
                        "permission": "deny",
                        "topic": "eq test/#"
                      },
                      {
                        "action": "publish",
                        "retain": "true",
                        "permission": "allow",
                        "topic": "test/topic/3",
                        "qos": [
                          "1"
                        ]
                      },
                      {
                        "action": "publish",
                        "retain": "all",
                        "permission": "allow",
                        "topic": "test/topic/4",
                        "qos": [
                          "0",
                          "1",
                          "2"
                        ]
                      }
                    ]
                  },
                  "summary": "All"
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authz_api_mnesia.rules"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/ds/storages/{ds}": {
      "get": {
        "description": "Get durable storage",
        "tags": [
          "Durable storage"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "ds",
            "description": "Durable storage ID",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "messages"
              ]
            },
            "example": "messages"
          }
        ],
        "responses": {
          "200": {
            "description": "Get information about a durable storage",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_ds.db"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Durable storage not found"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NOT_FOUND"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Durable storage is disabled"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/relup/status/{node}": {
      "get": {
        "description": "Get the hot upgrade status of a specified node",
        "tags": [
          "Relup"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/relup.node_name"
          }
        ],
        "summary": "Get the hot upgrade status of a specified node",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/relup.running_status"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/load_rebalance/availability_check": {
      "get": {
        "description": "Check if the node is being evacuated or rebalanced",
        "tags": [
          "Load Rebalance"
        ],
        "parameters": [],
        "summary": "Node rebalance availability check",
        "responses": {
          "200": {
            "description": "The response is empty",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "example": {}
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "NODE_EVACUATING"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Node Evacuating"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": []
      }
    },
    "/rule_engine": {
      "get": {
        "description": "Get rule engine configuration.",
        "tags": [
          "Rules"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/rule_engine.rule_engine"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      },
      "put": {
        "description": "Update rule engine configuration.",
        "tags": [
          "Rules"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/rule_engine.rule_engine"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "type": "string",
                      "enum": [
                        "BAD_REQUEST"
                      ]
                    },
                    "message": {
                      "type": "string",
                      "description": "Invalid request"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/rule_engine.rule_engine"
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/load_rebalance/global_status": {
      "get": {
        "description": "Get status of all rebalance/evacuation processes across the cluster",
        "tags": [
          "Load Rebalance"
        ],
        "parameters": [],
        "summary": "Get global rebalance status",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/load_rebalance.global_status"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    }
  },
  "servers": [
    {
      "url": "/api/v5"
    }
  ],
  "openapi": "3.0.0"
}
