{
  "components": {
    "parameters": {
      "api_key.name": {
        "description": "^[A-Za-z]+[A-Za-z0-9-_]*$",
        "example": "EMQX-API-KEY-1",
        "in": "path",
        "name": "name",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "cluster.node": {
        "description": "node name",
        "example": "emqx2@127.0.0.1",
        "in": "path",
        "name": "node",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "emqx_authz_api_mnesia.clientid": {
        "description": "ClientID",
        "example": "client1",
        "in": "path",
        "name": "clientid",
        "required": true,
        "schema": {
          "type": "string"
        },
        "summary": "clientid"
      },
      "emqx_authz_api_mnesia.username": {
        "description": "Username",
        "example": "user1",
        "in": "path",
        "name": "username",
        "required": true,
        "schema": {
          "type": "string"
        },
        "summary": "username"
      },
      "emqx_mgmt_api_nodes.node_name": {
        "description": "Node name",
        "example": "emqx@127.0.0.1",
        "in": "path",
        "name": "node",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "emqx_mgmt_api_stats.aggregate": {
        "description": "Calculation aggregate for all nodes",
        "example": false,
        "in": "query",
        "name": "aggregate",
        "required": false,
        "schema": {
          "type": "boolean"
        }
      },
      "listeners.listener_id": {
        "description": "Listener id",
        "example": "tcp:demo",
        "in": "path",
        "name": "id",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "plugins.name": {
        "description": "^[A-Za-z]+[A-Za-z0-9-_.]*$",
        "example": "emqx_plugin_template-5.0-rc.1",
        "in": "path",
        "name": "name",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "public.limit": {
        "description": "Results per page(max 1000)",
        "example": 50,
        "in": "query",
        "name": "limit",
        "schema": {
          "default": 100,
          "maximum": 1000,
          "minimum": 1,
          "type": "integer"
        }
      },
      "public.page": {
        "description": "Page number of the results to fetch.",
        "example": 1,
        "in": "query",
        "name": "page",
        "schema": {
          "default": 1,
          "minimum": 1,
          "type": "integer"
        }
      },
      "trace.bytes": {
        "description": "Maximum number of bytes to send in response",
        "in": "query",
        "maximum": 2147483647,
        "minimum": 0,
        "name": "bytes",
        "required": false,
        "schema": {
          "default": 1000,
          "maximum": 2147483647,
          "minimum": 0,
          "type": "integer"
        }
      },
      "trace.name": {
        "description": "[a-zA-Z0-9-_]",
        "example": "EMQX-TRACE-1",
        "in": "path",
        "name": "name",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "trace.node": {
        "description": "Node name",
        "example": "emqx@127.0.0.1",
        "in": "query",
        "name": "node",
        "required": false,
        "schema": {
          "type": "string"
        }
      },
      "trace.position": {
        "description": "Offset from the current trace position.",
        "in": "query",
        "name": "position",
        "required": false,
        "schema": {
          "default": 0,
          "type": "integer"
        }
      }
    },
    "schemas": {
      "emqx_gateway_api.gateway_listener_overview": {
        "properties": {
          "id": {
            "description": "Listener ID",
            "type": "string"
          },
          "running": {
            "description": "Listener Running status",
            "type": "boolean"
          },
          "type": {
            "description": "Listener Type",
            "enum": [
              "tcp",
              "ssl",
              "udp",
              "dtls"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_rule_api_schema.ctx_unsub": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "description": "Event Type",
            "enum": [
              "session_unsubscribed"
            ],
            "summary": "Event Type",
            "type": "string"
          },
          "clientid": {
            "description": "The Client ID",
            "summary": "Client ID",
            "type": "string"
          },
          "username": {
            "description": "Username",
            "summary": "Username",
            "type": "string"
          },
          "payload": {
            "description": "The Message Payload",
            "summary": "Message Payload",
            "type": "string"
          },
          "peerhost": {
            "description": "The IP Address of the Peer Client",
            "summary": "Peer IP Address",
            "type": "string"
          },
          "topic": {
            "description": "Message Topic",
            "summary": "Message Topic",
            "type": "string"
          },
          "publish_received_at": {
            "description": "The Time that this Message is Received",
            "summary": "Message Received Time",
            "type": "integer"
          },
          "qos": {
            "description": "The Message QoS",
            "example": 0,
            "maximum": 2,
            "minimum": 0,
            "summary": "Message QoS",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "modules.rewrite": {
        "required": [
          "action",
          "dest_topic",
          "re",
          "source_topic"
        ],
        "properties": {
          "action": {
            "description": "Topic rewriting takes effect on the type of operation:<br/>  - `subscribe`: Rewrite topic when client do subscribe.<br/>  - `publish`: Rewrite topic when client do publish.<br/>  - `all`: Both",
            "enum": [
              "subscribe",
              "publish",
              "all"
            ],
            "example": "publish",
            "summary": "Action",
            "type": "string"
          },
          "source_topic": {
            "description": "Source topic, specified by the client.",
            "example": "x/#",
            "summary": "Source Topic",
            "type": "string"
          },
          "dest_topic": {
            "description": "Destination topic.",
            "example": "z/y/$1",
            "summary": "Destination Topic",
            "type": "string"
          },
          "re": {
            "description": "Regular expressions",
            "example": "^x/y/(.+)$",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_ee_schema_registry_schema.avro": {
        "required": [
          "source",
          "type"
        ],
        "properties": {
          "type": {
            "description": "Schema type.",
            "enum": [
              "avro"
            ],
            "summary": "Schema type",
            "type": "string"
          },
          "source": {
            "description": "Source text for the schema.",
            "example": "{\"a\": [1,true]}",
            "summary": "Schema source",
            "type": "string"
          },
          "description": {
            "default": "",
            "description": "A description for this schema.",
            "summary": "Schema description",
            "type": "string"
          }
        },
        "type": "object"
      },
      "authz.node_status": {
        "properties": {
          "node": {
            "description": "Node name.",
            "example": "emqx@127.0.0.1",
            "summary": "Node Name.",
            "type": "string"
          },
          "status": {
            "description": "The status of the resource for each node.",
            "enum": [
              "connected",
              "disconnected",
              "connecting"
            ],
            "summary": "Resource Status in Node",
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge_cassa.get": {
        "required": [
          "keyspace",
          "name",
          "servers",
          "type"
        ],
        "properties": {
          "status": {
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status.",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary": "Bridge Status",
            "type": "string"
          },
          "status_reason": {
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused",
            "summary": "Failure reason",
            "type": "string"
          },
          "node_status": {
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            },
            "summary": "Node Status",
            "type": "array"
          },
          "type": {
            "description": "The Bridge Type",
            "enum": [
              "cassandra"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name.",
            "summary": "Bridge Name",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "cql": {
            "default": "insert into mqtt_msg(topic, msgid, sender, qos, payload, arrived, retain) values (${topic}, ${id}, ${clientid}, ${qos}, ${payload}, ${timestamp}, ${flags.retain})",
            "description": "CQL Template",
            "format": "sql",
            "summary": "CQL Template",
            "type": "string"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to Cassandra. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "servers": {
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port][,Host2:Port]`.<br/><br/>The Cassandra default port 9042 is used if `[:Port]` is not specified.",
            "summary": "Servers",
            "type": "string"
          },
          "keyspace": {
            "description": "Keyspace name to connect to.",
            "summary": "Keyspace",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "bridge_redis.post_sentinel": {
        "required": [
          "command_template",
          "name",
          "sentinel",
          "servers",
          "type"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to Redis. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "command_template": {
            "description": "Redis command template used to export messages. Each list element stands for a command name or its argument.<br/>For example, to push payloads in a Redis list by key `msgs`, the elements should be the following:<br/>`rpush`, `msgs`, `${payload}`.",
            "items": {
              "type": "string"
            },
            "summary": "Redis Command Template",
            "type": "array"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/bridge_redis.creation_opts_redis_sentinel"
          },
          "servers": {
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The Redis default port 6379 is used if `[:Port]` is not specified.",
            "summary": "Servers",
            "type": "string"
          },
          "redis_type": {
            "default": "sentinel",
            "description": "Sentinel mode. Must be set to 'sentinel' when Redis server is running in sentinel mode.",
            "enum": [
              "sentinel"
            ],
            "summary": "Sentinel Mode",
            "type": "string"
          },
          "sentinel": {
            "description": "The cluster name in Redis sentinel mode.",
            "summary": "Cluster Name",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "database": {
            "default": 0,
            "description": "Redis database ID.",
            "summary": "Database ID",
            "type": "integer"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          },
          "type": {
            "description": "The Bridge Type",
            "enum": [
              "redis_sentinel"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name, used as a human-readable description of the bridge.",
            "summary": "Bridge Name",
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge_kafka.producer_buffer": {
        "properties": {
          "mode": {
            "default": "memory",
            "description": "Message buffer mode.<br/><br/><code>memory</code>: Buffer all messages in memory. The messages will be lost in case of EMQX node restart<br/><code>disk</code>: Buffer all messages on disk. The messages on disk are able to survive EMQX node restart.<br/><code>hybrid</code>: Buffer message in memory first, when up to certain limit (see <code>segment_bytes</code> config for more information), then start offloading messages to disk, Like <code>memory</code> mode, the messages will be lost in case of EMQX node restart.",
            "enum": [
              "memory",
              "disk",
              "hybrid"
            ],
            "summary": "Buffer Mode",
            "type": "string"
          },
          "per_partition_limit": {
            "default": "2GB",
            "description": "Number of bytes allowed to buffer for each Kafka partition. When this limit is exceeded, old messages will be dropped in a trade for credits for new messages to be buffered.",
            "example": "32MB",
            "summary": "Per-partition Buffer Limit",
            "type": "string"
          },
          "segment_bytes": {
            "default": "100MB",
            "description": "Applicable when buffer mode is set to <code>disk</code> or <code>hybrid</code>.<br/>This value is to specify the size of each on-disk buffer file.",
            "example": "32MB",
            "summary": "Segment File Bytes",
            "type": "string"
          },
          "memory_overload_protection": {
            "default": false,
            "description": "Applicable when buffer mode is set to <code>memory</code><br/>EMQX will drop old buffered messages under high memory pressure. The high memory threshold is defined in config <code>sysmon.os.sysmem_high_watermark</code>. NOTE: This config only works on Linux.",
            "summary": "Memory Overload Protection",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_publish.publish_ok": {
        "properties": {
          "id": {
            "description": "A globally unique message ID for correlation/tracing.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_exproto_schema.exproto_grpc_server": {
        "required": [
          "bind"
        ],
        "properties": {
          "bind": {
            "description": "Listening address and port for the gRPC server.",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "ssl_options": {
            "description": "SSL configuration for the gRPC server.",
            "$ref": "#/components/schemas/emqx_exproto_schema.ssl_server_opts"
          }
        },
        "type": "object"
      },
      "broker.listener_wss_opts": {
        "properties": {
          "cacertfile": {
            "description": "Trusted PEM format CA certificates bundle file.<br/><br/>The certificates in this file are used to verify the TLS peer's certificates.<br/>Append new certificates to the file if new CAs are to be trusted.<br/>There is no need to restart EMQX to have the updated file loaded, because<br/>the system regularly checks if file has been updated (and reload).<br/><br/>NOTE: invalidating (deleting) a certificate from the file will not affect<br/>already established connections.",
            "summary": "CACertfile",
            "type": "string"
          },
          "certfile": {
            "description": "PEM format certificates chain file.<br/><br/>The certificates in this file should be in reversed order of the certificate<br/>issue chain. That is, the host's certificate should be placed in the beginning<br/>of the file, followed by the immediate issuer certificate and so on.<br/>Although the root CA certificate is optional, it should be placed at the end of<br/>the file if it is to be added.",
            "summary": "Certfile",
            "type": "string"
          },
          "keyfile": {
            "description": "PEM format private key file.",
            "summary": "Keyfile",
            "type": "string"
          },
          "verify": {
            "default": "verify_none",
            "description": "Enable or disable peer verification.",
            "enum": [
              "verify_peer",
              "verify_none"
            ],
            "summary": "Verify peer",
            "type": "string"
          },
          "reuse_sessions": {
            "default": true,
            "description": "Enable TLS session reuse.",
            "summary": "TLS session reuse",
            "type": "boolean"
          },
          "depth": {
            "default": 10,
            "description": "Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path.<br/>So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly;<br/><br/>if 1 the path can be PEER, Intermediate-CA, ROOT-CA;<br/><br/>if 2 the path can be PEER, Intermediate-CA1, Intermediate-CA2, ROOT-CA.",
            "summary": "CACert Depth",
            "type": "integer"
          },
          "password": {
            "description": "String containing the user's password. Only used if the private key file is password-protected.",
            "example": "",
            "format": "password",
            "summary": "Keyfile passphrase",
            "type": "string"
          },
          "versions": {
            "default": [
              "tlsv1.3",
              "tlsv1.2",
              "tlsv1.1",
              "tlsv1"
            ],
            "description": "All TLS/DTLS versions to be supported.<br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.<br/><br/>In case PSK cipher suites are intended, make sure to configure<br/><code>['tlsv1.2', 'tlsv1.1']</code> here.",
            "items": {
              "type": "string"
            },
            "summary": "SSL versions",
            "type": "array"
          },
          "ciphers": {
            "default": "",
            "description": "This config holds TLS cipher suite names separated by comma,<br/>or as an array of strings. e.g.<br/><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or<br/><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.<br/><br/><br/>Ciphers (and their ordering) define the way in which the<br/>client and server encrypts information over the network connection.<br/>Selecting a good cipher suite is critical for the<br/>application's data security, confidentiality and performance.<br/><br/>The names should be in OpenSSL string format (not RFC format).<br/>All default values and examples provided by EMQX config<br/>documentation are all in OpenSSL format.<br/><br/><br/>NOTE: Certain cipher suites are only compatible with<br/>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')<br/>incompatible cipher suites will be silently dropped.<br/>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,<br/>configuring cipher suites for other versions will have no effect.<br/><br/><br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br/><br/>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.<br/><br/>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,<br/>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,<br/>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,<br/>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code>",
            "items": {
              "type": "string"
            },
            "summary": "",
            "type": "array"
          },
          "secure_renegotiate": {
            "default": true,
            "description": "SSL parameter renegotiation is a feature that allows a client and a server<br/>to renegotiate the parameters of the SSL connection on the fly.<br/>RFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,<br/>you drop support for the insecure renegotiation, prone to MitM attacks.",
            "summary": "SSL renegotiate",
            "type": "boolean"
          },
          "hibernate_after": {
            "default": "5s",
            "description": "Hibernate the SSL process after idling for amount of time reducing its memory footprint.",
            "example": "12m",
            "summary": "hibernate after",
            "type": "string"
          },
          "dhfile": {
            "description": "Path to a file containing PEM-encoded Diffie-Hellman parameters<br/>to be used by the server if a cipher suite using Diffie-Hellman<br/>key exchange is negotiated. If not specified, default parameters<br/>are used.<br/><br/>NOTE: The <code>dhfile</code> option is not supported by TLS 1.3.",
            "summary": "SSL dhfile",
            "type": "string"
          },
          "fail_if_no_peer_cert": {
            "default": false,
            "description": "Used together with {verify, verify_peer} by an TLS/DTLS server.<br/>If set to true, the server fails if the client does not have a<br/>certificate to send, that is, sends an empty certificate.<br/>If set to false, it fails only if the client sends an invalid<br/>certificate (an empty certificate is considered valid).",
            "summary": "SSL fail if no peer cert",
            "type": "boolean"
          },
          "honor_cipher_order": {
            "default": true,
            "description": "An important security setting, it forces the cipher to be set based<br/> on the server-specified order instead of the client-specified order,<br/> hence enforcing the (usually more properly configured) security<br/> ordering of the server administrator.",
            "summary": "SSL honor cipher order",
            "type": "boolean"
          },
          "client_renegotiation": {
            "default": true,
            "description": "In protocols that support client-initiated renegotiation,<br/>the cost of resources of such an operation is higher for the server than the client.<br/>This can act as a vector for denial of service attacks.<br/>The SSL application already takes measures to counter-act such attempts,<br/>but client-initiated renegotiation can be strictly disabled by setting this option to false.<br/>The default value is true. Note that disabling renegotiation can result in<br/>long-lived connections becoming unusable due to limits on<br/>the number of messages the underlying cipher suite can encipher.",
            "summary": "SSL client renegotiation",
            "type": "boolean"
          },
          "handshake_timeout": {
            "default": "15s",
            "description": "Maximum time duration allowed for the handshake to complete",
            "example": "12m",
            "summary": "Handshake timeout",
            "type": "string"
          }
        },
        "type": "object"
      },
      "broker.sysmon_os": {
        "properties": {
          "cpu_check_interval": {
            "default": "60s",
            "description": "The time interval for the periodic CPU check.",
            "example": "12m",
            "summary": "The time interval for the periodic CPU check.",
            "type": "string"
          },
          "cpu_high_watermark": {
            "default": "80%",
            "description": "The threshold, as percentage of system CPU load,<br/> for how much system cpu can be used before the corresponding alarm is raised.",
            "example": "12%",
            "summary": "CPU high watermark",
            "type": "number"
          },
          "cpu_low_watermark": {
            "default": "60%",
            "description": "The threshold, as percentage of system CPU load,<br/> for how much system cpu can be used before the corresponding alarm is cleared.",
            "example": "12%",
            "summary": "CPU low watermark",
            "type": "number"
          },
          "mem_check_interval": {
            "default": "60s",
            "description": "The time interval for the periodic memory check.",
            "summary": "Mem check interval",
            "oneOf": [
              {
                "example": "12m",
                "type": "string"
              },
              {
                "enum": [
                  "disabled"
                ],
                "type": "string"
              }
            ]
          },
          "sysmem_high_watermark": {
            "default": "70%",
            "description": "The threshold, as percentage of system memory,<br/> for how much system memory can be allocated before the corresponding alarm is raised.",
            "example": "12%",
            "summary": "SysMem high wartermark",
            "type": "number"
          },
          "procmem_high_watermark": {
            "default": "5%",
            "description": "The threshold, as percentage of system memory,<br/> for how much system memory can be allocated by one Erlang process before<br/> the corresponding alarm is raised.",
            "example": "12%",
            "summary": "ProcMem high wartermark",
            "type": "number"
          }
        },
        "type": "object"
      },
      "rule_engine.builtin_action_republish": {
        "properties": {
          "function": {
            "description": "Republish the message as a new MQTT message",
            "enum": [
              "republish"
            ],
            "summary": "Republish Function",
            "type": "string"
          },
          "args": {
            "default": {},
            "$ref": "#/components/schemas/rule_engine.republish_args"
          }
        },
        "type": "object"
      },
      "emqx_authn_schema.metrics": {
        "properties": {
          "nomatch": {
            "description": "The number of times the instance was ignored when the required authentication information was not found in the current instance.",
            "summary": "Nomatch Times",
            "type": "integer"
          },
          "total": {
            "description": "The total number of times the current instance was triggered.",
            "summary": "Total Triggered Times",
            "type": "integer"
          },
          "success": {
            "description": "The required authentication information is found in the current instance, and the instance returns authentication success.",
            "summary": "Authentication Success Times",
            "type": "integer"
          },
          "failed": {
            "description": "The required authentication information is found in the current instance, and the instance returns authentication failure.",
            "summary": "Authentication Failed Times",
            "type": "integer"
          },
          "rate": {
            "description": "The total rate at which instances are triggered, times/second.",
            "summary": "Total Triggered Rate",
            "type": "number"
          },
          "rate_max": {
            "description": "The highest trigger rate the instance has ever reached, times/second.",
            "summary": "Highest Triggered Rate",
            "type": "number"
          },
          "rate_last5m": {
            "description": "The average trigger rate of the instance within 5 minutes, times/second.",
            "summary": "Average Triggered Rate in Last 5min",
            "type": "number"
          }
        },
        "type": "object"
      },
      "broker.sysmon": {
        "properties": {
          "vm": {
            "$ref": "#/components/schemas/broker.sysmon_vm"
          },
          "os": {
            "$ref": "#/components/schemas/broker.sysmon_os"
          }
        },
        "type": "object"
      },
      "dashboard.http": {
        "required": [
          "bind",
          "enable"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Ignore or enable this listener",
            "summary": "Enable",
            "type": "boolean"
          },
          "bind": {
            "default": 18083,
            "description": "Port without IP(18083) or port with specified IP(127.0.0.1:18083).",
            "example": "0.0.0.0:18083",
            "summary": "Bind",
            "oneOf": [
              {
                "example": "127.0.0.1:80",
                "type": "string"
              },
              {
                "minimum": 0,
                "type": "integer"
              }
            ]
          },
          "num_acceptors": {
            "default": 8,
            "description": "Socket acceptor pool size for TCP protocols. Default is the number of schedulers online",
            "summary": "Number of acceptors",
            "type": "integer"
          },
          "max_connections": {
            "default": 512,
            "description": "Maximum number of simultaneous connections.",
            "summary": "Maximum connections",
            "type": "integer"
          },
          "backlog": {
            "default": 1024,
            "description": "Defines the maximum length that the queue of pending connections can grow to.",
            "summary": "Backlog",
            "type": "integer"
          },
          "send_timeout": {
            "default": "10s",
            "description": "Send timeout for the socket.",
            "example": "12m",
            "summary": "Send timeout",
            "type": "string"
          },
          "inet6": {
            "default": false,
            "description": "Enable IPv6 support, default is false, which means IPv4 only.",
            "summary": "IPv6",
            "type": "boolean"
          },
          "ipv6_v6only": {
            "default": false,
            "description": "Disable IPv4-to-IPv6 mapping for the listener.<br/>The configuration is only valid when the inet6 is true.",
            "summary": "IPv6 only",
            "type": "boolean"
          },
          "proxy_header": {
            "default": false,
            "description": "Enable support for `HAProxy` header. Be aware once enabled regular HTTP requests can't be handled anymore.",
            "summary": "Enable support for HAProxy header",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.update_exproto": {
        "required": [
          "handler",
          "server"
        ],
        "properties": {
          "server": {
            "description": "Configurations for starting the <code>ConnectionAdapter</code> service",
            "$ref": "#/components/schemas/emqx_exproto_schema.exproto_grpc_server"
          },
          "handler": {
            "description": "Configurations for request to <code>ConnectionHandler</code> service",
            "$ref": "#/components/schemas/emqx_exproto_schema.exproto_grpc_handler"
          },
          "mountpoint": {
            "default": "",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message is delivered to the subscriber.<br/>The mountpoint is a way that users can use to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,<br/>then the client actually subscribes to the topic `some_tenant/t`.<br/>Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,<br/>the message is routed to all the clients subscribed `some_tenant/t`,<br/>so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.<br/>Variables in mountpoint string:<br/><br/>  - <code>${clientid}</code>: clientid<br/><br/>  - <code>${username}</code>: username",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Whether to enable this gateway",
            "type": "boolean"
          },
          "enable_stats": {
            "default": true,
            "description": "Whether to enable client process statistic",
            "type": "boolean"
          },
          "idle_timeout": {
            "default": "30s",
            "description": "The idle time of the client connection process. It has two purposes:<br/>  1. A newly created client process that does not receive any client requests after that time will be closed directly.<br/>  2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.",
            "example": "12m",
            "type": "string"
          },
          "clientinfo_override": {
            "description": "ClientInfo override.",
            "$ref": "#/components/schemas/gateway.clientinfo_override"
          }
        },
        "type": "object"
      },
      "emqx_authn_api.request_user_create": {
        "required": [
          "password",
          "user_id"
        ],
        "properties": {
          "user_id": {
            "type": "string"
          },
          "password": {
            "type": "string"
          },
          "is_superuser": {
            "default": false,
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "authn-mysql.authentication": {
        "required": [
          "backend",
          "database",
          "mechanism",
          "query",
          "server"
        ],
        "properties": {
          "mechanism": {
            "description": "Authentication mechanism.",
            "enum": [
              "password_based"
            ],
            "summary": "Authentication Mechanism",
            "type": "string"
          },
          "backend": {
            "description": "Backend type.",
            "enum": [
              "mysql"
            ],
            "summary": "Backend Type",
            "type": "string"
          },
          "password_hash_algorithm": {
            "default": {
              "name": "sha256",
              "salt_position": "prefix"
            },
            "description": "Options for password hash verification.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn-hash.simple"
              },
              {
                "$ref": "#/components/schemas/authn-hash.pbkdf2"
              },
              {
                "$ref": "#/components/schemas/authn-hash.bcrypt"
              }
            ]
          },
          "query": {
            "description": "SQL used to query data for authentication, such as password hash.",
            "summary": "Query",
            "type": "string"
          },
          "query_timeout": {
            "default": "5s",
            "description": "Timeout for the SQL query.",
            "example": "32s",
            "summary": "Query Timeout",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
            "summary": "Enable",
            "type": "boolean"
          },
          "server": {
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The MySQL default port 3306 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "default": "root",
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "bridge_tdengine.post": {
        "required": [
          "database",
          "name",
          "password",
          "server",
          "type"
        ],
        "properties": {
          "type": {
            "description": "The Bridge Type",
            "enum": [
              "tdengine"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name.",
            "summary": "Bridge Name",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "sql": {
            "default": "insert into t_mqtt_msg(ts, msgid, mqtt_topic, qos, payload, arrived) values (${ts}, ${id}, ${topic}, ${qos}, ${payload}, ${timestamp})",
            "description": "SQL Template",
            "format": "sql",
            "summary": "SQL Template",
            "type": "string"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to TDengine. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The TDengine default port 6041 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "default": "root",
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "bridge_influxdb.post_api_v1": {
        "required": [
          "database",
          "name",
          "type",
          "write_syntax"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to the InfluxDB. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "write_syntax": {
            "description": "Conf of InfluxDB line protocol to write data points. It is a text-based format that provides the measurement, tag set, field set, and timestamp of a data point, and placeholder supported.<br/>See also [InfluxDB 2.3 Line Protocol](https://docs.influxdata.com/influxdb/v2.3/reference/syntax/line-protocol/) and<br/>[InfluxDB 1.8 Line Protocol](https://docs.influxdata.com/influxdb/v1.8/write_protocols/line_protocol_tutorial/) </br><br/>TLDR:</br><br/>```<br/><measurement>[,<tag_key>=<tag_value>[,<tag_key>=<tag_value>]] <field_key>=<field_value>[,<field_key>=<field_value>] [<timestamp>]<br/>```<br/>Please note that a placeholder for an integer value must be annotated with a suffix `i`. For example `${payload.int_value}i`.",
            "example": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,bool=${payload.bool}",
            "format": "sql",
            "summary": "Write Syntax",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "default": "127.0.0.1:8086",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.</br><br/>A host entry has the following form: `Host[:Port]`.</br><br/>The InfluxDB default port 8086 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "precision": {
            "default": "ms",
            "description": "InfluxDB time precision.",
            "enum": [
              "ns",
              "us",
              "ms",
              "s"
            ],
            "summary": "Time Precision",
            "type": "string"
          },
          "database": {
            "description": "InfluxDB database.",
            "summary": "Database",
            "type": "string"
          },
          "username": {
            "description": "InfluxDB username.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "InfluxDB password.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          },
          "type": {
            "description": "The Bridge Type.",
            "enum": [
              "influxdb_api_v1"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name.",
            "summary": "Bridge Name",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.update_mqttsn": {
        "required": [
          "gateway_id"
        ],
        "properties": {
          "gateway_id": {
            "default": 1,
            "description": "MQTT-SN Gateway ID.<br/>When the <code>broadcast</code> option is enabled, the gateway will broadcast ADVERTISE message with this value",
            "type": "integer"
          },
          "broadcast": {
            "default": false,
            "description": "Whether to periodically broadcast ADVERTISE messages",
            "type": "boolean"
          },
          "enable_qos3": {
            "default": true,
            "description": "Allows connectionless clients to publish messages with a Qos of -1.<br/>This feature is defined for very simple client implementations which do not support any other features except this one. There is no connection setup nor tear down, no registration nor subscription. The client just sends its 'PUBLISH' messages to a GW",
            "type": "boolean"
          },
          "subs_resume": {
            "default": false,
            "description": "Whether to initiate all subscribed topic name registration messages to the client after the Session has been taken over by a new channel",
            "type": "boolean"
          },
          "predefined": {
            "default": "",
            "description": "The pre-defined topic IDs and topic names.<br/>A 'pre-defined' topic ID is a topic ID whose mapping to a topic name is known in advance by both the client's application and the gateway",
            "items": {
              "$ref": "#/components/schemas/emqx_mqttsn_schema.mqttsn_predefined"
            },
            "type": "array"
          },
          "mountpoint": {
            "default": "",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message is delivered to the subscriber.<br/>The mountpoint is a way that users can use to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,<br/>then the client actually subscribes to the topic `some_tenant/t`.<br/>Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,<br/>the message is routed to all the clients subscribed `some_tenant/t`,<br/>so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.<br/>Variables in mountpoint string:<br/><br/>  - <code>${clientid}</code>: clientid<br/><br/>  - <code>${username}</code>: username",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Whether to enable this gateway",
            "type": "boolean"
          },
          "enable_stats": {
            "default": true,
            "description": "Whether to enable client process statistic",
            "type": "boolean"
          },
          "idle_timeout": {
            "default": "30s",
            "description": "The idle time of the client connection process. It has two purposes:<br/>  1. A newly created client process that does not receive any client requests after that time will be closed directly.<br/>  2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.",
            "example": "12m",
            "type": "string"
          },
          "clientinfo_override": {
            "description": "ClientInfo override.",
            "$ref": "#/components/schemas/gateway.clientinfo_override"
          }
        },
        "type": "object"
      },
      "authn-hash.simple": {
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "description": "Simple password hashing algorithm.",
            "enum": [
              "plain",
              "md5",
              "sha",
              "sha256",
              "sha512"
            ],
            "type": "string"
          },
          "salt_position": {
            "default": "prefix",
            "description": "Salt position for PLAIN, MD5, SHA, SHA256 and SHA512 algorithms.",
            "enum": [
              "disable",
              "prefix",
              "suffix"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.stomp": {
        "properties": {
          "name": {
            "description": "Gateway Name",
            "enum": [
              "stomp"
            ],
            "type": "string"
          },
          "frame": {
            "$ref": "#/components/schemas/emqx_stomp_schema.stomp_frame"
          },
          "mountpoint": {
            "default": "",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message is delivered to the subscriber.<br/>The mountpoint is a way that users can use to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,<br/>then the client actually subscribes to the topic `some_tenant/t`.<br/>Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,<br/>the message is routed to all the clients subscribed `some_tenant/t`,<br/>so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.<br/>Variables in mountpoint string:<br/><br/>  - <code>${clientid}</code>: clientid<br/><br/>  - <code>${username}</code>: username",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Whether to enable this gateway",
            "type": "boolean"
          },
          "enable_stats": {
            "default": true,
            "description": "Whether to enable client process statistic",
            "type": "boolean"
          },
          "idle_timeout": {
            "default": "30s",
            "description": "The idle time of the client connection process. It has two purposes:<br/>  1. A newly created client process that does not receive any client requests after that time will be closed directly.<br/>  2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.",
            "example": "12m",
            "type": "string"
          },
          "clientinfo_override": {
            "description": "ClientInfo override.",
            "$ref": "#/components/schemas/gateway.clientinfo_override"
          },
          "listeners": {
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/emqx_gateway_api.ssl_listener"
                },
                {
                  "$ref": "#/components/schemas/emqx_gateway_api.tcp_listener"
                }
              ]
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_mnesia.rules_for_username": {
        "required": [
          "username"
        ],
        "properties": {
          "rules": {
            "items": {
              "$ref": "#/components/schemas/emqx_authz_api_mnesia.rule_item"
            },
            "type": "array"
          },
          "username": {
            "description": "Username",
            "example": "user1",
            "summary": "username",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api_clients.exproto_client": {
        "properties": {
          "node": {
            "description": "Name of the node to which the client is connected",
            "type": "string"
          },
          "clientid": {
            "description": "Client ID",
            "type": "string"
          },
          "username": {
            "description": "Username of client when connecting",
            "type": "string"
          },
          "mountpoint": {
            "description": "Topic mountpoint",
            "type": "string"
          },
          "proto_name": {
            "description": "Client protocol name",
            "type": "string"
          },
          "proto_ver": {
            "description": "Protocol version used by the client",
            "type": "string"
          },
          "ip_address": {
            "description": "Client's IP address",
            "type": "string"
          },
          "port": {
            "description": "Client's port",
            "type": "integer"
          },
          "is_bridge": {
            "description": "Indicates whether the client is connected via bridge",
            "type": "boolean"
          },
          "connected_at": {
            "description": "Client connection time",
            "oneOf": [
              {
                "description": "epoch-millisecond",
                "example": 1640995200000,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "disconnected_at": {
            "description": "Client offline time, This field is only valid and returned when connected is false",
            "oneOf": [
              {
                "description": "epoch-millisecond",
                "example": 1640995200000,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "connected": {
            "description": "Whether the client is connected",
            "type": "boolean"
          },
          "keepalive": {
            "description": "Keepalive time, with the unit of second",
            "type": "integer"
          },
          "clean_start": {
            "description": "Indicate whether the client is using a brand new session",
            "type": "boolean"
          },
          "expiry_interval": {
            "description": "Session expiration interval, with the unit of second",
            "type": "integer"
          },
          "created_at": {
            "description": "Session creation time",
            "oneOf": [
              {
                "description": "epoch-millisecond",
                "example": 1640995200000,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "subscriptions_cnt": {
            "description": "Number of subscriptions established by this client",
            "type": "integer"
          },
          "subscriptions_max": {
            "description": "Maximum number of subscriptions allowed by this client",
            "type": "integer"
          },
          "inflight_cnt": {
            "description": "Current length of inflight",
            "type": "integer"
          },
          "inflight_max": {
            "description": "Maximum length of inflight",
            "type": "integer"
          },
          "mqueue_len": {
            "description": "Current length of message queue",
            "type": "integer"
          },
          "mqueue_max": {
            "description": "Maximum length of message queue",
            "type": "integer"
          },
          "mqueue_dropped": {
            "description": "Number of messages dropped by the message queue due to exceeding the length",
            "type": "integer"
          },
          "awaiting_rel_cnt": {
            "description": "Number of awaiting acknowledge packet",
            "type": "integer"
          },
          "awaiting_rel_max": {
            "description": "Maximum allowed number of awaiting PUBREC packet",
            "type": "integer"
          },
          "recv_oct": {
            "description": "Number of bytes received",
            "type": "integer"
          },
          "recv_cnt": {
            "description": "Number of socket packets received",
            "type": "integer"
          },
          "recv_pkt": {
            "description": "Number of protocol packets received",
            "type": "integer"
          },
          "recv_msg": {
            "description": "Number of message packets received",
            "type": "integer"
          },
          "send_oct": {
            "description": "Number of bytes sent",
            "type": "integer"
          },
          "send_cnt": {
            "description": "Number of socket packets sent",
            "type": "integer"
          },
          "send_pkt": {
            "description": "Number of protocol packets sent",
            "type": "integer"
          },
          "send_msg": {
            "description": "Number of message packets sent",
            "type": "integer"
          },
          "mailbox_len": {
            "description": "Process mailbox size",
            "type": "integer"
          },
          "heap_size": {
            "description": "Process heap size with the unit of byte",
            "type": "integer"
          },
          "reductions": {
            "description": "Erlang reduction",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "emqx_lwm2m_schema.translator": {
        "required": [
          "topic"
        ],
        "properties": {
          "topic": {
            "description": "Topic Name",
            "type": "string"
          },
          "qos": {
            "default": 0,
            "description": "QoS Level",
            "example": 0,
            "maximum": 2,
            "minimum": 0,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "connector-mqtt.ingress": {
        "properties": {
          "remote": {
            "description": "The configs about subscribing to the remote broker.",
            "summary": "Remote Configs",
            "$ref": "#/components/schemas/connector-mqtt.ingress_remote"
          },
          "local": {
            "description": "The configs about sending message to the local broker.",
            "summary": "Local Configs",
            "$ref": "#/components/schemas/connector-mqtt.ingress_local"
          }
        },
        "type": "object"
      },
      "bridge_influxdb.get_api_v2": {
        "required": [
          "bucket",
          "name",
          "org",
          "token",
          "type",
          "write_syntax"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to the InfluxDB. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "write_syntax": {
            "description": "Conf of InfluxDB line protocol to write data points. It is a text-based format that provides the measurement, tag set, field set, and timestamp of a data point, and placeholder supported.<br/>See also [InfluxDB 2.3 Line Protocol](https://docs.influxdata.com/influxdb/v2.3/reference/syntax/line-protocol/) and<br/>[InfluxDB 1.8 Line Protocol](https://docs.influxdata.com/influxdb/v1.8/write_protocols/line_protocol_tutorial/) </br><br/>TLDR:</br><br/>```<br/><measurement>[,<tag_key>=<tag_value>[,<tag_key>=<tag_value>]] <field_key>=<field_value>[,<field_key>=<field_value>] [<timestamp>]<br/>```<br/>Please note that a placeholder for an integer value must be annotated with a suffix `i`. For example `${payload.int_value}i`.",
            "example": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,bool=${payload.bool}",
            "format": "sql",
            "summary": "Write Syntax",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "default": "127.0.0.1:8086",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.</br><br/>A host entry has the following form: `Host[:Port]`.</br><br/>The InfluxDB default port 8086 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "precision": {
            "default": "ms",
            "description": "InfluxDB time precision.",
            "enum": [
              "ns",
              "us",
              "ms",
              "s"
            ],
            "summary": "Time Precision",
            "type": "string"
          },
          "bucket": {
            "description": "InfluxDB bucket name.",
            "summary": "Bucket",
            "type": "string"
          },
          "org": {
            "description": "Organization name of InfluxDB.",
            "summary": "Organization",
            "type": "string"
          },
          "token": {
            "description": "InfluxDB token.",
            "summary": "Token",
            "type": "string"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          },
          "type": {
            "description": "The Bridge Type.",
            "enum": [
              "influxdb_api_v2"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name.",
            "summary": "Bridge Name",
            "type": "string"
          },
          "status": {
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status.",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary": "Bridge Status",
            "type": "string"
          },
          "status_reason": {
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused",
            "summary": "Failure reason",
            "type": "string"
          },
          "node_status": {
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            },
            "summary": "Node Status",
            "type": "array"
          }
        },
        "type": "object"
      },
      "connector-mqtt.egress_local": {
        "properties": {
          "topic": {
            "description": "The local topic to be forwarded to the remote broker",
            "summary": "Local Topic",
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge_influxdb.put_api_v2": {
        "required": [
          "bucket",
          "org",
          "token",
          "write_syntax"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to the InfluxDB. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "write_syntax": {
            "description": "Conf of InfluxDB line protocol to write data points. It is a text-based format that provides the measurement, tag set, field set, and timestamp of a data point, and placeholder supported.<br/>See also [InfluxDB 2.3 Line Protocol](https://docs.influxdata.com/influxdb/v2.3/reference/syntax/line-protocol/) and<br/>[InfluxDB 1.8 Line Protocol](https://docs.influxdata.com/influxdb/v1.8/write_protocols/line_protocol_tutorial/) </br><br/>TLDR:</br><br/>```<br/><measurement>[,<tag_key>=<tag_value>[,<tag_key>=<tag_value>]] <field_key>=<field_value>[,<field_key>=<field_value>] [<timestamp>]<br/>```<br/>Please note that a placeholder for an integer value must be annotated with a suffix `i`. For example `${payload.int_value}i`.",
            "example": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,bool=${payload.bool}",
            "format": "sql",
            "summary": "Write Syntax",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "default": "127.0.0.1:8086",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.</br><br/>A host entry has the following form: `Host[:Port]`.</br><br/>The InfluxDB default port 8086 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "precision": {
            "default": "ms",
            "description": "InfluxDB time precision.",
            "enum": [
              "ns",
              "us",
              "ms",
              "s"
            ],
            "summary": "Time Precision",
            "type": "string"
          },
          "bucket": {
            "description": "InfluxDB bucket name.",
            "summary": "Bucket",
            "type": "string"
          },
          "org": {
            "description": "Organization name of InfluxDB.",
            "summary": "Organization",
            "type": "string"
          },
          "token": {
            "description": "InfluxDB token.",
            "summary": "Token",
            "type": "string"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_schema.mongo_sharded": {
        "required": [
          "collection",
          "database",
          "servers",
          "type"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this ACL provider.",
            "summary": "enable",
            "type": "boolean"
          },
          "type": {
            "default": "mongodb",
            "description": "Backend type.",
            "enum": [
              "mongodb"
            ],
            "summary": "type",
            "type": "string"
          },
          "collection": {
            "description": "`MongoDB` collection containing the authorization data.",
            "summary": "collection",
            "type": "string"
          },
          "filter": {
            "default": {},
            "description": "Conditional expression that defines the filter condition in the query.<br/>Filter supports the following placeholders:<br/> - <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting;<br/> - <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting.",
            "example": {},
            "summary": "Filter",
            "type": "object"
          },
          "mongo_type": {
            "default": "sharded",
            "description": "Sharded cluster. Must be set to 'sharded' when MongoDB server is running in 'sharded' mode.",
            "enum": [
              "sharded"
            ],
            "summary": "Sharded cluster",
            "type": "string"
          },
          "servers": {
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The MongoDB default port 27017 is used if `[:Port]` is not specified.",
            "summary": "Servers",
            "type": "string"
          },
          "w_mode": {
            "default": "unsafe",
            "description": "Write mode.",
            "enum": [
              "unsafe",
              "safe"
            ],
            "summary": "Write Mode",
            "type": "string"
          },
          "srv_record": {
            "default": false,
            "description": "Use DNS SRV record.",
            "summary": "Srv Record",
            "type": "boolean"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auth_source": {
            "description": "Database name associated with the user's credentials.",
            "summary": "Auth Source",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "topology": {
            "$ref": "#/components/schemas/emqx_connector_mongo.topology"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "bridge_redis.creation_opts_redis_single": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 0,
            "summary": "Buffer Pool Size",
            "type": "integer"
          },
          "health_check_interval": {
            "default": "15s",
            "description": "Health check interval.",
            "example": "32s",
            "summary": "Health Check Interval",
            "type": "string"
          },
          "start_after_created": {
            "default": "true",
            "description": "Whether start the resource right after created.",
            "summary": "Start After Created",
            "type": "boolean"
          },
          "start_timeout": {
            "default": "5s",
            "description": "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "example": "32s",
            "summary": "Start Timeout",
            "type": "string"
          },
          "auto_restart_interval": {
            "default": "60s",
            "description": "The auto restart interval after the resource is disconnected.",
            "summary": "Auto Restart Interval",
            "oneOf": [
              {
                "example": "32s",
                "type": "string"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "query_mode": {
            "default": "async",
            "description": "Query mode. Optional 'sync/async', default 'async'.",
            "enum": [
              "sync",
              "async"
            ],
            "summary": "Query mode",
            "type": "string"
          },
          "request_timeout": {
            "default": "15s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "summary": "Request Expiry",
            "oneOf": [
              {
                "example": "32s",
                "type": "string"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1,
            "summary": "Inflight window",
            "type": "integer"
          },
          "enable_batch": {
            "default": true,
            "deprecated": true,
            "description": "Batch mode enabled.",
            "summary": "Enable batch",
            "type": "boolean"
          },
          "batch_size": {
            "default": 1,
            "description": "Maximum batch count. If equal to 1, there's effectively no batching.",
            "minimum": 1,
            "summary": "Max batch size",
            "type": "integer"
          },
          "batch_time": {
            "default": "0ms",
            "description": "Maximum waiting interval when accumulating a batch at a low message rates for more efficient resource usage.",
            "example": "32s",
            "summary": "Max batch wait time",
            "type": "string"
          },
          "enable_queue": {
            "default": false,
            "deprecated": true,
            "description": "Enable disk buffer queue (only applicable for egress bridges).<br/>When Enabled, messages will be buffered on disk when the bridge connection is down.<br/>When disabled the messages are buffered in RAM only.",
            "summary": "Enable disk buffer queue",
            "type": "boolean"
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB",
            "summary": "Max buffer queue size",
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge_mongodb.post_rs": {
        "required": [
          "database",
          "name",
          "replica_set_name",
          "servers",
          "type"
        ],
        "properties": {
          "mongo_type": {
            "default": "rs",
            "description": "Replica set. Must be set to 'rs' when MongoDB server is running in 'replica set' mode.",
            "enum": [
              "rs"
            ],
            "summary": "Replica set",
            "type": "string"
          },
          "servers": {
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The MongoDB default port 27017 is used if `[:Port]` is not specified.",
            "summary": "Servers",
            "type": "string"
          },
          "w_mode": {
            "default": "unsafe",
            "description": "Write mode.",
            "enum": [
              "unsafe",
              "safe"
            ],
            "summary": "Write Mode",
            "type": "string"
          },
          "r_mode": {
            "default": "master",
            "description": "Read mode.",
            "enum": [
              "master",
              "slave_ok"
            ],
            "summary": "Read Mode",
            "type": "string"
          },
          "replica_set_name": {
            "description": "Name of the replica set.",
            "summary": "Replica Set Name",
            "type": "string"
          },
          "srv_record": {
            "default": false,
            "description": "Use DNS SRV record.",
            "summary": "Srv Record",
            "type": "boolean"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auth_source": {
            "description": "Database name associated with the user's credentials.",
            "summary": "Auth Source",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "topology": {
            "$ref": "#/components/schemas/emqx_connector_mongo.topology"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable this MongoDB Bridge",
            "summary": "Enable or disable",
            "type": "boolean"
          },
          "collection": {
            "default": "mqtt",
            "description": "The collection where data will be stored into",
            "summary": "Collection to be used",
            "type": "string"
          },
          "payload_template": {
            "description": "The template for formatting the outgoing messages.  If undefined, rule engine will use JSON format to serialize all visible inputs, such as clientid, topic, payload etc.",
            "summary": "Payload template",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "type": {
            "description": "The Bridge Type.",
            "enum": [
              "mongodb_rs"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name.",
            "summary": "Bridge Name",
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge_clickhouse.creation_opts": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 0,
            "summary": "Buffer Pool Size",
            "type": "integer"
          },
          "health_check_interval": {
            "default": "15s",
            "description": "Health check interval.",
            "example": "32s",
            "summary": "Health Check Interval",
            "type": "string"
          },
          "start_after_created": {
            "default": "true",
            "description": "Whether start the resource right after created.",
            "summary": "Start After Created",
            "type": "boolean"
          },
          "start_timeout": {
            "default": "5s",
            "description": "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "example": "32s",
            "summary": "Start Timeout",
            "type": "string"
          },
          "auto_restart_interval": {
            "default": "60s",
            "description": "The auto restart interval after the resource is disconnected.",
            "summary": "Auto Restart Interval",
            "oneOf": [
              {
                "example": "32s",
                "type": "string"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "query_mode": {
            "default": "async",
            "description": "Query mode. Optional 'sync/async', default 'async'.",
            "enum": [
              "sync",
              "async"
            ],
            "summary": "Query mode",
            "type": "string"
          },
          "request_timeout": {
            "default": "15s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "summary": "Request Expiry",
            "oneOf": [
              {
                "example": "32s",
                "type": "string"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1,
            "summary": "Inflight window",
            "type": "integer"
          },
          "enable_batch": {
            "default": true,
            "deprecated": true,
            "description": "Batch mode enabled.",
            "summary": "Enable batch",
            "type": "boolean"
          },
          "batch_size": {
            "default": 1,
            "description": "Maximum batch count. If equal to 1, there's effectively no batching.",
            "minimum": 1,
            "summary": "Max batch size",
            "type": "integer"
          },
          "batch_time": {
            "default": "0ms",
            "description": "Maximum waiting interval when accumulating a batch at a low message rates for more efficient resource usage.",
            "example": "32s",
            "summary": "Max batch wait time",
            "type": "string"
          },
          "enable_queue": {
            "default": false,
            "deprecated": true,
            "description": "Enable disk buffer queue (only applicable for egress bridges).<br/>When Enabled, messages will be buffered on disk when the bridge connection is down.<br/>When disabled the messages are buffered in RAM only.",
            "summary": "Enable disk buffer queue",
            "type": "boolean"
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB",
            "summary": "Max buffer queue size",
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge_clickhouse.put": {
        "required": [
          "database",
          "url"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "sql": {
            "default": "INSERT INTO mqtt_test(payload, arrived) VALUES ('${payload}', ${timestamp})",
            "description": "The template string can contain ${field} placeholders for message metadata and payload field. Make sure that the inserted values are formatted and escaped correctly. [Prepared Statement](https://docs.emqx.com/en/enterprise/v5.0/data-integration/data-bridges.html#Prepared-Statement) is not supported.",
            "format": "sql",
            "summary": "SQL Template",
            "type": "string"
          },
          "batch_value_separator": {
            "default": ", ",
            "description": "The default value ',' works for the VALUES format. You can also use other separator if other format is specified. See [INSERT INTO Statement](https://clickhouse.com/docs/en/sql-reference/statements/insert-into).",
            "summary": "Batch Value Separator",
            "type": "string"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to Clickhouse. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/bridge_clickhouse.creation_opts"
          },
          "url": {
            "description": "The HTTP URL to the Clickhouse server that you want to connect to (for example http://myhostname:8123)",
            "example": "http://127.0.0.1",
            "summary": "Server URL",
            "type": "string"
          },
          "connect_timeout": {
            "default": "15s",
            "description": "The timeout when connecting to the Clickhouse server.",
            "example": "32s",
            "summary": "Clickhouse Timeout",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "listeners.wss_required_bind": {
        "required": [
          "bind",
          "id",
          "type"
        ],
        "properties": {
          "type": {
            "description": "Listener type",
            "enum": [
              "wss"
            ],
            "type": "string"
          },
          "running": {
            "description": "Listener status",
            "type": "boolean"
          },
          "id": {
            "description": "Listener id",
            "type": "string"
          },
          "current_connections": {
            "description": "Current connections",
            "minimum": 0,
            "type": "integer"
          },
          "enabled": {
            "default": true,
            "description": "Enable listener.",
            "summary": "Enable listener",
            "type": "boolean"
          },
          "bind": {
            "default": 8084,
            "description": "IP address and port for the listening socket.",
            "summary": "IP address and port",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "acceptors": {
            "default": 16,
            "description": "The size of the listener's receiving pool.",
            "minimum": 1,
            "summary": "Acceptors Num",
            "type": "integer"
          },
          "max_connections": {
            "default": 5000000,
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "summary": "Max connections",
            "oneOf": [
              {
                "minimum": 1,
                "type": "integer"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message<br/>is delivered to the subscriber. The mountpoint is a way that users can use<br/>to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`<br/>set to `some_tenant`, then the client actually subscribes to the topic<br/>`some_tenant/t`. Similarly, if another client B (connected to the same listener<br/>as the client A) sends a message to topic `t`, the message is routed<br/>to all the clients subscribed `some_tenant/t`, so client A will receive the<br/>message, with topic name `t`.<br/><br/>Set to `\"\"` to disable the feature.<br/><br/><br/>Variables in mountpoint string:<br/>  - <code>${clientid}</code>: clientid<br/>  - <code>${username}</code>: username",
            "summary": "mountpoint",
            "type": "string"
          },
          "zone": {
            "default": "default",
            "description": "The configuration zone to which the listener belongs.",
            "summary": "Zone",
            "type": "string"
          },
          "limiter": {
            "description": "Type of the rate limit.",
            "summary": "Type of the rate limit.",
            "$ref": "#/components/schemas/limiter.listener_fields"
          },
          "enable_authn": {
            "default": true,
            "description": "Set <code>true</code> (default) to enable client authentication on this listener, the authentication<br/>process goes through the configured authentication chain.<br/>When set to <code>false</code> to allow any clients with or without authentication information such as username or password to log in.<br/>When set to <code>quick_deny_anonymous</code>, it behaves like when set to <code>true</code>, but clients will be<br/>denied immediately without going through any authenticators if <code>username</code> is not provided. This is useful to fence off<br/>anonymous clients early.",
            "enum": [
              true,
              false,
              "quick_deny_anonymous"
            ],
            "summary": "Enable authentication",
            "type": "string"
          },
          "access_rules": {
            "default": [
              "allow all"
            ],
            "description": "The access control rules for this listener.<br/>See: https://github.com/emqtt/esockd#allowdeny",
            "items": {
              "type": "string"
            },
            "summary": "Access rules",
            "type": "array"
          },
          "proxy_protocol": {
            "default": false,
            "description": "Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.<br/><br/>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/",
            "summary": "Proxy protocol",
            "type": "boolean"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "description": "Timeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.",
            "example": "12m",
            "summary": "Proxy protocol timeout",
            "type": "string"
          },
          "tcp_options": {
            "$ref": "#/components/schemas/broker.tcp_opts"
          },
          "ssl_options": {
            "$ref": "#/components/schemas/broker.listener_wss_opts"
          },
          "websocket": {
            "$ref": "#/components/schemas/broker.ws_opts"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_schema.built_in_database": {
        "required": [
          "type"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this ACL provider.",
            "summary": "enable",
            "type": "boolean"
          },
          "type": {
            "default": "built_in_database",
            "description": "Backend type.",
            "enum": [
              "built_in_database"
            ],
            "summary": "type",
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge_mongodb.put_rs": {
        "required": [
          "database",
          "replica_set_name",
          "servers"
        ],
        "properties": {
          "mongo_type": {
            "default": "rs",
            "description": "Replica set. Must be set to 'rs' when MongoDB server is running in 'replica set' mode.",
            "enum": [
              "rs"
            ],
            "summary": "Replica set",
            "type": "string"
          },
          "servers": {
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The MongoDB default port 27017 is used if `[:Port]` is not specified.",
            "summary": "Servers",
            "type": "string"
          },
          "w_mode": {
            "default": "unsafe",
            "description": "Write mode.",
            "enum": [
              "unsafe",
              "safe"
            ],
            "summary": "Write Mode",
            "type": "string"
          },
          "r_mode": {
            "default": "master",
            "description": "Read mode.",
            "enum": [
              "master",
              "slave_ok"
            ],
            "summary": "Read Mode",
            "type": "string"
          },
          "replica_set_name": {
            "description": "Name of the replica set.",
            "summary": "Replica Set Name",
            "type": "string"
          },
          "srv_record": {
            "default": false,
            "description": "Use DNS SRV record.",
            "summary": "Srv Record",
            "type": "boolean"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auth_source": {
            "description": "Database name associated with the user's credentials.",
            "summary": "Auth Source",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "topology": {
            "$ref": "#/components/schemas/emqx_connector_mongo.topology"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable this MongoDB Bridge",
            "summary": "Enable or disable",
            "type": "boolean"
          },
          "collection": {
            "default": "mqtt",
            "description": "The collection where data will be stored into",
            "summary": "Collection to be used",
            "type": "string"
          },
          "payload_template": {
            "description": "The template for formatting the outgoing messages.  If undefined, rule engine will use JSON format to serialize all visible inputs, such as clientid, topic, payload etc.",
            "summary": "Payload template",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_stats.node_stats_data": {
        "properties": {
          "channels.count": {
            "description": "sessions.count",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "channels.max": {
            "description": "session.max",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "connections.count": {
            "description": "Number of current connections",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "connections.max": {
            "description": "Historical maximum number of connections",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "delayed.count": {
            "description": "Number of delayed messages",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "delayed.max": {
            "description": "Historical maximum number of delayed messages",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "live_connections.count": {
            "description": "Number of current live connections",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "live_connections.max": {
            "description": "Historical maximum number of live connections",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "retained.count": {
            "description": "Number of currently retained messages",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "retained.max": {
            "description": "Historical maximum number of retained messages",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "sessions.count": {
            "description": "Number of current sessions",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "sessions.max": {
            "description": "Historical maximum number of sessions",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "suboptions.count": {
            "description": "subscriptions.count",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "suboptions.max": {
            "description": "subscriptions.max",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "subscribers.count": {
            "description": "Number of current subscribers",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "subscribers.max": {
            "description": "Historical maximum number of subscribers",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "subscriptions.count": {
            "description": "Number of current subscriptions, including shared subscriptions",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "subscriptions.max": {
            "description": "Historical maximum number of subscriptions",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "subscriptions.shared.count": {
            "description": "Number of current shared subscriptions",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "subscriptions.shared.max": {
            "description": "Historical maximum number of shared subscriptions",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "topics.count": {
            "description": "Number of current topics",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "topics.max": {
            "description": "Historical maximum number of topics",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "emqx_rule_api_schema.rule_info": {
        "required": [
          "id",
          "sql"
        ],
        "properties": {
          "id": {
            "description": "The ID of the rule",
            "example": "293fb66f",
            "summary": "Rule ID",
            "type": "string"
          },
          "from": {
            "description": "The topics of the rule",
            "example": "t/#",
            "items": {
              "type": "string"
            },
            "summary": "Topics of Rule",
            "type": "array"
          },
          "created_at": {
            "description": "The created time of the rule",
            "example": "2021-12-01T15:00:43.153+08:00",
            "summary": "Rule Create Time",
            "type": "string"
          },
          "name": {
            "default": "",
            "description": "The name of the rule",
            "example": "foo",
            "summary": "Rule Name",
            "type": "string"
          },
          "sql": {
            "description": "SQL query to transform the messages.<br/>Example: <code>SELECT * FROM \"test/topic\" WHERE payload.x = 1</code>",
            "example": "SELECT * FROM \"test/topic\" WHERE payload.x = 1",
            "summary": "Rule SQL",
            "type": "string"
          },
          "actions": {
            "default": "",
            "description": "A list of actions of the rule.<br/>An action can be a string that refers to the channel ID of an EMQX bridge, or an object<br/>that refers to a function.<br/>There a some built-in functions like \"republish\" and \"console\", and we also support user<br/>provided functions in the format: \"{module}:{function}\".<br/>The actions in the list are executed sequentially.<br/>This means that if one of the action is executing slowly, all the following actions will not<br/>be executed until it returns.<br/>If one of the action crashed, all other actions come after it will still be executed, in the<br/>original order.<br/>If there's any error when running an action, there will be an error message, and the 'failure'<br/>counter of the function action or the bridge channel will increase.",
            "example": [
              "webhook:my_webhook",
              {
                "args": {
                  "payload": "${payload}",
                  "topic": "t/1"
                },
                "function": "republish"
              },
              {
                "function": "console"
              }
            ],
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/rule_engine.user_provided_function"
                },
                {
                  "$ref": "#/components/schemas/rule_engine.builtin_action_console"
                },
                {
                  "$ref": "#/components/schemas/rule_engine.builtin_action_republish"
                },
                {
                  "type": "string"
                }
              ]
            },
            "summary": "Rule Action List",
            "type": "array"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable the rule",
            "summary": "Enable Or Disable Rule",
            "type": "boolean"
          },
          "description": {
            "default": "",
            "description": "The description of the rule",
            "example": "Some description",
            "summary": "Rule Description",
            "type": "string"
          },
          "metadata": {
            "description": "Rule metadata, do not change manually",
            "example": {},
            "summary": "Rule metadata",
            "type": "object"
          }
        },
        "type": "object"
      },
      "rule_engine.republish_args": {
        "required": [
          "topic"
        ],
        "properties": {
          "topic": {
            "description": "The target topic of message to be re-published.<br/>Template with variables is allowed, see description of the 'republish_args'.",
            "example": "a/1",
            "summary": "Target Topic",
            "type": "string"
          },
          "qos": {
            "default": "${qos}",
            "description": "The qos of the message to be re-published.<br/>Template with variables is allowed, see description of the 'republish_args'.<br/>Defaults to ${qos}. If variable ${qos} is not found from the selected result of the rule,<br/>0 is used.",
            "example": "${qos}",
            "summary": "Message QoS",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "example": 0,
                "maximum": 2,
                "minimum": 0,
                "type": "integer"
              }
            ]
          },
          "retain": {
            "default": "${retain}",
            "description": "The 'retain' flag of the message to be re-published.<br/>Template with variables is allowed, see description of the 'republish_args'.<br/>Defaults to ${retain}. If variable ${retain} is not found from the selected result<br/>of the rule, false is used.",
            "example": "${retain}",
            "summary": "Retain Flag",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "boolean"
              }
            ]
          },
          "payload": {
            "default": "${payload}",
            "description": "The payload of the message to be re-published.<br/>Template with variables is allowed, see description of the 'republish_args'.<br/>Defaults to ${payload}. If variable ${payload} is not found from the selected result<br/>of the rule, then the string \"undefined\" is used.",
            "example": "${payload}",
            "summary": "Message Payload",
            "type": "string"
          },
          "user_properties": {
            "default": "${user_properties}",
            "description": "From which variable should the MQTT message's User-Property pairs be taken from.<br/>The value must be a map.<br/>You may configure it to <code>${pub_props.'User-Property'}</code> or<br/>use <code>SELECT *,pub_props.'User-Property' as user_properties</code><br/>to forward the original user properties to the republished message.<br/>You may also call <code>map_put</code> function like<br/><code>map_put('my-prop-name', 'my-prop-value', user_properties) as user_properties</code><br/>to inject user properties.<br/>NOTE: MQTT spec allows duplicated user property names, but EMQX Rule-Engine does not.",
            "example": "${pub_props.'User-Property'}",
            "type": "string"
          }
        },
        "type": "object"
      },
      "authz.node_metrics": {
        "properties": {
          "node": {
            "description": "Node name.",
            "example": "emqx@127.0.0.1",
            "summary": "Node Name.",
            "type": "string"
          },
          "metrics": {
            "description": "The metrics of the resource.",
            "summary": "Metrics",
            "$ref": "#/components/schemas/authz.metrics"
          }
        },
        "type": "object"
      },
      "emqx_rule_api_schema.metrics": {
        "properties": {
          "matched": {
            "description": "How much times the FROM clause of the SQL is matched.",
            "minimum": 0,
            "summary": "Matched",
            "type": "integer"
          },
          "matched.rate": {
            "description": "The rate of matched, times/second",
            "summary": "命中速率",
            "type": "number"
          },
          "matched.rate.max": {
            "description": "The max rate of matched, times/second",
            "summary": "Max Matched Rate",
            "type": "number"
          },
          "matched.rate.last5m": {
            "description": "The average rate of matched in last 5 minutes, times/second",
            "summary": "Average Matched Rate",
            "type": "number"
          },
          "passed": {
            "description": "How much times the SQL is passed",
            "minimum": 0,
            "summary": "SQL Passed",
            "type": "integer"
          },
          "failed": {
            "description": "How much times the SQL is failed",
            "minimum": 0,
            "summary": "SQL Failed",
            "type": "integer"
          },
          "failed.exception": {
            "description": "How much times the SQL is failed due to exceptions. This may because of a crash when calling a SQL function, or trying to do arithmetic operation on undefined variables",
            "minimum": 0,
            "summary": "SQL Exception",
            "type": "integer"
          },
          "failed.unknown": {
            "description": "How much times the SQL is failed due to an unknown error.",
            "minimum": 0,
            "summary": "SQL Unknown Error",
            "type": "integer"
          },
          "actions.total": {
            "description": "How much times the actions are called by the rule. This value may several times of 'matched', depending on the number of the actions of the rule.",
            "minimum": 0,
            "summary": "Action Total",
            "type": "integer"
          },
          "actions.success": {
            "description": "How much times the rule success to call the actions.",
            "minimum": 0,
            "summary": "Success Action",
            "type": "integer"
          },
          "actions.failed": {
            "description": "How much times the rule failed to call the actions.",
            "minimum": 0,
            "summary": "Failed Action",
            "type": "integer"
          },
          "actions.failed.out_of_service": {
            "description": "How much times the rule failed to call actions due to the action is out of service. For example, a bridge is disabled or stopped.",
            "minimum": 0,
            "summary": "Fail Action",
            "type": "integer"
          },
          "actions.failed.unknown": {
            "description": "How much times the rule failed to call actions due to to an unknown error.",
            "minimum": 0,
            "summary": "Fail Action",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "bridge.metrics": {
        "properties": {
          "dropped": {
            "description": "Count of messages dropped.",
            "summary": "Dropped",
            "type": "integer"
          },
          "dropped.other": {
            "description": "Count of messages dropped due to other reasons.",
            "summary": "Dropped Other",
            "type": "integer"
          },
          "dropped.queue_full": {
            "description": "Count of messages dropped due to the queue is full.",
            "summary": "Dropped Queue Full",
            "type": "integer"
          },
          "dropped.resource_not_found": {
            "description": "Count of messages dropped due to the resource is not found.",
            "summary": "Dropped Resource NotFound",
            "type": "integer"
          },
          "dropped.resource_stopped": {
            "description": "Count of messages dropped due to the resource is stopped.",
            "summary": "Dropped Resource Stopped",
            "type": "integer"
          },
          "matched": {
            "description": "Count of this bridge is matched and queried.",
            "summary": "Matched",
            "type": "integer"
          },
          "queuing": {
            "description": "Count of messages that are currently queuing.",
            "summary": "Queued",
            "type": "integer"
          },
          "retried": {
            "description": "Times of retried.",
            "summary": "Retried",
            "type": "integer"
          },
          "failed": {
            "description": "Count of messages that sent failed.",
            "summary": "Sent Failed",
            "type": "integer"
          },
          "inflight": {
            "description": "Count of messages that were sent asynchronously but ACKs are not yet received.",
            "summary": "Sent Inflight",
            "type": "integer"
          },
          "success": {
            "description": "Count of messages that sent successfully.",
            "summary": "Sent Success",
            "type": "integer"
          },
          "rate": {
            "description": "The rate of matched, times/second",
            "summary": "Rate",
            "type": "number"
          },
          "rate_max": {
            "description": "The max rate of matched, times/second",
            "summary": "Max Rate Of Matched",
            "type": "number"
          },
          "rate_last5m": {
            "description": "The average rate of matched in the last 5 minutes, times/second",
            "summary": "Last 5 Minutes Rate",
            "type": "number"
          },
          "received": {
            "description": "Count of messages that is received from the remote system.",
            "summary": "Received",
            "type": "number"
          }
        },
        "type": "object"
      },
      "emqx_rule_api_schema.ctx_acked": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "description": "Event Type",
            "enum": [
              "message_acked"
            ],
            "summary": "Event Type",
            "type": "string"
          },
          "id": {
            "description": "Message ID",
            "summary": "Message ID",
            "type": "string"
          },
          "from_clientid": {
            "description": "The Client ID",
            "summary": "Client ID",
            "type": "string"
          },
          "from_username": {
            "description": "The User Name",
            "summary": "Username",
            "type": "string"
          },
          "clientid": {
            "description": "The Client ID",
            "summary": "Client ID",
            "type": "string"
          },
          "username": {
            "description": "Username",
            "summary": "Username",
            "type": "string"
          },
          "payload": {
            "description": "The Message Payload",
            "summary": "Message Payload",
            "type": "string"
          },
          "peerhost": {
            "description": "The IP Address of the Peer Client",
            "summary": "Peer IP Address",
            "type": "string"
          },
          "topic": {
            "description": "Message Topic",
            "summary": "Message Topic",
            "type": "string"
          },
          "publish_received_at": {
            "description": "The Time that this Message is Received",
            "summary": "Message Received Time",
            "type": "integer"
          },
          "qos": {
            "description": "The Message QoS",
            "example": 0,
            "maximum": 2,
            "minimum": 0,
            "summary": "Message QoS",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "dashboard.error_code": {
        "properties": {
          "code": {
            "description": "Code Name",
            "type": "string"
          },
          "description": {
            "description": "Description",
            "type": "string"
          }
        },
        "type": "object"
      },
      "listeners.wss_not_required_bind": {
        "required": [
          "id",
          "type"
        ],
        "properties": {
          "type": {
            "description": "Listener type",
            "enum": [
              "wss"
            ],
            "type": "string"
          },
          "running": {
            "description": "Listener status",
            "type": "boolean"
          },
          "id": {
            "description": "Listener id",
            "type": "string"
          },
          "current_connections": {
            "description": "Current connections",
            "minimum": 0,
            "type": "integer"
          },
          "bind": {
            "default": 8084,
            "description": "IP address and port for the listening socket.",
            "summary": "IP address and port",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "enabled": {
            "default": true,
            "description": "Enable listener.",
            "summary": "Enable listener",
            "type": "boolean"
          },
          "acceptors": {
            "default": 16,
            "description": "The size of the listener's receiving pool.",
            "minimum": 1,
            "summary": "Acceptors Num",
            "type": "integer"
          },
          "max_connections": {
            "default": 5000000,
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "summary": "Max connections",
            "oneOf": [
              {
                "minimum": 1,
                "type": "integer"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message<br/>is delivered to the subscriber. The mountpoint is a way that users can use<br/>to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`<br/>set to `some_tenant`, then the client actually subscribes to the topic<br/>`some_tenant/t`. Similarly, if another client B (connected to the same listener<br/>as the client A) sends a message to topic `t`, the message is routed<br/>to all the clients subscribed `some_tenant/t`, so client A will receive the<br/>message, with topic name `t`.<br/><br/>Set to `\"\"` to disable the feature.<br/><br/><br/>Variables in mountpoint string:<br/>  - <code>${clientid}</code>: clientid<br/>  - <code>${username}</code>: username",
            "summary": "mountpoint",
            "type": "string"
          },
          "zone": {
            "default": "default",
            "description": "The configuration zone to which the listener belongs.",
            "summary": "Zone",
            "type": "string"
          },
          "limiter": {
            "description": "Type of the rate limit.",
            "summary": "Type of the rate limit.",
            "$ref": "#/components/schemas/limiter.listener_fields"
          },
          "enable_authn": {
            "default": true,
            "description": "Set <code>true</code> (default) to enable client authentication on this listener, the authentication<br/>process goes through the configured authentication chain.<br/>When set to <code>false</code> to allow any clients with or without authentication information such as username or password to log in.<br/>When set to <code>quick_deny_anonymous</code>, it behaves like when set to <code>true</code>, but clients will be<br/>denied immediately without going through any authenticators if <code>username</code> is not provided. This is useful to fence off<br/>anonymous clients early.",
            "enum": [
              true,
              false,
              "quick_deny_anonymous"
            ],
            "summary": "Enable authentication",
            "type": "string"
          },
          "access_rules": {
            "default": [
              "allow all"
            ],
            "description": "The access control rules for this listener.<br/>See: https://github.com/emqtt/esockd#allowdeny",
            "items": {
              "type": "string"
            },
            "summary": "Access rules",
            "type": "array"
          },
          "proxy_protocol": {
            "default": false,
            "description": "Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.<br/><br/>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/",
            "summary": "Proxy protocol",
            "type": "boolean"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "description": "Timeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.",
            "example": "12m",
            "summary": "Proxy protocol timeout",
            "type": "string"
          },
          "tcp_options": {
            "$ref": "#/components/schemas/broker.tcp_opts"
          },
          "ssl_options": {
            "$ref": "#/components/schemas/broker.listener_wss_opts"
          },
          "websocket": {
            "$ref": "#/components/schemas/broker.ws_opts"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_schema.postgresql": {
        "required": [
          "database",
          "query",
          "server",
          "type"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this ACL provider.",
            "summary": "enable",
            "type": "boolean"
          },
          "type": {
            "default": "postgresql",
            "description": "Backend type.",
            "enum": [
              "postgresql"
            ],
            "summary": "type",
            "type": "string"
          },
          "query": {
            "description": "Database query used to retrieve authorization data.",
            "summary": "query",
            "type": "string"
          },
          "server": {
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The PostgreSQL default port 5432 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_metrics.aggregated_metrics": {
        "properties": {
          "actions.failure": {
            "description": "Number of failure executions of the rule engine action",
            "minimum": 0,
            "type": "integer"
          },
          "actions.success": {
            "description": "Number of successful executions of the rule engine action",
            "minimum": 0,
            "type": "integer"
          },
          "bytes.received": {
            "description": "Number of bytes received ",
            "minimum": 0,
            "type": "integer"
          },
          "bytes.sent": {
            "description": "Number of bytes sent on this connection",
            "minimum": 0,
            "type": "integer"
          },
          "client.auth.anonymous": {
            "description": "Number of clients who log in anonymously",
            "minimum": 0,
            "type": "integer"
          },
          "client.authenticate": {
            "description": "Number of client authentications",
            "minimum": 0,
            "type": "integer"
          },
          "client.check_authz": {
            "description": "Number of Authorization rule checks",
            "minimum": 0,
            "type": "integer"
          },
          "client.connack": {
            "description": "Number of CONNACK packet sent",
            "minimum": 0,
            "type": "integer"
          },
          "client.connect": {
            "description": "Number of client connections",
            "minimum": 0,
            "type": "integer"
          },
          "client.connected": {
            "description": "Number of successful client connections",
            "minimum": 0,
            "type": "integer"
          },
          "client.disconnected": {
            "description": "Number of client disconnects",
            "minimum": 0,
            "type": "integer"
          },
          "client.subscribe": {
            "description": "Number of client subscriptions",
            "minimum": 0,
            "type": "integer"
          },
          "client.unsubscribe": {
            "description": "Number of client unsubscriptions",
            "minimum": 0,
            "type": "integer"
          },
          "delivery.dropped": {
            "description": "Total number of discarded messages when sending",
            "minimum": 0,
            "type": "integer"
          },
          "delivery.dropped.expired": {
            "description": "Number of messages dropped due to message expiration on sending",
            "minimum": 0,
            "type": "integer"
          },
          "delivery.dropped.no_local": {
            "description": "Number of messages that were dropped due to the No Local subscription option when sending",
            "minimum": 0,
            "type": "integer"
          },
          "delivery.dropped.qos0_msg": {
            "description": "Number of messages with QoS 0 that were dropped because the message queue was full when sending",
            "minimum": 0,
            "type": "integer"
          },
          "delivery.dropped.queue_full": {
            "description": "Number of messages with a non-zero QoS that were dropped because the message queue was full when sending",
            "minimum": 0,
            "type": "integer"
          },
          "delivery.dropped.too_large": {
            "description": "The number of messages that were dropped because the length exceeded the limit when sending",
            "minimum": 0,
            "type": "integer"
          },
          "messages.acked": {
            "description": "Number of received PUBACK and PUBREC packet",
            "minimum": 0,
            "type": "integer"
          },
          "messages.delayed": {
            "description": "Number of delay-published messages",
            "minimum": 0,
            "type": "integer"
          },
          "messages.delivered": {
            "description": "Number of messages forwarded to the subscription process internally",
            "minimum": 0,
            "type": "integer"
          },
          "messages.dropped": {
            "description": "Total number of messages dropped before forwarding to the subscription process",
            "minimum": 0,
            "type": "integer"
          },
          "messages.dropped.await_pubrel_timeout": {
            "description": "Number of messages dropped due to waiting PUBREL timeout",
            "minimum": 0,
            "type": "integer"
          },
          "messages.dropped.no_subscribers": {
            "description": "Number of messages dropped due to no subscribers",
            "minimum": 0,
            "type": "integer"
          },
          "messages.forward": {
            "description": "Number of messages forwarded to other nodes",
            "minimum": 0,
            "type": "integer"
          },
          "messages.publish": {
            "description": "Number of messages published in addition to system messages",
            "minimum": 0,
            "type": "integer"
          },
          "messages.qos0.received": {
            "description": "Number of QoS 0 messages received from clients",
            "minimum": 0,
            "type": "integer"
          },
          "messages.qos0.sent": {
            "description": "Number of QoS 0 messages sent to clients",
            "minimum": 0,
            "type": "integer"
          },
          "messages.qos1.received": {
            "description": "Number of QoS 1 messages received from clients",
            "minimum": 0,
            "type": "integer"
          },
          "messages.qos1.sent": {
            "description": "Number of QoS 1 messages sent to clients",
            "minimum": 0,
            "type": "integer"
          },
          "messages.qos2.received": {
            "description": "Number of QoS 2 messages received from clients",
            "minimum": 0,
            "type": "integer"
          },
          "messages.qos2.sent": {
            "description": "Number of QoS 2 messages sent to clients",
            "minimum": 0,
            "type": "integer"
          },
          "messages.received": {
            "description": "Number of messages received from the client, equal to the sum of messages.qos0.received\fmessages.qos1.received and messages.qos2.received",
            "minimum": 0,
            "type": "integer"
          },
          "messages.retained": {
            "description": "Number of retained messages",
            "minimum": 0,
            "type": "integer"
          },
          "messages.sent": {
            "description": "Number of messages sent to the client, equal to the sum of messages.qos0.sent\fmessages.qos1.sent and messages.qos2.sent",
            "minimum": 0,
            "type": "integer"
          },
          "packets.auth.received": {
            "description": "Number of received AUTH packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.auth.sent": {
            "description": "Number of sent AUTH packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.connack.auth_error": {
            "description": "Number of received CONNECT packet with failed authentication",
            "minimum": 0,
            "type": "integer"
          },
          "packets.connack.error": {
            "description": "Number of received CONNECT packet with unsuccessful connections",
            "minimum": 0,
            "type": "integer"
          },
          "packets.connack.sent": {
            "description": "Number of sent CONNACK packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.connect.received": {
            "description": "Number of received CONNECT packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.disconnect.received": {
            "description": "Number of received DISCONNECT packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.disconnect.sent": {
            "description": "Number of sent DISCONNECT packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pingreq.received": {
            "description": "Number of received PINGREQ packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pingresp.sent": {
            "description": "Number of sent PUBRESP packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.puback.inuse": {
            "description": "Number of received PUBACK packet with occupied identifiers",
            "minimum": 0,
            "type": "integer"
          },
          "packets.puback.missed": {
            "description": "Number of received packet with identifiers.",
            "minimum": 0,
            "type": "integer"
          },
          "packets.puback.received": {
            "description": "Number of received PUBACK packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.puback.sent": {
            "description": "Number of sent PUBACK packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubcomp.inuse": {
            "description": "Number of received PUBCOMP packet with occupied identifiers",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubcomp.missed": {
            "description": "Number of missed PUBCOMP packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubcomp.received": {
            "description": "Number of received PUBCOMP packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubcomp.sent": {
            "description": "Number of sent PUBCOMP packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.publish.auth_error": {
            "description": "Number of received PUBLISH packets with failed the Authorization check",
            "minimum": 0,
            "type": "integer"
          },
          "packets.publish.dropped": {
            "description": "Number of messages discarded due to the receiving limit",
            "minimum": 0,
            "type": "integer"
          },
          "packets.publish.error": {
            "description": "Number of received PUBLISH packet that cannot be published",
            "minimum": 0,
            "type": "integer"
          },
          "packets.publish.inuse": {
            "description": "Number of received PUBLISH packet with occupied identifiers",
            "minimum": 0,
            "type": "integer"
          },
          "packets.publish.received": {
            "description": "Number of received PUBLISH packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.publish.sent": {
            "description": "Number of sent PUBLISH packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubrec.inuse": {
            "description": "Number of received PUBREC packet with occupied identifiers",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubrec.missed": {
            "description": "Number of received PUBREC packet with unknown identifiers",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubrec.received": {
            "description": "Number of received PUBREC packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubrec.sent": {
            "description": "Number of sent PUBREC packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubrel.missed": {
            "description": "Number of received PUBREC packet with unknown identifiers",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubrel.received": {
            "description": "Number of received PUBREL packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubrel.sent": {
            "description": "Number of sent PUBREL packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.received": {
            "description": "Number of received packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.sent": {
            "description": "Number of sent packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.suback.sent": {
            "description": "Number of sent SUBACK packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.subscribe.auth_error": {
            "description": "Number of received SUBACK packet with failed Authorization check",
            "minimum": 0,
            "type": "integer"
          },
          "packets.subscribe.error": {
            "description": "Number of received SUBSCRIBE packet with failed subscriptions",
            "minimum": 0,
            "type": "integer"
          },
          "packets.subscribe.received": {
            "description": "Number of received SUBSCRIBE packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.unsuback.sent": {
            "description": "Number of sent UNSUBACK packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.unsubscribe.error": {
            "description": "Number of received UNSUBSCRIBE packet with failed unsubscriptions",
            "minimum": 0,
            "type": "integer"
          },
          "packets.unsubscribe.received": {
            "description": "Number of received UNSUBSCRIBE packet",
            "minimum": 0,
            "type": "integer"
          },
          "rules.matched": {
            "description": "Number of rule matched",
            "minimum": 0,
            "type": "integer"
          },
          "session.created": {
            "description": "Number of sessions created",
            "minimum": 0,
            "type": "integer"
          },
          "session.discarded": {
            "description": "Number of sessions dropped because Clean Session or Clean Start is true",
            "minimum": 0,
            "type": "integer"
          },
          "session.resumed": {
            "description": "Number of sessions resumed because Clean Session or Clean Start is false",
            "minimum": 0,
            "type": "integer"
          },
          "session.takenover": {
            "description": "Number of sessions takenover because Clean Session or Clean Start is false",
            "minimum": 0,
            "type": "integer"
          },
          "session.terminated": {
            "description": "Number of terminated sessions",
            "minimum": 0,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "bridge_influxdb.get_api_v1": {
        "required": [
          "database",
          "name",
          "type",
          "write_syntax"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to the InfluxDB. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "write_syntax": {
            "description": "Conf of InfluxDB line protocol to write data points. It is a text-based format that provides the measurement, tag set, field set, and timestamp of a data point, and placeholder supported.<br/>See also [InfluxDB 2.3 Line Protocol](https://docs.influxdata.com/influxdb/v2.3/reference/syntax/line-protocol/) and<br/>[InfluxDB 1.8 Line Protocol](https://docs.influxdata.com/influxdb/v1.8/write_protocols/line_protocol_tutorial/) </br><br/>TLDR:</br><br/>```<br/><measurement>[,<tag_key>=<tag_value>[,<tag_key>=<tag_value>]] <field_key>=<field_value>[,<field_key>=<field_value>] [<timestamp>]<br/>```<br/>Please note that a placeholder for an integer value must be annotated with a suffix `i`. For example `${payload.int_value}i`.",
            "example": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,bool=${payload.bool}",
            "format": "sql",
            "summary": "Write Syntax",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "default": "127.0.0.1:8086",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.</br><br/>A host entry has the following form: `Host[:Port]`.</br><br/>The InfluxDB default port 8086 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "precision": {
            "default": "ms",
            "description": "InfluxDB time precision.",
            "enum": [
              "ns",
              "us",
              "ms",
              "s"
            ],
            "summary": "Time Precision",
            "type": "string"
          },
          "database": {
            "description": "InfluxDB database.",
            "summary": "Database",
            "type": "string"
          },
          "username": {
            "description": "InfluxDB username.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "InfluxDB password.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          },
          "type": {
            "description": "The Bridge Type.",
            "enum": [
              "influxdb_api_v1"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name.",
            "summary": "Bridge Name",
            "type": "string"
          },
          "status": {
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status.",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary": "Bridge Status",
            "type": "string"
          },
          "status_reason": {
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused",
            "summary": "Failure reason",
            "type": "string"
          },
          "node_status": {
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            },
            "summary": "Node Status",
            "type": "array"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_schema.redis_cluster": {
        "required": [
          "cmd",
          "servers",
          "type"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this ACL provider.",
            "summary": "enable",
            "type": "boolean"
          },
          "type": {
            "default": "redis",
            "description": "Backend type.",
            "enum": [
              "redis"
            ],
            "summary": "type",
            "type": "string"
          },
          "cmd": {
            "description": "Database query used to retrieve authorization data.",
            "example": "HGETALL mqtt_authz",
            "summary": "cmd",
            "type": "string"
          },
          "servers": {
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The Redis default port 6379 is used if `[:Port]` is not specified.",
            "summary": "Servers",
            "type": "string"
          },
          "redis_type": {
            "default": "cluster",
            "description": "Cluster mode. Must be set to 'cluster' when Redis server is running in clustered mode.",
            "enum": [
              "cluster"
            ],
            "summary": "Cluster Mode",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "bridge_mysql.put": {
        "required": [
          "database",
          "server"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "sql": {
            "default": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, FROM_UNIXTIME(${timestamp}/1000))",
            "description": "SQL Template",
            "format": "sql",
            "summary": "SQL Template",
            "type": "string"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to MySQL. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The MySQL default port 3306 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "default": "root",
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "connector-http.request": {
        "properties": {
          "method": {
            "description": "HTTP method.",
            "summary": "HTTP Method",
            "type": "string"
          },
          "path": {
            "description": "URL path.",
            "summary": "URL Path",
            "type": "string"
          },
          "body": {
            "description": "HTTP request body.",
            "summary": "HTTP Body",
            "type": "string"
          },
          "headers": {
            "description": "List of HTTP headers.",
            "example": {},
            "summary": "HTTP Headers",
            "type": "object"
          },
          "max_retries": {
            "description": "Max retry times if error on sending request.",
            "minimum": 0,
            "summary": "Max Retries",
            "type": "integer"
          },
          "request_timeout": {
            "description": "HTTP request timeout.",
            "example": "32s",
            "summary": "Request Timeout",
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge_mongodb.post_sharded": {
        "required": [
          "database",
          "name",
          "servers",
          "type"
        ],
        "properties": {
          "mongo_type": {
            "default": "sharded",
            "description": "Sharded cluster. Must be set to 'sharded' when MongoDB server is running in 'sharded' mode.",
            "enum": [
              "sharded"
            ],
            "summary": "Sharded cluster",
            "type": "string"
          },
          "servers": {
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The MongoDB default port 27017 is used if `[:Port]` is not specified.",
            "summary": "Servers",
            "type": "string"
          },
          "w_mode": {
            "default": "unsafe",
            "description": "Write mode.",
            "enum": [
              "unsafe",
              "safe"
            ],
            "summary": "Write Mode",
            "type": "string"
          },
          "srv_record": {
            "default": false,
            "description": "Use DNS SRV record.",
            "summary": "Srv Record",
            "type": "boolean"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auth_source": {
            "description": "Database name associated with the user's credentials.",
            "summary": "Auth Source",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "topology": {
            "$ref": "#/components/schemas/emqx_connector_mongo.topology"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable this MongoDB Bridge",
            "summary": "Enable or disable",
            "type": "boolean"
          },
          "collection": {
            "default": "mqtt",
            "description": "The collection where data will be stored into",
            "summary": "Collection to be used",
            "type": "string"
          },
          "payload_template": {
            "description": "The template for formatting the outgoing messages.  If undefined, rule engine will use JSON format to serialize all visible inputs, such as clientid, topic, payload etc.",
            "summary": "Payload template",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "type": {
            "description": "The Bridge Type.",
            "enum": [
              "mongodb_sharded"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name.",
            "summary": "Bridge Name",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_banned.ban": {
        "required": [
          "as",
          "who"
        ],
        "properties": {
          "as": {
            "description": "Ban method, which can be client ID, username or IP address.",
            "enum": [
              "clientid",
              "username",
              "peerhost"
            ],
            "example": "username",
            "summary": "Ban Method",
            "type": "string"
          },
          "who": {
            "description": "Ban object, specific client ID, username or IP address.",
            "example": "Banned name",
            "summary": "Ban Object",
            "type": "string"
          },
          "by": {
            "description": "Initiator of the ban.",
            "example": "mgmt_api",
            "summary": "Ban Initiator",
            "type": "string"
          },
          "reason": {
            "description": "Ban reason, record the reason why the current object was banned.",
            "example": "Too many requests",
            "summary": "Ban Reason",
            "type": "string"
          },
          "at": {
            "description": "The start time of the ban, the format is rfc3339, the default is the time when the operation was initiated.",
            "example": "2021-10-25T21:48:47+08:00",
            "summary": "Ban Time",
            "oneOf": [
              {
                "description": "epoch-second",
                "example": 1640995200,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "until": {
            "description": "The end time of the ban, the format is rfc3339, the default is the time when the operation was initiated + 1 year.",
            "example": "2021-10-25T21:53:47+08:00",
            "summary": "Ban End Time",
            "oneOf": [
              {
                "description": "epoch-second",
                "example": 1640995200,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          }
        },
        "type": "object"
      },
      "bridge.node_status": {
        "properties": {
          "node": {
            "description": "The node name.",
            "example": "emqx@127.0.0.1",
            "summary": "Node Name",
            "type": "string"
          },
          "status": {
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "type": "string"
          },
          "status_reason": {
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused",
            "summary": "Failure reason",
            "type": "string"
          }
        },
        "type": "object"
      },
      "limiter.node_opts": {
        "properties": {
          "rate": {
            "default": "infinity",
            "description": "Rate for this bucket.",
            "example": "10MB",
            "summary": "Rate",
            "type": "string"
          },
          "burst": {
            "default": "0",
            "description": "The burst, This value is based on rate.<br/><br/> This value + rate = the maximum limit that can be achieved when limiter burst.",
            "example": "10MB",
            "summary": "Burst",
            "type": "string"
          }
        },
        "type": "object"
      },
      "authz.node_error": {
        "properties": {
          "node": {
            "description": "Node name.",
            "example": "emqx@127.0.0.1",
            "summary": "Node Name.",
            "type": "string"
          },
          "error": {
            "description": "The error of node.",
            "summary": "Error in Node",
            "type": "string"
          }
        },
        "type": "object"
      },
      "api_key.app": {
        "properties": {
          "name": {
            "description": "Unique and format by [a-zA-Z0-9-_]",
            "example": "EMQX-API-KEY-1",
            "type": "string"
          },
          "api_key": {
            "description": "TODO:uses HMAC-SHA256 for signing.",
            "example": "a4697a5c75a769f6",
            "type": "string"
          },
          "api_secret": {
            "description": "An API secret is a simple encrypted string that identifiesan application without any principal.They are useful for accessing public data anonymously,and are used to associate API requests.",
            "example": "MzAyMjk3ODMwMDk0NjIzOTUxNjcwNzQ0NzQ3MTE2NDYyMDI",
            "type": "string"
          },
          "expired_at": {
            "default": "infinity",
            "description": "No longer valid datetime",
            "example": "2021-12-05T02:01:34.186Z",
            "oneOf": [
              {
                "oneOf": [
                  {
                    "description": "epoch-second",
                    "example": 1640995200,
                    "type": "integer"
                  },
                  {
                    "example": "2022-01-01T00:00:00.000Z",
                    "format": "date-time",
                    "type": "string"
                  }
                ]
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "created_at": {
            "description": "ApiKey create datetime",
            "example": "2021-12-01T00:00:00.000Z",
            "oneOf": [
              {
                "description": "epoch-second",
                "example": 1640995200,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "desc": {
            "example": "Note",
            "type": "string"
          },
          "enable": {
            "description": "Enable/Disable",
            "type": "boolean"
          },
          "expired": {
            "description": "Expired",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_publish.publish_error": {
        "properties": {
          "reason_code": {
            "description": "The MQTT reason code, as the same ones used in PUBACK packet.<br/><br/>Currently supported codes are:<br/><br/><br/>16(0x10): No matching subscribers;<br/><br/>131(0x81): Error happened when dispatching the message. e.g. during EMQX restart;<br/><br/>144(0x90): Topic name invalid;<br/><br/>151(0x97): Publish rate limited, or message size exceeded limit. The global size limit can be configured with <code>mqtt.max_packet_size</code><br/><br/>NOTE: The message size is estimated with the received topic and payload size, meaning the actual size of serialized bytes (when sent to MQTT subscriber)<br/>might be slightly over the limit.",
            "example": 16,
            "type": "integer"
          },
          "message": {
            "description": "Describes the failure reason in detail.",
            "example": "no_matching_subscribers",
            "type": "string"
          }
        },
        "type": "object"
      },
      "broker.deflate_opts": {
        "properties": {
          "level": {
            "description": "Compression level.",
            "enum": [
              "none",
              "default",
              "best_compression",
              "best_speed"
            ],
            "summary": "Compression level",
            "type": "string"
          },
          "mem_level": {
            "default": 8,
            "description": "Specifies the size of the compression state.<br/><br/>Lower values decrease memory usage per connection.",
            "maximum": 9,
            "minimum": 1,
            "summary": "Size of the compression state",
            "type": "integer"
          },
          "strategy": {
            "default": "default",
            "description": "Specifies the compression strategy.",
            "enum": [
              "default",
              "filtered",
              "huffman_only",
              "rle"
            ],
            "summary": "compression strategy",
            "type": "string"
          },
          "server_context_takeover": {
            "default": "takeover",
            "description": "Takeover means the compression state is retained between server messages.",
            "enum": [
              "takeover",
              "no_takeover"
            ],
            "summary": "Server context takeover",
            "type": "string"
          },
          "client_context_takeover": {
            "default": "takeover",
            "description": "Takeover means the compression state is retained between client messages.",
            "enum": [
              "takeover",
              "no_takeover"
            ],
            "summary": "Client context takeover",
            "type": "string"
          },
          "server_max_window_bits": {
            "default": 15,
            "description": "Specifies the size of the compression context for the server.",
            "maximum": 15,
            "minimum": 8,
            "summary": "Server compression max window size",
            "type": "integer"
          },
          "client_max_window_bits": {
            "default": 15,
            "description": "Specifies the size of the compression context for the client.",
            "maximum": 15,
            "minimum": 8,
            "summary": "Client compression max window size",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "broker.authz_cache": {
        "required": [
          "enable"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable or disable the authorization cache.",
            "summary": "Enable or disable the authorization cache.",
            "type": "boolean"
          },
          "max_size": {
            "default": 32,
            "description": "Maximum number of cached items.",
            "maximum": 1048576,
            "minimum": 1,
            "summary": "Maximum number of cached items.",
            "type": "integer"
          },
          "ttl": {
            "default": "1m",
            "description": "Time to live for the cached data.",
            "example": "12m",
            "summary": "Time to live for the cached data.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "broker.tcp_opts": {
        "properties": {
          "active_n": {
            "default": 100,
            "description": "Specify the {active, N} option for this Socket.<br/><br/>See: https://erlang.org/doc/man/inet.html#setopts-2",
            "summary": "active_n",
            "type": "integer"
          },
          "backlog": {
            "default": 1024,
            "description": "TCP backlog defines the maximum length that the queue of<br/>pending connections can grow to.",
            "minimum": 1,
            "summary": "TCP backlog length",
            "type": "integer"
          },
          "send_timeout": {
            "default": "15s",
            "description": "The TCP send timeout for the connections.",
            "example": "12m",
            "summary": "TCP send timeout",
            "type": "string"
          },
          "send_timeout_close": {
            "default": true,
            "description": "Close the connection if send timeout.",
            "summary": "TCP send timeout close",
            "type": "boolean"
          },
          "recbuf": {
            "description": "The TCP receive buffer (OS kernel) for the connections.",
            "example": "2KB",
            "summary": "TCP receive buffer",
            "type": "string"
          },
          "sndbuf": {
            "description": "The TCP send buffer (OS kernel) for the connections.",
            "example": "4KB",
            "summary": "TCP send buffer",
            "type": "string"
          },
          "buffer": {
            "default": "4KB",
            "description": "The size of the user-space buffer used by the driver.",
            "example": "4KB",
            "summary": "TCP user-space buffer",
            "type": "string"
          },
          "high_watermark": {
            "default": "1MB",
            "description": "The socket is set to a busy state when the amount of data queued internally<br/>by the VM socket implementation reaches this limit.",
            "example": "32MB",
            "summary": "TCP 高水位线",
            "type": "string"
          },
          "nodelay": {
            "default": true,
            "description": "The TCP_NODELAY flag for the connections.",
            "summary": "TCP_NODELAY",
            "type": "boolean"
          },
          "reuseaddr": {
            "default": true,
            "description": "The SO_REUSEADDR flag for the connections.",
            "summary": "SO_REUSEADDR",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "emqx_topic_metrics_api.reset": {
        "required": [
          "action"
        ],
        "properties": {
          "topic": {
            "description": "Topic Name. If this parameter is not present,all created topic metrics will be reset.",
            "example": "testtopic/1",
            "type": "string"
          },
          "action": {
            "description": "Action. Only support reset",
            "example": "reset",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_rule_api_schema.rule_metrics": {
        "required": [
          "id"
        ],
        "properties": {
          "id": {
            "description": "The ID of the rule",
            "example": "293fb66f",
            "summary": "Rule ID",
            "type": "string"
          },
          "metrics": {
            "description": "The metrics of the rule",
            "summary": "Rule Metrics",
            "$ref": "#/components/schemas/emqx_rule_api_schema.metrics"
          },
          "node_metrics": {
            "description": "The metrics of the rule for each node",
            "items": {
              "$ref": "#/components/schemas/emqx_rule_api_schema.node_metrics"
            },
            "summary": "Each Node Rule Metrics",
            "type": "array"
          }
        },
        "type": "object"
      },
      "bridge_hstreamdb.post": {
        "required": [
          "connector",
          "name",
          "type"
        ],
        "properties": {
          "type": {
            "description": "The Bridge Type",
            "enum": [
              "hstreamdb"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name, used as a human-readable description of the bridge.",
            "summary": "Bridge Name",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "direction": {
            "default": "egress",
            "description": "The direction of this bridge, MUST be 'egress'",
            "enum": [
              "egress"
            ],
            "summary": "Bridge Direction",
            "type": "string"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to the HStreamDB. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "payload": {
            "default": "${payload}",
            "description": "The payload to be forwarded to the HStreamDB. Placeholders supported.",
            "summary": "Payload",
            "type": "string"
          },
          "connector": {
            "description": "Generic configuration for the connector.",
            "example": "hstreamdb:demo",
            "summary": "Connector Generic Configuration",
            "oneOf": [
              {
                "$ref": "#/components/schemas/connector_hstreamdb.config"
              },
              {
                "type": "string"
              }
            ]
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.update_stomp": {
        "properties": {
          "frame": {
            "$ref": "#/components/schemas/emqx_stomp_schema.stomp_frame"
          },
          "mountpoint": {
            "default": "",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message is delivered to the subscriber.<br/>The mountpoint is a way that users can use to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,<br/>then the client actually subscribes to the topic `some_tenant/t`.<br/>Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,<br/>the message is routed to all the clients subscribed `some_tenant/t`,<br/>so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.<br/>Variables in mountpoint string:<br/><br/>  - <code>${clientid}</code>: clientid<br/><br/>  - <code>${username}</code>: username",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Whether to enable this gateway",
            "type": "boolean"
          },
          "enable_stats": {
            "default": true,
            "description": "Whether to enable client process statistic",
            "type": "boolean"
          },
          "idle_timeout": {
            "default": "30s",
            "description": "The idle time of the client connection process. It has two purposes:<br/>  1. A newly created client process that does not receive any client requests after that time will be closed directly.<br/>  2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.",
            "example": "12m",
            "type": "string"
          },
          "clientinfo_override": {
            "description": "ClientInfo override.",
            "$ref": "#/components/schemas/gateway.clientinfo_override"
          }
        },
        "type": "object"
      },
      "emqx_conf_schema.log_burst_limit": {
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable log burst control feature.",
            "summary": "Enable Burst",
            "type": "boolean"
          },
          "max_count": {
            "default": 10000,
            "description": "Maximum number of log events to handle within a `window_time` interval. After the limit is reached, successive events are dropped until the end of the `window_time`.",
            "minimum": 1,
            "summary": "Events Number",
            "type": "integer"
          },
          "window_time": {
            "default": "1s",
            "description": "See <code>max_count</code>.",
            "example": "12m",
            "summary": "Window Time",
            "type": "string"
          }
        },
        "type": "object"
      },
      "connector-mqtt.egress_remote": {
        "required": [
          "topic"
        ],
        "properties": {
          "topic": {
            "description": "Forward to which topic of the remote broker.<br/><br/>Template with variables is allowed.",
            "summary": "Remote Topic",
            "type": "string"
          },
          "qos": {
            "default": 1,
            "description": "The QoS of the MQTT message to be sent.<br/><br/>Template with variables is allowed.",
            "summary": "Remote QoS",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "example": 0,
                "maximum": 2,
                "minimum": 0,
                "type": "integer"
              }
            ]
          },
          "retain": {
            "default": false,
            "description": "The 'retain' flag of the MQTT message to be sent.<br/><br/>Template with variables is allowed.",
            "summary": "Retain Flag",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "boolean"
              }
            ]
          },
          "payload": {
            "description": "The payload of the MQTT message to be sent.<br/><br/>Template with variables is allowed.",
            "summary": "Payload",
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge_redis.get_sentinel": {
        "required": [
          "command_template",
          "name",
          "sentinel",
          "servers",
          "type"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to Redis. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "command_template": {
            "description": "Redis command template used to export messages. Each list element stands for a command name or its argument.<br/>For example, to push payloads in a Redis list by key `msgs`, the elements should be the following:<br/>`rpush`, `msgs`, `${payload}`.",
            "items": {
              "type": "string"
            },
            "summary": "Redis Command Template",
            "type": "array"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/bridge_redis.creation_opts_redis_sentinel"
          },
          "servers": {
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The Redis default port 6379 is used if `[:Port]` is not specified.",
            "summary": "Servers",
            "type": "string"
          },
          "redis_type": {
            "default": "sentinel",
            "description": "Sentinel mode. Must be set to 'sentinel' when Redis server is running in sentinel mode.",
            "enum": [
              "sentinel"
            ],
            "summary": "Sentinel Mode",
            "type": "string"
          },
          "sentinel": {
            "description": "The cluster name in Redis sentinel mode.",
            "summary": "Cluster Name",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "database": {
            "default": 0,
            "description": "Redis database ID.",
            "summary": "Database ID",
            "type": "integer"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          },
          "type": {
            "description": "The Bridge Type",
            "enum": [
              "redis_sentinel"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name, used as a human-readable description of the bridge.",
            "summary": "Bridge Name",
            "type": "string"
          },
          "status": {
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status.",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary": "Bridge Status",
            "type": "string"
          },
          "status_reason": {
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused",
            "summary": "Failure reason",
            "type": "string"
          },
          "node_status": {
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            },
            "summary": "Node Status",
            "type": "array"
          }
        },
        "type": "object"
      },
      "plugins.position": {
        "properties": {
          "position": {
            "description": "<br/>             Enable auto-boot at position in the boot list, where Position could be<br/>             'front', 'rear', or 'before:other-vsn', 'after:other-vsn'<br/>             to specify a relative position.<br/>            ",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "enum": [
                  "rear"
                ],
                "type": "string"
              },
              {
                "enum": [
                  "front"
                ],
                "type": "string"
              }
            ]
          }
        },
        "type": "object"
      },
      "bridge.node_metrics": {
        "properties": {
          "node": {
            "description": "The node name.",
            "example": "emqx@127.0.0.1",
            "summary": "Node Name",
            "type": "string"
          },
          "metrics": {
            "$ref": "#/components/schemas/bridge.metrics"
          }
        },
        "type": "object"
      },
      "bridge_sqlserver.get": {
        "required": [
          "database",
          "name",
          "server",
          "type"
        ],
        "properties": {
          "status": {
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status.",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary": "Bridge Status",
            "type": "string"
          },
          "status_reason": {
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused",
            "summary": "Failure reason",
            "type": "string"
          },
          "node_status": {
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            },
            "summary": "Node Status",
            "type": "array"
          },
          "type": {
            "description": "The Bridge Type",
            "enum": [
              "sqlserver"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name.",
            "summary": "Bridge Name",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "sql": {
            "default": "insert into t_mqtt_msg(msgid, topic, qos, payload) values ( ${id}, ${topic}, ${qos}, ${payload} )",
            "description": "SQL Template",
            "format": "sql",
            "summary": "SQL Template",
            "type": "string"
          },
          "driver": {
            "default": "ms-sql",
            "description": "SQL Server Driver Name",
            "summary": "SQL Server Driver Name",
            "type": "string"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to Microsoft SQL Server. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/bridge_sqlserver.creation_opts"
          },
          "server": {
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The SQL Server default port 1433 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "default": "sa",
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "emqx_exproto_schema.ssl_server_opts": {
        "properties": {
          "cacertfile": {
            "description": "Trusted PEM format CA certificates bundle file.<br/><br/>The certificates in this file are used to verify the TLS peer's certificates.<br/>Append new certificates to the file if new CAs are to be trusted.<br/>There is no need to restart EMQX to have the updated file loaded, because<br/>the system regularly checks if file has been updated (and reload).<br/><br/>NOTE: invalidating (deleting) a certificate from the file will not affect<br/>already established connections.",
            "summary": "CACertfile",
            "type": "string"
          },
          "certfile": {
            "description": "PEM format certificates chain file.<br/><br/>The certificates in this file should be in reversed order of the certificate<br/>issue chain. That is, the host's certificate should be placed in the beginning<br/>of the file, followed by the immediate issuer certificate and so on.<br/>Although the root CA certificate is optional, it should be placed at the end of<br/>the file if it is to be added.",
            "summary": "Certfile",
            "type": "string"
          },
          "keyfile": {
            "description": "PEM format private key file.",
            "summary": "Keyfile",
            "type": "string"
          },
          "verify": {
            "default": "verify_none",
            "description": "Enable or disable peer verification.",
            "enum": [
              "verify_peer",
              "verify_none"
            ],
            "summary": "Verify peer",
            "type": "string"
          },
          "reuse_sessions": {
            "default": true,
            "description": "Enable TLS session reuse.",
            "summary": "TLS session reuse",
            "type": "boolean"
          },
          "depth": {
            "default": 10,
            "description": "Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path.<br/>So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly;<br/><br/>if 1 the path can be PEER, Intermediate-CA, ROOT-CA;<br/><br/>if 2 the path can be PEER, Intermediate-CA1, Intermediate-CA2, ROOT-CA.",
            "summary": "CACert Depth",
            "type": "integer"
          },
          "password": {
            "description": "String containing the user's password. Only used if the private key file is password-protected.",
            "example": "",
            "format": "password",
            "summary": "Keyfile passphrase",
            "type": "string"
          },
          "versions": {
            "default": [
              "tlsv1.3",
              "tlsv1.2",
              "tlsv1.1",
              "tlsv1"
            ],
            "description": "All TLS/DTLS versions to be supported.<br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.<br/><br/>In case PSK cipher suites are intended, make sure to configure<br/><code>['tlsv1.2', 'tlsv1.1']</code> here.",
            "items": {
              "type": "string"
            },
            "summary": "SSL versions",
            "type": "array"
          },
          "ciphers": {
            "default": "",
            "description": "This config holds TLS cipher suite names separated by comma,<br/>or as an array of strings. e.g.<br/><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or<br/><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.<br/><br/><br/>Ciphers (and their ordering) define the way in which the<br/>client and server encrypts information over the network connection.<br/>Selecting a good cipher suite is critical for the<br/>application's data security, confidentiality and performance.<br/><br/>The names should be in OpenSSL string format (not RFC format).<br/>All default values and examples provided by EMQX config<br/>documentation are all in OpenSSL format.<br/><br/><br/>NOTE: Certain cipher suites are only compatible with<br/>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')<br/>incompatible cipher suites will be silently dropped.<br/>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,<br/>configuring cipher suites for other versions will have no effect.<br/><br/><br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br/><br/>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.<br/><br/>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,<br/>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,<br/>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,<br/>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code>",
            "items": {
              "type": "string"
            },
            "summary": "",
            "type": "array"
          },
          "secure_renegotiate": {
            "default": true,
            "description": "SSL parameter renegotiation is a feature that allows a client and a server<br/>to renegotiate the parameters of the SSL connection on the fly.<br/>RFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,<br/>you drop support for the insecure renegotiation, prone to MitM attacks.",
            "summary": "SSL renegotiate",
            "type": "boolean"
          },
          "hibernate_after": {
            "default": "5s",
            "description": "Hibernate the SSL process after idling for amount of time reducing its memory footprint.",
            "example": "12m",
            "summary": "hibernate after",
            "type": "string"
          },
          "dhfile": {
            "description": "Path to a file containing PEM-encoded Diffie-Hellman parameters<br/>to be used by the server if a cipher suite using Diffie-Hellman<br/>key exchange is negotiated. If not specified, default parameters<br/>are used.<br/><br/>NOTE: The <code>dhfile</code> option is not supported by TLS 1.3.",
            "summary": "SSL dhfile",
            "type": "string"
          },
          "fail_if_no_peer_cert": {
            "default": false,
            "description": "Used together with {verify, verify_peer} by an TLS/DTLS server.<br/>If set to true, the server fails if the client does not have a<br/>certificate to send, that is, sends an empty certificate.<br/>If set to false, it fails only if the client sends an invalid<br/>certificate (an empty certificate is considered valid).",
            "summary": "SSL fail if no peer cert",
            "type": "boolean"
          },
          "honor_cipher_order": {
            "default": true,
            "description": "An important security setting, it forces the cipher to be set based<br/> on the server-specified order instead of the client-specified order,<br/> hence enforcing the (usually more properly configured) security<br/> ordering of the server administrator.",
            "summary": "SSL honor cipher order",
            "type": "boolean"
          },
          "client_renegotiation": {
            "default": true,
            "description": "In protocols that support client-initiated renegotiation,<br/>the cost of resources of such an operation is higher for the server than the client.<br/>This can act as a vector for denial of service attacks.<br/>The SSL application already takes measures to counter-act such attempts,<br/>but client-initiated renegotiation can be strictly disabled by setting this option to false.<br/>The default value is true. Note that disabling renegotiation can result in<br/>long-lived connections becoming unusable due to limits on<br/>the number of messages the underlying cipher suite can encipher.",
            "summary": "SSL client renegotiation",
            "type": "boolean"
          },
          "handshake_timeout": {
            "default": "15s",
            "description": "Maximum time duration allowed for the handshake to complete",
            "example": "12m",
            "summary": "Handshake timeout",
            "type": "string"
          }
        },
        "type": "object"
      },
      "plugins.running_status": {
        "properties": {
          "node": {
            "example": "emqx@127.0.0.1",
            "type": "string"
          },
          "status": {
            "description": "Install plugin status at runtime<br/>1. running: plugin is running.<br/>2. stopped: plugin is stopped.<br/>",
            "enum": [
              "running",
              "stopped"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge_mqtt.creation_opts": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 0,
            "summary": "Buffer Pool Size",
            "type": "integer"
          },
          "health_check_interval": {
            "default": "15s",
            "description": "Health check interval.",
            "example": "32s",
            "summary": "Health Check Interval",
            "type": "string"
          },
          "start_after_created": {
            "default": "true",
            "description": "Whether start the resource right after created.",
            "summary": "Start After Created",
            "type": "boolean"
          },
          "start_timeout": {
            "default": "5s",
            "description": "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "example": "32s",
            "summary": "Start Timeout",
            "type": "string"
          },
          "auto_restart_interval": {
            "default": "60s",
            "description": "The auto restart interval after the resource is disconnected.",
            "summary": "Auto Restart Interval",
            "oneOf": [
              {
                "example": "32s",
                "type": "string"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "query_mode": {
            "default": "async",
            "description": "Query mode. Optional 'sync/async', default 'async'.",
            "enum": [
              "sync",
              "async"
            ],
            "summary": "Query mode",
            "type": "string"
          },
          "request_timeout": {
            "default": "15s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "summary": "Request Expiry",
            "oneOf": [
              {
                "example": "32s",
                "type": "string"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1,
            "summary": "Inflight window",
            "type": "integer"
          },
          "enable_queue": {
            "default": false,
            "deprecated": true,
            "description": "Enable disk buffer queue (only applicable for egress bridges).<br/>When Enabled, messages will be buffered on disk when the bridge connection is down.<br/>When disabled the messages are buffered in RAM only.",
            "summary": "Enable disk buffer queue",
            "type": "boolean"
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB",
            "summary": "Max buffer queue size",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.update_coap": {
        "properties": {
          "heartbeat": {
            "default": "30s",
            "description": "The gateway server required minimum heartbeat interval.<br/>When connection mode is enabled, this parameter is used to set the minimum heartbeat interval for the connection to be alive",
            "example": "12m",
            "type": "string"
          },
          "connection_required": {
            "default": false,
            "description": "Enable or disable connection mode.<br/>Connection mode is a feature of non-standard protocols. When connection mode is enabled, it is necessary to maintain the creation, authentication and alive of connection resources",
            "type": "boolean"
          },
          "notify_type": {
            "default": "qos",
            "description": "The Notification Message will be delivered to the CoAP client if a new message received on an observed topic.<br/>The type of delivered coap message can be set to:<br/><br/>  - non: Non-confirmable;<br/><br/>  - con: Confirmable;<br/><br/>  - qos: Mapping from QoS type of received message, QoS0 -> non, QoS1,2 -> con",
            "enum": [
              "non",
              "con",
              "qos"
            ],
            "type": "string"
          },
          "subscribe_qos": {
            "default": "coap",
            "description": "The Default QoS Level indicator for subscribe request.<br/>This option specifies the QoS level for the CoAP Client when establishing a subscription membership, if the subscribe request is not carried `qos` option. The indicator can be set to:<br/><br/>  - qos0, qos1, qos2: Fixed default QoS level<br/><br/>  - coap: Dynamic QoS level by the message type of subscribe request<br/><br/>    * qos0: If the subscribe request is non-confirmable<br/><br/>    * qos1: If the subscribe request is confirmable",
            "enum": [
              "qos0",
              "qos1",
              "qos2",
              "coap"
            ],
            "type": "string"
          },
          "publish_qos": {
            "default": "coap",
            "description": "The Default QoS Level indicator for publish request.<br/>This option specifies the QoS level for the CoAP Client when publishing a message to EMQX PUB/SUB system, if the publish request is not carried `qos` option. The indicator can be set to:<br/><br/>  - qos0, qos1, qos2: Fixed default QoS level<br/><br/>  - coap: Dynamic QoS level by the message type of publish request<br/><br/>    * qos0: If the publish request is non-confirmable<br/><br/>    * qos1: If the publish request is confirmable",
            "enum": [
              "qos0",
              "qos1",
              "qos2",
              "coap"
            ],
            "type": "string"
          },
          "mountpoint": {
            "default": "",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message is delivered to the subscriber.<br/>The mountpoint is a way that users can use to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,<br/>then the client actually subscribes to the topic `some_tenant/t`.<br/>Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,<br/>the message is routed to all the clients subscribed `some_tenant/t`,<br/>so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.<br/>Variables in mountpoint string:<br/><br/>  - <code>${clientid}</code>: clientid<br/><br/>  - <code>${username}</code>: username",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Whether to enable this gateway",
            "type": "boolean"
          },
          "enable_stats": {
            "default": true,
            "description": "Whether to enable client process statistic",
            "type": "boolean"
          },
          "idle_timeout": {
            "default": "30s",
            "description": "The idle time of the client connection process. It has two purposes:<br/>  1. A newly created client process that does not receive any client requests after that time will be closed directly.<br/>  2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.",
            "example": "12m",
            "type": "string"
          },
          "clientinfo_override": {
            "description": "ClientInfo override.",
            "$ref": "#/components/schemas/gateway.clientinfo_override"
          }
        },
        "type": "object"
      },
      "bridge_kafka.auth_username_password": {
        "required": [
          "mechanism",
          "password",
          "username"
        ],
        "properties": {
          "mechanism": {
            "description": "SASL authentication mechanism.",
            "enum": [
              "plain",
              "scram_sha_256",
              "scram_sha_512"
            ],
            "summary": "Mechanism",
            "type": "string"
          },
          "username": {
            "description": "SASL authentication username.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "SASL authentication password.",
            "summary": "Password",
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge_dynamo.get": {
        "required": [
          "aws_access_key_id",
          "aws_secret_access_key",
          "name",
          "table",
          "type",
          "url"
        ],
        "properties": {
          "status": {
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status.",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary": "Bridge Status",
            "type": "string"
          },
          "status_reason": {
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused",
            "summary": "Failure reason",
            "type": "string"
          },
          "node_status": {
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            },
            "summary": "Node Status",
            "type": "array"
          },
          "type": {
            "description": "The Bridge Type",
            "enum": [
              "dynamo"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name.",
            "summary": "Bridge Name",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "template": {
            "default": "",
            "description": "Template, the default value is empty. When this value is empty the whole message will be stored in the database",
            "summary": "Template",
            "type": "string"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to DynamoDB. All MQTT `PUBLISH` messages with the topic<br/>matching the `local_topic` will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also `local_topic` is<br/>configured, then both the data got from the rule and the MQTT messages that match `local_topic`<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/bridge_dynamo.creation_opts"
          },
          "url": {
            "description": "The url of DynamoDB endpoint.",
            "summary": "DynamoDB Endpoint",
            "type": "string"
          },
          "table": {
            "description": "DynamoDB Table.",
            "summary": "Table ",
            "type": "string"
          },
          "aws_access_key_id": {
            "description": "Access Key ID for connecting to DynamoDB.",
            "summary": "AWS Access Key ID",
            "type": "string"
          },
          "aws_secret_access_key": {
            "description": "AWS Secret Access Key for connecting to DynamoDB.",
            "summary": "AWS Secret Access Key",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "listeners.ssl_required_bind(with_name)": {
        "required": [
          "bind",
          "name",
          "type"
        ],
        "properties": {
          "type": {
            "description": "Listener type",
            "enum": [
              "ssl"
            ],
            "type": "string"
          },
          "running": {
            "description": "Listener status",
            "type": "boolean"
          },
          "name": {
            "description": "Listener name",
            "type": "string"
          },
          "current_connections": {
            "description": "Current connections",
            "minimum": 0,
            "type": "integer"
          },
          "enabled": {
            "default": true,
            "description": "Enable listener.",
            "summary": "Enable listener",
            "type": "boolean"
          },
          "bind": {
            "default": 8883,
            "description": "IP address and port for the listening socket.",
            "summary": "IP address and port",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "acceptors": {
            "default": 16,
            "description": "The size of the listener's receiving pool.",
            "minimum": 1,
            "summary": "Acceptors Num",
            "type": "integer"
          },
          "max_connections": {
            "default": 5000000,
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "summary": "Max connections",
            "oneOf": [
              {
                "minimum": 1,
                "type": "integer"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message<br/>is delivered to the subscriber. The mountpoint is a way that users can use<br/>to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`<br/>set to `some_tenant`, then the client actually subscribes to the topic<br/>`some_tenant/t`. Similarly, if another client B (connected to the same listener<br/>as the client A) sends a message to topic `t`, the message is routed<br/>to all the clients subscribed `some_tenant/t`, so client A will receive the<br/>message, with topic name `t`.<br/><br/>Set to `\"\"` to disable the feature.<br/><br/><br/>Variables in mountpoint string:<br/>  - <code>${clientid}</code>: clientid<br/>  - <code>${username}</code>: username",
            "summary": "mountpoint",
            "type": "string"
          },
          "zone": {
            "default": "default",
            "description": "The configuration zone to which the listener belongs.",
            "summary": "Zone",
            "type": "string"
          },
          "limiter": {
            "description": "Type of the rate limit.",
            "summary": "Type of the rate limit.",
            "$ref": "#/components/schemas/limiter.listener_fields"
          },
          "enable_authn": {
            "default": true,
            "description": "Set <code>true</code> (default) to enable client authentication on this listener, the authentication<br/>process goes through the configured authentication chain.<br/>When set to <code>false</code> to allow any clients with or without authentication information such as username or password to log in.<br/>When set to <code>quick_deny_anonymous</code>, it behaves like when set to <code>true</code>, but clients will be<br/>denied immediately without going through any authenticators if <code>username</code> is not provided. This is useful to fence off<br/>anonymous clients early.",
            "enum": [
              true,
              false,
              "quick_deny_anonymous"
            ],
            "summary": "Enable authentication",
            "type": "string"
          },
          "access_rules": {
            "default": [
              "allow all"
            ],
            "description": "The access control rules for this listener.<br/>See: https://github.com/emqtt/esockd#allowdeny",
            "items": {
              "type": "string"
            },
            "summary": "Access rules",
            "type": "array"
          },
          "proxy_protocol": {
            "default": false,
            "description": "Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.<br/><br/>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/",
            "summary": "Proxy protocol",
            "type": "boolean"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "description": "Timeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.",
            "example": "12m",
            "summary": "Proxy protocol timeout",
            "type": "string"
          },
          "tcp_options": {
            "$ref": "#/components/schemas/broker.tcp_opts"
          },
          "ssl_options": {
            "$ref": "#/components/schemas/broker.listener_ssl_opts"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_publish.publish_message": {
        "required": [
          "payload",
          "topic"
        ],
        "properties": {
          "payload_encoding": {
            "default": "plain",
            "description": "MQTT Payload Encoding, <code>base64</code> or <code>plain</code>. When set to <code>base64</code>, the message is decoded before it is published.",
            "enum": [
              "plain",
              "base64"
            ],
            "type": "string"
          },
          "topic": {
            "description": "Topic Name",
            "example": "api/example/topic",
            "type": "string"
          },
          "qos": {
            "default": 0,
            "description": "MQTT message QoS",
            "example": 0,
            "maximum": 2,
            "minimum": 0,
            "type": "integer"
          },
          "clientid": {
            "deprecated": true,
            "type": "string"
          },
          "payload": {
            "description": "The MQTT message payload.",
            "example": "hello emqx api",
            "type": "string"
          },
          "properties": {
            "description": "The Properties of the PUBLISH message.",
            "$ref": "#/components/schemas/emqx_mgmt_api_publish.message_properties"
          },
          "retain": {
            "default": false,
            "description": "A boolean field to indicate if this message should be retained.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_clients.subscribe": {
        "required": [
          "topic"
        ],
        "properties": {
          "topic": {
            "description": "Topic",
            "type": "string"
          },
          "qos": {
            "default": 0,
            "description": "QoS",
            "example": 0,
            "maximum": 2,
            "minimum": 0,
            "type": "integer"
          },
          "nl": {
            "default": 0,
            "description": "No Local",
            "type": "integer"
          },
          "rap": {
            "default": 0,
            "description": "Retain as Published",
            "type": "integer"
          },
          "rh": {
            "default": 0,
            "description": "Retain Handling",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "emqx_authn_api.response_users": {
        "properties": {
          "data": {
            "items": {
              "$ref": "#/components/schemas/emqx_authn_api.response_user"
            },
            "type": "array"
          },
          "meta": {
            "$ref": "#/components/schemas/public.meta"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.tcp_listener": {
        "properties": {
          "id": {
            "description": "Listener ID",
            "type": "string"
          },
          "type": {
            "description": "Listener Type",
            "enum": [
              "tcp"
            ],
            "type": "string"
          },
          "name": {
            "description": "Listener Name",
            "type": "string"
          },
          "running": {
            "description": "Listener Running status",
            "type": "boolean"
          },
          "acceptors": {
            "default": 16,
            "description": "Size of the acceptor pool.",
            "type": "integer"
          },
          "tcp_options": {
            "description": "Setting the TCP socket options.",
            "$ref": "#/components/schemas/broker.tcp_opts"
          },
          "proxy_protocol": {
            "default": false,
            "description": "Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.<br/>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/",
            "type": "boolean"
          },
          "proxy_protocol_timeout": {
            "default": "15s",
            "description": "Timeout for proxy protocol.<br/>EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.",
            "example": "12m",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable the listener.",
            "type": "boolean"
          },
          "bind": {
            "description": "The IP address and port that the listener will bind.",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "max_connections": {
            "default": 1024,
            "description": "Maximum number of concurrent connections.",
            "type": "integer"
          },
          "max_conn_rate": {
            "default": 1000,
            "description": "Maximum connections per second.",
            "type": "integer"
          },
          "enable_authn": {
            "default": true,
            "description": "Set <code>true</code> (default) to enable client authentication on this listener. <br/>When set to <code>false</code> clients will be allowed to connect without authentication.",
            "type": "boolean"
          },
          "mountpoint": {
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message is delivered to the subscriber.<br/>The mountpoint is a way that users can use to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,<br/>then the client actually subscribes to the topic `some_tenant/t`.<br/>Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,<br/>the message is routed to all the clients subscribed `some_tenant/t`,<br/>so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.<br/>Variables in mountpoint string:<br/><br/>  - <code>${clientid}</code>: clientid<br/><br/>  - <code>${username}</code>: username",
            "type": "string"
          },
          "access_rules": {
            "default": "",
            "description": "The access control rules for this listener.<br/>See: https://github.com/emqtt/esockd#allowdeny",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "bridge_matrix.post": {
        "required": [
          "database",
          "name",
          "server",
          "type"
        ],
        "properties": {
          "type": {
            "description": "The Bridge Type",
            "enum": [
              "matrix"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name.",
            "summary": "Bridge Name",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "sql": {
            "default": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
            "description": "SQL Template",
            "format": "sql",
            "summary": "SQL Template",
            "type": "string"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to PostgreSQL. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The PostgreSQL default port 5432 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "bridge_influxdb.put_api_v1": {
        "required": [
          "database",
          "write_syntax"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to the InfluxDB. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "write_syntax": {
            "description": "Conf of InfluxDB line protocol to write data points. It is a text-based format that provides the measurement, tag set, field set, and timestamp of a data point, and placeholder supported.<br/>See also [InfluxDB 2.3 Line Protocol](https://docs.influxdata.com/influxdb/v2.3/reference/syntax/line-protocol/) and<br/>[InfluxDB 1.8 Line Protocol](https://docs.influxdata.com/influxdb/v1.8/write_protocols/line_protocol_tutorial/) </br><br/>TLDR:</br><br/>```<br/><measurement>[,<tag_key>=<tag_value>[,<tag_key>=<tag_value>]] <field_key>=<field_value>[,<field_key>=<field_value>] [<timestamp>]<br/>```<br/>Please note that a placeholder for an integer value must be annotated with a suffix `i`. For example `${payload.int_value}i`.",
            "example": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,bool=${payload.bool}",
            "format": "sql",
            "summary": "Write Syntax",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "default": "127.0.0.1:8086",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.</br><br/>A host entry has the following form: `Host[:Port]`.</br><br/>The InfluxDB default port 8086 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "precision": {
            "default": "ms",
            "description": "InfluxDB time precision.",
            "enum": [
              "ns",
              "us",
              "ms",
              "s"
            ],
            "summary": "Time Precision",
            "type": "string"
          },
          "database": {
            "description": "InfluxDB database.",
            "summary": "Database",
            "type": "string"
          },
          "username": {
            "description": "InfluxDB username.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "InfluxDB password.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "emqx_conf_schema.log": {
        "properties": {
          "console_handler": {
            "$ref": "#/components/schemas/emqx_conf_schema.console_handler"
          },
          "file_handlers": {
            "default": {
              "default": {
                "level": "warning"
              }
            },
            "description": "File-based log handlers.",
            "summary": "File Handler",
            "properties": {
              "$name": {
                "$ref": "#/components/schemas/emqx_conf_schema.log_file_handler"
              }
            },
            "type": "object"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_schema.http_get": {
        "required": [
          "method",
          "type",
          "url"
        ],
        "properties": {
          "method": {
            "default": "get",
            "description": "HTTP method.",
            "enum": [
              "get"
            ],
            "summary": "method",
            "type": "string"
          },
          "headers": {
            "default": {
              "accept": "application/json",
              "cache-control": "no-cache",
              "connection": "keep-alive",
              "keep-alive": "timeout=30, max=1000"
            },
            "description": "List of HTTP headers (without <code>content-type</code>).",
            "example": {},
            "summary": "headers_no_content_type",
            "type": "object"
          },
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this ACL provider.",
            "summary": "enable",
            "type": "boolean"
          },
          "type": {
            "default": "http",
            "description": "Backend type.",
            "enum": [
              "http"
            ],
            "summary": "type",
            "type": "string"
          },
          "url": {
            "description": "URL of the auth server.",
            "summary": "url",
            "type": "string"
          },
          "body": {
            "description": "HTTP request body.",
            "example": {},
            "summary": "body",
            "type": "object"
          },
          "request_timeout": {
            "default": "30s",
            "description": "Request timeout.",
            "summary": "request_timeout",
            "type": "string"
          },
          "connect_timeout": {
            "default": "15s",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s",
            "summary": "Connect Timeout",
            "type": "string"
          },
          "enable_pipelining": {
            "default": 100,
            "description": "A positive integer. Whether to send HTTP requests continuously, when set to 1, it means that after each HTTP request is sent, you need to wait for the server to return and then continue to send the next request.",
            "minimum": 1,
            "summary": "HTTP Pipelineing",
            "type": "integer"
          },
          "max_retries": {
            "deprecated": true,
            "minimum": 0,
            "type": "integer"
          },
          "pool_size": {
            "default": 8,
            "description": "The pool size.",
            "minimum": 1,
            "summary": "Pool Size",
            "type": "integer"
          },
          "request": {
            "description": "Configure HTTP request parameters.",
            "summary": "Request",
            "$ref": "#/components/schemas/connector-http.request"
          },
          "retry_interval": {
            "deprecated": true,
            "example": "12m",
            "type": "string"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "bridge_pgsql.put": {
        "required": [
          "database",
          "server"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "sql": {
            "default": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
            "description": "SQL Template",
            "format": "sql",
            "summary": "SQL Template",
            "type": "string"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to PostgreSQL. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The PostgreSQL default port 5432 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_clients.unsubscribe": {
        "properties": {
          "topic": {
            "description": "Topic",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_metrics.node_metrics": {
        "properties": {
          "node": {
            "description": "Node name",
            "type": "string"
          },
          "actions.failure": {
            "description": "Number of failure executions of the rule engine action",
            "minimum": 0,
            "type": "integer"
          },
          "actions.success": {
            "description": "Number of successful executions of the rule engine action",
            "minimum": 0,
            "type": "integer"
          },
          "bytes.received": {
            "description": "Number of bytes received ",
            "minimum": 0,
            "type": "integer"
          },
          "bytes.sent": {
            "description": "Number of bytes sent on this connection",
            "minimum": 0,
            "type": "integer"
          },
          "client.auth.anonymous": {
            "description": "Number of clients who log in anonymously",
            "minimum": 0,
            "type": "integer"
          },
          "client.authenticate": {
            "description": "Number of client authentications",
            "minimum": 0,
            "type": "integer"
          },
          "client.check_authz": {
            "description": "Number of Authorization rule checks",
            "minimum": 0,
            "type": "integer"
          },
          "client.connack": {
            "description": "Number of CONNACK packet sent",
            "minimum": 0,
            "type": "integer"
          },
          "client.connect": {
            "description": "Number of client connections",
            "minimum": 0,
            "type": "integer"
          },
          "client.connected": {
            "description": "Number of successful client connections",
            "minimum": 0,
            "type": "integer"
          },
          "client.disconnected": {
            "description": "Number of client disconnects",
            "minimum": 0,
            "type": "integer"
          },
          "client.subscribe": {
            "description": "Number of client subscriptions",
            "minimum": 0,
            "type": "integer"
          },
          "client.unsubscribe": {
            "description": "Number of client unsubscriptions",
            "minimum": 0,
            "type": "integer"
          },
          "delivery.dropped": {
            "description": "Total number of discarded messages when sending",
            "minimum": 0,
            "type": "integer"
          },
          "delivery.dropped.expired": {
            "description": "Number of messages dropped due to message expiration on sending",
            "minimum": 0,
            "type": "integer"
          },
          "delivery.dropped.no_local": {
            "description": "Number of messages that were dropped due to the No Local subscription option when sending",
            "minimum": 0,
            "type": "integer"
          },
          "delivery.dropped.qos0_msg": {
            "description": "Number of messages with QoS 0 that were dropped because the message queue was full when sending",
            "minimum": 0,
            "type": "integer"
          },
          "delivery.dropped.queue_full": {
            "description": "Number of messages with a non-zero QoS that were dropped because the message queue was full when sending",
            "minimum": 0,
            "type": "integer"
          },
          "delivery.dropped.too_large": {
            "description": "The number of messages that were dropped because the length exceeded the limit when sending",
            "minimum": 0,
            "type": "integer"
          },
          "messages.acked": {
            "description": "Number of received PUBACK and PUBREC packet",
            "minimum": 0,
            "type": "integer"
          },
          "messages.delayed": {
            "description": "Number of delay-published messages",
            "minimum": 0,
            "type": "integer"
          },
          "messages.delivered": {
            "description": "Number of messages forwarded to the subscription process internally",
            "minimum": 0,
            "type": "integer"
          },
          "messages.dropped": {
            "description": "Total number of messages dropped before forwarding to the subscription process",
            "minimum": 0,
            "type": "integer"
          },
          "messages.dropped.await_pubrel_timeout": {
            "description": "Number of messages dropped due to waiting PUBREL timeout",
            "minimum": 0,
            "type": "integer"
          },
          "messages.dropped.no_subscribers": {
            "description": "Number of messages dropped due to no subscribers",
            "minimum": 0,
            "type": "integer"
          },
          "messages.forward": {
            "description": "Number of messages forwarded to other nodes",
            "minimum": 0,
            "type": "integer"
          },
          "messages.publish": {
            "description": "Number of messages published in addition to system messages",
            "minimum": 0,
            "type": "integer"
          },
          "messages.qos0.received": {
            "description": "Number of QoS 0 messages received from clients",
            "minimum": 0,
            "type": "integer"
          },
          "messages.qos0.sent": {
            "description": "Number of QoS 0 messages sent to clients",
            "minimum": 0,
            "type": "integer"
          },
          "messages.qos1.received": {
            "description": "Number of QoS 1 messages received from clients",
            "minimum": 0,
            "type": "integer"
          },
          "messages.qos1.sent": {
            "description": "Number of QoS 1 messages sent to clients",
            "minimum": 0,
            "type": "integer"
          },
          "messages.qos2.received": {
            "description": "Number of QoS 2 messages received from clients",
            "minimum": 0,
            "type": "integer"
          },
          "messages.qos2.sent": {
            "description": "Number of QoS 2 messages sent to clients",
            "minimum": 0,
            "type": "integer"
          },
          "messages.received": {
            "description": "Number of messages received from the client, equal to the sum of messages.qos0.received\fmessages.qos1.received and messages.qos2.received",
            "minimum": 0,
            "type": "integer"
          },
          "messages.retained": {
            "description": "Number of retained messages",
            "minimum": 0,
            "type": "integer"
          },
          "messages.sent": {
            "description": "Number of messages sent to the client, equal to the sum of messages.qos0.sent\fmessages.qos1.sent and messages.qos2.sent",
            "minimum": 0,
            "type": "integer"
          },
          "packets.auth.received": {
            "description": "Number of received AUTH packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.auth.sent": {
            "description": "Number of sent AUTH packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.connack.auth_error": {
            "description": "Number of received CONNECT packet with failed authentication",
            "minimum": 0,
            "type": "integer"
          },
          "packets.connack.error": {
            "description": "Number of received CONNECT packet with unsuccessful connections",
            "minimum": 0,
            "type": "integer"
          },
          "packets.connack.sent": {
            "description": "Number of sent CONNACK packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.connect.received": {
            "description": "Number of received CONNECT packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.disconnect.received": {
            "description": "Number of received DISCONNECT packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.disconnect.sent": {
            "description": "Number of sent DISCONNECT packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pingreq.received": {
            "description": "Number of received PINGREQ packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pingresp.sent": {
            "description": "Number of sent PUBRESP packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.puback.inuse": {
            "description": "Number of received PUBACK packet with occupied identifiers",
            "minimum": 0,
            "type": "integer"
          },
          "packets.puback.missed": {
            "description": "Number of received packet with identifiers.",
            "minimum": 0,
            "type": "integer"
          },
          "packets.puback.received": {
            "description": "Number of received PUBACK packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.puback.sent": {
            "description": "Number of sent PUBACK packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubcomp.inuse": {
            "description": "Number of received PUBCOMP packet with occupied identifiers",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubcomp.missed": {
            "description": "Number of missed PUBCOMP packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubcomp.received": {
            "description": "Number of received PUBCOMP packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubcomp.sent": {
            "description": "Number of sent PUBCOMP packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.publish.auth_error": {
            "description": "Number of received PUBLISH packets with failed the Authorization check",
            "minimum": 0,
            "type": "integer"
          },
          "packets.publish.dropped": {
            "description": "Number of messages discarded due to the receiving limit",
            "minimum": 0,
            "type": "integer"
          },
          "packets.publish.error": {
            "description": "Number of received PUBLISH packet that cannot be published",
            "minimum": 0,
            "type": "integer"
          },
          "packets.publish.inuse": {
            "description": "Number of received PUBLISH packet with occupied identifiers",
            "minimum": 0,
            "type": "integer"
          },
          "packets.publish.received": {
            "description": "Number of received PUBLISH packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.publish.sent": {
            "description": "Number of sent PUBLISH packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubrec.inuse": {
            "description": "Number of received PUBREC packet with occupied identifiers",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubrec.missed": {
            "description": "Number of received PUBREC packet with unknown identifiers",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubrec.received": {
            "description": "Number of received PUBREC packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubrec.sent": {
            "description": "Number of sent PUBREC packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubrel.missed": {
            "description": "Number of received PUBREC packet with unknown identifiers",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubrel.received": {
            "description": "Number of received PUBREL packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubrel.sent": {
            "description": "Number of sent PUBREL packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.received": {
            "description": "Number of received packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.sent": {
            "description": "Number of sent packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.suback.sent": {
            "description": "Number of sent SUBACK packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.subscribe.auth_error": {
            "description": "Number of received SUBACK packet with failed Authorization check",
            "minimum": 0,
            "type": "integer"
          },
          "packets.subscribe.error": {
            "description": "Number of received SUBSCRIBE packet with failed subscriptions",
            "minimum": 0,
            "type": "integer"
          },
          "packets.subscribe.received": {
            "description": "Number of received SUBSCRIBE packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.unsuback.sent": {
            "description": "Number of sent UNSUBACK packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.unsubscribe.error": {
            "description": "Number of received UNSUBSCRIBE packet with failed unsubscriptions",
            "minimum": 0,
            "type": "integer"
          },
          "packets.unsubscribe.received": {
            "description": "Number of received UNSUBSCRIBE packet",
            "minimum": 0,
            "type": "integer"
          },
          "rules.matched": {
            "description": "Number of rule matched",
            "minimum": 0,
            "type": "integer"
          },
          "session.created": {
            "description": "Number of sessions created",
            "minimum": 0,
            "type": "integer"
          },
          "session.discarded": {
            "description": "Number of sessions dropped because Clean Session or Clean Start is true",
            "minimum": 0,
            "type": "integer"
          },
          "session.resumed": {
            "description": "Number of sessions resumed because Clean Session or Clean Start is false",
            "minimum": 0,
            "type": "integer"
          },
          "session.takenover": {
            "description": "Number of sessions takenover because Clean Session or Clean Start is false",
            "minimum": 0,
            "type": "integer"
          },
          "session.terminated": {
            "description": "Number of terminated sessions",
            "minimum": 0,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "bridge_pgsql.post": {
        "required": [
          "database",
          "name",
          "server",
          "type"
        ],
        "properties": {
          "type": {
            "description": "The Bridge Type",
            "enum": [
              "pgsql"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name.",
            "summary": "Bridge Name",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "sql": {
            "default": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
            "description": "SQL Template",
            "format": "sql",
            "summary": "SQL Template",
            "type": "string"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to PostgreSQL. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The PostgreSQL default port 5432 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "bridge_gcp_pubsub.put": {
        "required": [
          "pubsub_topic",
          "service_account_json"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "connect_timeout": {
            "default": "15s",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s",
            "summary": "Connect Timeout",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "The pool size.",
            "minimum": 1,
            "summary": "Pool Size",
            "type": "integer"
          },
          "pipelining": {
            "default": 100,
            "description": "A positive integer. Whether to send HTTP requests continuously, when set to 1, it means that after each HTTP request is sent, you need to wait for the server to return and then continue to send the next request.",
            "minimum": 1,
            "summary": "HTTP Pipelineing",
            "type": "integer"
          },
          "max_retries": {
            "default": 2,
            "description": "Max retry times if an error occurs when sending a request.",
            "minimum": 0,
            "summary": "Max Retries",
            "type": "integer"
          },
          "request_timeout": {
            "default": "15s",
            "deprecated": true,
            "description": "Deprecated: Configure the request timeout in the buffer settings.",
            "example": "32s",
            "summary": "Request Timeout",
            "type": "string"
          },
          "payload_template": {
            "default": "",
            "description": "The template for formatting the outgoing messages.  If undefined, will send all the available context in JSON format.",
            "summary": "Payload template",
            "type": "string"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to GCP PubSub. All MQTT 'PUBLISH' messages with the topic<br/>matching `local_topic` will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "pubsub_topic": {
            "description": "The GCP PubSub topic to publish messages to.",
            "summary": "GCP PubSub Topic",
            "type": "string"
          },
          "service_account_json": {
            "description": "JSON containing the GCP Service Account credentials to be used with PubSub.<br/>When a GCP Service Account is created (as described in https://developers.google.com/identity/protocols/oauth2/service-account#creatinganaccount), you have the option of downloading the credentials in JSON form.  That's the file needed.",
            "example": {},
            "summary": "GCP Service Account Credentials",
            "type": "object"
          }
        },
        "type": "object"
      },
      "bridge_hstreamdb.put": {
        "required": [
          "connector"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "direction": {
            "default": "egress",
            "description": "The direction of this bridge, MUST be 'egress'",
            "enum": [
              "egress"
            ],
            "summary": "Bridge Direction",
            "type": "string"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to the HStreamDB. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "payload": {
            "default": "${payload}",
            "description": "The payload to be forwarded to the HStreamDB. Placeholders supported.",
            "summary": "Payload",
            "type": "string"
          },
          "connector": {
            "description": "Generic configuration for the connector.",
            "example": "hstreamdb:demo",
            "summary": "Connector Generic Configuration",
            "oneOf": [
              {
                "$ref": "#/components/schemas/connector_hstreamdb.config"
              },
              {
                "type": "string"
              }
            ]
          }
        },
        "type": "object"
      },
      "listeners.ws_required_bind(with_name)": {
        "required": [
          "bind",
          "name",
          "type"
        ],
        "properties": {
          "type": {
            "description": "Listener type",
            "enum": [
              "ws"
            ],
            "type": "string"
          },
          "running": {
            "description": "Listener status",
            "type": "boolean"
          },
          "name": {
            "description": "Listener name",
            "type": "string"
          },
          "current_connections": {
            "description": "Current connections",
            "minimum": 0,
            "type": "integer"
          },
          "enabled": {
            "default": true,
            "description": "Enable listener.",
            "summary": "Enable listener",
            "type": "boolean"
          },
          "bind": {
            "default": 8083,
            "description": "IP address and port for the listening socket.",
            "summary": "IP address and port",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "acceptors": {
            "default": 16,
            "description": "The size of the listener's receiving pool.",
            "minimum": 1,
            "summary": "Acceptors Num",
            "type": "integer"
          },
          "max_connections": {
            "default": 5000000,
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "summary": "Max connections",
            "oneOf": [
              {
                "minimum": 1,
                "type": "integer"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message<br/>is delivered to the subscriber. The mountpoint is a way that users can use<br/>to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`<br/>set to `some_tenant`, then the client actually subscribes to the topic<br/>`some_tenant/t`. Similarly, if another client B (connected to the same listener<br/>as the client A) sends a message to topic `t`, the message is routed<br/>to all the clients subscribed `some_tenant/t`, so client A will receive the<br/>message, with topic name `t`.<br/><br/>Set to `\"\"` to disable the feature.<br/><br/><br/>Variables in mountpoint string:<br/>  - <code>${clientid}</code>: clientid<br/>  - <code>${username}</code>: username",
            "summary": "mountpoint",
            "type": "string"
          },
          "zone": {
            "default": "default",
            "description": "The configuration zone to which the listener belongs.",
            "summary": "Zone",
            "type": "string"
          },
          "limiter": {
            "description": "Type of the rate limit.",
            "summary": "Type of the rate limit.",
            "$ref": "#/components/schemas/limiter.listener_fields"
          },
          "enable_authn": {
            "default": true,
            "description": "Set <code>true</code> (default) to enable client authentication on this listener, the authentication<br/>process goes through the configured authentication chain.<br/>When set to <code>false</code> to allow any clients with or without authentication information such as username or password to log in.<br/>When set to <code>quick_deny_anonymous</code>, it behaves like when set to <code>true</code>, but clients will be<br/>denied immediately without going through any authenticators if <code>username</code> is not provided. This is useful to fence off<br/>anonymous clients early.",
            "enum": [
              true,
              false,
              "quick_deny_anonymous"
            ],
            "summary": "Enable authentication",
            "type": "string"
          },
          "access_rules": {
            "default": [
              "allow all"
            ],
            "description": "The access control rules for this listener.<br/>See: https://github.com/emqtt/esockd#allowdeny",
            "items": {
              "type": "string"
            },
            "summary": "Access rules",
            "type": "array"
          },
          "proxy_protocol": {
            "default": false,
            "description": "Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.<br/><br/>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/",
            "summary": "Proxy protocol",
            "type": "boolean"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "description": "Timeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.",
            "example": "12m",
            "summary": "Proxy protocol timeout",
            "type": "string"
          },
          "tcp_options": {
            "$ref": "#/components/schemas/broker.tcp_opts"
          },
          "websocket": {
            "$ref": "#/components/schemas/broker.ws_opts"
          }
        },
        "type": "object"
      },
      "listeners.quic_not_required_bind": {
        "required": [
          "id",
          "type"
        ],
        "properties": {
          "type": {
            "description": "Listener type",
            "enum": [
              "quic"
            ],
            "type": "string"
          },
          "running": {
            "description": "Listener status",
            "type": "boolean"
          },
          "id": {
            "description": "Listener id",
            "type": "string"
          },
          "current_connections": {
            "description": "Current connections",
            "minimum": 0,
            "type": "integer"
          },
          "bind": {
            "default": 14567,
            "description": "IP address and port for the listening socket.",
            "summary": "IP address and port",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "certfile": {
            "description": "Path to the certificate file. Will be deprecated in 5.1, use .ssl_options.certfile instead.",
            "summary": "Certificate file",
            "type": "string"
          },
          "keyfile": {
            "description": "Path to the secret key file. Will be deprecated in 5.1, use .ssl_options.keyfile instead.",
            "summary": "Key file",
            "type": "string"
          },
          "ciphers": {
            "default": [
              "TLS_AES_256_GCM_SHA384",
              "TLS_AES_128_GCM_SHA256",
              "TLS_CHACHA20_POLY1305_SHA256"
            ],
            "description": "This config holds TLS cipher suite names separated by comma,<br/>or as an array of strings. e.g.<br/><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or<br/><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.<br/><br/><br/>Ciphers (and their ordering) define the way in which the<br/>client and server encrypts information over the network connection.<br/>Selecting a good cipher suite is critical for the<br/>application's data security, confidentiality and performance.<br/><br/>The names should be in OpenSSL string format (not RFC format).<br/>All default values and examples provided by EMQX config<br/>documentation are all in OpenSSL format.<br/><br/><br/>NOTE: Certain cipher suites are only compatible with<br/>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')<br/>incompatible cipher suites will be silently dropped.<br/>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,<br/>configuring cipher suites for other versions will have no effect.<br/><br/><br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br/><br/>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.<br/><br/>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,<br/>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,<br/>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,<br/>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code><br/><br/><br/>NOTE: QUIC listener supports only 'tlsv1.3' ciphers",
            "items": {
              "type": "string"
            },
            "summary": "",
            "type": "array"
          },
          "idle_timeout": {
            "default": 0,
            "description": "How long a connection can go idle before it is gracefully shut down. 0 to disable",
            "example": "32s",
            "summary": "Idle Timeout",
            "type": "string"
          },
          "handshake_idle_timeout": {
            "default": "10s",
            "description": "How long a handshake can idle before it is discarded.",
            "example": "32s",
            "summary": "Handshake Idle Timeout",
            "type": "string"
          },
          "keep_alive_interval": {
            "default": 0,
            "description": "How often to send PING frames to keep a connection alive. 0 means disabled.",
            "example": "32s",
            "summary": "Keep Alive Interval",
            "type": "string"
          },
          "ssl_options": {
            "description": "TLS options for QUIC transport",
            "summary": "TLS Options",
            "$ref": "#/components/schemas/broker.listener_quic_ssl_opts"
          },
          "enabled": {
            "default": true,
            "description": "Enable listener.",
            "summary": "Enable listener",
            "type": "boolean"
          },
          "acceptors": {
            "default": 16,
            "description": "The size of the listener's receiving pool.",
            "minimum": 1,
            "summary": "Acceptors Num",
            "type": "integer"
          },
          "max_connections": {
            "default": 5000000,
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "summary": "Max connections",
            "oneOf": [
              {
                "minimum": 1,
                "type": "integer"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message<br/>is delivered to the subscriber. The mountpoint is a way that users can use<br/>to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`<br/>set to `some_tenant`, then the client actually subscribes to the topic<br/>`some_tenant/t`. Similarly, if another client B (connected to the same listener<br/>as the client A) sends a message to topic `t`, the message is routed<br/>to all the clients subscribed `some_tenant/t`, so client A will receive the<br/>message, with topic name `t`.<br/><br/>Set to `\"\"` to disable the feature.<br/><br/><br/>Variables in mountpoint string:<br/>  - <code>${clientid}</code>: clientid<br/>  - <code>${username}</code>: username",
            "summary": "mountpoint",
            "type": "string"
          },
          "zone": {
            "default": "default",
            "description": "The configuration zone to which the listener belongs.",
            "summary": "Zone",
            "type": "string"
          },
          "limiter": {
            "description": "Type of the rate limit.",
            "summary": "Type of the rate limit.",
            "$ref": "#/components/schemas/limiter.listener_fields"
          },
          "enable_authn": {
            "default": true,
            "description": "Set <code>true</code> (default) to enable client authentication on this listener, the authentication<br/>process goes through the configured authentication chain.<br/>When set to <code>false</code> to allow any clients with or without authentication information such as username or password to log in.<br/>When set to <code>quick_deny_anonymous</code>, it behaves like when set to <code>true</code>, but clients will be<br/>denied immediately without going through any authenticators if <code>username</code> is not provided. This is useful to fence off<br/>anonymous clients early.",
            "enum": [
              true,
              false,
              "quick_deny_anonymous"
            ],
            "summary": "Enable authentication",
            "type": "string"
          }
        },
        "type": "object"
      },
      "retainer.message": {
        "properties": {
          "payload": {
            "description": "Payload.",
            "type": "string"
          },
          "msgid": {
            "description": "Message ID.",
            "type": "string"
          },
          "topic": {
            "description": "Topic.",
            "type": "string"
          },
          "qos": {
            "description": "QoS.",
            "example": 0,
            "maximum": 2,
            "minimum": 0,
            "type": "integer"
          },
          "publish_at": {
            "description": "Message publish time, RFC 3339 format.",
            "type": "string"
          },
          "from_clientid": {
            "description": "The clientid of publisher.",
            "type": "string"
          },
          "from_username": {
            "description": "The username of publisher.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_authn_schema.node_status": {
        "properties": {
          "node": {
            "description": "Node name.",
            "example": "emqx@127.0.0.1",
            "summary": "Node Name.",
            "type": "string"
          },
          "status": {
            "description": "The status of the resource for each node.",
            "enum": [
              "connected",
              "disconnected",
              "connecting"
            ],
            "summary": "Resource Status in Node",
            "type": "string"
          }
        },
        "type": "object"
      },
      "exhook.server_config": {
        "required": [
          "name",
          "url"
        ],
        "properties": {
          "name": {
            "description": "Name of the exhook server",
            "example": "default",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable this Exhook server",
            "type": "boolean"
          },
          "url": {
            "description": "URL of the gRPC server",
            "example": "http://127.0.0.1:9000",
            "type": "string"
          },
          "request_timeout": {
            "default": "5s",
            "description": "The timeout of request gRPC server",
            "example": "12m",
            "type": "string"
          },
          "failed_action": {
            "default": "deny",
            "description": "The value that is returned when the request to the gRPC server fails for any reason",
            "enum": [
              "deny",
              "ignore"
            ],
            "type": "string"
          },
          "ssl": {
            "$ref": "#/components/schemas/exhook.ssl_conf"
          },
          "socket_options": {
            "default": {
              "keepalive": true,
              "nodelay": true
            },
            "$ref": "#/components/schemas/exhook.socket_options"
          },
          "auto_reconnect": {
            "default": "60s",
            "description": "Whether to automatically reconnect (initialize) the gRPC server.<br/>When gRPC is not available, Exhook tries to request the gRPC service at that interval and reinitialize the list of mounted hooks.",
            "oneOf": [
              {
                "example": "12m",
                "type": "string"
              },
              {
                "enum": [
                  false
                ],
                "type": "string"
              }
            ]
          },
          "pool_size": {
            "default": 8,
            "description": "The process pool size for gRPC client",
            "minimum": 1,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "bridge_mongodb.get_sharded": {
        "required": [
          "database",
          "name",
          "servers",
          "type"
        ],
        "properties": {
          "status": {
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status.",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary": "Bridge Status",
            "type": "string"
          },
          "status_reason": {
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused",
            "summary": "Failure reason",
            "type": "string"
          },
          "node_status": {
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            },
            "summary": "Node Status",
            "type": "array"
          },
          "mongo_type": {
            "default": "sharded",
            "description": "Sharded cluster. Must be set to 'sharded' when MongoDB server is running in 'sharded' mode.",
            "enum": [
              "sharded"
            ],
            "summary": "Sharded cluster",
            "type": "string"
          },
          "servers": {
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The MongoDB default port 27017 is used if `[:Port]` is not specified.",
            "summary": "Servers",
            "type": "string"
          },
          "w_mode": {
            "default": "unsafe",
            "description": "Write mode.",
            "enum": [
              "unsafe",
              "safe"
            ],
            "summary": "Write Mode",
            "type": "string"
          },
          "srv_record": {
            "default": false,
            "description": "Use DNS SRV record.",
            "summary": "Srv Record",
            "type": "boolean"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auth_source": {
            "description": "Database name associated with the user's credentials.",
            "summary": "Auth Source",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "topology": {
            "$ref": "#/components/schemas/emqx_connector_mongo.topology"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable this MongoDB Bridge",
            "summary": "Enable or disable",
            "type": "boolean"
          },
          "collection": {
            "default": "mqtt",
            "description": "The collection where data will be stored into",
            "summary": "Collection to be used",
            "type": "string"
          },
          "payload_template": {
            "description": "The template for formatting the outgoing messages.  If undefined, rule engine will use JSON format to serialize all visible inputs, such as clientid, topic, payload etc.",
            "summary": "Payload template",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "type": {
            "description": "The Bridge Type.",
            "enum": [
              "mongodb_sharded"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name.",
            "summary": "Bridge Name",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_rule_api_schema.ctx_sub": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "description": "Event Type",
            "enum": [
              "session_subscribed"
            ],
            "summary": "Event Type",
            "type": "string"
          },
          "clientid": {
            "description": "The Client ID",
            "summary": "Client ID",
            "type": "string"
          },
          "username": {
            "description": "Username",
            "summary": "Username",
            "type": "string"
          },
          "payload": {
            "description": "The Message Payload",
            "summary": "Message Payload",
            "type": "string"
          },
          "peerhost": {
            "description": "The IP Address of the Peer Client",
            "summary": "Peer IP Address",
            "type": "string"
          },
          "topic": {
            "description": "Message Topic",
            "summary": "Message Topic",
            "type": "string"
          },
          "publish_received_at": {
            "description": "The Time that this Message is Received",
            "summary": "Message Received Time",
            "type": "integer"
          },
          "qos": {
            "description": "The Message QoS",
            "example": 0,
            "maximum": 2,
            "minimum": 0,
            "summary": "Message QoS",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "bridge_mongodb.post_single": {
        "required": [
          "database",
          "name",
          "server",
          "type"
        ],
        "properties": {
          "mongo_type": {
            "default": "single",
            "description": "Standalone instance. Must be set to 'single' when MongoDB server is running in standalone mode.",
            "enum": [
              "single"
            ],
            "summary": "Standalone instance",
            "type": "string"
          },
          "server": {
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The MongoDB default port 27017 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "w_mode": {
            "default": "unsafe",
            "description": "Write mode.",
            "enum": [
              "unsafe",
              "safe"
            ],
            "summary": "Write Mode",
            "type": "string"
          },
          "srv_record": {
            "default": false,
            "description": "Use DNS SRV record.",
            "summary": "Srv Record",
            "type": "boolean"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auth_source": {
            "description": "Database name associated with the user's credentials.",
            "summary": "Auth Source",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "topology": {
            "$ref": "#/components/schemas/emqx_connector_mongo.topology"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable this MongoDB Bridge",
            "summary": "Enable or disable",
            "type": "boolean"
          },
          "collection": {
            "default": "mqtt",
            "description": "The collection where data will be stored into",
            "summary": "Collection to be used",
            "type": "string"
          },
          "payload_template": {
            "description": "The template for formatting the outgoing messages.  If undefined, rule engine will use JSON format to serialize all visible inputs, such as clientid, topic, payload etc.",
            "summary": "Payload template",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "type": {
            "description": "The Bridge Type.",
            "enum": [
              "mongodb_single"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name.",
            "summary": "Bridge Name",
            "type": "string"
          }
        },
        "type": "object"
      },
      "gateway.clientinfo_override": {
        "properties": {
          "username": {
            "description": "Template for overriding username.",
            "type": "string"
          },
          "password": {
            "description": "Template for overriding password.",
            "format": "password",
            "type": "string"
          },
          "clientid": {
            "description": "Template for overriding clientid.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "statsd.statsd": {
        "properties": {
          "enable": {
            "default": false,
            "description": "Enable or disable StatsD metrics collection and push service.",
            "type": "boolean"
          },
          "server": {
            "default": "127.0.0.1:8125",
            "description": "StatsD server address.",
            "type": "string"
          },
          "sample_time_interval": {
            "default": "30s",
            "description": "The sampling interval for metrics.",
            "example": "32s",
            "type": "string"
          },
          "flush_time_interval": {
            "default": "30s",
            "description": "The push interval for metrics.",
            "example": "32s",
            "type": "string"
          },
          "tags": {
            "default": {},
            "description": "The tags for metrics.",
            "example": {},
            "type": "object"
          }
        },
        "type": "object"
      },
      "emqx_rule_api_schema.rule_events": {
        "required": [
          "event"
        ],
        "properties": {
          "event": {
            "description": "The event topics",
            "enum": [
              "$events/client_connected",
              "$events/client_disconnected",
              "$events/client_connack",
              "$events/client_check_authz_complete",
              "$events/session_subscribed",
              "$events/session_unsubscribed",
              "$events/message_delivered",
              "$events/message_acked",
              "$events/message_dropped",
              "$events/delivery_dropped"
            ],
            "summary": "Event Topics",
            "type": "string"
          },
          "title": {
            "description": "The title",
            "example": "some title",
            "summary": "Title",
            "type": "string"
          },
          "description": {
            "description": "The description",
            "example": "some desc",
            "summary": "Description",
            "type": "string"
          },
          "columns": {
            "description": "The columns",
            "example": {},
            "summary": "Column",
            "type": "object"
          },
          "test_columns": {
            "description": "The test columns",
            "example": {},
            "summary": "Test Columns",
            "type": "object"
          },
          "sql_example": {
            "description": "The sql_example",
            "summary": "SQL Example",
            "type": "string"
          }
        },
        "type": "object"
      },
      "exhook.socket_options": {
        "properties": {
          "keepalive": {
            "default": true,
            "description": "Enables/disables periodic transmission on a connected socket when no other data is exchanged.<br/>If the other end does not respond, the connection is considered broken and an error message is sent to the controlling process.",
            "type": "boolean"
          },
          "nodelay": {
            "default": true,
            "description": "If true, option TCP_NODELAY is turned on for the socket,<br/>which means that also small amounts of data are sent immediately",
            "type": "boolean"
          },
          "recbuf": {
            "description": "The minimum size of receive buffer to use for the socket",
            "example": "64KB",
            "type": "string"
          },
          "sndbuf": {
            "description": "The minimum size of send buffer to use for the socket",
            "example": "16KB",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_clients.keepalive": {
        "properties": {
          "interval": {
            "description": "Keepalive time, with the unit of second",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "listeners.status": {
        "required": [
          "running"
        ],
        "properties": {
          "running": {
            "description": "Listener running status",
            "oneOf": [
              {
                "type": "boolean"
              },
              {
                "enum": [
                  "inconsistent"
                ],
                "type": "string"
              }
            ]
          },
          "max_connections": {
            "description": "Max connections",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "current_connections": {
            "description": "Current connections",
            "minimum": 0,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "bridge_cassa.put": {
        "required": [
          "keyspace",
          "servers"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "cql": {
            "default": "insert into mqtt_msg(topic, msgid, sender, qos, payload, arrived, retain) values (${topic}, ${id}, ${clientid}, ${qos}, ${payload}, ${timestamp}, ${flags.retain})",
            "description": "CQL Template",
            "format": "sql",
            "summary": "CQL Template",
            "type": "string"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to Cassandra. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "servers": {
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port][,Host2:Port]`.<br/><br/>The Cassandra default port 9042 is used if `[:Port]` is not specified.",
            "summary": "Servers",
            "type": "string"
          },
          "keyspace": {
            "description": "Keyspace name to connect to.",
            "summary": "Keyspace",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "listeners.ws_not_required_bind": {
        "required": [
          "id",
          "type"
        ],
        "properties": {
          "type": {
            "description": "Listener type",
            "enum": [
              "ws"
            ],
            "type": "string"
          },
          "running": {
            "description": "Listener status",
            "type": "boolean"
          },
          "id": {
            "description": "Listener id",
            "type": "string"
          },
          "current_connections": {
            "description": "Current connections",
            "minimum": 0,
            "type": "integer"
          },
          "bind": {
            "default": 8083,
            "description": "IP address and port for the listening socket.",
            "summary": "IP address and port",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "enabled": {
            "default": true,
            "description": "Enable listener.",
            "summary": "Enable listener",
            "type": "boolean"
          },
          "acceptors": {
            "default": 16,
            "description": "The size of the listener's receiving pool.",
            "minimum": 1,
            "summary": "Acceptors Num",
            "type": "integer"
          },
          "max_connections": {
            "default": 5000000,
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "summary": "Max connections",
            "oneOf": [
              {
                "minimum": 1,
                "type": "integer"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message<br/>is delivered to the subscriber. The mountpoint is a way that users can use<br/>to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`<br/>set to `some_tenant`, then the client actually subscribes to the topic<br/>`some_tenant/t`. Similarly, if another client B (connected to the same listener<br/>as the client A) sends a message to topic `t`, the message is routed<br/>to all the clients subscribed `some_tenant/t`, so client A will receive the<br/>message, with topic name `t`.<br/><br/>Set to `\"\"` to disable the feature.<br/><br/><br/>Variables in mountpoint string:<br/>  - <code>${clientid}</code>: clientid<br/>  - <code>${username}</code>: username",
            "summary": "mountpoint",
            "type": "string"
          },
          "zone": {
            "default": "default",
            "description": "The configuration zone to which the listener belongs.",
            "summary": "Zone",
            "type": "string"
          },
          "limiter": {
            "description": "Type of the rate limit.",
            "summary": "Type of the rate limit.",
            "$ref": "#/components/schemas/limiter.listener_fields"
          },
          "enable_authn": {
            "default": true,
            "description": "Set <code>true</code> (default) to enable client authentication on this listener, the authentication<br/>process goes through the configured authentication chain.<br/>When set to <code>false</code> to allow any clients with or without authentication information such as username or password to log in.<br/>When set to <code>quick_deny_anonymous</code>, it behaves like when set to <code>true</code>, but clients will be<br/>denied immediately without going through any authenticators if <code>username</code> is not provided. This is useful to fence off<br/>anonymous clients early.",
            "enum": [
              true,
              false,
              "quick_deny_anonymous"
            ],
            "summary": "Enable authentication",
            "type": "string"
          },
          "access_rules": {
            "default": [
              "allow all"
            ],
            "description": "The access control rules for this listener.<br/>See: https://github.com/emqtt/esockd#allowdeny",
            "items": {
              "type": "string"
            },
            "summary": "Access rules",
            "type": "array"
          },
          "proxy_protocol": {
            "default": false,
            "description": "Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.<br/><br/>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/",
            "summary": "Proxy protocol",
            "type": "boolean"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "description": "Timeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.",
            "example": "12m",
            "summary": "Proxy protocol timeout",
            "type": "string"
          },
          "tcp_options": {
            "$ref": "#/components/schemas/broker.tcp_opts"
          },
          "websocket": {
            "$ref": "#/components/schemas/broker.ws_opts"
          }
        },
        "type": "object"
      },
      "connector-mqtt.egress": {
        "required": [
          "remote"
        ],
        "properties": {
          "local": {
            "description": "The configs about receiving messages from local broker.",
            "summary": "Local Configs",
            "$ref": "#/components/schemas/connector-mqtt.egress_local"
          },
          "remote": {
            "description": "The configs about sending message to the remote broker.",
            "summary": "Remote Configs",
            "$ref": "#/components/schemas/connector-mqtt.egress_remote"
          }
        },
        "type": "object"
      },
      "emqx_authn_api.request_user_update": {
        "required": [
          "password"
        ],
        "properties": {
          "password": {
            "type": "string"
          },
          "is_superuser": {
            "default": false,
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api_clients.subscription": {
        "properties": {
          "topic": {
            "description": "Topic Filter/Name",
            "type": "string"
          },
          "qos": {
            "description": "QoS level, enum: 0, 1, 2",
            "type": "integer"
          },
          "nl": {
            "description": "No Local option, enum: 0, 1",
            "type": "integer"
          },
          "rap": {
            "description": "Retain as Published option, enum: 0, 1",
            "type": "integer"
          },
          "rh": {
            "description": "Retain Handling option, enum: 0, 1, 2",
            "type": "integer"
          },
          "sub_props": {
            "description": "Subscription properties",
            "$ref": "#/components/schemas/emqx_gateway_api_clients.extra_sub_props"
          }
        },
        "type": "object"
      },
      "bridge_kafka.post_consumer": {
        "required": [
          "bootstrap_hosts",
          "name",
          "topic_mapping",
          "type"
        ],
        "properties": {
          "type": {
            "description": "The Bridge Type",
            "enum": [
              "kafka_consumer",
              "kafka"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name, used as a human-readable description of the bridge.",
            "summary": "Bridge Name",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable (true) or disable (false) this Kafka bridge.",
            "summary": "Enable or Disable",
            "type": "boolean"
          },
          "bootstrap_hosts": {
            "description": "A comma separated list of Kafka <code>host[:port]</code> endpoints to bootstrap the client. Default port number is 9092.",
            "summary": "Bootstrap Hosts",
            "type": "string"
          },
          "connect_timeout": {
            "default": "5s",
            "description": "Maximum wait time for TCP connection establishment (including authentication time if enabled).",
            "example": "32s",
            "summary": "Connect Timeout",
            "type": "string"
          },
          "min_metadata_refresh_interval": {
            "default": "3s",
            "description": "Minimum time interval the client has to wait before refreshing Kafka broker and topic metadata. Setting too small value may add extra load on Kafka.",
            "example": "32s",
            "summary": "Min Metadata Refresh Interval",
            "type": "string"
          },
          "metadata_request_timeout": {
            "default": "5s",
            "description": "Maximum wait time when fetching metadata from Kafka.",
            "example": "32s",
            "summary": "Metadata Request Timeout",
            "type": "string"
          },
          "authentication": {
            "default": "none",
            "description": "Authentication configs.",
            "summary": "Authentication",
            "oneOf": [
              {
                "$ref": "#/components/schemas/bridge_kafka.auth_gssapi_kerberos"
              },
              {
                "$ref": "#/components/schemas/bridge_kafka.auth_username_password"
              },
              {
                "enum": [
                  "none"
                ],
                "type": "string"
              }
            ]
          },
          "socket_opts": {
            "description": "Extra socket options.",
            "summary": "Socket Options",
            "$ref": "#/components/schemas/bridge_kafka.socket_opts"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          },
          "kafka": {
            "description": "Kafka consumer configs.",
            "summary": "Kafka Consumer",
            "$ref": "#/components/schemas/bridge_kafka.consumer_kafka_opts"
          },
          "topic_mapping": {
            "description": "Defines the mapping between Kafka topics and MQTT topics. Must contain at least one item.",
            "items": {
              "$ref": "#/components/schemas/bridge_kafka.consumer_topic_mapping"
            },
            "summary": "Topic Mapping",
            "type": "array"
          },
          "key_encoding_mode": {
            "default": "none",
            "description": "Defines how the key from the Kafka message is encoded before being forwarded via MQTT.<br/><code>none</code> Uses the key from the Kafka message unchanged.  Note: in this case, the key must be a valid UTF-8 string.<br/><code>base64</code> Uses base-64 encoding on the received key.",
            "enum": [
              "none",
              "base64"
            ],
            "summary": "Key Encoding Mode",
            "type": "string"
          },
          "value_encoding_mode": {
            "default": "none",
            "description": "Defines how the value from the Kafka message is encoded before being forwarded via MQTT.<br/><code>none</code> Uses the value from the Kafka message unchanged.  Note: in this case, the value must be a valid UTF-8 string.<br/><code>base64</code> Uses base-64 encoding on the received value.",
            "enum": [
              "none",
              "base64"
            ],
            "summary": "Value Encoding Mode",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.ssl_listener": {
        "properties": {
          "id": {
            "description": "Listener ID",
            "type": "string"
          },
          "type": {
            "description": "Listener Type",
            "enum": [
              "ssl"
            ],
            "type": "string"
          },
          "name": {
            "description": "Listener Name",
            "type": "string"
          },
          "running": {
            "description": "Listener Running status",
            "type": "boolean"
          },
          "acceptors": {
            "default": 16,
            "description": "Size of the acceptor pool.",
            "type": "integer"
          },
          "tcp_options": {
            "description": "Setting the TCP socket options.",
            "$ref": "#/components/schemas/broker.tcp_opts"
          },
          "proxy_protocol": {
            "default": false,
            "description": "Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.<br/>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/",
            "type": "boolean"
          },
          "proxy_protocol_timeout": {
            "default": "15s",
            "description": "Timeout for proxy protocol.<br/>EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.",
            "example": "12m",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable the listener.",
            "type": "boolean"
          },
          "bind": {
            "description": "The IP address and port that the listener will bind.",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "max_connections": {
            "default": 1024,
            "description": "Maximum number of concurrent connections.",
            "type": "integer"
          },
          "max_conn_rate": {
            "default": 1000,
            "description": "Maximum connections per second.",
            "type": "integer"
          },
          "enable_authn": {
            "default": true,
            "description": "Set <code>true</code> (default) to enable client authentication on this listener. <br/>When set to <code>false</code> clients will be allowed to connect without authentication.",
            "type": "boolean"
          },
          "mountpoint": {
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message is delivered to the subscriber.<br/>The mountpoint is a way that users can use to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,<br/>then the client actually subscribes to the topic `some_tenant/t`.<br/>Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,<br/>the message is routed to all the clients subscribed `some_tenant/t`,<br/>so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.<br/>Variables in mountpoint string:<br/><br/>  - <code>${clientid}</code>: clientid<br/><br/>  - <code>${username}</code>: username",
            "type": "string"
          },
          "access_rules": {
            "default": "",
            "description": "The access control rules for this listener.<br/>See: https://github.com/emqtt/esockd#allowdeny",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "ssl_options": {
            "description": "SSL Socket options.",
            "$ref": "#/components/schemas/broker.listener_ssl_opts"
          }
        },
        "type": "object"
      },
      "bridge_dynamo.post": {
        "required": [
          "aws_access_key_id",
          "aws_secret_access_key",
          "name",
          "table",
          "type",
          "url"
        ],
        "properties": {
          "type": {
            "description": "The Bridge Type",
            "enum": [
              "dynamo"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name.",
            "summary": "Bridge Name",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "template": {
            "default": "",
            "description": "Template, the default value is empty. When this value is empty the whole message will be stored in the database",
            "summary": "Template",
            "type": "string"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to DynamoDB. All MQTT `PUBLISH` messages with the topic<br/>matching the `local_topic` will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also `local_topic` is<br/>configured, then both the data got from the rule and the MQTT messages that match `local_topic`<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/bridge_dynamo.creation_opts"
          },
          "url": {
            "description": "The url of DynamoDB endpoint.",
            "summary": "DynamoDB Endpoint",
            "type": "string"
          },
          "table": {
            "description": "DynamoDB Table.",
            "summary": "Table ",
            "type": "string"
          },
          "aws_access_key_id": {
            "description": "Access Key ID for connecting to DynamoDB.",
            "summary": "AWS Access Key ID",
            "type": "string"
          },
          "aws_secret_access_key": {
            "description": "AWS Secret Access Key for connecting to DynamoDB.",
            "summary": "AWS Secret Access Key",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "bridge_clickhouse.get": {
        "required": [
          "database",
          "name",
          "type",
          "url"
        ],
        "properties": {
          "status": {
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status.",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary": "Bridge Status",
            "type": "string"
          },
          "status_reason": {
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused",
            "summary": "Failure reason",
            "type": "string"
          },
          "node_status": {
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            },
            "summary": "Node Status",
            "type": "array"
          },
          "type": {
            "description": "The Bridge Type",
            "enum": [
              "clickhouse"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name.",
            "summary": "Bridge Name",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "sql": {
            "default": "INSERT INTO mqtt_test(payload, arrived) VALUES ('${payload}', ${timestamp})",
            "description": "The template string can contain ${field} placeholders for message metadata and payload field. Make sure that the inserted values are formatted and escaped correctly. [Prepared Statement](https://docs.emqx.com/en/enterprise/v5.0/data-integration/data-bridges.html#Prepared-Statement) is not supported.",
            "format": "sql",
            "summary": "SQL Template",
            "type": "string"
          },
          "batch_value_separator": {
            "default": ", ",
            "description": "The default value ',' works for the VALUES format. You can also use other separator if other format is specified. See [INSERT INTO Statement](https://clickhouse.com/docs/en/sql-reference/statements/insert-into).",
            "summary": "Batch Value Separator",
            "type": "string"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to Clickhouse. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/bridge_clickhouse.creation_opts"
          },
          "url": {
            "description": "The HTTP URL to the Clickhouse server that you want to connect to (for example http://myhostname:8123)",
            "example": "http://127.0.0.1",
            "summary": "Server URL",
            "type": "string"
          },
          "connect_timeout": {
            "default": "15s",
            "description": "The timeout when connecting to the Clickhouse server.",
            "example": "32s",
            "summary": "Clickhouse Timeout",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "bridge_matrix.put": {
        "required": [
          "database",
          "server"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "sql": {
            "default": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
            "description": "SQL Template",
            "format": "sql",
            "summary": "SQL Template",
            "type": "string"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to PostgreSQL. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The PostgreSQL default port 5432 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_schema.http_post": {
        "required": [
          "method",
          "type",
          "url"
        ],
        "properties": {
          "method": {
            "default": "post",
            "description": "HTTP method.",
            "enum": [
              "post"
            ],
            "summary": "method",
            "type": "string"
          },
          "headers": {
            "default": {
              "accept": "application/json",
              "cache-control": "no-cache",
              "connection": "keep-alive",
              "content-type": "application/json",
              "keep-alive": "timeout=30, max=1000"
            },
            "description": "List of HTTP Headers.",
            "example": {},
            "summary": "Headers",
            "type": "object"
          },
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this ACL provider.",
            "summary": "enable",
            "type": "boolean"
          },
          "type": {
            "default": "http",
            "description": "Backend type.",
            "enum": [
              "http"
            ],
            "summary": "type",
            "type": "string"
          },
          "url": {
            "description": "URL of the auth server.",
            "summary": "url",
            "type": "string"
          },
          "body": {
            "description": "HTTP request body.",
            "example": {},
            "summary": "body",
            "type": "object"
          },
          "request_timeout": {
            "default": "30s",
            "description": "Request timeout.",
            "summary": "request_timeout",
            "type": "string"
          },
          "connect_timeout": {
            "default": "15s",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s",
            "summary": "Connect Timeout",
            "type": "string"
          },
          "enable_pipelining": {
            "default": 100,
            "description": "A positive integer. Whether to send HTTP requests continuously, when set to 1, it means that after each HTTP request is sent, you need to wait for the server to return and then continue to send the next request.",
            "minimum": 1,
            "summary": "HTTP Pipelineing",
            "type": "integer"
          },
          "max_retries": {
            "deprecated": true,
            "minimum": 0,
            "type": "integer"
          },
          "pool_size": {
            "default": 8,
            "description": "The pool size.",
            "minimum": 1,
            "summary": "Pool Size",
            "type": "integer"
          },
          "request": {
            "description": "Configure HTTP request parameters.",
            "summary": "Request",
            "$ref": "#/components/schemas/connector-http.request"
          },
          "retry_interval": {
            "deprecated": true,
            "example": "12m",
            "type": "string"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "retainer.mnesia_config": {
        "properties": {
          "type": {
            "default": "built_in_database",
            "description": "Backend type.",
            "enum": [
              "built_in_database"
            ],
            "type": "string"
          },
          "storage_type": {
            "default": "ram",
            "description": "Specifies whether the messages are stored in RAM or persisted on disc.",
            "enum": [
              "ram",
              "disc"
            ],
            "type": "string"
          },
          "max_retained_messages": {
            "default": 0,
            "description": "Maximum number of retained messages. 0 means no limit.",
            "minimum": 0,
            "type": "integer"
          },
          "index_specs": {
            "default": [
              [
                1,
                2,
                3
              ],
              [
                1,
                3
              ],
              [
                2,
                3
              ],
              [
                3
              ]
            ],
            "description": "Retainer index specifications: list of arrays of positive ascending integers. Each array specifies an index. Numbers in an index specification are 1-based word positions in topics. Words from specified positions will be used for indexing.<br/>For example, it is good to have <code>[2, 4]</code> index to optimize <code>+/X/+/Y/...</code> topic wildcard subscriptions.",
            "example": [
              [
                2,
                4
              ],
              [
                1,
                3
              ]
            ],
            "items": {
              "type": "integer"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "emqx_conf_schema.console_handler": {
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable this log handler.",
            "summary": "Enable Log Handler",
            "type": "boolean"
          },
          "level": {
            "default": "warning",
            "description": "The log level for the current log handler.<br/>Defaults to warning.",
            "enum": [
              "debug",
              "info",
              "notice",
              "warning",
              "error",
              "critical",
              "alert",
              "emergency",
              "all"
            ],
            "summary": "Log Level",
            "type": "string"
          },
          "time_offset": {
            "default": "system",
            "description": "The time offset to be used when formatting the timestamp.<br/>Can be one of:<br/>  - <code>system</code>: the time offset used by the local system<br/>  - <code>utc</code>: the UTC time offset<br/>  - <code>+-[hh]:[mm]</code>: user specified time offset, such as \"-02:00\" or \"+00:00\"<br/>Defaults to: <code>system</code>.",
            "summary": "Time Offset",
            "type": "string"
          },
          "chars_limit": {
            "default": "unlimited",
            "description": "Set the maximum length of a single log message. If this length is exceeded, the log message will be truncated.<br/>NOTE: Restrict char limiter if formatter is JSON , it will get a truncated incomplete JSON data, which is not recommended.",
            "summary": "Single Log Max Length",
            "oneOf": [
              {
                "minimum": 100,
                "type": "integer"
              },
              {
                "enum": [
                  "unlimited"
                ],
                "type": "string"
              }
            ]
          },
          "formatter": {
            "default": "text",
            "description": "Choose log formatter. <code>text</code> for free text, and <code>json</code> for structured logging.",
            "enum": [
              "text",
              "json"
            ],
            "summary": "Log Formatter",
            "type": "string"
          },
          "single_line": {
            "default": true,
            "description": "Print logs in a single line if set to true. Otherwise, log messages may span multiple lines.",
            "summary": "Single Line Mode",
            "type": "boolean"
          },
          "sync_mode_qlen": {
            "default": 100,
            "description": "As long as the number of buffered log events is lower than this value,<br/>all log events are handled asynchronously. This means that the client process sending the log event,<br/>by calling a log function in the Logger API, does not wait for a response from the handler<br/>but continues executing immediately after the event is sent.<br/>It is not affected by the time it takes the handler to print the event to the log device.<br/>If the message queue grows larger than this value,<br/>the handler starts handling log events synchronously instead,<br/>meaning that the client process sending the event must wait for a response.<br/>When the handler reduces the message queue to a level below the sync_mode_qlen threshold,<br/>asynchronous operation is resumed.",
            "minimum": 0,
            "summary": "Queue Length before Entering Sync Mode",
            "type": "integer"
          },
          "drop_mode_qlen": {
            "default": 3000,
            "description": "When the number of buffered log events is larger than this value, the new log events are dropped.<br/>When drop mode is activated or deactivated, a message is printed in the logs.",
            "minimum": 1,
            "summary": "Queue Length before Entering Drop Mode",
            "type": "integer"
          },
          "flush_qlen": {
            "default": 8000,
            "description": "If the number of buffered log events grows larger than this threshold, a flush (delete) operation takes place.<br/>To flush events, the handler discards the buffered log messages without logging.",
            "minimum": 1,
            "summary": "Flush Threshold",
            "type": "integer"
          },
          "overload_kill": {
            "$ref": "#/components/schemas/emqx_conf_schema.log_overload_kill"
          },
          "burst_limit": {
            "$ref": "#/components/schemas/emqx_conf_schema.log_burst_limit"
          },
          "supervisor_reports": {
            "default": "error",
            "description": "Type of supervisor reports that are logged. Defaults to <code>error</code><br/><br/>  - <code>error</code>: only log errors in the Erlang processes<br/>.<br/>  - <code>progress</code>: log process startup.",
            "enum": [
              "error",
              "progress"
            ],
            "summary": "Report Type",
            "type": "string"
          },
          "max_depth": {
            "default": 100,
            "description": "Maximum depth for Erlang term log formatting and Erlang process message queue inspection.",
            "summary": "Max Depth",
            "oneOf": [
              {
                "minimum": 0,
                "type": "integer"
              },
              {
                "enum": [
                  "unlimited"
                ],
                "type": "string"
              }
            ]
          }
        },
        "type": "object"
      },
      "bridge_mongodb.get_rs": {
        "required": [
          "database",
          "name",
          "replica_set_name",
          "servers",
          "type"
        ],
        "properties": {
          "status": {
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status.",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary": "Bridge Status",
            "type": "string"
          },
          "status_reason": {
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused",
            "summary": "Failure reason",
            "type": "string"
          },
          "node_status": {
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            },
            "summary": "Node Status",
            "type": "array"
          },
          "mongo_type": {
            "default": "rs",
            "description": "Replica set. Must be set to 'rs' when MongoDB server is running in 'replica set' mode.",
            "enum": [
              "rs"
            ],
            "summary": "Replica set",
            "type": "string"
          },
          "servers": {
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The MongoDB default port 27017 is used if `[:Port]` is not specified.",
            "summary": "Servers",
            "type": "string"
          },
          "w_mode": {
            "default": "unsafe",
            "description": "Write mode.",
            "enum": [
              "unsafe",
              "safe"
            ],
            "summary": "Write Mode",
            "type": "string"
          },
          "r_mode": {
            "default": "master",
            "description": "Read mode.",
            "enum": [
              "master",
              "slave_ok"
            ],
            "summary": "Read Mode",
            "type": "string"
          },
          "replica_set_name": {
            "description": "Name of the replica set.",
            "summary": "Replica Set Name",
            "type": "string"
          },
          "srv_record": {
            "default": false,
            "description": "Use DNS SRV record.",
            "summary": "Srv Record",
            "type": "boolean"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auth_source": {
            "description": "Database name associated with the user's credentials.",
            "summary": "Auth Source",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "topology": {
            "$ref": "#/components/schemas/emqx_connector_mongo.topology"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable this MongoDB Bridge",
            "summary": "Enable or disable",
            "type": "boolean"
          },
          "collection": {
            "default": "mqtt",
            "description": "The collection where data will be stored into",
            "summary": "Collection to be used",
            "type": "string"
          },
          "payload_template": {
            "description": "The template for formatting the outgoing messages.  If undefined, rule engine will use JSON format to serialize all visible inputs, such as clientid, topic, payload etc.",
            "summary": "Payload template",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "type": {
            "description": "The Bridge Type.",
            "enum": [
              "mongodb_rs"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name.",
            "summary": "Bridge Name",
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge_kafka.put_consumer": {
        "required": [
          "bootstrap_hosts",
          "topic_mapping"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable (true) or disable (false) this Kafka bridge.",
            "summary": "Enable or Disable",
            "type": "boolean"
          },
          "bootstrap_hosts": {
            "description": "A comma separated list of Kafka <code>host[:port]</code> endpoints to bootstrap the client. Default port number is 9092.",
            "summary": "Bootstrap Hosts",
            "type": "string"
          },
          "connect_timeout": {
            "default": "5s",
            "description": "Maximum wait time for TCP connection establishment (including authentication time if enabled).",
            "example": "32s",
            "summary": "Connect Timeout",
            "type": "string"
          },
          "min_metadata_refresh_interval": {
            "default": "3s",
            "description": "Minimum time interval the client has to wait before refreshing Kafka broker and topic metadata. Setting too small value may add extra load on Kafka.",
            "example": "32s",
            "summary": "Min Metadata Refresh Interval",
            "type": "string"
          },
          "metadata_request_timeout": {
            "default": "5s",
            "description": "Maximum wait time when fetching metadata from Kafka.",
            "example": "32s",
            "summary": "Metadata Request Timeout",
            "type": "string"
          },
          "authentication": {
            "default": "none",
            "description": "Authentication configs.",
            "summary": "Authentication",
            "oneOf": [
              {
                "$ref": "#/components/schemas/bridge_kafka.auth_gssapi_kerberos"
              },
              {
                "$ref": "#/components/schemas/bridge_kafka.auth_username_password"
              },
              {
                "enum": [
                  "none"
                ],
                "type": "string"
              }
            ]
          },
          "socket_opts": {
            "description": "Extra socket options.",
            "summary": "Socket Options",
            "$ref": "#/components/schemas/bridge_kafka.socket_opts"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          },
          "kafka": {
            "description": "Kafka consumer configs.",
            "summary": "Kafka Consumer",
            "$ref": "#/components/schemas/bridge_kafka.consumer_kafka_opts"
          },
          "topic_mapping": {
            "description": "Defines the mapping between Kafka topics and MQTT topics. Must contain at least one item.",
            "items": {
              "$ref": "#/components/schemas/bridge_kafka.consumer_topic_mapping"
            },
            "summary": "Topic Mapping",
            "type": "array"
          },
          "key_encoding_mode": {
            "default": "none",
            "description": "Defines how the key from the Kafka message is encoded before being forwarded via MQTT.<br/><code>none</code> Uses the key from the Kafka message unchanged.  Note: in this case, the key must be a valid UTF-8 string.<br/><code>base64</code> Uses base-64 encoding on the received key.",
            "enum": [
              "none",
              "base64"
            ],
            "summary": "Key Encoding Mode",
            "type": "string"
          },
          "value_encoding_mode": {
            "default": "none",
            "description": "Defines how the value from the Kafka message is encoded before being forwarded via MQTT.<br/><code>none</code> Uses the value from the Kafka message unchanged.  Note: in this case, the value must be a valid UTF-8 string.<br/><code>base64</code> Uses base-64 encoding on the received value.",
            "enum": [
              "none",
              "base64"
            ],
            "summary": "Value Encoding Mode",
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge_mongodb.put_single": {
        "required": [
          "database",
          "server"
        ],
        "properties": {
          "mongo_type": {
            "default": "single",
            "description": "Standalone instance. Must be set to 'single' when MongoDB server is running in standalone mode.",
            "enum": [
              "single"
            ],
            "summary": "Standalone instance",
            "type": "string"
          },
          "server": {
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The MongoDB default port 27017 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "w_mode": {
            "default": "unsafe",
            "description": "Write mode.",
            "enum": [
              "unsafe",
              "safe"
            ],
            "summary": "Write Mode",
            "type": "string"
          },
          "srv_record": {
            "default": false,
            "description": "Use DNS SRV record.",
            "summary": "Srv Record",
            "type": "boolean"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auth_source": {
            "description": "Database name associated with the user's credentials.",
            "summary": "Auth Source",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "topology": {
            "$ref": "#/components/schemas/emqx_connector_mongo.topology"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable this MongoDB Bridge",
            "summary": "Enable or disable",
            "type": "boolean"
          },
          "collection": {
            "default": "mqtt",
            "description": "The collection where data will be stored into",
            "summary": "Collection to be used",
            "type": "string"
          },
          "payload_template": {
            "description": "The template for formatting the outgoing messages.  If undefined, rule engine will use JSON format to serialize all visible inputs, such as clientid, topic, payload etc.",
            "summary": "Payload template",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          }
        },
        "type": "object"
      },
      "bridge_webhook.get": {
        "required": [
          "name",
          "type",
          "url"
        ],
        "properties": {
          "status": {
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status.",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary": "Bridge Status",
            "type": "string"
          },
          "status_reason": {
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused",
            "summary": "Failure reason",
            "type": "string"
          },
          "node_status": {
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            },
            "summary": "Node Status",
            "type": "array"
          },
          "type": {
            "description": "The Bridge Type",
            "enum": [
              "webhook"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name, used as a human-readable description of the bridge.",
            "summary": "Bridge Name",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/bridge_webhook.creation_opts"
          },
          "connect_timeout": {
            "default": "15s",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s",
            "summary": "Connect Timeout",
            "type": "string"
          },
          "retry_interval": {
            "deprecated": true,
            "example": "12m",
            "type": "string"
          },
          "pool_type": {
            "default": "random",
            "description": "The type of the pool. Can be one of `random`, `hash`.",
            "enum": [
              "random",
              "hash"
            ],
            "summary": "Pool Type",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "The pool size.",
            "minimum": 1,
            "summary": "Pool Size",
            "type": "integer"
          },
          "enable_pipelining": {
            "default": 100,
            "description": "A positive integer. Whether to send HTTP requests continuously, when set to 1, it means that after each HTTP request is sent, you need to wait for the server to return and then continue to send the next request.",
            "minimum": 1,
            "summary": "HTTP Pipelineing",
            "type": "integer"
          },
          "request": {
            "description": "Configure HTTP request parameters.",
            "summary": "Request",
            "$ref": "#/components/schemas/connector-http.request"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          },
          "url": {
            "description": "The URL of the HTTP Bridge.<br/><br/>Template with variables is allowed in the path, but variables cannot be used in the scheme, host,<br/>or port part.<br/><br/>For example, <code> http://localhost:9901/${topic} </code> is allowed, but<br/><code> http://${host}:9901/message </code> or <code> http://localhost:${port}/message </code><br/>is not allowed.",
            "summary": "HTTP Bridge",
            "type": "string"
          },
          "direction": {
            "deprecated": true,
            "description": "Deprecated, The direction of this bridge, MUST be 'egress'",
            "enum": [
              "egress"
            ],
            "summary": "Bridge Direction",
            "type": "string"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to the HTTP server. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "method": {
            "default": "post",
            "description": "The method of the HTTP request. All the available methods are: post, put, get, delete.<br/><br/>Template with variables is allowed.",
            "enum": [
              "post",
              "put",
              "get",
              "delete"
            ],
            "summary": "HTTP Method",
            "type": "string"
          },
          "headers": {
            "default": {
              "accept": "application/json",
              "cache-control": "no-cache",
              "connection": "keep-alive",
              "content-type": "application/json",
              "keep-alive": "timeout=5"
            },
            "description": "The headers of the HTTP request.<br/><br/>Template with variables is allowed.",
            "example": {},
            "summary": "HTTP Header",
            "type": "object"
          },
          "body": {
            "description": "The body of the HTTP request.<br/><br/>If not provided, the body will be a JSON object of all the available fields.<br/><br/>There, 'all the available fields' means the context of a MQTT message when<br/>this webhook is triggered by receiving a MQTT message (the `local_topic` is set),<br/>or the context of the event when this webhook is triggered by a rule (i.e. this<br/>webhook is used as an action of a rule).<br/><br/>Template with variables is allowed.",
            "summary": "HTTP Body",
            "type": "string"
          },
          "max_retries": {
            "default": 2,
            "description": "HTTP request max retry times if failed.",
            "minimum": 0,
            "summary": "HTTP Request Max Retries",
            "type": "integer"
          },
          "request_timeout": {
            "default": "15s",
            "description": "HTTP request timeout.",
            "example": "32s",
            "summary": "HTTP Request Timeout",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_authn_schema.metrics_status_fields": {
        "properties": {
          "resource_metrics": {
            "description": "The metrics of the resource.",
            "summary": "Metrics",
            "$ref": "#/components/schemas/emqx_authn_schema.resource_metrics"
          },
          "node_resource_metrics": {
            "description": "The metrics of the resource for each node.",
            "summary": "Resource Metrics in Node",
            "$ref": "#/components/schemas/emqx_authn_schema.node_resource_metrics"
          },
          "metrics": {
            "description": "The metrics of the resource.",
            "summary": "Metrics",
            "$ref": "#/components/schemas/emqx_authn_schema.metrics"
          },
          "node_metrics": {
            "description": "The metrics of the resource for each node.",
            "summary": "Resource Metrics in Node",
            "$ref": "#/components/schemas/emqx_authn_schema.node_metrics"
          },
          "status": {
            "description": "The status of the resource.",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary": "Status",
            "type": "string"
          },
          "node_status": {
            "description": "The status of the resource for each node.",
            "summary": "Resource Status in Node",
            "$ref": "#/components/schemas/emqx_authn_schema.node_status"
          },
          "node_error": {
            "description": "The error of node.",
            "summary": "Error in Node",
            "$ref": "#/components/schemas/emqx_authn_schema.node_error"
          }
        },
        "type": "object"
      },
      "listeners.tcp_not_required_bind": {
        "required": [
          "id",
          "type"
        ],
        "properties": {
          "type": {
            "description": "Listener type",
            "enum": [
              "tcp"
            ],
            "type": "string"
          },
          "running": {
            "description": "Listener status",
            "type": "boolean"
          },
          "id": {
            "description": "Listener id",
            "type": "string"
          },
          "current_connections": {
            "description": "Current connections",
            "minimum": 0,
            "type": "integer"
          },
          "bind": {
            "default": 1883,
            "description": "IP address and port for the listening socket.",
            "summary": "IP address and port",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "enabled": {
            "default": true,
            "description": "Enable listener.",
            "summary": "Enable listener",
            "type": "boolean"
          },
          "acceptors": {
            "default": 16,
            "description": "The size of the listener's receiving pool.",
            "minimum": 1,
            "summary": "Acceptors Num",
            "type": "integer"
          },
          "max_connections": {
            "default": 5000000,
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "summary": "Max connections",
            "oneOf": [
              {
                "minimum": 1,
                "type": "integer"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message<br/>is delivered to the subscriber. The mountpoint is a way that users can use<br/>to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`<br/>set to `some_tenant`, then the client actually subscribes to the topic<br/>`some_tenant/t`. Similarly, if another client B (connected to the same listener<br/>as the client A) sends a message to topic `t`, the message is routed<br/>to all the clients subscribed `some_tenant/t`, so client A will receive the<br/>message, with topic name `t`.<br/><br/>Set to `\"\"` to disable the feature.<br/><br/><br/>Variables in mountpoint string:<br/>  - <code>${clientid}</code>: clientid<br/>  - <code>${username}</code>: username",
            "summary": "mountpoint",
            "type": "string"
          },
          "zone": {
            "default": "default",
            "description": "The configuration zone to which the listener belongs.",
            "summary": "Zone",
            "type": "string"
          },
          "limiter": {
            "description": "Type of the rate limit.",
            "summary": "Type of the rate limit.",
            "$ref": "#/components/schemas/limiter.listener_fields"
          },
          "enable_authn": {
            "default": true,
            "description": "Set <code>true</code> (default) to enable client authentication on this listener, the authentication<br/>process goes through the configured authentication chain.<br/>When set to <code>false</code> to allow any clients with or without authentication information such as username or password to log in.<br/>When set to <code>quick_deny_anonymous</code>, it behaves like when set to <code>true</code>, but clients will be<br/>denied immediately without going through any authenticators if <code>username</code> is not provided. This is useful to fence off<br/>anonymous clients early.",
            "enum": [
              true,
              false,
              "quick_deny_anonymous"
            ],
            "summary": "Enable authentication",
            "type": "string"
          },
          "access_rules": {
            "default": [
              "allow all"
            ],
            "description": "The access control rules for this listener.<br/>See: https://github.com/emqtt/esockd#allowdeny",
            "items": {
              "type": "string"
            },
            "summary": "Access rules",
            "type": "array"
          },
          "proxy_protocol": {
            "default": false,
            "description": "Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.<br/><br/>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/",
            "summary": "Proxy protocol",
            "type": "boolean"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "description": "Timeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.",
            "example": "12m",
            "summary": "Proxy protocol timeout",
            "type": "string"
          },
          "tcp_options": {
            "$ref": "#/components/schemas/broker.tcp_opts"
          }
        },
        "type": "object"
      },
      "limiter.internal": {
        "properties": {
          "rate": {
            "default": "infinity",
            "description": "Rate for this bucket.",
            "example": "10MB",
            "summary": "Rate",
            "type": "string"
          },
          "capacity": {
            "default": "infinity",
            "description": "The capacity of this token bucket.",
            "example": "100MB",
            "summary": "Capacity",
            "type": "string"
          },
          "initial": {
            "default": "0",
            "description": "The initial number of tokens for this bucket.",
            "example": "0MB",
            "summary": "Initial",
            "type": "string"
          },
          "client": {
            "description": "The rate limit for each user of the bucket",
            "summary": "Per Client",
            "$ref": "#/components/schemas/limiter.client_opts"
          }
        },
        "type": "object"
      },
      "public.meta": {
        "required": [
          "hasnext"
        ],
        "properties": {
          "page": {
            "default": 1,
            "description": "Page number of the results to fetch.",
            "example": 1,
            "minimum": 1,
            "type": "integer"
          },
          "limit": {
            "default": 100,
            "description": "Results per page(max 1000)",
            "example": 50,
            "maximum": 1000,
            "minimum": 1,
            "type": "integer"
          },
          "count": {
            "description": "Total number of records matching the query.<br/>Note: this field is present only if the query can be optimized and does not require a full table scan.",
            "minimum": 0,
            "type": "integer"
          },
          "hasnext": {
            "description": "Flag indicating whether there are more results available on next pages.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api_clients.extra_sub_props": {
        "properties": {
          "subid": {
            "description": "Only stomp protocol, a unique identity for the subscription. range: 1-65535.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_telemetry_api.status": {
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable telemetry",
            "example": false,
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "authn-hash.bcrypt_rw": {
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "description": "BCRYPT password hashing.",
            "enum": [
              "bcrypt"
            ],
            "type": "string"
          },
          "salt_rounds": {
            "default": 10,
            "description": "Salt rounds for BCRYPT password generation.",
            "example": 10,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "emqx_mqttsn_schema.mqttsn_predefined": {
        "required": [
          "id",
          "topic"
        ],
        "properties": {
          "id": {
            "description": "Topic ID. Range: 1-65535",
            "type": "integer"
          },
          "topic": {
            "description": "Topic Name",
            "type": "string"
          }
        },
        "type": "object"
      },
      "broker.event_names": {
        "properties": {
          "client_connected": {
            "default": true,
            "description": "Enable to publish client connected event messages",
            "type": "boolean"
          },
          "client_disconnected": {
            "default": true,
            "description": "Enable to publish client disconnected event messages.",
            "type": "boolean"
          },
          "client_subscribed": {
            "default": false,
            "description": "Enable to publish event message that client subscribed a topic successfully.",
            "type": "boolean"
          },
          "client_unsubscribed": {
            "default": false,
            "description": "Enable to publish event message that client unsubscribed a topic successfully.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "gateway.dtls_opts": {
        "properties": {
          "cacertfile": {
            "description": "Trusted PEM format CA certificates bundle file.<br/><br/>The certificates in this file are used to verify the TLS peer's certificates.<br/>Append new certificates to the file if new CAs are to be trusted.<br/>There is no need to restart EMQX to have the updated file loaded, because<br/>the system regularly checks if file has been updated (and reload).<br/><br/>NOTE: invalidating (deleting) a certificate from the file will not affect<br/>already established connections.",
            "summary": "CACertfile",
            "type": "string"
          },
          "certfile": {
            "description": "PEM format certificates chain file.<br/><br/>The certificates in this file should be in reversed order of the certificate<br/>issue chain. That is, the host's certificate should be placed in the beginning<br/>of the file, followed by the immediate issuer certificate and so on.<br/>Although the root CA certificate is optional, it should be placed at the end of<br/>the file if it is to be added.",
            "summary": "Certfile",
            "type": "string"
          },
          "keyfile": {
            "description": "PEM format private key file.",
            "summary": "Keyfile",
            "type": "string"
          },
          "verify": {
            "default": "verify_none",
            "description": "Enable or disable peer verification.",
            "enum": [
              "verify_peer",
              "verify_none"
            ],
            "summary": "Verify peer",
            "type": "string"
          },
          "reuse_sessions": {
            "default": true,
            "description": "Enable TLS session reuse.",
            "summary": "TLS session reuse",
            "type": "boolean"
          },
          "depth": {
            "default": 10,
            "description": "Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path.<br/>So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly;<br/><br/>if 1 the path can be PEER, Intermediate-CA, ROOT-CA;<br/><br/>if 2 the path can be PEER, Intermediate-CA1, Intermediate-CA2, ROOT-CA.",
            "summary": "CACert Depth",
            "type": "integer"
          },
          "password": {
            "description": "String containing the user's password. Only used if the private key file is password-protected.",
            "example": "",
            "format": "password",
            "summary": "Keyfile passphrase",
            "type": "string"
          },
          "versions": {
            "default": [
              "dtlsv1.2",
              "dtlsv1"
            ],
            "description": "All TLS/DTLS versions to be supported.<br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.<br/><br/>In case PSK cipher suites are intended, make sure to configure<br/><code>['tlsv1.2', 'tlsv1.1']</code> here.",
            "items": {
              "type": "string"
            },
            "summary": "SSL versions",
            "type": "array"
          },
          "ciphers": {
            "default": "",
            "description": "This config holds TLS cipher suite names separated by comma,<br/>or as an array of strings. e.g.<br/><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or<br/><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.<br/><br/><br/>Ciphers (and their ordering) define the way in which the<br/>client and server encrypts information over the network connection.<br/>Selecting a good cipher suite is critical for the<br/>application's data security, confidentiality and performance.<br/><br/>The names should be in OpenSSL string format (not RFC format).<br/>All default values and examples provided by EMQX config<br/>documentation are all in OpenSSL format.<br/><br/><br/>NOTE: Certain cipher suites are only compatible with<br/>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')<br/>incompatible cipher suites will be silently dropped.<br/>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,<br/>configuring cipher suites for other versions will have no effect.<br/><br/><br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br/><br/>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.<br/><br/>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,<br/>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,<br/>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,<br/>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code>",
            "items": {
              "type": "string"
            },
            "summary": "",
            "type": "array"
          },
          "secure_renegotiate": {
            "default": true,
            "description": "SSL parameter renegotiation is a feature that allows a client and a server<br/>to renegotiate the parameters of the SSL connection on the fly.<br/>RFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,<br/>you drop support for the insecure renegotiation, prone to MitM attacks.",
            "summary": "SSL renegotiate",
            "type": "boolean"
          },
          "hibernate_after": {
            "default": "5s",
            "description": "Hibernate the SSL process after idling for amount of time reducing its memory footprint.",
            "example": "12m",
            "summary": "hibernate after",
            "type": "string"
          },
          "dhfile": {
            "description": "Path to a file containing PEM-encoded Diffie-Hellman parameters<br/>to be used by the server if a cipher suite using Diffie-Hellman<br/>key exchange is negotiated. If not specified, default parameters<br/>are used.<br/><br/>NOTE: The <code>dhfile</code> option is not supported by TLS 1.3.",
            "summary": "SSL dhfile",
            "type": "string"
          },
          "fail_if_no_peer_cert": {
            "default": false,
            "description": "Used together with {verify, verify_peer} by an TLS/DTLS server.<br/>If set to true, the server fails if the client does not have a<br/>certificate to send, that is, sends an empty certificate.<br/>If set to false, it fails only if the client sends an invalid<br/>certificate (an empty certificate is considered valid).",
            "summary": "SSL fail if no peer cert",
            "type": "boolean"
          },
          "honor_cipher_order": {
            "default": true,
            "description": "An important security setting, it forces the cipher to be set based<br/> on the server-specified order instead of the client-specified order,<br/> hence enforcing the (usually more properly configured) security<br/> ordering of the server administrator.",
            "summary": "SSL honor cipher order",
            "type": "boolean"
          },
          "client_renegotiation": {
            "default": true,
            "description": "In protocols that support client-initiated renegotiation,<br/>the cost of resources of such an operation is higher for the server than the client.<br/>This can act as a vector for denial of service attacks.<br/>The SSL application already takes measures to counter-act such attempts,<br/>but client-initiated renegotiation can be strictly disabled by setting this option to false.<br/>The default value is true. Note that disabling renegotiation can result in<br/>long-lived connections becoming unusable due to limits on<br/>the number of messages the underlying cipher suite can encipher.",
            "summary": "SSL client renegotiation",
            "type": "boolean"
          },
          "handshake_timeout": {
            "default": "15s",
            "description": "Maximum time duration allowed for the handshake to complete",
            "example": "12m",
            "summary": "Handshake timeout",
            "type": "string"
          },
          "gc_after_handshake": {
            "default": false,
            "description": "Memory usage tuning. If enabled, will immediately perform a garbage collection after the TLS/SSL handshake.",
            "summary": "Perform GC after handshake",
            "type": "boolean"
          },
          "ocsp": {
            "$ref": "#/components/schemas/broker.ocsp"
          },
          "enable_crl_check": {
            "default": false,
            "description": "Whether to enable CRL verification for this listener.",
            "summary": "Enable CRL Check",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "bridge_redis.put_cluster": {
        "required": [
          "command_template",
          "servers"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to Redis. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "command_template": {
            "description": "Redis command template used to export messages. Each list element stands for a command name or its argument.<br/>For example, to push payloads in a Redis list by key `msgs`, the elements should be the following:<br/>`rpush`, `msgs`, `${payload}`.",
            "items": {
              "type": "string"
            },
            "summary": "Redis Command Template",
            "type": "array"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/bridge_redis.creation_opts_redis_cluster"
          },
          "servers": {
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The Redis default port 6379 is used if `[:Port]` is not specified.",
            "summary": "Servers",
            "type": "string"
          },
          "redis_type": {
            "default": "cluster",
            "description": "Cluster mode. Must be set to 'cluster' when Redis server is running in clustered mode.",
            "enum": [
              "cluster"
            ],
            "summary": "Cluster Mode",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "bridge_rocketmq.post": {
        "required": [
          "name",
          "servers",
          "type"
        ],
        "properties": {
          "type": {
            "description": "The Bridge Type",
            "enum": [
              "rocketmq"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name.",
            "summary": "Bridge Name",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "template": {
            "default": "",
            "description": "Template, the default value is empty. When this value is empty the whole message will be stored in the RocketMQ.<br><br/>            The template can be any valid string with placeholders, example:<br><br/>            - ${id}, ${username}, ${clientid}, ${timestamp}<br><br/>            - {\"id\" : ${id}, \"username\" : ${username}}",
            "summary": "Template",
            "type": "string"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to RocketMQ. All MQTT `PUBLISH` messages with the topic<br/>matching the `local_topic` will be forwarded.</br><br/>NOTE: if the bridge is used as a rule action, `local_topic` should be left empty otherwise the messages will be duplicated.",
            "summary": "Local Topic",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "servers": {
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The RocketMQ default port 9876 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "topic": {
            "default": "TopicTest",
            "description": "RocketMQ Topic",
            "summary": "RocketMQ Topic",
            "type": "string"
          },
          "access_key": {
            "default": "",
            "description": "RocketMQ server `accessKey`.",
            "summary": "AccessKey",
            "type": "string"
          },
          "secret_key": {
            "default": "",
            "description": "RocketMQ server `secretKey`.",
            "summary": "SecretKey",
            "type": "string"
          },
          "security_token": {
            "default": "",
            "description": "RocketMQ Server Security Token",
            "summary": "Security Token",
            "type": "string"
          },
          "sync_timeout": {
            "default": "3s",
            "description": "Timeout of RocketMQ driver synchronous call.",
            "example": "12m",
            "summary": "Sync Timeout",
            "type": "string"
          },
          "refresh_interval": {
            "default": "3s",
            "description": "RocketMQ Topic Route Refresh Interval.",
            "example": "12m",
            "summary": "Topic Route Refresh Interval",
            "type": "string"
          },
          "send_buffer": {
            "default": "1024KB",
            "description": "The socket send buffer size of the RocketMQ driver client.",
            "example": "32MB",
            "summary": "Send Buffer Size",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "authn-http.post": {
        "required": [
          "backend",
          "mechanism",
          "method",
          "url"
        ],
        "properties": {
          "method": {
            "description": "HTTP request method.",
            "enum": [
              "post"
            ],
            "summary": "Request Method",
            "type": "string"
          },
          "headers": {
            "default": {
              "accept": "application/json",
              "cache-control": "no-cache",
              "connection": "keep-alive",
              "content-type": "application/json",
              "keep-alive": "timeout=30, max=1000"
            },
            "description": "List of HTTP Headers.",
            "example": {},
            "summary": "Headers",
            "type": "object"
          },
          "mechanism": {
            "description": "Authentication mechanism.",
            "enum": [
              "password_based"
            ],
            "summary": "Authentication Mechanism",
            "type": "string"
          },
          "backend": {
            "description": "Backend type.",
            "enum": [
              "http"
            ],
            "summary": "Backend Type",
            "type": "string"
          },
          "url": {
            "description": "URL of the HTTP server.",
            "summary": "URL",
            "type": "string"
          },
          "body": {
            "description": "HTTP request body.",
            "example": {},
            "summary": "Request Body",
            "type": "object"
          },
          "request_timeout": {
            "default": "5s",
            "description": "HTTP request timeout.",
            "example": "32s",
            "summary": "Request Timeout",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
            "summary": "Enable",
            "type": "boolean"
          },
          "connect_timeout": {
            "default": "15s",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s",
            "summary": "Connect Timeout",
            "type": "string"
          },
          "enable_pipelining": {
            "default": 100,
            "description": "A positive integer. Whether to send HTTP requests continuously, when set to 1, it means that after each HTTP request is sent, you need to wait for the server to return and then continue to send the next request.",
            "minimum": 1,
            "summary": "HTTP Pipelineing",
            "type": "integer"
          },
          "max_retries": {
            "deprecated": true,
            "minimum": 0,
            "type": "integer"
          },
          "pool_size": {
            "default": 8,
            "description": "The pool size.",
            "minimum": 1,
            "summary": "Pool Size",
            "type": "integer"
          },
          "request": {
            "description": "Configure HTTP request parameters.",
            "summary": "Request",
            "$ref": "#/components/schemas/connector-http.request"
          },
          "retry_interval": {
            "deprecated": true,
            "example": "12m",
            "type": "string"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api_clients.stomp_client": {
        "properties": {
          "node": {
            "description": "Name of the node to which the client is connected",
            "type": "string"
          },
          "clientid": {
            "description": "Client ID",
            "type": "string"
          },
          "username": {
            "description": "Username of client when connecting",
            "type": "string"
          },
          "mountpoint": {
            "description": "Topic mountpoint",
            "type": "string"
          },
          "proto_name": {
            "description": "Client protocol name",
            "type": "string"
          },
          "proto_ver": {
            "description": "Protocol version used by the client",
            "type": "string"
          },
          "ip_address": {
            "description": "Client's IP address",
            "type": "string"
          },
          "port": {
            "description": "Client's port",
            "type": "integer"
          },
          "is_bridge": {
            "description": "Indicates whether the client is connected via bridge",
            "type": "boolean"
          },
          "connected_at": {
            "description": "Client connection time",
            "oneOf": [
              {
                "description": "epoch-millisecond",
                "example": 1640995200000,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "disconnected_at": {
            "description": "Client offline time, This field is only valid and returned when connected is false",
            "oneOf": [
              {
                "description": "epoch-millisecond",
                "example": 1640995200000,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "connected": {
            "description": "Whether the client is connected",
            "type": "boolean"
          },
          "keepalive": {
            "description": "Keepalive time, with the unit of second",
            "type": "integer"
          },
          "clean_start": {
            "description": "Indicate whether the client is using a brand new session",
            "type": "boolean"
          },
          "expiry_interval": {
            "description": "Session expiration interval, with the unit of second",
            "type": "integer"
          },
          "created_at": {
            "description": "Session creation time",
            "oneOf": [
              {
                "description": "epoch-millisecond",
                "example": 1640995200000,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "subscriptions_cnt": {
            "description": "Number of subscriptions established by this client",
            "type": "integer"
          },
          "subscriptions_max": {
            "description": "Maximum number of subscriptions allowed by this client",
            "type": "integer"
          },
          "inflight_cnt": {
            "description": "Current length of inflight",
            "type": "integer"
          },
          "inflight_max": {
            "description": "Maximum length of inflight",
            "type": "integer"
          },
          "mqueue_len": {
            "description": "Current length of message queue",
            "type": "integer"
          },
          "mqueue_max": {
            "description": "Maximum length of message queue",
            "type": "integer"
          },
          "mqueue_dropped": {
            "description": "Number of messages dropped by the message queue due to exceeding the length",
            "type": "integer"
          },
          "awaiting_rel_cnt": {
            "description": "Number of awaiting acknowledge packet",
            "type": "integer"
          },
          "awaiting_rel_max": {
            "description": "Maximum allowed number of awaiting PUBREC packet",
            "type": "integer"
          },
          "recv_oct": {
            "description": "Number of bytes received",
            "type": "integer"
          },
          "recv_cnt": {
            "description": "Number of socket packets received",
            "type": "integer"
          },
          "recv_pkt": {
            "description": "Number of protocol packets received",
            "type": "integer"
          },
          "recv_msg": {
            "description": "Number of message packets received",
            "type": "integer"
          },
          "send_oct": {
            "description": "Number of bytes sent",
            "type": "integer"
          },
          "send_cnt": {
            "description": "Number of socket packets sent",
            "type": "integer"
          },
          "send_pkt": {
            "description": "Number of protocol packets sent",
            "type": "integer"
          },
          "send_msg": {
            "description": "Number of message packets sent",
            "type": "integer"
          },
          "mailbox_len": {
            "description": "Process mailbox size",
            "type": "integer"
          },
          "heap_size": {
            "description": "Process heap size with the unit of byte",
            "type": "integer"
          },
          "reductions": {
            "description": "Erlang reduction",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "bridge_clickhouse.post": {
        "required": [
          "database",
          "name",
          "type",
          "url"
        ],
        "properties": {
          "type": {
            "description": "The Bridge Type",
            "enum": [
              "clickhouse"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name.",
            "summary": "Bridge Name",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "sql": {
            "default": "INSERT INTO mqtt_test(payload, arrived) VALUES ('${payload}', ${timestamp})",
            "description": "The template string can contain ${field} placeholders for message metadata and payload field. Make sure that the inserted values are formatted and escaped correctly. [Prepared Statement](https://docs.emqx.com/en/enterprise/v5.0/data-integration/data-bridges.html#Prepared-Statement) is not supported.",
            "format": "sql",
            "summary": "SQL Template",
            "type": "string"
          },
          "batch_value_separator": {
            "default": ", ",
            "description": "The default value ',' works for the VALUES format. You can also use other separator if other format is specified. See [INSERT INTO Statement](https://clickhouse.com/docs/en/sql-reference/statements/insert-into).",
            "summary": "Batch Value Separator",
            "type": "string"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to Clickhouse. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/bridge_clickhouse.creation_opts"
          },
          "url": {
            "description": "The HTTP URL to the Clickhouse server that you want to connect to (for example http://myhostname:8123)",
            "example": "http://127.0.0.1",
            "summary": "Server URL",
            "type": "string"
          },
          "connect_timeout": {
            "default": "15s",
            "description": "The timeout when connecting to the Clickhouse server.",
            "example": "32s",
            "summary": "Clickhouse Timeout",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_mnesia.clientid_response_data": {
        "properties": {
          "data": {
            "items": {
              "$ref": "#/components/schemas/emqx_authz_api_mnesia.rules_for_clientid"
            },
            "type": "array"
          },
          "meta": {
            "$ref": "#/components/schemas/public.meta"
          }
        },
        "type": "object"
      },
      "listeners.wss_required_bind(with_name)": {
        "required": [
          "bind",
          "name",
          "type"
        ],
        "properties": {
          "type": {
            "description": "Listener type",
            "enum": [
              "wss"
            ],
            "type": "string"
          },
          "running": {
            "description": "Listener status",
            "type": "boolean"
          },
          "name": {
            "description": "Listener name",
            "type": "string"
          },
          "current_connections": {
            "description": "Current connections",
            "minimum": 0,
            "type": "integer"
          },
          "enabled": {
            "default": true,
            "description": "Enable listener.",
            "summary": "Enable listener",
            "type": "boolean"
          },
          "bind": {
            "default": 8084,
            "description": "IP address and port for the listening socket.",
            "summary": "IP address and port",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "acceptors": {
            "default": 16,
            "description": "The size of the listener's receiving pool.",
            "minimum": 1,
            "summary": "Acceptors Num",
            "type": "integer"
          },
          "max_connections": {
            "default": 5000000,
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "summary": "Max connections",
            "oneOf": [
              {
                "minimum": 1,
                "type": "integer"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message<br/>is delivered to the subscriber. The mountpoint is a way that users can use<br/>to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`<br/>set to `some_tenant`, then the client actually subscribes to the topic<br/>`some_tenant/t`. Similarly, if another client B (connected to the same listener<br/>as the client A) sends a message to topic `t`, the message is routed<br/>to all the clients subscribed `some_tenant/t`, so client A will receive the<br/>message, with topic name `t`.<br/><br/>Set to `\"\"` to disable the feature.<br/><br/><br/>Variables in mountpoint string:<br/>  - <code>${clientid}</code>: clientid<br/>  - <code>${username}</code>: username",
            "summary": "mountpoint",
            "type": "string"
          },
          "zone": {
            "default": "default",
            "description": "The configuration zone to which the listener belongs.",
            "summary": "Zone",
            "type": "string"
          },
          "limiter": {
            "description": "Type of the rate limit.",
            "summary": "Type of the rate limit.",
            "$ref": "#/components/schemas/limiter.listener_fields"
          },
          "enable_authn": {
            "default": true,
            "description": "Set <code>true</code> (default) to enable client authentication on this listener, the authentication<br/>process goes through the configured authentication chain.<br/>When set to <code>false</code> to allow any clients with or without authentication information such as username or password to log in.<br/>When set to <code>quick_deny_anonymous</code>, it behaves like when set to <code>true</code>, but clients will be<br/>denied immediately without going through any authenticators if <code>username</code> is not provided. This is useful to fence off<br/>anonymous clients early.",
            "enum": [
              true,
              false,
              "quick_deny_anonymous"
            ],
            "summary": "Enable authentication",
            "type": "string"
          },
          "access_rules": {
            "default": [
              "allow all"
            ],
            "description": "The access control rules for this listener.<br/>See: https://github.com/emqtt/esockd#allowdeny",
            "items": {
              "type": "string"
            },
            "summary": "Access rules",
            "type": "array"
          },
          "proxy_protocol": {
            "default": false,
            "description": "Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.<br/><br/>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/",
            "summary": "Proxy protocol",
            "type": "boolean"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "description": "Timeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.",
            "example": "12m",
            "summary": "Proxy protocol timeout",
            "type": "string"
          },
          "tcp_options": {
            "$ref": "#/components/schemas/broker.tcp_opts"
          },
          "ssl_options": {
            "$ref": "#/components/schemas/broker.listener_wss_opts"
          },
          "websocket": {
            "$ref": "#/components/schemas/broker.ws_opts"
          }
        },
        "type": "object"
      },
      "zone.force_gc": {
        "properties": {
          "enable": {
            "description": "Enable forced garbage collection.",
            "summary": "Enable forced garbage collection",
            "type": "boolean"
          },
          "count": {
            "description": "GC the process after this many received messages.",
            "minimum": 0,
            "summary": "Process GC messages num",
            "type": "integer"
          },
          "bytes": {
            "description": "GC the process after specified number of bytes have passed through.",
            "example": "32MB",
            "summary": "Process GC bytes",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_nodes.node_info": {
        "properties": {
          "node": {
            "description": "Node name",
            "example": "emqx@127.0.0.1",
            "type": "string"
          },
          "connections": {
            "description": "Number of clients currently connected to this node",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "load1": {
            "description": "CPU average load in 1 minute",
            "example": 2.66,
            "type": "number"
          },
          "load5": {
            "description": "CPU average load in 5 minute",
            "example": 2.66,
            "type": "number"
          },
          "load15": {
            "description": "CPU average load in 15 minute",
            "example": 2.66,
            "type": "number"
          },
          "max_fds": {
            "description": "File descriptors limit",
            "example": 1024,
            "minimum": 0,
            "type": "integer"
          },
          "memory_total": {
            "description": "Allocated memory",
            "example": "512.00M",
            "type": "string"
          },
          "memory_used": {
            "description": "Used memory",
            "example": "256.00M",
            "type": "string"
          },
          "node_status": {
            "description": "Node status",
            "enum": [
              "running",
              "stopped"
            ],
            "example": "running",
            "type": "string"
          },
          "otp_release": {
            "description": "Erlang/OTP version",
            "example": "24.2/12.2",
            "type": "string"
          },
          "process_available": {
            "description": "Erlang processes limit",
            "example": 2097152,
            "minimum": 0,
            "type": "integer"
          },
          "process_used": {
            "description": "Running Erlang processes",
            "example": 1024,
            "minimum": 0,
            "type": "integer"
          },
          "uptime": {
            "description": "System uptime, milliseconds",
            "example": 5120000,
            "minimum": 0,
            "type": "integer"
          },
          "version": {
            "description": "Release version",
            "example": "5.0.0",
            "type": "string"
          },
          "edition": {
            "description": "Release edition",
            "enum": [
              "Opensource",
              "Enterprise"
            ],
            "example": "Opensource",
            "type": "string"
          },
          "sys_path": {
            "description": "Path to system files",
            "example": "path/to/emqx",
            "type": "string"
          },
          "log_path": {
            "description": "Path to log files",
            "example": "path/to/log | The log path is not yet set",
            "type": "string"
          },
          "role": {
            "description": "Node role",
            "enum": [
              "core",
              "replicant"
            ],
            "example": "core",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_delayed_api.message_without_payload": {
        "properties": {
          "msgid": {
            "description": "Delayed Message ID",
            "type": "integer"
          },
          "node": {
            "description": "The node where message from",
            "type": "string"
          },
          "publish_at": {
            "description": "Clinet publish message time, in RFC 3339 format",
            "type": "string"
          },
          "delayed_interval": {
            "description": "Delayed interval(second)",
            "minimum": 1,
            "type": "integer"
          },
          "delayed_remaining": {
            "description": "Delayed remaining(second)",
            "minimum": 0,
            "type": "integer"
          },
          "expected_at": {
            "description": "Expect publish time, in RFC 3339 format",
            "type": "string"
          },
          "topic": {
            "description": "Topic",
            "example": "/sys/#",
            "type": "string"
          },
          "qos": {
            "description": "QoS",
            "example": 0,
            "maximum": 2,
            "minimum": 0,
            "type": "integer"
          },
          "from_clientid": {
            "description": "From ClientID",
            "type": "string"
          },
          "from_username": {
            "description": "From Username",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_mnesia.rules": {
        "properties": {
          "rules": {
            "items": {
              "$ref": "#/components/schemas/emqx_authz_api_mnesia.rule_item"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "bridge_kafka.consumer_topic_mapping": {
        "required": [
          "kafka_topic",
          "mqtt_topic"
        ],
        "properties": {
          "kafka_topic": {
            "description": "Kafka topic to consume from.",
            "summary": "Kafka Topic",
            "type": "string"
          },
          "mqtt_topic": {
            "description": "Local topic to which consumed Kafka messages should be published to.",
            "summary": "MQTT Topic",
            "type": "string"
          },
          "qos": {
            "default": 0,
            "description": "MQTT QoS used to publish messages consumed from Kafka.",
            "example": 0,
            "maximum": 2,
            "minimum": 0,
            "summary": "QoS",
            "type": "integer"
          },
          "payload_template": {
            "default": "${.}",
            "description": "The template for transforming the incoming Kafka message.  By default, it will use JSON format to serialize inputs from the Kafka message.  Such fields are:<br/><code>headers</code>: an object containing string key-value pairs.<br/><code>key</code>: Kafka message key (uses the chosen key encoding).<br/><code>offset</code>: offset for the message.<br/><code>topic</code>: Kafka topic.<br/><code>ts</code>: message timestamp.<br/><code>ts_type</code>: message timestamp type, which is one of <code>create</code>, <code>append</code> or <code>undefined</code>.<br/><code>value</code>: Kafka message value (uses the chosen value encoding).",
            "summary": "MQTT Payload Template",
            "type": "string"
          }
        },
        "type": "object"
      },
      "slow_subscribers_statistics.record": {
        "properties": {
          "clientid": {
            "description": "Message clientid",
            "type": "string"
          },
          "node": {
            "description": "Message node name",
            "type": "string"
          },
          "topic": {
            "description": "Message topic",
            "type": "string"
          },
          "timespan": {
            "description": "Timespan for message transmission",
            "type": "integer"
          },
          "last_update_time": {
            "description": "The timestamp of last update",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api_clients.mqttsn_client": {
        "properties": {
          "node": {
            "description": "Name of the node to which the client is connected",
            "type": "string"
          },
          "clientid": {
            "description": "Client ID",
            "type": "string"
          },
          "username": {
            "description": "Username of client when connecting",
            "type": "string"
          },
          "mountpoint": {
            "description": "Topic mountpoint",
            "type": "string"
          },
          "proto_name": {
            "description": "Client protocol name",
            "type": "string"
          },
          "proto_ver": {
            "description": "Protocol version used by the client",
            "type": "string"
          },
          "ip_address": {
            "description": "Client's IP address",
            "type": "string"
          },
          "port": {
            "description": "Client's port",
            "type": "integer"
          },
          "is_bridge": {
            "description": "Indicates whether the client is connected via bridge",
            "type": "boolean"
          },
          "connected_at": {
            "description": "Client connection time",
            "oneOf": [
              {
                "description": "epoch-millisecond",
                "example": 1640995200000,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "disconnected_at": {
            "description": "Client offline time, This field is only valid and returned when connected is false",
            "oneOf": [
              {
                "description": "epoch-millisecond",
                "example": 1640995200000,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "connected": {
            "description": "Whether the client is connected",
            "type": "boolean"
          },
          "keepalive": {
            "description": "Keepalive time, with the unit of second",
            "type": "integer"
          },
          "clean_start": {
            "description": "Indicate whether the client is using a brand new session",
            "type": "boolean"
          },
          "expiry_interval": {
            "description": "Session expiration interval, with the unit of second",
            "type": "integer"
          },
          "created_at": {
            "description": "Session creation time",
            "oneOf": [
              {
                "description": "epoch-millisecond",
                "example": 1640995200000,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "subscriptions_cnt": {
            "description": "Number of subscriptions established by this client",
            "type": "integer"
          },
          "subscriptions_max": {
            "description": "Maximum number of subscriptions allowed by this client",
            "type": "integer"
          },
          "inflight_cnt": {
            "description": "Current length of inflight",
            "type": "integer"
          },
          "inflight_max": {
            "description": "Maximum length of inflight",
            "type": "integer"
          },
          "mqueue_len": {
            "description": "Current length of message queue",
            "type": "integer"
          },
          "mqueue_max": {
            "description": "Maximum length of message queue",
            "type": "integer"
          },
          "mqueue_dropped": {
            "description": "Number of messages dropped by the message queue due to exceeding the length",
            "type": "integer"
          },
          "awaiting_rel_cnt": {
            "description": "Number of awaiting acknowledge packet",
            "type": "integer"
          },
          "awaiting_rel_max": {
            "description": "Maximum allowed number of awaiting PUBREC packet",
            "type": "integer"
          },
          "recv_oct": {
            "description": "Number of bytes received",
            "type": "integer"
          },
          "recv_cnt": {
            "description": "Number of socket packets received",
            "type": "integer"
          },
          "recv_pkt": {
            "description": "Number of protocol packets received",
            "type": "integer"
          },
          "recv_msg": {
            "description": "Number of message packets received",
            "type": "integer"
          },
          "send_oct": {
            "description": "Number of bytes sent",
            "type": "integer"
          },
          "send_cnt": {
            "description": "Number of socket packets sent",
            "type": "integer"
          },
          "send_pkt": {
            "description": "Number of protocol packets sent",
            "type": "integer"
          },
          "send_msg": {
            "description": "Number of message packets sent",
            "type": "integer"
          },
          "mailbox_len": {
            "description": "Process mailbox size",
            "type": "integer"
          },
          "heap_size": {
            "description": "Process heap size with the unit of byte",
            "type": "integer"
          },
          "reductions": {
            "description": "Erlang reduction",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "emqx_topic_metrics_api.metrics": {
        "properties": {
          "message.dropped.count": {
            "description": "Dropped messages count",
            "example": 0,
            "type": "integer"
          },
          "message.in.count": {
            "description": "In messages count",
            "example": 0,
            "type": "integer"
          },
          "message.out.count": {
            "description": "Out messages count",
            "example": 0,
            "type": "integer"
          },
          "message.qos0.in.count": {
            "description": "QoS0 in messages count",
            "example": 0,
            "type": "integer"
          },
          "message.qos0.out.count": {
            "description": "QoS0 out messages count",
            "example": 0,
            "type": "integer"
          },
          "message.qos1.in.count": {
            "description": "QoS1 in messages count",
            "example": 0,
            "type": "integer"
          },
          "message.qos1.out.count": {
            "description": "QoS1 out messages count",
            "example": 0,
            "type": "integer"
          },
          "message.qos2.in.count": {
            "description": "QoS2 in messages count",
            "example": 0,
            "type": "integer"
          },
          "message.qos2.out.count": {
            "description": "QoS2 out messages count",
            "example": 0,
            "type": "integer"
          },
          "message.dropped.rate": {
            "description": "Dropped messages rate",
            "example": 0,
            "type": "number"
          },
          "message.in.rate": {
            "description": "In messages rate",
            "example": 0,
            "type": "number"
          },
          "message.out.rate": {
            "description": "Out messages rate",
            "example": 0,
            "type": "number"
          },
          "message.qos0.in.rate": {
            "description": "QoS0 in messages rate",
            "example": 0,
            "type": "number"
          },
          "message.qos0.out.rate": {
            "description": "QoS0 out messages rate",
            "example": 0,
            "type": "number"
          },
          "message.qos1.in.rate": {
            "description": "QoS1 in messages rate",
            "example": 0,
            "type": "number"
          },
          "message.qos1.out.rate": {
            "description": "QoS1 out messages rate",
            "example": 0,
            "type": "number"
          },
          "message.qos2.in.rate": {
            "description": "QoS2 in messages rate",
            "example": 0,
            "type": "number"
          },
          "message.qos2.out.rate": {
            "description": "QoS2 out messages rate",
            "example": 0,
            "type": "number"
          }
        },
        "type": "object"
      },
      "listeners.ssl_not_required_bind": {
        "required": [
          "id",
          "type"
        ],
        "properties": {
          "type": {
            "description": "Listener type",
            "enum": [
              "ssl"
            ],
            "type": "string"
          },
          "running": {
            "description": "Listener status",
            "type": "boolean"
          },
          "id": {
            "description": "Listener id",
            "type": "string"
          },
          "current_connections": {
            "description": "Current connections",
            "minimum": 0,
            "type": "integer"
          },
          "bind": {
            "default": 8883,
            "description": "IP address and port for the listening socket.",
            "summary": "IP address and port",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "enabled": {
            "default": true,
            "description": "Enable listener.",
            "summary": "Enable listener",
            "type": "boolean"
          },
          "acceptors": {
            "default": 16,
            "description": "The size of the listener's receiving pool.",
            "minimum": 1,
            "summary": "Acceptors Num",
            "type": "integer"
          },
          "max_connections": {
            "default": 5000000,
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "summary": "Max connections",
            "oneOf": [
              {
                "minimum": 1,
                "type": "integer"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message<br/>is delivered to the subscriber. The mountpoint is a way that users can use<br/>to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`<br/>set to `some_tenant`, then the client actually subscribes to the topic<br/>`some_tenant/t`. Similarly, if another client B (connected to the same listener<br/>as the client A) sends a message to topic `t`, the message is routed<br/>to all the clients subscribed `some_tenant/t`, so client A will receive the<br/>message, with topic name `t`.<br/><br/>Set to `\"\"` to disable the feature.<br/><br/><br/>Variables in mountpoint string:<br/>  - <code>${clientid}</code>: clientid<br/>  - <code>${username}</code>: username",
            "summary": "mountpoint",
            "type": "string"
          },
          "zone": {
            "default": "default",
            "description": "The configuration zone to which the listener belongs.",
            "summary": "Zone",
            "type": "string"
          },
          "limiter": {
            "description": "Type of the rate limit.",
            "summary": "Type of the rate limit.",
            "$ref": "#/components/schemas/limiter.listener_fields"
          },
          "enable_authn": {
            "default": true,
            "description": "Set <code>true</code> (default) to enable client authentication on this listener, the authentication<br/>process goes through the configured authentication chain.<br/>When set to <code>false</code> to allow any clients with or without authentication information such as username or password to log in.<br/>When set to <code>quick_deny_anonymous</code>, it behaves like when set to <code>true</code>, but clients will be<br/>denied immediately without going through any authenticators if <code>username</code> is not provided. This is useful to fence off<br/>anonymous clients early.",
            "enum": [
              true,
              false,
              "quick_deny_anonymous"
            ],
            "summary": "Enable authentication",
            "type": "string"
          },
          "access_rules": {
            "default": [
              "allow all"
            ],
            "description": "The access control rules for this listener.<br/>See: https://github.com/emqtt/esockd#allowdeny",
            "items": {
              "type": "string"
            },
            "summary": "Access rules",
            "type": "array"
          },
          "proxy_protocol": {
            "default": false,
            "description": "Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.<br/><br/>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/",
            "summary": "Proxy protocol",
            "type": "boolean"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "description": "Timeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.",
            "example": "12m",
            "summary": "Proxy protocol timeout",
            "type": "string"
          },
          "tcp_options": {
            "$ref": "#/components/schemas/broker.tcp_opts"
          },
          "ssl_options": {
            "$ref": "#/components/schemas/broker.listener_ssl_opts"
          }
        },
        "type": "object"
      },
      "bridge_influxdb.post_api_v2": {
        "required": [
          "bucket",
          "name",
          "org",
          "token",
          "type",
          "write_syntax"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to the InfluxDB. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "write_syntax": {
            "description": "Conf of InfluxDB line protocol to write data points. It is a text-based format that provides the measurement, tag set, field set, and timestamp of a data point, and placeholder supported.<br/>See also [InfluxDB 2.3 Line Protocol](https://docs.influxdata.com/influxdb/v2.3/reference/syntax/line-protocol/) and<br/>[InfluxDB 1.8 Line Protocol](https://docs.influxdata.com/influxdb/v1.8/write_protocols/line_protocol_tutorial/) </br><br/>TLDR:</br><br/>```<br/><measurement>[,<tag_key>=<tag_value>[,<tag_key>=<tag_value>]] <field_key>=<field_value>[,<field_key>=<field_value>] [<timestamp>]<br/>```<br/>Please note that a placeholder for an integer value must be annotated with a suffix `i`. For example `${payload.int_value}i`.",
            "example": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,bool=${payload.bool}",
            "format": "sql",
            "summary": "Write Syntax",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "default": "127.0.0.1:8086",
            "description": "The IPv4 or IPv6 address or the hostname to connect to.</br><br/>A host entry has the following form: `Host[:Port]`.</br><br/>The InfluxDB default port 8086 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "precision": {
            "default": "ms",
            "description": "InfluxDB time precision.",
            "enum": [
              "ns",
              "us",
              "ms",
              "s"
            ],
            "summary": "Time Precision",
            "type": "string"
          },
          "bucket": {
            "description": "InfluxDB bucket name.",
            "summary": "Bucket",
            "type": "string"
          },
          "org": {
            "description": "Organization name of InfluxDB.",
            "summary": "Organization",
            "type": "string"
          },
          "token": {
            "description": "InfluxDB token.",
            "summary": "Token",
            "type": "string"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          },
          "type": {
            "description": "The Bridge Type.",
            "enum": [
              "influxdb_api_v2"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name.",
            "summary": "Bridge Name",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.update_lwm2m": {
        "required": [
          "translators",
          "xml_dir"
        ],
        "properties": {
          "xml_dir": {
            "description": "The Directory for LwM2M Resource definition.",
            "example": "/etc/emqx/lwm2m_xml",
            "type": "string"
          },
          "lifetime_min": {
            "default": "15s",
            "description": "Minimum value of lifetime allowed to be set by the LwM2M client.",
            "example": "12m",
            "type": "string"
          },
          "lifetime_max": {
            "default": "86400s",
            "description": "Maximum value of lifetime allowed to be set by the LwM2M client.",
            "example": "12m",
            "type": "string"
          },
          "qmode_time_window": {
            "default": "22s",
            "description": "The value of the time window during which the network link is considered valid by the LwM2M Gateway in QMode mode.<br/>For example, after receiving an update message from a client, any messages within this time window are sent directly to the LwM2M client, and all messages beyond this time window are temporarily stored in memory.",
            "example": "1h",
            "type": "string"
          },
          "auto_observe": {
            "default": false,
            "description": "Automatically observe the object list of REGISTER packet.",
            "type": "boolean"
          },
          "update_msg_publish_condition": {
            "default": "contains_object_list",
            "description": "Policy for publishing UPDATE event message.<br/><br/>  - always: send update events as long as the UPDATE request is received.<br/><br/>  - contains_object_list: send update events only if the UPDATE request carries any Object List",
            "enum": [
              "always",
              "contains_object_list"
            ],
            "type": "string"
          },
          "translators": {
            "description": "Topic configuration for LwM2M's gateway publishing and subscription.",
            "$ref": "#/components/schemas/emqx_lwm2m_schema.lwm2m_translators"
          },
          "mountpoint": {
            "default": "lwm2m/${endpoint_name}/",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message is delivered to the subscriber.<br/>The mountpoint is a way that users can use to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,<br/>then the client actually subscribes to the topic `some_tenant/t`.<br/>Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,<br/>the message is routed to all the clients subscribed `some_tenant/t`,<br/>so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.<br/>Variables in mountpoint string:<br/><br/>  - <code>${clientid}</code>: clientid<br/><br/>  - <code>${username}</code>: username",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Whether to enable this gateway",
            "type": "boolean"
          },
          "enable_stats": {
            "default": true,
            "description": "Whether to enable client process statistic",
            "type": "boolean"
          },
          "idle_timeout": {
            "default": "30s",
            "description": "The idle time of the client connection process. It has two purposes:<br/>  1. A newly created client process that does not receive any client requests after that time will be closed directly.<br/>  2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.",
            "example": "12m",
            "type": "string"
          },
          "clientinfo_override": {
            "description": "ClientInfo override.",
            "$ref": "#/components/schemas/gateway.clientinfo_override"
          }
        },
        "type": "object"
      },
      "emqx_rule_api_schema.ctx_bridge_mqtt": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "description": "Event Type",
            "enum": [
              "$bridges/mqtt:*"
            ],
            "summary": "Event Type",
            "type": "string"
          },
          "id": {
            "description": "Message ID",
            "summary": "Message ID",
            "type": "string"
          },
          "payload": {
            "description": "The Message Payload",
            "summary": "Message Payload",
            "type": "string"
          },
          "topic": {
            "description": "Message Topic",
            "summary": "Message Topic",
            "type": "string"
          },
          "server": {
            "description": "The IP address (or hostname) and port of the MQTT broker, in IP:Port format",
            "summary": "Server IP And Port",
            "type": "string"
          },
          "dup": {
            "description": "The DUP flag of the MQTT message",
            "summary": "DUP Flag",
            "type": "string"
          },
          "retain": {
            "description": "If is a retain message",
            "summary": "Retain Message",
            "type": "string"
          },
          "message_received_at": {
            "description": "The Time that this Message is Received",
            "summary": "Message Received Time",
            "type": "integer"
          },
          "qos": {
            "description": "The Message QoS",
            "example": 0,
            "maximum": 2,
            "minimum": 0,
            "summary": "Message QoS",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "emqx_rule_api_schema.ctx_delivered": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "description": "Event Type",
            "enum": [
              "message_delivered"
            ],
            "summary": "Event Type",
            "type": "string"
          },
          "id": {
            "description": "Message ID",
            "summary": "Message ID",
            "type": "string"
          },
          "from_clientid": {
            "description": "The Client ID",
            "summary": "Client ID",
            "type": "string"
          },
          "from_username": {
            "description": "The User Name",
            "summary": "Username",
            "type": "string"
          },
          "clientid": {
            "description": "The Client ID",
            "summary": "Client ID",
            "type": "string"
          },
          "username": {
            "description": "Username",
            "summary": "Username",
            "type": "string"
          },
          "payload": {
            "description": "The Message Payload",
            "summary": "Message Payload",
            "type": "string"
          },
          "peerhost": {
            "description": "The IP Address of the Peer Client",
            "summary": "Peer IP Address",
            "type": "string"
          },
          "topic": {
            "description": "Message Topic",
            "summary": "Message Topic",
            "type": "string"
          },
          "publish_received_at": {
            "description": "The Time that this Message is Received",
            "summary": "Message Received Time",
            "type": "integer"
          },
          "qos": {
            "description": "The Message QoS",
            "example": 0,
            "maximum": 2,
            "minimum": 0,
            "summary": "Message QoS",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "modules.delayed": {
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable this feature",
            "type": "boolean"
          },
          "max_delayed_messages": {
            "default": 0,
            "description": "Maximum number of delayed messages (0 is no limit).",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "emqx_connector_mongo.topology": {
        "properties": {
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "max_overflow": {
            "default": 0,
            "description": "Max Overflow.",
            "minimum": 0,
            "summary": "Max Overflow",
            "type": "integer"
          },
          "overflow_ttl": {
            "description": "Period of time before workers that exceed the configured pool size (\"overflow\") to be terminated.",
            "example": "32s",
            "summary": "Overflow TTL",
            "type": "string"
          },
          "overflow_check_period": {
            "description": "Period for checking if there are more workers than configured (\"overflow\").",
            "example": "32s",
            "summary": "Overflow Check Period",
            "type": "string"
          },
          "local_threshold_ms": {
            "description": "The size of the latency window for selecting among multiple suitable MongoDB instances.",
            "example": "32s",
            "summary": "Local Threshold",
            "type": "string"
          },
          "connect_timeout_ms": {
            "description": "The duration to attempt a connection before timing out.",
            "example": "32s",
            "summary": "Connect Timeout",
            "type": "string"
          },
          "socket_timeout_ms": {
            "description": "The duration to attempt to send or to receive on a socket before the attempt times out.",
            "example": "32s",
            "summary": "Socket Timeout",
            "type": "string"
          },
          "server_selection_timeout_ms": {
            "description": "Specifies how long to block for server selection before throwing an exception.",
            "example": "32s",
            "summary": "Server Selection Timeout",
            "type": "string"
          },
          "wait_queue_timeout_ms": {
            "description": "The maximum duration that a worker can wait for a connection to become available.",
            "example": "32s",
            "summary": "Wait Queue Timeout",
            "type": "string"
          },
          "heartbeat_frequency_ms": {
            "default": "200s",
            "description": "Controls when the driver checks the state of the MongoDB deployment. Specify the interval between checks, counted from the end of the previous check until the beginning of the next one. If the number of connections is increased (which will happen, for example, if you increase the pool size), you may need to increase this period as well to avoid creating too many log entries in the MongoDB log file.",
            "example": "32s",
            "summary": "Heartbeat period",
            "type": "string"
          },
          "min_heartbeat_frequency_ms": {
            "description": "Controls the minimum amount of time to wait between heartbeats.",
            "example": "32s",
            "summary": "Minimum Heartbeat Period",
            "type": "string"
          }
        },
        "type": "object"
      },
      "plugins.builder": {
        "properties": {
          "contact": {
            "example": "emqx-support@emqx.io",
            "type": "string"
          },
          "name": {
            "example": "EMQX Team",
            "type": "string"
          },
          "website": {
            "example": "www.emqx.com",
            "type": "string"
          }
        },
        "type": "object"
      },
      "retainer.flow_control": {
        "properties": {
          "batch_read_number": {
            "default": 0,
            "description": "Size of the batch when reading messages from storage. 0 means no limit.",
            "minimum": 0,
            "type": "integer"
          },
          "batch_deliver_number": {
            "default": 0,
            "description": "The number of retained messages can be delivered per batch.",
            "maximum": 1000,
            "minimum": 0,
            "type": "integer"
          },
          "batch_deliver_limiter": {
            "description": "The rate limiter name for retained messages' delivery.<br/>Limiter helps to avoid delivering too many messages to the client at once, which may cause the client to block or crash, or drop messages due to exceeding the size of the message queue.<br/>The names of the available rate limiters are taken from the existing rate limiters under `limiter.batch`.<br/>If this field is empty, limiter is not used.",
            "$ref": "#/components/schemas/limiter.internal"
          }
        },
        "type": "object"
      },
      "bridge_kafka.post_producer": {
        "required": [
          "bootstrap_hosts",
          "kafka",
          "name",
          "type"
        ],
        "properties": {
          "type": {
            "description": "The Bridge Type",
            "enum": [
              "kafka_consumer",
              "kafka"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name, used as a human-readable description of the bridge.",
            "summary": "Bridge Name",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable (true) or disable (false) this Kafka bridge.",
            "summary": "Enable or Disable",
            "type": "boolean"
          },
          "bootstrap_hosts": {
            "description": "A comma separated list of Kafka <code>host[:port]</code> endpoints to bootstrap the client. Default port number is 9092.",
            "summary": "Bootstrap Hosts",
            "type": "string"
          },
          "connect_timeout": {
            "default": "5s",
            "description": "Maximum wait time for TCP connection establishment (including authentication time if enabled).",
            "example": "32s",
            "summary": "Connect Timeout",
            "type": "string"
          },
          "min_metadata_refresh_interval": {
            "default": "3s",
            "description": "Minimum time interval the client has to wait before refreshing Kafka broker and topic metadata. Setting too small value may add extra load on Kafka.",
            "example": "32s",
            "summary": "Min Metadata Refresh Interval",
            "type": "string"
          },
          "metadata_request_timeout": {
            "default": "5s",
            "description": "Maximum wait time when fetching metadata from Kafka.",
            "example": "32s",
            "summary": "Metadata Request Timeout",
            "type": "string"
          },
          "authentication": {
            "default": "none",
            "description": "Authentication configs.",
            "summary": "Authentication",
            "oneOf": [
              {
                "$ref": "#/components/schemas/bridge_kafka.auth_gssapi_kerberos"
              },
              {
                "$ref": "#/components/schemas/bridge_kafka.auth_username_password"
              },
              {
                "enum": [
                  "none"
                ],
                "type": "string"
              }
            ]
          },
          "socket_opts": {
            "description": "Extra socket options.",
            "summary": "Socket Options",
            "$ref": "#/components/schemas/bridge_kafka.socket_opts"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          },
          "local_topic": {
            "description": "MQTT topic or topic filter as data source (bridge input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in Kafka.",
            "summary": "Source MQTT Topic",
            "type": "string"
          },
          "kafka": {
            "description": "Kafka producer configs.",
            "summary": "Kafka Producer",
            "$ref": "#/components/schemas/bridge_kafka.producer_kafka_opts"
          }
        },
        "type": "object"
      },
      "exhook.hook_info": {
        "properties": {
          "name": {
            "description": "The hook's name",
            "type": "string"
          },
          "params": {
            "description": "The parameters used when the hook is registered",
            "properties": {
              "$name": {
                "type": "string"
              }
            },
            "type": "object"
          }
        },
        "type": "object"
      },
      "authn-redis.cluster": {
        "required": [
          "backend",
          "cmd",
          "mechanism",
          "servers"
        ],
        "properties": {
          "mechanism": {
            "description": "Authentication mechanism.",
            "enum": [
              "password_based"
            ],
            "summary": "Authentication Mechanism",
            "type": "string"
          },
          "backend": {
            "description": "Backend type.",
            "enum": [
              "redis"
            ],
            "summary": "Backend Type",
            "type": "string"
          },
          "cmd": {
            "description": "The Redis Command used to query data for authentication such as password hash, currently only supports <code>HGET</code> and <code>HMGET</code>.",
            "summary": "Command",
            "type": "string"
          },
          "password_hash_algorithm": {
            "default": {
              "name": "sha256",
              "salt_position": "prefix"
            },
            "description": "Options for password hash verification.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn-hash.simple"
              },
              {
                "$ref": "#/components/schemas/authn-hash.pbkdf2"
              },
              {
                "$ref": "#/components/schemas/authn-hash.bcrypt"
              }
            ]
          },
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
            "summary": "Enable",
            "type": "boolean"
          },
          "servers": {
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The Redis default port 6379 is used if `[:Port]` is not specified.",
            "summary": "Servers",
            "type": "string"
          },
          "redis_type": {
            "default": "cluster",
            "description": "Cluster mode. Must be set to 'cluster' when Redis server is running in clustered mode.",
            "enum": [
              "cluster"
            ],
            "summary": "Cluster Mode",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "limiter.listener_fields": {
        "properties": {
          "bytes_in": {
            "description": "The bytes_in limiter.<br/>This is used to limit the inbound bytes rate for this EMQX node.<br/>Once the limit is reached, the restricted client will be slow down even be hung for a while.",
            "summary": "Bytes In",
            "$ref": "#/components/schemas/limiter.bucket_infinity"
          },
          "message_in": {
            "description": "The message in limiter.<br/>This is used to limit the inbound message numbers for this EMQX node<br/>Once the limit is reached, the restricted client will be slow down even be hung for a while.",
            "summary": "Message In",
            "$ref": "#/components/schemas/limiter.bucket_infinity"
          },
          "connection": {
            "description": "The connection limiter.<br/>This is used to limit the connection rate for this EMQX node.<br/>Once the limit is reached, new connections will be refused",
            "summary": "Connection",
            "$ref": "#/components/schemas/limiter.bucket_limit"
          },
          "message_routing": {
            "description": "The message routing limiter.<br/>This is used to limit the forwarding rate for this EMQX node.<br/>Once the limit is reached, new publish will be refused",
            "summary": "Message Routing",
            "$ref": "#/components/schemas/limiter.bucket_infinity"
          },
          "client": {
            "description": "The rate limit for each user of the bucket",
            "summary": "Per Client",
            "$ref": "#/components/schemas/limiter.listener_client_fields"
          }
        },
        "type": "object"
      },
      "emqx_conf_schema.log_file_handler": {
        "properties": {
          "file": {
            "default": "${EMQX_LOG_DIR}/emqx.log",
            "description": "Name the log file.",
            "example": "/path/to/file",
            "summary": "Log File Name",
            "type": "string"
          },
          "rotation": {
            "$ref": "#/components/schemas/emqx_conf_schema.log_rotation"
          },
          "max_size": {
            "default": "50MB",
            "description": "This parameter controls log file rotation. The value `infinity` means the log file will grow indefinitely, otherwise the log file will be rotated once it reaches `max_size` in bytes.",
            "summary": "Rotation Size",
            "oneOf": [
              {
                "example": "32MB",
                "type": "string"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "enable": {
            "default": false,
            "description": "Enable this log handler.",
            "summary": "Enable Log Handler",
            "type": "boolean"
          },
          "level": {
            "default": "warning",
            "description": "The log level for the current log handler.<br/>Defaults to warning.",
            "enum": [
              "debug",
              "info",
              "notice",
              "warning",
              "error",
              "critical",
              "alert",
              "emergency",
              "all"
            ],
            "summary": "Log Level",
            "type": "string"
          },
          "time_offset": {
            "default": "system",
            "description": "The time offset to be used when formatting the timestamp.<br/>Can be one of:<br/>  - <code>system</code>: the time offset used by the local system<br/>  - <code>utc</code>: the UTC time offset<br/>  - <code>+-[hh]:[mm]</code>: user specified time offset, such as \"-02:00\" or \"+00:00\"<br/>Defaults to: <code>system</code>.",
            "summary": "Time Offset",
            "type": "string"
          },
          "chars_limit": {
            "default": "unlimited",
            "description": "Set the maximum length of a single log message. If this length is exceeded, the log message will be truncated.<br/>NOTE: Restrict char limiter if formatter is JSON , it will get a truncated incomplete JSON data, which is not recommended.",
            "summary": "Single Log Max Length",
            "oneOf": [
              {
                "minimum": 100,
                "type": "integer"
              },
              {
                "enum": [
                  "unlimited"
                ],
                "type": "string"
              }
            ]
          },
          "formatter": {
            "default": "text",
            "description": "Choose log formatter. <code>text</code> for free text, and <code>json</code> for structured logging.",
            "enum": [
              "text",
              "json"
            ],
            "summary": "Log Formatter",
            "type": "string"
          },
          "single_line": {
            "default": true,
            "description": "Print logs in a single line if set to true. Otherwise, log messages may span multiple lines.",
            "summary": "Single Line Mode",
            "type": "boolean"
          },
          "sync_mode_qlen": {
            "default": 100,
            "description": "As long as the number of buffered log events is lower than this value,<br/>all log events are handled asynchronously. This means that the client process sending the log event,<br/>by calling a log function in the Logger API, does not wait for a response from the handler<br/>but continues executing immediately after the event is sent.<br/>It is not affected by the time it takes the handler to print the event to the log device.<br/>If the message queue grows larger than this value,<br/>the handler starts handling log events synchronously instead,<br/>meaning that the client process sending the event must wait for a response.<br/>When the handler reduces the message queue to a level below the sync_mode_qlen threshold,<br/>asynchronous operation is resumed.",
            "minimum": 0,
            "summary": "Queue Length before Entering Sync Mode",
            "type": "integer"
          },
          "drop_mode_qlen": {
            "default": 3000,
            "description": "When the number of buffered log events is larger than this value, the new log events are dropped.<br/>When drop mode is activated or deactivated, a message is printed in the logs.",
            "minimum": 1,
            "summary": "Queue Length before Entering Drop Mode",
            "type": "integer"
          },
          "flush_qlen": {
            "default": 8000,
            "description": "If the number of buffered log events grows larger than this threshold, a flush (delete) operation takes place.<br/>To flush events, the handler discards the buffered log messages without logging.",
            "minimum": 1,
            "summary": "Flush Threshold",
            "type": "integer"
          },
          "overload_kill": {
            "$ref": "#/components/schemas/emqx_conf_schema.log_overload_kill"
          },
          "burst_limit": {
            "$ref": "#/components/schemas/emqx_conf_schema.log_burst_limit"
          },
          "supervisor_reports": {
            "default": "error",
            "description": "Type of supervisor reports that are logged. Defaults to <code>error</code><br/><br/>  - <code>error</code>: only log errors in the Erlang processes<br/>.<br/>  - <code>progress</code>: log process startup.",
            "enum": [
              "error",
              "progress"
            ],
            "summary": "Report Type",
            "type": "string"
          },
          "max_depth": {
            "default": 100,
            "description": "Maximum depth for Erlang term log formatting and Erlang process message queue inspection.",
            "summary": "Max Depth",
            "oneOf": [
              {
                "minimum": 0,
                "type": "integer"
              },
              {
                "enum": [
                  "unlimited"
                ],
                "type": "string"
              }
            ]
          }
        },
        "type": "object"
      },
      "retainer.retainer": {
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable retainer feature",
            "type": "boolean"
          },
          "msg_expiry_interval": {
            "default": "0s",
            "description": "Message retention time. 0 means message will never be expired.",
            "example": "32s",
            "type": "string"
          },
          "msg_clear_interval": {
            "default": "0s",
            "description": "Periodic interval for cleaning up expired messages.<br/>Never clear if the value is 0.",
            "example": "32s",
            "type": "string"
          },
          "flow_control": {
            "default": {},
            "description": "Flow control.",
            "$ref": "#/components/schemas/retainer.flow_control"
          },
          "max_payload_size": {
            "default": "1MB",
            "description": "Maximum retained message size.",
            "example": "32MB",
            "type": "string"
          },
          "stop_publish_clear_msg": {
            "default": false,
            "description": "When the retained flag of the `PUBLISH` message is set and Payload is empty,<br/>whether to continue to publish the message.<br/>See:<br/>http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038",
            "type": "boolean"
          },
          "backend": {
            "description": "Settings for the database storing the retained messages.",
            "$ref": "#/components/schemas/retainer.mnesia_config"
          }
        },
        "type": "object"
      },
      "limiter.bucket_infinity": {
        "properties": {
          "rate": {
            "default": "infinity",
            "description": "Rate for this bucket.",
            "example": "10MB",
            "summary": "Rate",
            "type": "string"
          },
          "capacity": {
            "default": "infinity",
            "description": "The capacity of this token bucket.",
            "example": "100MB",
            "summary": "Capacity",
            "type": "string"
          },
          "initial": {
            "default": "0",
            "description": "The initial number of tokens for this bucket.",
            "example": "0MB",
            "summary": "Initial",
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge_kafka.get_producer": {
        "required": [
          "bootstrap_hosts",
          "kafka",
          "name",
          "type"
        ],
        "properties": {
          "status": {
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status.",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary": "Bridge Status",
            "type": "string"
          },
          "status_reason": {
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused",
            "summary": "Failure reason",
            "type": "string"
          },
          "node_status": {
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            },
            "summary": "Node Status",
            "type": "array"
          },
          "type": {
            "description": "The Bridge Type",
            "enum": [
              "kafka_consumer",
              "kafka"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name, used as a human-readable description of the bridge.",
            "summary": "Bridge Name",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable (true) or disable (false) this Kafka bridge.",
            "summary": "Enable or Disable",
            "type": "boolean"
          },
          "bootstrap_hosts": {
            "description": "A comma separated list of Kafka <code>host[:port]</code> endpoints to bootstrap the client. Default port number is 9092.",
            "summary": "Bootstrap Hosts",
            "type": "string"
          },
          "connect_timeout": {
            "default": "5s",
            "description": "Maximum wait time for TCP connection establishment (including authentication time if enabled).",
            "example": "32s",
            "summary": "Connect Timeout",
            "type": "string"
          },
          "min_metadata_refresh_interval": {
            "default": "3s",
            "description": "Minimum time interval the client has to wait before refreshing Kafka broker and topic metadata. Setting too small value may add extra load on Kafka.",
            "example": "32s",
            "summary": "Min Metadata Refresh Interval",
            "type": "string"
          },
          "metadata_request_timeout": {
            "default": "5s",
            "description": "Maximum wait time when fetching metadata from Kafka.",
            "example": "32s",
            "summary": "Metadata Request Timeout",
            "type": "string"
          },
          "authentication": {
            "default": "none",
            "description": "Authentication configs.",
            "summary": "Authentication",
            "oneOf": [
              {
                "$ref": "#/components/schemas/bridge_kafka.auth_gssapi_kerberos"
              },
              {
                "$ref": "#/components/schemas/bridge_kafka.auth_username_password"
              },
              {
                "enum": [
                  "none"
                ],
                "type": "string"
              }
            ]
          },
          "socket_opts": {
            "description": "Extra socket options.",
            "summary": "Socket Options",
            "$ref": "#/components/schemas/bridge_kafka.socket_opts"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          },
          "local_topic": {
            "description": "MQTT topic or topic filter as data source (bridge input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in Kafka.",
            "summary": "Source MQTT Topic",
            "type": "string"
          },
          "kafka": {
            "description": "Kafka producer configs.",
            "summary": "Kafka Producer",
            "$ref": "#/components/schemas/bridge_kafka.producer_kafka_opts"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_schema.position": {
        "required": [
          "position"
        ],
        "properties": {
          "position": {
            "description": "Where to place the source.",
            "summary": "position",
            "type": "string"
          }
        },
        "type": "object"
      },
      "authn-jwt.hmac-based": {
        "required": [
          "algorithm",
          "mechanism",
          "secret",
          "use_jwks"
        ],
        "properties": {
          "use_jwks": {
            "description": "Whether to use JWKS.",
            "enum": [
              false
            ],
            "summary": "Whether to Use JWKS",
            "type": "string"
          },
          "algorithm": {
            "description": "JWT signing algorithm, Supports HMAC (configured as <code>hmac-based</code>) and RSA, ECDSA (configured as <code>public-key</code>).",
            "enum": [
              "hmac-based"
            ],
            "summary": "JWT Signing Algorithm",
            "type": "string"
          },
          "secret": {
            "description": "The key to verify the JWT using HMAC algorithm.",
            "summary": "Secret",
            "type": "string"
          },
          "secret_base64_encoded": {
            "default": false,
            "description": "Whether secret is base64 encoded.",
            "summary": "Whether Secret is Base64 Encoded",
            "type": "boolean"
          },
          "mechanism": {
            "description": "Authentication mechanism.",
            "enum": [
              "jwt"
            ],
            "summary": "Authentication Mechanism",
            "type": "string"
          },
          "acl_claim_name": {
            "default": "acl",
            "description": "JWT claim name to use for getting ACL rules.",
            "summary": "ACL claim name",
            "type": "string"
          },
          "verify_claims": {
            "default": {},
            "description": "A list of custom claims to validate, which is a list of name/value pairs.<br/>Values can use the following placeholders:<br/>- <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting<br/>- <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting<br/>Authentication will verify that the value of claims in the JWT (taken from the Password field) matches what is required in <code>verify_claims</code>.",
            "items": {
              "example": "any",
              "type": "string"
            },
            "summary": "Verify Claims",
            "type": "array"
          },
          "from": {
            "default": "password",
            "description": "Field to take JWT from.",
            "enum": [
              "username",
              "password"
            ],
            "summary": "From Field",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
            "summary": "Enable",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "emqx_rule_api_schema.node_metrics": {
        "properties": {
          "node": {
            "description": "The node name",
            "example": "emqx@127.0.0.1",
            "summary": "Node Name",
            "type": "string"
          },
          "matched": {
            "description": "How much times the FROM clause of the SQL is matched.",
            "minimum": 0,
            "summary": "Matched",
            "type": "integer"
          },
          "matched.rate": {
            "description": "The rate of matched, times/second",
            "summary": "命中速率",
            "type": "number"
          },
          "matched.rate.max": {
            "description": "The max rate of matched, times/second",
            "summary": "Max Matched Rate",
            "type": "number"
          },
          "matched.rate.last5m": {
            "description": "The average rate of matched in last 5 minutes, times/second",
            "summary": "Average Matched Rate",
            "type": "number"
          },
          "passed": {
            "description": "How much times the SQL is passed",
            "minimum": 0,
            "summary": "SQL Passed",
            "type": "integer"
          },
          "failed": {
            "description": "How much times the SQL is failed",
            "minimum": 0,
            "summary": "SQL Failed",
            "type": "integer"
          },
          "failed.exception": {
            "description": "How much times the SQL is failed due to exceptions. This may because of a crash when calling a SQL function, or trying to do arithmetic operation on undefined variables",
            "minimum": 0,
            "summary": "SQL Exception",
            "type": "integer"
          },
          "failed.unknown": {
            "description": "How much times the SQL is failed due to an unknown error.",
            "minimum": 0,
            "summary": "SQL Unknown Error",
            "type": "integer"
          },
          "actions.total": {
            "description": "How much times the actions are called by the rule. This value may several times of 'matched', depending on the number of the actions of the rule.",
            "minimum": 0,
            "summary": "Action Total",
            "type": "integer"
          },
          "actions.success": {
            "description": "How much times the rule success to call the actions.",
            "minimum": 0,
            "summary": "Success Action",
            "type": "integer"
          },
          "actions.failed": {
            "description": "How much times the rule failed to call the actions.",
            "minimum": 0,
            "summary": "Failed Action",
            "type": "integer"
          },
          "actions.failed.out_of_service": {
            "description": "How much times the rule failed to call actions due to the action is out of service. For example, a bridge is disabled or stopped.",
            "minimum": 0,
            "summary": "Fail Action",
            "type": "integer"
          },
          "actions.failed.unknown": {
            "description": "How much times the rule failed to call actions due to to an unknown error.",
            "minimum": 0,
            "summary": "Fail Action",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "broker.listener_quic_ssl_opts": {
        "properties": {
          "cacertfile": {
            "description": "Trusted PEM format CA certificates bundle file.<br/><br/>The certificates in this file are used to verify the TLS peer's certificates.<br/>Append new certificates to the file if new CAs are to be trusted.<br/>There is no need to restart EMQX to have the updated file loaded, because<br/>the system regularly checks if file has been updated (and reload).<br/><br/>NOTE: invalidating (deleting) a certificate from the file will not affect<br/>already established connections.",
            "summary": "CACertfile",
            "type": "string"
          },
          "certfile": {
            "description": "PEM format certificates chain file.<br/><br/>The certificates in this file should be in reversed order of the certificate<br/>issue chain. That is, the host's certificate should be placed in the beginning<br/>of the file, followed by the immediate issuer certificate and so on.<br/>Although the root CA certificate is optional, it should be placed at the end of<br/>the file if it is to be added.",
            "summary": "Certfile",
            "type": "string"
          },
          "keyfile": {
            "description": "PEM format private key file.",
            "summary": "Keyfile",
            "type": "string"
          },
          "verify": {
            "default": "verify_none",
            "description": "Enable or disable peer verification.",
            "enum": [
              "verify_peer",
              "verify_none"
            ],
            "summary": "Verify peer",
            "type": "string"
          },
          "reuse_sessions": {
            "default": true,
            "deprecated": true,
            "description": "Enable TLS session reuse.",
            "summary": "TLS session reuse",
            "type": "boolean"
          },
          "depth": {
            "default": 10,
            "deprecated": true,
            "description": "Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path.<br/>So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly;<br/><br/>if 1 the path can be PEER, Intermediate-CA, ROOT-CA;<br/><br/>if 2 the path can be PEER, Intermediate-CA1, Intermediate-CA2, ROOT-CA.",
            "summary": "CACert Depth",
            "type": "integer"
          },
          "password": {
            "description": "String containing the user's password. Only used if the private key file is password-protected.",
            "example": "",
            "format": "password",
            "summary": "Keyfile passphrase",
            "type": "string"
          },
          "versions": {
            "default": [
              "tlsv1.3",
              "tlsv1.2",
              "tlsv1.1",
              "tlsv1"
            ],
            "deprecated": true,
            "description": "All TLS/DTLS versions to be supported.<br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.<br/><br/>In case PSK cipher suites are intended, make sure to configure<br/><code>['tlsv1.2', 'tlsv1.1']</code> here.",
            "items": {
              "type": "string"
            },
            "summary": "SSL versions",
            "type": "array"
          },
          "ciphers": {
            "default": "",
            "deprecated": true,
            "description": "This config holds TLS cipher suite names separated by comma,<br/>or as an array of strings. e.g.<br/><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or<br/><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.<br/><br/><br/>Ciphers (and their ordering) define the way in which the<br/>client and server encrypts information over the network connection.<br/>Selecting a good cipher suite is critical for the<br/>application's data security, confidentiality and performance.<br/><br/>The names should be in OpenSSL string format (not RFC format).<br/>All default values and examples provided by EMQX config<br/>documentation are all in OpenSSL format.<br/><br/><br/>NOTE: Certain cipher suites are only compatible with<br/>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')<br/>incompatible cipher suites will be silently dropped.<br/>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,<br/>configuring cipher suites for other versions will have no effect.<br/><br/><br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br/><br/>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.<br/><br/>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,<br/>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,<br/>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,<br/>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code>",
            "items": {
              "type": "string"
            },
            "summary": "",
            "type": "array"
          },
          "secure_renegotiate": {
            "default": true,
            "deprecated": true,
            "description": "SSL parameter renegotiation is a feature that allows a client and a server<br/>to renegotiate the parameters of the SSL connection on the fly.<br/>RFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,<br/>you drop support for the insecure renegotiation, prone to MitM attacks.",
            "summary": "SSL renegotiate",
            "type": "boolean"
          },
          "hibernate_after": {
            "default": "5s",
            "deprecated": true,
            "description": "Hibernate the SSL process after idling for amount of time reducing its memory footprint.",
            "example": "12m",
            "summary": "hibernate after",
            "type": "string"
          },
          "dhfile": {
            "deprecated": true,
            "description": "Path to a file containing PEM-encoded Diffie-Hellman parameters<br/>to be used by the server if a cipher suite using Diffie-Hellman<br/>key exchange is negotiated. If not specified, default parameters<br/>are used.<br/><br/>NOTE: The <code>dhfile</code> option is not supported by TLS 1.3.",
            "summary": "SSL dhfile",
            "type": "string"
          },
          "fail_if_no_peer_cert": {
            "default": false,
            "deprecated": true,
            "description": "Used together with {verify, verify_peer} by an TLS/DTLS server.<br/>If set to true, the server fails if the client does not have a<br/>certificate to send, that is, sends an empty certificate.<br/>If set to false, it fails only if the client sends an invalid<br/>certificate (an empty certificate is considered valid).",
            "summary": "SSL fail if no peer cert",
            "type": "boolean"
          },
          "honor_cipher_order": {
            "default": true,
            "deprecated": true,
            "description": "An important security setting, it forces the cipher to be set based<br/> on the server-specified order instead of the client-specified order,<br/> hence enforcing the (usually more properly configured) security<br/> ordering of the server administrator.",
            "summary": "SSL honor cipher order",
            "type": "boolean"
          },
          "client_renegotiation": {
            "default": true,
            "deprecated": true,
            "description": "In protocols that support client-initiated renegotiation,<br/>the cost of resources of such an operation is higher for the server than the client.<br/>This can act as a vector for denial of service attacks.<br/>The SSL application already takes measures to counter-act such attempts,<br/>but client-initiated renegotiation can be strictly disabled by setting this option to false.<br/>The default value is true. Note that disabling renegotiation can result in<br/>long-lived connections becoming unusable due to limits on<br/>the number of messages the underlying cipher suite can encipher.",
            "summary": "SSL client renegotiation",
            "type": "boolean"
          },
          "handshake_timeout": {
            "default": "15s",
            "deprecated": true,
            "description": "Maximum time duration allowed for the handshake to complete",
            "example": "12m",
            "summary": "Handshake timeout",
            "type": "string"
          },
          "gc_after_handshake": {
            "default": false,
            "deprecated": true,
            "description": "Memory usage tuning. If enabled, will immediately perform a garbage collection after the TLS/SSL handshake.",
            "summary": "Perform GC after handshake",
            "type": "boolean"
          },
          "ocsp": {
            "deprecated": true,
            "$ref": "#/components/schemas/broker.ocsp"
          },
          "enable_crl_check": {
            "default": false,
            "deprecated": true,
            "description": "Whether to enable CRL verification for this listener.",
            "summary": "Enable CRL Check",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "authn-mongodb.replica-set": {
        "required": [
          "backend",
          "collection",
          "database",
          "mechanism",
          "replica_set_name",
          "servers"
        ],
        "properties": {
          "mechanism": {
            "description": "Authentication mechanism.",
            "enum": [
              "password_based"
            ],
            "summary": "Authentication Mechanism",
            "type": "string"
          },
          "backend": {
            "description": "Backend type.",
            "enum": [
              "mongodb"
            ],
            "summary": "Backend Type",
            "type": "string"
          },
          "collection": {
            "description": "Collection used to store authentication data.",
            "summary": "Collection",
            "type": "string"
          },
          "filter": {
            "default": {},
            "description": "Conditional expression that defines the filter condition in the query.<br/>Filter supports the following placeholders:<br/>- <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting<br/>- <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting",
            "example": {},
            "summary": "Filter",
            "type": "object"
          },
          "password_hash_field": {
            "default": "password_hash",
            "description": "Document field that contains password hash.",
            "summary": "Password Hash Field",
            "type": "string"
          },
          "salt_field": {
            "default": "salt",
            "description": "Document field that contains the password salt.",
            "summary": "Salt Field",
            "type": "string"
          },
          "is_superuser_field": {
            "default": "is_superuser",
            "description": "Document field that defines if the user has superuser privileges.",
            "summary": "Is Superuser Field",
            "type": "string"
          },
          "password_hash_algorithm": {
            "default": {
              "name": "sha256",
              "salt_position": "prefix"
            },
            "description": "Options for password hash verification.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn-hash.simple"
              },
              {
                "$ref": "#/components/schemas/authn-hash.pbkdf2"
              },
              {
                "$ref": "#/components/schemas/authn-hash.bcrypt"
              }
            ]
          },
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
            "summary": "Enable",
            "type": "boolean"
          },
          "mongo_type": {
            "default": "rs",
            "description": "Replica set. Must be set to 'rs' when MongoDB server is running in 'replica set' mode.",
            "enum": [
              "rs"
            ],
            "summary": "Replica set",
            "type": "string"
          },
          "servers": {
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The MongoDB default port 27017 is used if `[:Port]` is not specified.",
            "summary": "Servers",
            "type": "string"
          },
          "w_mode": {
            "default": "unsafe",
            "description": "Write mode.",
            "enum": [
              "unsafe",
              "safe"
            ],
            "summary": "Write Mode",
            "type": "string"
          },
          "r_mode": {
            "default": "master",
            "description": "Read mode.",
            "enum": [
              "master",
              "slave_ok"
            ],
            "summary": "Read Mode",
            "type": "string"
          },
          "replica_set_name": {
            "description": "Name of the replica set.",
            "summary": "Replica Set Name",
            "type": "string"
          },
          "srv_record": {
            "default": false,
            "description": "Use DNS SRV record.",
            "summary": "Srv Record",
            "type": "boolean"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auth_source": {
            "description": "Database name associated with the user's credentials.",
            "summary": "Auth Source",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "topology": {
            "$ref": "#/components/schemas/emqx_connector_mongo.topology"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "exhook.node_metrics": {
        "properties": {
          "node": {
            "description": "Node name",
            "type": "string"
          },
          "metrics": {
            "description": "Metrics information",
            "$ref": "#/components/schemas/exhook.metrics"
          }
        },
        "type": "object"
      },
      "exhook.move_req": {
        "required": [
          "position"
        ],
        "properties": {
          "position": {
            "description": "The target position to be moved",
            "example": "front",
            "type": "string"
          }
        },
        "type": "object"
      },
      "broker.zone": {
        "properties": {
          "mqtt": {
            "$ref": "#/components/schemas/zone.mqtt"
          },
          "force_shutdown": {
            "$ref": "#/components/schemas/zone.force_shutdown"
          },
          "force_gc": {
            "$ref": "#/components/schemas/zone.force_gc"
          }
        },
        "type": "object"
      },
      "emqx_conf_schema.log_overload_kill": {
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable log handler overload kill feature.",
            "summary": "Log Handler Overload Kill",
            "type": "boolean"
          },
          "mem_size": {
            "default": "30MB",
            "description": "Maximum memory size that the log handler process is allowed to use.",
            "example": "32MB",
            "summary": "Log Handler Max Memory Size",
            "type": "string"
          },
          "qlen": {
            "default": 20000,
            "description": "Maximum allowed queue length.",
            "minimum": 1,
            "summary": "Max Queue Length",
            "type": "integer"
          },
          "restart_after": {
            "default": "5s",
            "description": "The handler restarts automatically after a delay in the event of termination, unless the value `infinity` is set, which blocks any subsequent restarts.",
            "summary": "Handler Restart Timer",
            "oneOf": [
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              },
              {
                "example": "32s",
                "type": "string"
              }
            ]
          }
        },
        "type": "object"
      },
      "exhook.node_status": {
        "properties": {
          "node": {
            "description": "Node name",
            "type": "string"
          },
          "status": {
            "description": "The status of Exhook server.<br/><br/>connected: connection succeeded<br/><br/>connecting: connection failed, reconnecting<br/><br/>disconnected: failed to connect and didn't reconnect<br/><br/>disabled: this server is disabled<br/><br/>error: failed to view the status of this server",
            "enum": [
              "connected",
              "connecting",
              "disconnected",
              "disabled",
              "error"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_rule_api_schema.rule_creation": {
        "required": [
          "sql"
        ],
        "properties": {
          "name": {
            "default": "",
            "description": "The name of the rule",
            "example": "foo",
            "summary": "Rule Name",
            "type": "string"
          },
          "sql": {
            "description": "SQL query to transform the messages.<br/>Example: <code>SELECT * FROM \"test/topic\" WHERE payload.x = 1</code>",
            "example": "SELECT * FROM \"test/topic\" WHERE payload.x = 1",
            "summary": "Rule SQL",
            "type": "string"
          },
          "actions": {
            "default": "",
            "description": "A list of actions of the rule.<br/>An action can be a string that refers to the channel ID of an EMQX bridge, or an object<br/>that refers to a function.<br/>There a some built-in functions like \"republish\" and \"console\", and we also support user<br/>provided functions in the format: \"{module}:{function}\".<br/>The actions in the list are executed sequentially.<br/>This means that if one of the action is executing slowly, all the following actions will not<br/>be executed until it returns.<br/>If one of the action crashed, all other actions come after it will still be executed, in the<br/>original order.<br/>If there's any error when running an action, there will be an error message, and the 'failure'<br/>counter of the function action or the bridge channel will increase.",
            "example": [
              "webhook:my_webhook",
              {
                "args": {
                  "payload": "${payload}",
                  "topic": "t/1"
                },
                "function": "republish"
              },
              {
                "function": "console"
              }
            ],
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/rule_engine.user_provided_function"
                },
                {
                  "$ref": "#/components/schemas/rule_engine.builtin_action_console"
                },
                {
                  "$ref": "#/components/schemas/rule_engine.builtin_action_republish"
                },
                {
                  "type": "string"
                }
              ]
            },
            "summary": "Rule Action List",
            "type": "array"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable the rule",
            "summary": "Enable Or Disable Rule",
            "type": "boolean"
          },
          "description": {
            "default": "",
            "description": "The description of the rule",
            "example": "Some description",
            "summary": "Rule Description",
            "type": "string"
          },
          "metadata": {
            "description": "Rule metadata, do not change manually",
            "example": {},
            "summary": "Rule metadata",
            "type": "object"
          }
        },
        "type": "object"
      },
      "listeners.ws_required_bind": {
        "required": [
          "bind",
          "id",
          "type"
        ],
        "properties": {
          "type": {
            "description": "Listener type",
            "enum": [
              "ws"
            ],
            "type": "string"
          },
          "running": {
            "description": "Listener status",
            "type": "boolean"
          },
          "id": {
            "description": "Listener id",
            "type": "string"
          },
          "current_connections": {
            "description": "Current connections",
            "minimum": 0,
            "type": "integer"
          },
          "enabled": {
            "default": true,
            "description": "Enable listener.",
            "summary": "Enable listener",
            "type": "boolean"
          },
          "bind": {
            "default": 8083,
            "description": "IP address and port for the listening socket.",
            "summary": "IP address and port",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "acceptors": {
            "default": 16,
            "description": "The size of the listener's receiving pool.",
            "minimum": 1,
            "summary": "Acceptors Num",
            "type": "integer"
          },
          "max_connections": {
            "default": 5000000,
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "summary": "Max connections",
            "oneOf": [
              {
                "minimum": 1,
                "type": "integer"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message<br/>is delivered to the subscriber. The mountpoint is a way that users can use<br/>to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`<br/>set to `some_tenant`, then the client actually subscribes to the topic<br/>`some_tenant/t`. Similarly, if another client B (connected to the same listener<br/>as the client A) sends a message to topic `t`, the message is routed<br/>to all the clients subscribed `some_tenant/t`, so client A will receive the<br/>message, with topic name `t`.<br/><br/>Set to `\"\"` to disable the feature.<br/><br/><br/>Variables in mountpoint string:<br/>  - <code>${clientid}</code>: clientid<br/>  - <code>${username}</code>: username",
            "summary": "mountpoint",
            "type": "string"
          },
          "zone": {
            "default": "default",
            "description": "The configuration zone to which the listener belongs.",
            "summary": "Zone",
            "type": "string"
          },
          "limiter": {
            "description": "Type of the rate limit.",
            "summary": "Type of the rate limit.",
            "$ref": "#/components/schemas/limiter.listener_fields"
          },
          "enable_authn": {
            "default": true,
            "description": "Set <code>true</code> (default) to enable client authentication on this listener, the authentication<br/>process goes through the configured authentication chain.<br/>When set to <code>false</code> to allow any clients with or without authentication information such as username or password to log in.<br/>When set to <code>quick_deny_anonymous</code>, it behaves like when set to <code>true</code>, but clients will be<br/>denied immediately without going through any authenticators if <code>username</code> is not provided. This is useful to fence off<br/>anonymous clients early.",
            "enum": [
              true,
              false,
              "quick_deny_anonymous"
            ],
            "summary": "Enable authentication",
            "type": "string"
          },
          "access_rules": {
            "default": [
              "allow all"
            ],
            "description": "The access control rules for this listener.<br/>See: https://github.com/emqtt/esockd#allowdeny",
            "items": {
              "type": "string"
            },
            "summary": "Access rules",
            "type": "array"
          },
          "proxy_protocol": {
            "default": false,
            "description": "Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.<br/><br/>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/",
            "summary": "Proxy protocol",
            "type": "boolean"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "description": "Timeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.",
            "example": "12m",
            "summary": "Proxy protocol timeout",
            "type": "string"
          },
          "tcp_options": {
            "$ref": "#/components/schemas/broker.tcp_opts"
          },
          "websocket": {
            "$ref": "#/components/schemas/broker.ws_opts"
          }
        },
        "type": "object"
      },
      "broker.persistent_session_builtin": {
        "properties": {
          "type": {
            "default": "builtin",
            "description": "",
            "enum": [
              "builtin"
            ],
            "type": "string"
          },
          "session": {
            "description": "Performance tuning options for built-in session table.",
            "summary": "Persistent session",
            "$ref": "#/components/schemas/broker.persistent_table_mria_opts"
          },
          "session_messages": {
            "description": "Performance tuning options for built-in session messages table.",
            "summary": "Persistent session messages",
            "$ref": "#/components/schemas/broker.persistent_table_mria_opts"
          },
          "messages": {
            "description": "Performance tuning options for built-in messages table.",
            "summary": "Persistent messages",
            "$ref": "#/components/schemas/broker.persistent_table_mria_opts"
          }
        },
        "type": "object"
      },
      "bridge_gcp_pubsub.get": {
        "required": [
          "name",
          "pubsub_topic",
          "service_account_json",
          "type"
        ],
        "properties": {
          "status": {
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status.",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary": "Bridge Status",
            "type": "string"
          },
          "status_reason": {
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused",
            "summary": "Failure reason",
            "type": "string"
          },
          "node_status": {
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            },
            "summary": "Node Status",
            "type": "array"
          },
          "type": {
            "description": "The Bridge Type",
            "enum": [
              "gcp_pubsub"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name, used as a human-readable description of the bridge.",
            "summary": "Bridge Name",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "connect_timeout": {
            "default": "15s",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s",
            "summary": "Connect Timeout",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "The pool size.",
            "minimum": 1,
            "summary": "Pool Size",
            "type": "integer"
          },
          "pipelining": {
            "default": 100,
            "description": "A positive integer. Whether to send HTTP requests continuously, when set to 1, it means that after each HTTP request is sent, you need to wait for the server to return and then continue to send the next request.",
            "minimum": 1,
            "summary": "HTTP Pipelineing",
            "type": "integer"
          },
          "max_retries": {
            "default": 2,
            "description": "Max retry times if an error occurs when sending a request.",
            "minimum": 0,
            "summary": "Max Retries",
            "type": "integer"
          },
          "request_timeout": {
            "default": "15s",
            "deprecated": true,
            "description": "Deprecated: Configure the request timeout in the buffer settings.",
            "example": "32s",
            "summary": "Request Timeout",
            "type": "string"
          },
          "payload_template": {
            "default": "",
            "description": "The template for formatting the outgoing messages.  If undefined, will send all the available context in JSON format.",
            "summary": "Payload template",
            "type": "string"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to GCP PubSub. All MQTT 'PUBLISH' messages with the topic<br/>matching `local_topic` will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "pubsub_topic": {
            "description": "The GCP PubSub topic to publish messages to.",
            "summary": "GCP PubSub Topic",
            "type": "string"
          },
          "service_account_json": {
            "description": "JSON containing the GCP Service Account credentials to be used with PubSub.<br/>When a GCP Service Account is created (as described in https://developers.google.com/identity/protocols/oauth2/service-account#creatinganaccount), you have the option of downloading the credentials in JSON form.  That's the file needed.",
            "example": {},
            "summary": "GCP Service Account Credentials",
            "type": "object"
          }
        },
        "type": "object"
      },
      "listeners.listener_type_status": {
        "required": [
          "enable",
          "ids",
          "type"
        ],
        "properties": {
          "type": {
            "description": "Listener type",
            "enum": [
              "tcp",
              "ssl",
              "ws",
              "wss",
              "quic"
            ],
            "type": "string"
          },
          "enable": {
            "description": "Listener enable",
            "type": "boolean"
          },
          "ids": {
            "description": "Listener Ids",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "status": {
            "$ref": "#/components/schemas/listeners.status"
          },
          "node_status": {
            "items": {
              "$ref": "#/components/schemas/listeners.node_status"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_schema.redis_sentinel": {
        "required": [
          "cmd",
          "sentinel",
          "servers",
          "type"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this ACL provider.",
            "summary": "enable",
            "type": "boolean"
          },
          "type": {
            "default": "redis",
            "description": "Backend type.",
            "enum": [
              "redis"
            ],
            "summary": "type",
            "type": "string"
          },
          "cmd": {
            "description": "Database query used to retrieve authorization data.",
            "example": "HGETALL mqtt_authz",
            "summary": "cmd",
            "type": "string"
          },
          "servers": {
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The Redis default port 6379 is used if `[:Port]` is not specified.",
            "summary": "Servers",
            "type": "string"
          },
          "redis_type": {
            "default": "sentinel",
            "description": "Sentinel mode. Must be set to 'sentinel' when Redis server is running in sentinel mode.",
            "enum": [
              "sentinel"
            ],
            "summary": "Sentinel Mode",
            "type": "string"
          },
          "sentinel": {
            "description": "The cluster name in Redis sentinel mode.",
            "summary": "Cluster Name",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "database": {
            "default": 0,
            "description": "Redis database ID.",
            "summary": "Database ID",
            "type": "integer"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_schema.mysql": {
        "required": [
          "database",
          "query",
          "server",
          "type"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this ACL provider.",
            "summary": "enable",
            "type": "boolean"
          },
          "type": {
            "default": "mysql",
            "description": "Backend type.",
            "enum": [
              "mysql"
            ],
            "summary": "type",
            "type": "string"
          },
          "query": {
            "description": "Database query used to retrieve authorization data.",
            "summary": "query",
            "type": "string"
          },
          "server": {
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The MySQL default port 3306 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "default": "root",
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_stats.aggergate_data": {
        "properties": {
          "node": {
            "description": "Node name",
            "example": "emqx@127.0.0.1",
            "type": "string"
          },
          "channels.count": {
            "description": "sessions.count",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "channels.max": {
            "description": "session.max",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "connections.count": {
            "description": "Number of current connections",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "connections.max": {
            "description": "Historical maximum number of connections",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "delayed.count": {
            "description": "Number of delayed messages",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "delayed.max": {
            "description": "Historical maximum number of delayed messages",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "live_connections.count": {
            "description": "Number of current live connections",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "live_connections.max": {
            "description": "Historical maximum number of live connections",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "retained.count": {
            "description": "Number of currently retained messages",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "retained.max": {
            "description": "Historical maximum number of retained messages",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "sessions.count": {
            "description": "Number of current sessions",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "sessions.max": {
            "description": "Historical maximum number of sessions",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "suboptions.count": {
            "description": "subscriptions.count",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "suboptions.max": {
            "description": "subscriptions.max",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "subscribers.count": {
            "description": "Number of current subscribers",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "subscribers.max": {
            "description": "Historical maximum number of subscribers",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "subscriptions.count": {
            "description": "Number of current subscriptions, including shared subscriptions",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "subscriptions.max": {
            "description": "Historical maximum number of subscriptions",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "subscriptions.shared.count": {
            "description": "Number of current shared subscriptions",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "subscriptions.shared.max": {
            "description": "Historical maximum number of shared subscriptions",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "topics.count": {
            "description": "Number of current topics",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "topics.max": {
            "description": "Historical maximum number of topics",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "authn-redis.standalone": {
        "required": [
          "backend",
          "cmd",
          "mechanism",
          "server"
        ],
        "properties": {
          "mechanism": {
            "description": "Authentication mechanism.",
            "enum": [
              "password_based"
            ],
            "summary": "Authentication Mechanism",
            "type": "string"
          },
          "backend": {
            "description": "Backend type.",
            "enum": [
              "redis"
            ],
            "summary": "Backend Type",
            "type": "string"
          },
          "cmd": {
            "description": "The Redis Command used to query data for authentication such as password hash, currently only supports <code>HGET</code> and <code>HMGET</code>.",
            "summary": "Command",
            "type": "string"
          },
          "password_hash_algorithm": {
            "default": {
              "name": "sha256",
              "salt_position": "prefix"
            },
            "description": "Options for password hash verification.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn-hash.simple"
              },
              {
                "$ref": "#/components/schemas/authn-hash.pbkdf2"
              },
              {
                "$ref": "#/components/schemas/authn-hash.bcrypt"
              }
            ]
          },
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
            "summary": "Enable",
            "type": "boolean"
          },
          "server": {
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The Redis default port 6379 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "redis_type": {
            "default": "single",
            "description": "Single mode. Must be set to 'single' when Redis server is running in single mode.",
            "enum": [
              "single"
            ],
            "summary": "Single Mode",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "database": {
            "default": 0,
            "description": "Redis database ID.",
            "summary": "Database ID",
            "type": "integer"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "bridge_redis.creation_opts_redis_cluster": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 0,
            "summary": "Buffer Pool Size",
            "type": "integer"
          },
          "health_check_interval": {
            "default": "15s",
            "description": "Health check interval.",
            "example": "32s",
            "summary": "Health Check Interval",
            "type": "string"
          },
          "start_after_created": {
            "default": "true",
            "description": "Whether start the resource right after created.",
            "summary": "Start After Created",
            "type": "boolean"
          },
          "start_timeout": {
            "default": "5s",
            "description": "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "example": "32s",
            "summary": "Start Timeout",
            "type": "string"
          },
          "auto_restart_interval": {
            "default": "60s",
            "description": "The auto restart interval after the resource is disconnected.",
            "summary": "Auto Restart Interval",
            "oneOf": [
              {
                "example": "32s",
                "type": "string"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "query_mode": {
            "default": "async",
            "description": "Query mode. Optional 'sync/async', default 'async'.",
            "enum": [
              "sync",
              "async"
            ],
            "summary": "Query mode",
            "type": "string"
          },
          "request_timeout": {
            "default": "15s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "summary": "Request Expiry",
            "oneOf": [
              {
                "example": "32s",
                "type": "string"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1,
            "summary": "Inflight window",
            "type": "integer"
          },
          "enable_queue": {
            "default": false,
            "deprecated": true,
            "description": "Enable disk buffer queue (only applicable for egress bridges).<br/>When Enabled, messages will be buffered on disk when the bridge connection is down.<br/>When disabled the messages are buffered in RAM only.",
            "summary": "Enable disk buffer queue",
            "type": "boolean"
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB",
            "summary": "Max buffer queue size",
            "type": "string"
          }
        },
        "type": "object"
      },
      "authn-jwt.public-key": {
        "required": [
          "algorithm",
          "mechanism",
          "use_jwks"
        ],
        "properties": {
          "use_jwks": {
            "description": "Whether to use JWKS.",
            "enum": [
              false
            ],
            "summary": "Whether to Use JWKS",
            "type": "string"
          },
          "algorithm": {
            "description": "JWT signing algorithm, Supports HMAC (configured as <code>hmac-based</code>) and RSA, ECDSA (configured as <code>public-key</code>).",
            "enum": [
              "public-key"
            ],
            "summary": "JWT Signing Algorithm",
            "type": "string"
          },
          "public_key": {
            "description": "The public key used to verify the JWT.",
            "summary": "Public Key",
            "type": "string"
          },
          "mechanism": {
            "description": "Authentication mechanism.",
            "enum": [
              "jwt"
            ],
            "summary": "Authentication Mechanism",
            "type": "string"
          },
          "acl_claim_name": {
            "default": "acl",
            "description": "JWT claim name to use for getting ACL rules.",
            "summary": "ACL claim name",
            "type": "string"
          },
          "verify_claims": {
            "default": {},
            "description": "A list of custom claims to validate, which is a list of name/value pairs.<br/>Values can use the following placeholders:<br/>- <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting<br/>- <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting<br/>Authentication will verify that the value of claims in the JWT (taken from the Password field) matches what is required in <code>verify_claims</code>.",
            "items": {
              "example": "any",
              "type": "string"
            },
            "summary": "Verify Claims",
            "type": "array"
          },
          "from": {
            "default": "password",
            "description": "Field to take JWT from.",
            "enum": [
              "username",
              "password"
            ],
            "summary": "From Field",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
            "summary": "Enable",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "connector-mqtt.ingress_remote": {
        "required": [
          "topic"
        ],
        "properties": {
          "topic": {
            "description": "Receive messages from which topic of the remote broker",
            "summary": "Remote Topic",
            "type": "string"
          },
          "qos": {
            "default": 1,
            "description": "The QoS level to be used when subscribing to the remote broker",
            "example": 0,
            "maximum": 2,
            "minimum": 0,
            "summary": "Remote QoS",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_sources.sources": {
        "properties": {
          "sources": {
            "description": "Authorization sources",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/emqx_authz_api_schema.file"
                },
                {
                  "$ref": "#/components/schemas/emqx_authz_api_schema.postgresql"
                },
                {
                  "$ref": "#/components/schemas/emqx_authz_api_schema.mysql"
                },
                {
                  "$ref": "#/components/schemas/emqx_authz_api_schema.built_in_database"
                },
                {
                  "$ref": "#/components/schemas/emqx_authz_api_schema.redis_cluster"
                },
                {
                  "$ref": "#/components/schemas/emqx_authz_api_schema.redis_sentinel"
                },
                {
                  "$ref": "#/components/schemas/emqx_authz_api_schema.redis_single"
                },
                {
                  "$ref": "#/components/schemas/emqx_authz_api_schema.mongo_sharded"
                },
                {
                  "$ref": "#/components/schemas/emqx_authz_api_schema.mongo_rs"
                },
                {
                  "$ref": "#/components/schemas/emqx_authz_api_schema.mongo_single"
                },
                {
                  "$ref": "#/components/schemas/emqx_authz_api_schema.http_post"
                },
                {
                  "$ref": "#/components/schemas/emqx_authz_api_schema.http_get"
                }
              ]
            },
            "summary": "sources",
            "type": "array"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_alarms.alarm": {
        "properties": {
          "node": {
            "description": "The name of the node that triggered this alarm.",
            "example": "emqx@127.0.0.1",
            "type": "string"
          },
          "name": {
            "description": "The name of the node that triggered this alarm.",
            "example": "high_system_memory_usage",
            "type": "string"
          },
          "message": {
            "description": "Alarm message, which describes the alarm content in a human-readable format.",
            "example": "System memory usage is higher than 70%",
            "type": "string"
          },
          "details": {
            "description": "Alarm details, provides more alarm information, mainly for program processing.",
            "example": {
              "high_watermark": 70
            },
            "type": "object"
          },
          "duration": {
            "description": "Indicates how long the alarm has been active in milliseconds.",
            "example": 297056,
            "type": "integer"
          },
          "activate_at": {
            "description": "Alarm start time, using rfc3339 standard time format.",
            "example": "2021-10-25T11:52:52.548+08:00",
            "type": "string"
          },
          "deactivate_at": {
            "description": "Alarm end time, using rfc3339 standard time format.",
            "example": "2021-10-31T10:52:52.548+08:00",
            "type": "string"
          }
        },
        "type": "object"
      },
      "authn-redis.sentinel": {
        "required": [
          "backend",
          "cmd",
          "mechanism",
          "sentinel",
          "servers"
        ],
        "properties": {
          "mechanism": {
            "description": "Authentication mechanism.",
            "enum": [
              "password_based"
            ],
            "summary": "Authentication Mechanism",
            "type": "string"
          },
          "backend": {
            "description": "Backend type.",
            "enum": [
              "redis"
            ],
            "summary": "Backend Type",
            "type": "string"
          },
          "cmd": {
            "description": "The Redis Command used to query data for authentication such as password hash, currently only supports <code>HGET</code> and <code>HMGET</code>.",
            "summary": "Command",
            "type": "string"
          },
          "password_hash_algorithm": {
            "default": {
              "name": "sha256",
              "salt_position": "prefix"
            },
            "description": "Options for password hash verification.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn-hash.simple"
              },
              {
                "$ref": "#/components/schemas/authn-hash.pbkdf2"
              },
              {
                "$ref": "#/components/schemas/authn-hash.bcrypt"
              }
            ]
          },
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
            "summary": "Enable",
            "type": "boolean"
          },
          "servers": {
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The Redis default port 6379 is used if `[:Port]` is not specified.",
            "summary": "Servers",
            "type": "string"
          },
          "redis_type": {
            "default": "sentinel",
            "description": "Sentinel mode. Must be set to 'sentinel' when Redis server is running in sentinel mode.",
            "enum": [
              "sentinel"
            ],
            "summary": "Sentinel Mode",
            "type": "string"
          },
          "sentinel": {
            "description": "The cluster name in Redis sentinel mode.",
            "summary": "Cluster Name",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "database": {
            "default": 0,
            "description": "Redis database ID.",
            "summary": "Database ID",
            "type": "integer"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "broker.ssl_client_opts": {
        "properties": {
          "cacertfile": {
            "description": "Trusted PEM format CA certificates bundle file.<br/><br/>The certificates in this file are used to verify the TLS peer's certificates.<br/>Append new certificates to the file if new CAs are to be trusted.<br/>There is no need to restart EMQX to have the updated file loaded, because<br/>the system regularly checks if file has been updated (and reload).<br/><br/>NOTE: invalidating (deleting) a certificate from the file will not affect<br/>already established connections.",
            "summary": "CACertfile",
            "type": "string"
          },
          "certfile": {
            "description": "PEM format certificates chain file.<br/><br/>The certificates in this file should be in reversed order of the certificate<br/>issue chain. That is, the host's certificate should be placed in the beginning<br/>of the file, followed by the immediate issuer certificate and so on.<br/>Although the root CA certificate is optional, it should be placed at the end of<br/>the file if it is to be added.",
            "summary": "Certfile",
            "type": "string"
          },
          "keyfile": {
            "description": "PEM format private key file.",
            "summary": "Keyfile",
            "type": "string"
          },
          "verify": {
            "default": "verify_none",
            "description": "Enable or disable peer verification.",
            "enum": [
              "verify_peer",
              "verify_none"
            ],
            "summary": "Verify peer",
            "type": "string"
          },
          "reuse_sessions": {
            "default": true,
            "description": "Enable TLS session reuse.",
            "summary": "TLS session reuse",
            "type": "boolean"
          },
          "depth": {
            "default": 10,
            "description": "Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path.<br/>So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly;<br/><br/>if 1 the path can be PEER, Intermediate-CA, ROOT-CA;<br/><br/>if 2 the path can be PEER, Intermediate-CA1, Intermediate-CA2, ROOT-CA.",
            "summary": "CACert Depth",
            "type": "integer"
          },
          "password": {
            "description": "String containing the user's password. Only used if the private key file is password-protected.",
            "example": "",
            "format": "password",
            "summary": "Keyfile passphrase",
            "type": "string"
          },
          "versions": {
            "default": [
              "tlsv1.3",
              "tlsv1.2",
              "tlsv1.1",
              "tlsv1"
            ],
            "description": "All TLS/DTLS versions to be supported.<br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.<br/><br/>In case PSK cipher suites are intended, make sure to configure<br/><code>['tlsv1.2', 'tlsv1.1']</code> here.",
            "items": {
              "type": "string"
            },
            "summary": "SSL versions",
            "type": "array"
          },
          "ciphers": {
            "default": "",
            "description": "This config holds TLS cipher suite names separated by comma,<br/>or as an array of strings. e.g.<br/><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or<br/><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.<br/><br/><br/>Ciphers (and their ordering) define the way in which the<br/>client and server encrypts information over the network connection.<br/>Selecting a good cipher suite is critical for the<br/>application's data security, confidentiality and performance.<br/><br/>The names should be in OpenSSL string format (not RFC format).<br/>All default values and examples provided by EMQX config<br/>documentation are all in OpenSSL format.<br/><br/><br/>NOTE: Certain cipher suites are only compatible with<br/>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')<br/>incompatible cipher suites will be silently dropped.<br/>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,<br/>configuring cipher suites for other versions will have no effect.<br/><br/><br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br/><br/>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.<br/><br/>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,<br/>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,<br/>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,<br/>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code>",
            "items": {
              "type": "string"
            },
            "summary": "",
            "type": "array"
          },
          "secure_renegotiate": {
            "default": true,
            "description": "SSL parameter renegotiation is a feature that allows a client and a server<br/>to renegotiate the parameters of the SSL connection on the fly.<br/>RFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,<br/>you drop support for the insecure renegotiation, prone to MitM attacks.",
            "summary": "SSL renegotiate",
            "type": "boolean"
          },
          "hibernate_after": {
            "default": "5s",
            "description": "Hibernate the SSL process after idling for amount of time reducing its memory footprint.",
            "example": "12m",
            "summary": "hibernate after",
            "type": "string"
          },
          "enable": {
            "default": false,
            "description": "Enable TLS.",
            "summary": "Enable TLS.",
            "type": "boolean"
          },
          "server_name_indication": {
            "description": "Specify the host name to be used in TLS Server Name Indication extension.<br/><br/>For instance, when connecting to \"server.example.net\", the genuine server<br/>which accepts the connection and performs TLS handshake may differ from the<br/>host the TLS client initially connects to, e.g. when connecting to an IP address<br/>or when the host has multiple resolvable DNS records <br/><br/>If not specified, it will default to the host name string which is used<br/>to establish the connection, unless it is IP addressed used.<br/><br/>The host name is then also used in the host name verification of the peer<br/>certificate.<br/> The special value 'disable' prevents the Server Name<br/>Indication extension from being sent and disables the hostname<br/>verification check.",
            "example": "disable",
            "summary": "Server Name Indication",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "enum": [
                  "disable"
                ],
                "type": "string"
              }
            ]
          }
        },
        "type": "object"
      },
      "listeners.tcp_required_bind(with_name)": {
        "required": [
          "bind",
          "name",
          "type"
        ],
        "properties": {
          "type": {
            "description": "Listener type",
            "enum": [
              "tcp"
            ],
            "type": "string"
          },
          "running": {
            "description": "Listener status",
            "type": "boolean"
          },
          "name": {
            "description": "Listener name",
            "type": "string"
          },
          "current_connections": {
            "description": "Current connections",
            "minimum": 0,
            "type": "integer"
          },
          "enabled": {
            "default": true,
            "description": "Enable listener.",
            "summary": "Enable listener",
            "type": "boolean"
          },
          "bind": {
            "default": 1883,
            "description": "IP address and port for the listening socket.",
            "summary": "IP address and port",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "acceptors": {
            "default": 16,
            "description": "The size of the listener's receiving pool.",
            "minimum": 1,
            "summary": "Acceptors Num",
            "type": "integer"
          },
          "max_connections": {
            "default": 5000000,
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "summary": "Max connections",
            "oneOf": [
              {
                "minimum": 1,
                "type": "integer"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message<br/>is delivered to the subscriber. The mountpoint is a way that users can use<br/>to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`<br/>set to `some_tenant`, then the client actually subscribes to the topic<br/>`some_tenant/t`. Similarly, if another client B (connected to the same listener<br/>as the client A) sends a message to topic `t`, the message is routed<br/>to all the clients subscribed `some_tenant/t`, so client A will receive the<br/>message, with topic name `t`.<br/><br/>Set to `\"\"` to disable the feature.<br/><br/><br/>Variables in mountpoint string:<br/>  - <code>${clientid}</code>: clientid<br/>  - <code>${username}</code>: username",
            "summary": "mountpoint",
            "type": "string"
          },
          "zone": {
            "default": "default",
            "description": "The configuration zone to which the listener belongs.",
            "summary": "Zone",
            "type": "string"
          },
          "limiter": {
            "description": "Type of the rate limit.",
            "summary": "Type of the rate limit.",
            "$ref": "#/components/schemas/limiter.listener_fields"
          },
          "enable_authn": {
            "default": true,
            "description": "Set <code>true</code> (default) to enable client authentication on this listener, the authentication<br/>process goes through the configured authentication chain.<br/>When set to <code>false</code> to allow any clients with or without authentication information such as username or password to log in.<br/>When set to <code>quick_deny_anonymous</code>, it behaves like when set to <code>true</code>, but clients will be<br/>denied immediately without going through any authenticators if <code>username</code> is not provided. This is useful to fence off<br/>anonymous clients early.",
            "enum": [
              true,
              false,
              "quick_deny_anonymous"
            ],
            "summary": "Enable authentication",
            "type": "string"
          },
          "access_rules": {
            "default": [
              "allow all"
            ],
            "description": "The access control rules for this listener.<br/>See: https://github.com/emqtt/esockd#allowdeny",
            "items": {
              "type": "string"
            },
            "summary": "Access rules",
            "type": "array"
          },
          "proxy_protocol": {
            "default": false,
            "description": "Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.<br/><br/>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/",
            "summary": "Proxy protocol",
            "type": "boolean"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "description": "Timeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.",
            "example": "12m",
            "summary": "Proxy protocol timeout",
            "type": "string"
          },
          "tcp_options": {
            "$ref": "#/components/schemas/broker.tcp_opts"
          }
        },
        "type": "object"
      },
      "bridge_redis.get_single": {
        "required": [
          "command_template",
          "name",
          "server",
          "type"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to Redis. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "command_template": {
            "description": "Redis command template used to export messages. Each list element stands for a command name or its argument.<br/>For example, to push payloads in a Redis list by key `msgs`, the elements should be the following:<br/>`rpush`, `msgs`, `${payload}`.",
            "items": {
              "type": "string"
            },
            "summary": "Redis Command Template",
            "type": "array"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/bridge_redis.creation_opts_redis_single"
          },
          "server": {
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The Redis default port 6379 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "redis_type": {
            "default": "single",
            "description": "Single mode. Must be set to 'single' when Redis server is running in single mode.",
            "enum": [
              "single"
            ],
            "summary": "Single Mode",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "database": {
            "default": 0,
            "description": "Redis database ID.",
            "summary": "Database ID",
            "type": "integer"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          },
          "type": {
            "description": "The Bridge Type",
            "enum": [
              "redis_single"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name, used as a human-readable description of the bridge.",
            "summary": "Bridge Name",
            "type": "string"
          },
          "status": {
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status.",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary": "Bridge Status",
            "type": "string"
          },
          "status_reason": {
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused",
            "summary": "Failure reason",
            "type": "string"
          },
          "node_status": {
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            },
            "summary": "Node Status",
            "type": "array"
          }
        },
        "type": "object"
      },
      "emqx_stomp_schema.stomp_frame": {
        "properties": {
          "max_headers": {
            "default": 10,
            "description": "The maximum number of Header",
            "minimum": 0,
            "type": "integer"
          },
          "max_headers_length": {
            "default": 1024,
            "description": "The maximum string length of the Header Value",
            "minimum": 0,
            "type": "integer"
          },
          "max_body_length": {
            "default": 65536,
            "description": "Maximum number of bytes of Body allowed per Stomp packet",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "emqx_exproto_schema.exproto_grpc_handler": {
        "required": [
          "address"
        ],
        "properties": {
          "address": {
            "description": "gRPC server address.",
            "type": "string"
          },
          "ssl_options": {
            "description": "SSL configuration for the gRPC client.",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_schema.file": {
        "required": [
          "rules",
          "type"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this ACL provider.",
            "summary": "enable",
            "type": "boolean"
          },
          "type": {
            "default": "file",
            "description": "Backend type.",
            "enum": [
              "file"
            ],
            "summary": "type",
            "type": "string"
          },
          "rules": {
            "description": "Authorization static file rules.",
            "example": "{allow,{username,\"^dashboard?\"},subscribe,[\"$SYS/#\"]}.\n{allow,{ipaddr,\"127.0.0.1\"},all,[\"$SYS/#\",\"#\"]}.",
            "summary": "rules",
            "type": "string"
          }
        },
        "type": "object"
      },
      "exhook.detail_server_info": {
        "required": [
          "name",
          "url"
        ],
        "properties": {
          "metrics": {
            "description": "Metrics information of this server in the current node",
            "$ref": "#/components/schemas/exhook.metrics"
          },
          "node_metrics": {
            "description": "Metrics information of this server in all nodes",
            "items": {
              "$ref": "#/components/schemas/exhook.node_metrics"
            },
            "type": "array"
          },
          "node_status": {
            "description": "status of this server in all nodes",
            "items": {
              "$ref": "#/components/schemas/exhook.node_status"
            },
            "type": "array"
          },
          "hooks": {
            "items": {
              "$ref": "#/components/schemas/exhook.hook_info"
            },
            "type": "array"
          },
          "name": {
            "description": "Name of the exhook server",
            "example": "default",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable this Exhook server",
            "type": "boolean"
          },
          "url": {
            "description": "URL of the gRPC server",
            "example": "http://127.0.0.1:9000",
            "type": "string"
          },
          "request_timeout": {
            "default": "5s",
            "description": "The timeout of request gRPC server",
            "example": "12m",
            "type": "string"
          },
          "failed_action": {
            "default": "deny",
            "description": "The value that is returned when the request to the gRPC server fails for any reason",
            "enum": [
              "deny",
              "ignore"
            ],
            "type": "string"
          },
          "ssl": {
            "$ref": "#/components/schemas/exhook.ssl_conf"
          },
          "socket_options": {
            "default": {
              "keepalive": true,
              "nodelay": true
            },
            "$ref": "#/components/schemas/exhook.socket_options"
          },
          "auto_reconnect": {
            "default": "60s",
            "description": "Whether to automatically reconnect (initialize) the gRPC server.<br/>When gRPC is not available, Exhook tries to request the gRPC service at that interval and reinitialize the list of mounted hooks.",
            "oneOf": [
              {
                "example": "12m",
                "type": "string"
              },
              {
                "enum": [
                  false
                ],
                "type": "string"
              }
            ]
          },
          "pool_size": {
            "default": 8,
            "description": "The process pool size for gRPC client",
            "minimum": 1,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "emqx_dashboard_monitor_api.sampler": {
        "properties": {
          "time_stamp": {
            "description": "Timestamp",
            "minimum": 0,
            "type": "integer"
          },
          "subscriptions": {
            "description": "Subscriptions at the time of sampling. Can only represent the approximate state",
            "type": "integer"
          },
          "topics": {
            "description": "Count topics at the time of sampling. Can only represent the approximate state",
            "type": "integer"
          },
          "connections": {
            "description": "Connections at the time of sampling. Can only represent the approximate state",
            "type": "integer"
          },
          "received": {
            "description": "Received messages last 10 seconds",
            "type": "integer"
          },
          "sent": {
            "description": "Sent messages last 10 seconds",
            "type": "integer"
          },
          "dropped": {
            "description": "Dropped messages last 10 seconds",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "broker.trace": {
        "properties": [],
        "type": "object"
      },
      "emqx_rule_api_schema.ctx_check_authz_complete": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "description": "Event Type",
            "enum": [
              "client_check_authz_complete"
            ],
            "summary": "Event Type",
            "type": "string"
          },
          "clientid": {
            "description": "The Client ID",
            "summary": "Client ID",
            "type": "string"
          },
          "username": {
            "description": "Username",
            "summary": "Username",
            "type": "string"
          },
          "peerhost": {
            "description": "The IP Address of the Peer Client",
            "summary": "Peer IP Address",
            "type": "string"
          },
          "topic": {
            "description": "Message Topic",
            "summary": "Message Topic",
            "type": "string"
          },
          "action": {
            "description": "Publish or Subscribe",
            "summary": "Publish or Subscribe",
            "type": "string"
          },
          "authz_source": {
            "description": "Cache, Plugs or Default",
            "summary": "Auth Source",
            "type": "string"
          },
          "result": {
            "description": "Allow or Deny",
            "summary": "Auth Result",
            "type": "string"
          }
        },
        "type": "object"
      },
      "broker.ocsp": {
        "properties": {
          "enable_ocsp_stapling": {
            "default": false,
            "description": "Whether to enable Online Certificate Status Protocol (OCSP) stapling for the listener.  If set to true, requires defining the OCSP responder URL and issuer PEM path.",
            "summary": "Enable OCSP Stapling",
            "type": "boolean"
          },
          "responder_url": {
            "description": "URL for the OCSP responder to check the server certificate against.",
            "example": "http://127.0.0.1",
            "summary": "OCSP Responder URL",
            "type": "string"
          },
          "issuer_pem": {
            "description": "PEM-encoded certificate of the OCSP issuer for the server certificate.",
            "summary": "OCSP Issuer Certificate",
            "type": "string"
          },
          "refresh_interval": {
            "default": "5m",
            "description": "The period to refresh the OCSP response for the server.",
            "example": "12m",
            "summary": "OCSP Refresh Interval",
            "type": "string"
          },
          "refresh_http_timeout": {
            "default": "15s",
            "description": "The timeout for the HTTP request when checking OCSP responses.",
            "example": "12m",
            "summary": "OCSP Refresh HTTP Timeout",
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge_webhook.creation_opts": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 0,
            "summary": "Buffer Pool Size",
            "type": "integer"
          },
          "health_check_interval": {
            "default": "15s",
            "description": "Health check interval.",
            "example": "32s",
            "summary": "Health Check Interval",
            "type": "string"
          },
          "start_after_created": {
            "default": "true",
            "description": "Whether start the resource right after created.",
            "summary": "Start After Created",
            "type": "boolean"
          },
          "start_timeout": {
            "default": "5s",
            "description": "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "example": "32s",
            "summary": "Start Timeout",
            "type": "string"
          },
          "auto_restart_interval": {
            "default": "60s",
            "description": "The auto restart interval after the resource is disconnected.",
            "summary": "Auto Restart Interval",
            "oneOf": [
              {
                "example": "32s",
                "type": "string"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "query_mode": {
            "default": "async",
            "description": "Query mode. Optional 'sync/async', default 'async'.",
            "enum": [
              "sync",
              "async"
            ],
            "summary": "Query mode",
            "type": "string"
          },
          "request_timeout": {
            "default": "15s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "summary": "Request Expiry",
            "oneOf": [
              {
                "example": "32s",
                "type": "string"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1,
            "summary": "Inflight window",
            "type": "integer"
          },
          "enable_queue": {
            "default": false,
            "deprecated": true,
            "description": "Enable disk buffer queue (only applicable for egress bridges).<br/>When Enabled, messages will be buffered on disk when the bridge connection is down.<br/>When disabled the messages are buffered in RAM only.",
            "summary": "Enable disk buffer queue",
            "type": "boolean"
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB",
            "summary": "Max buffer queue size",
            "type": "string"
          }
        },
        "type": "object"
      },
      "limiter.listener_client_fields": {
        "properties": {
          "bytes_in": {
            "description": "The bytes_in limiter.<br/>This is used to limit the inbound bytes rate for this EMQX node.<br/>Once the limit is reached, the restricted client will be slow down even be hung for a while.",
            "summary": "Bytes In",
            "$ref": "#/components/schemas/limiter.client_opts"
          },
          "message_in": {
            "description": "The message in limiter.<br/>This is used to limit the inbound message numbers for this EMQX node<br/>Once the limit is reached, the restricted client will be slow down even be hung for a while.",
            "summary": "Message In",
            "$ref": "#/components/schemas/limiter.client_opts"
          },
          "connection": {
            "description": "The connection limiter.<br/>This is used to limit the connection rate for this EMQX node.<br/>Once the limit is reached, new connections will be refused",
            "summary": "Connection",
            "$ref": "#/components/schemas/limiter.client_opts"
          },
          "message_routing": {
            "description": "The message routing limiter.<br/>This is used to limit the forwarding rate for this EMQX node.<br/>Once the limit is reached, new publish will be refused",
            "summary": "Message Routing",
            "$ref": "#/components/schemas/limiter.client_opts"
          }
        },
        "type": "object"
      },
      "bridge_redis.get_cluster": {
        "required": [
          "command_template",
          "name",
          "servers",
          "type"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to Redis. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "command_template": {
            "description": "Redis command template used to export messages. Each list element stands for a command name or its argument.<br/>For example, to push payloads in a Redis list by key `msgs`, the elements should be the following:<br/>`rpush`, `msgs`, `${payload}`.",
            "items": {
              "type": "string"
            },
            "summary": "Redis Command Template",
            "type": "array"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/bridge_redis.creation_opts_redis_cluster"
          },
          "servers": {
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The Redis default port 6379 is used if `[:Port]` is not specified.",
            "summary": "Servers",
            "type": "string"
          },
          "redis_type": {
            "default": "cluster",
            "description": "Cluster mode. Must be set to 'cluster' when Redis server is running in clustered mode.",
            "enum": [
              "cluster"
            ],
            "summary": "Cluster Mode",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          },
          "type": {
            "description": "The Bridge Type",
            "enum": [
              "redis_cluster"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name, used as a human-readable description of the bridge.",
            "summary": "Bridge Name",
            "type": "string"
          },
          "status": {
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status.",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary": "Bridge Status",
            "type": "string"
          },
          "status_reason": {
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused",
            "summary": "Failure reason",
            "type": "string"
          },
          "node_status": {
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            },
            "summary": "Node Status",
            "type": "array"
          }
        },
        "type": "object"
      },
      "authz.metrics_status_fields": {
        "properties": {
          "resource_metrics": {
            "description": "The metrics of the resource.",
            "summary": "Metrics",
            "$ref": "#/components/schemas/authz.resource_metrics"
          },
          "node_resource_metrics": {
            "description": "The metrics of the resource for each node.",
            "items": {
              "$ref": "#/components/schemas/authz.node_resource_metrics"
            },
            "summary": "Resource Metrics in Node",
            "type": "array"
          },
          "metrics": {
            "description": "The metrics of the resource.",
            "summary": "Metrics",
            "$ref": "#/components/schemas/authz.metrics"
          },
          "node_metrics": {
            "description": "The metrics of the resource for each node.",
            "items": {
              "$ref": "#/components/schemas/authz.node_metrics"
            },
            "summary": "Resource Metrics in Node",
            "type": "array"
          },
          "status": {
            "description": "The status of the resource.",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary": "Status",
            "type": "string"
          },
          "node_status": {
            "description": "The status of the resource for each node.",
            "items": {
              "$ref": "#/components/schemas/authz.node_status"
            },
            "summary": "Resource Status in Node",
            "type": "array"
          },
          "node_error": {
            "description": "The error of node.",
            "items": {
              "$ref": "#/components/schemas/authz.node_error"
            },
            "summary": "Error in Node",
            "type": "array"
          }
        },
        "type": "object"
      },
      "emqx_authn_api.response_user": {
        "required": [
          "user_id"
        ],
        "properties": {
          "user_id": {
            "type": "string"
          },
          "is_superuser": {
            "default": false,
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "bridge_timescale.get": {
        "required": [
          "database",
          "name",
          "server",
          "type"
        ],
        "properties": {
          "status": {
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status.",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary": "Bridge Status",
            "type": "string"
          },
          "status_reason": {
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused",
            "summary": "Failure reason",
            "type": "string"
          },
          "node_status": {
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            },
            "summary": "Node Status",
            "type": "array"
          },
          "type": {
            "description": "The Bridge Type",
            "enum": [
              "pgsql"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name.",
            "summary": "Bridge Name",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "sql": {
            "default": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
            "description": "SQL Template",
            "format": "sql",
            "summary": "SQL Template",
            "type": "string"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to PostgreSQL. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The PostgreSQL default port 5432 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "broker.sysmon_vm": {
        "properties": {
          "process_check_interval": {
            "default": "30s",
            "description": "The time interval for the periodic process limit check.",
            "example": "12m",
            "summary": "Process limit check interval",
            "type": "string"
          },
          "process_high_watermark": {
            "default": "80%",
            "description": "The threshold, as percentage of processes, for how many<br/> processes can simultaneously exist at the local node before the corresponding<br/> alarm is raised.",
            "example": "12%",
            "summary": "Process high watermark",
            "type": "number"
          },
          "process_low_watermark": {
            "default": "60%",
            "description": "The threshold, as percentage of processes, for how many<br/> processes can simultaneously exist at the local node before the corresponding<br/> alarm is cleared.",
            "example": "12%",
            "summary": "Process low watermark",
            "type": "number"
          },
          "long_gc": {
            "default": "disabled",
            "description": "When an Erlang process spends long time to perform garbage collection, a warning level <code>long_gc</code> log is emitted,<br/>and an MQTT message is published to the system topic <code>$SYS/sysmon/long_gc</code>.",
            "summary": "Enable Long GC monitoring.",
            "oneOf": [
              {
                "example": "12m",
                "type": "string"
              },
              {
                "enum": [
                  "disabled"
                ],
                "type": "string"
              }
            ]
          },
          "long_schedule": {
            "default": "240ms",
            "description": "When the Erlang VM detect a task scheduled for too long, a warning level 'long_schedule' log is emitted,<br/>and an MQTT message is published to the system topic <code>$SYS/sysmon/long_schedule</code>.",
            "summary": "Enable Long Schedule monitoring.",
            "oneOf": [
              {
                "example": "12m",
                "type": "string"
              },
              {
                "enum": [
                  "disabled"
                ],
                "type": "string"
              }
            ]
          },
          "large_heap": {
            "default": "32MB",
            "description": "When an Erlang process consumed a large amount of memory for its heap space,<br/>the system will write a warning level <code>large_heap</code> log, and an MQTT message is published to<br/>the system topic <code>$SYS/sysmon/large_heap</code>.",
            "summary": "Enable Large Heap monitoring.",
            "oneOf": [
              {
                "example": "32MB",
                "type": "string"
              },
              {
                "enum": [
                  "disabled"
                ],
                "type": "string"
              }
            ]
          },
          "busy_dist_port": {
            "default": true,
            "description": "When the RPC connection used to communicate with other nodes in the cluster is overloaded,<br/>there will be a <code>busy_dist_port</code> warning log,<br/>and an MQTT message is published to system topic <code>$SYS/sysmon/busy_dist_port</code>.",
            "summary": "Enable Busy Distribution Port monitoring.",
            "type": "boolean"
          },
          "busy_port": {
            "default": true,
            "description": "When a port (e.g. TCP socket) is overloaded, there will be a <code>busy_port</code> warning log,<br/>and an MQTT message is published to the system topic <code>$SYS/sysmon/busy_port</code>.",
            "summary": "Enable Busy Port monitoring.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "exhook.metrics": {
        "properties": {
          "succeed": {
            "description": "The number of times the hooks execution successful",
            "type": "integer"
          },
          "failed": {
            "description": "The number of times the hook execution failed",
            "type": "integer"
          },
          "rate": {
            "description": "The call rate of hooks",
            "type": "integer"
          },
          "max_rate": {
            "description": "Maximum call rate of hooks",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "emqx_rule_api_schema.ctx_disconnected": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "description": "Event Type",
            "enum": [
              "client_disconnected"
            ],
            "summary": "Event Type",
            "type": "string"
          },
          "clientid": {
            "description": "The Client ID",
            "summary": "Client ID",
            "type": "string"
          },
          "username": {
            "description": "Username",
            "summary": "Username",
            "type": "string"
          },
          "reason": {
            "description": "The Reason for Disconnect",
            "summary": "Disconnect Reason",
            "type": "string"
          },
          "peername": {
            "description": "The IP Address and Port of the Peer Client",
            "summary": "IP Address And Port",
            "type": "string"
          },
          "sockname": {
            "description": "The IP Address and Port of the Local Listener",
            "summary": "IP Address And Port",
            "type": "string"
          },
          "disconnected_at": {
            "description": "The Time that this Client is Disconnected",
            "summary": "Disconnected Time",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "dashboard.listeners": {
        "properties": {
          "http": {
            "description": "TCP listeners",
            "$ref": "#/components/schemas/dashboard.http"
          },
          "https": {
            "description": "SSL listeners",
            "$ref": "#/components/schemas/dashboard.https"
          }
        },
        "type": "object"
      },
      "listeners.tcp_required_bind": {
        "required": [
          "bind",
          "id",
          "type"
        ],
        "properties": {
          "type": {
            "description": "Listener type",
            "enum": [
              "tcp"
            ],
            "type": "string"
          },
          "running": {
            "description": "Listener status",
            "type": "boolean"
          },
          "id": {
            "description": "Listener id",
            "type": "string"
          },
          "current_connections": {
            "description": "Current connections",
            "minimum": 0,
            "type": "integer"
          },
          "enabled": {
            "default": true,
            "description": "Enable listener.",
            "summary": "Enable listener",
            "type": "boolean"
          },
          "bind": {
            "default": 1883,
            "description": "IP address and port for the listening socket.",
            "summary": "IP address and port",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "acceptors": {
            "default": 16,
            "description": "The size of the listener's receiving pool.",
            "minimum": 1,
            "summary": "Acceptors Num",
            "type": "integer"
          },
          "max_connections": {
            "default": 5000000,
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "summary": "Max connections",
            "oneOf": [
              {
                "minimum": 1,
                "type": "integer"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message<br/>is delivered to the subscriber. The mountpoint is a way that users can use<br/>to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`<br/>set to `some_tenant`, then the client actually subscribes to the topic<br/>`some_tenant/t`. Similarly, if another client B (connected to the same listener<br/>as the client A) sends a message to topic `t`, the message is routed<br/>to all the clients subscribed `some_tenant/t`, so client A will receive the<br/>message, with topic name `t`.<br/><br/>Set to `\"\"` to disable the feature.<br/><br/><br/>Variables in mountpoint string:<br/>  - <code>${clientid}</code>: clientid<br/>  - <code>${username}</code>: username",
            "summary": "mountpoint",
            "type": "string"
          },
          "zone": {
            "default": "default",
            "description": "The configuration zone to which the listener belongs.",
            "summary": "Zone",
            "type": "string"
          },
          "limiter": {
            "description": "Type of the rate limit.",
            "summary": "Type of the rate limit.",
            "$ref": "#/components/schemas/limiter.listener_fields"
          },
          "enable_authn": {
            "default": true,
            "description": "Set <code>true</code> (default) to enable client authentication on this listener, the authentication<br/>process goes through the configured authentication chain.<br/>When set to <code>false</code> to allow any clients with or without authentication information such as username or password to log in.<br/>When set to <code>quick_deny_anonymous</code>, it behaves like when set to <code>true</code>, but clients will be<br/>denied immediately without going through any authenticators if <code>username</code> is not provided. This is useful to fence off<br/>anonymous clients early.",
            "enum": [
              true,
              false,
              "quick_deny_anonymous"
            ],
            "summary": "Enable authentication",
            "type": "string"
          },
          "access_rules": {
            "default": [
              "allow all"
            ],
            "description": "The access control rules for this listener.<br/>See: https://github.com/emqtt/esockd#allowdeny",
            "items": {
              "type": "string"
            },
            "summary": "Access rules",
            "type": "array"
          },
          "proxy_protocol": {
            "default": false,
            "description": "Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.<br/><br/>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/",
            "summary": "Proxy protocol",
            "type": "boolean"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "description": "Timeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.",
            "example": "12m",
            "summary": "Proxy protocol timeout",
            "type": "string"
          },
          "tcp_options": {
            "$ref": "#/components/schemas/broker.tcp_opts"
          }
        },
        "type": "object"
      },
      "bridge_dynamo.creation_opts": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 0,
            "summary": "Buffer Pool Size",
            "type": "integer"
          },
          "health_check_interval": {
            "default": "15s",
            "description": "Health check interval.",
            "example": "32s",
            "summary": "Health Check Interval",
            "type": "string"
          },
          "start_after_created": {
            "default": "true",
            "description": "Whether start the resource right after created.",
            "summary": "Start After Created",
            "type": "boolean"
          },
          "start_timeout": {
            "default": "5s",
            "description": "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "example": "32s",
            "summary": "Start Timeout",
            "type": "string"
          },
          "auto_restart_interval": {
            "default": "60s",
            "description": "The auto restart interval after the resource is disconnected.",
            "summary": "Auto Restart Interval",
            "oneOf": [
              {
                "example": "32s",
                "type": "string"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "query_mode": {
            "default": "async",
            "description": "Query mode. Optional 'sync/async', default 'async'.",
            "enum": [
              "sync",
              "async"
            ],
            "summary": "Query mode",
            "type": "string"
          },
          "request_timeout": {
            "default": "15s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "summary": "Request Expiry",
            "oneOf": [
              {
                "example": "32s",
                "type": "string"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1,
            "summary": "Inflight window",
            "type": "integer"
          },
          "enable_batch": {
            "default": true,
            "deprecated": true,
            "description": "Batch mode enabled.",
            "summary": "Enable batch",
            "type": "boolean"
          },
          "batch_size": {
            "default": 1,
            "description": "Maximum batch count. If equal to 1, there's effectively no batching.",
            "minimum": 1,
            "summary": "Max batch size",
            "type": "integer"
          },
          "batch_time": {
            "default": "0ms",
            "description": "Maximum waiting interval when accumulating a batch at a low message rates for more efficient resource usage.",
            "example": "32s",
            "summary": "Max batch wait time",
            "type": "string"
          },
          "enable_queue": {
            "default": false,
            "deprecated": true,
            "description": "Enable disk buffer queue (only applicable for egress bridges).<br/>When Enabled, messages will be buffered on disk when the bridge connection is down.<br/>When disabled the messages are buffered in RAM only.",
            "summary": "Enable disk buffer queue",
            "type": "boolean"
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB",
            "summary": "Max buffer queue size",
            "type": "string"
          }
        },
        "type": "object"
      },
      "broker.alarm": {
        "properties": {
          "actions": {
            "default": [
              "log",
              "publish"
            ],
            "description": "The actions triggered when the alarm is activated.<br/>Currently, the following actions are supported: <code>log</code> and <code>publish</code>.<br/><code>log</code> is to write the alarm to log (console or file).<br/><code>publish</code> is to publish the alarm as an MQTT message to the system topics:<br/><code>$SYS/brokers/emqx@xx.xx.xx.x/alarms/activate</code> and<br/><code>$SYS/brokers/emqx@xx.xx.xx.x/alarms/deactivate</code>",
            "example": [
              "log",
              "publish"
            ],
            "items": {
              "type": "string"
            },
            "summary": "Alarm Actions",
            "type": "array"
          },
          "size_limit": {
            "default": 1000,
            "description": "The maximum total number of deactivated alarms to keep as history.<br/>When this limit is exceeded, the oldest deactivated alarms are deleted to cap the total number.",
            "example": 1000,
            "maximum": 3000,
            "minimum": 1,
            "summary": "Alarm size limit",
            "type": "integer"
          },
          "validity_period": {
            "default": "24h",
            "description": "Retention time of deactivated alarms. Alarms are not deleted immediately<br/>when deactivated, but after the retention time.",
            "example": "24h",
            "summary": "Alarm validity period",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_license_schema.key_license": {
        "required": [
          "key"
        ],
        "properties": {
          "key": {
            "default": "MjIwMTExCjAKMTAKRXZhbHVhdGlvbgpjb250YWN0QGVtcXguaW8KZGVmYXVsdAoyMDIzMDEwOQoxODI1CjEwMAo=.MEUCIG62t8W15g05f1cKx3tA3YgJoR0dmyHOPCdbUxBGxgKKAiEAhHKh8dUwhU+OxNEaOn8mgRDtiT3R8RZooqy6dEsOmDI=",
            "description": "License string",
            "summary": "License string",
            "type": "string"
          },
          "connection_low_watermark": {
            "default": "75%",
            "description": "Low watermark limit below which license connection quota usage alarms are deactivated",
            "example": "12%",
            "summary": "Connection low watermark",
            "type": "number"
          },
          "connection_high_watermark": {
            "default": "80%",
            "description": "High watermark limit above which license connection quota usage alarms are activated",
            "example": "12%",
            "summary": "Connection high watermark",
            "type": "number"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_schema.mongo_rs": {
        "required": [
          "collection",
          "database",
          "replica_set_name",
          "servers",
          "type"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this ACL provider.",
            "summary": "enable",
            "type": "boolean"
          },
          "type": {
            "default": "mongodb",
            "description": "Backend type.",
            "enum": [
              "mongodb"
            ],
            "summary": "type",
            "type": "string"
          },
          "collection": {
            "description": "`MongoDB` collection containing the authorization data.",
            "summary": "collection",
            "type": "string"
          },
          "filter": {
            "default": {},
            "description": "Conditional expression that defines the filter condition in the query.<br/>Filter supports the following placeholders:<br/> - <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting;<br/> - <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting.",
            "example": {},
            "summary": "Filter",
            "type": "object"
          },
          "mongo_type": {
            "default": "rs",
            "description": "Replica set. Must be set to 'rs' when MongoDB server is running in 'replica set' mode.",
            "enum": [
              "rs"
            ],
            "summary": "Replica set",
            "type": "string"
          },
          "servers": {
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The MongoDB default port 27017 is used if `[:Port]` is not specified.",
            "summary": "Servers",
            "type": "string"
          },
          "w_mode": {
            "default": "unsafe",
            "description": "Write mode.",
            "enum": [
              "unsafe",
              "safe"
            ],
            "summary": "Write Mode",
            "type": "string"
          },
          "r_mode": {
            "default": "master",
            "description": "Read mode.",
            "enum": [
              "master",
              "slave_ok"
            ],
            "summary": "Read Mode",
            "type": "string"
          },
          "replica_set_name": {
            "description": "Name of the replica set.",
            "summary": "Replica Set Name",
            "type": "string"
          },
          "srv_record": {
            "default": false,
            "description": "Use DNS SRV record.",
            "summary": "Srv Record",
            "type": "boolean"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auth_source": {
            "description": "Database name associated with the user's credentials.",
            "summary": "Auth Source",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "topology": {
            "$ref": "#/components/schemas/emqx_connector_mongo.topology"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "broker.persistent_session_store": {
        "properties": {
          "enabled": {
            "default": false,
            "description": "Use the database to store information about persistent sessions.<br/>This makes it possible to migrate a client connection to another<br/>cluster node if a node is stopped.",
            "summary": "Enable persistent session store",
            "type": "boolean"
          },
          "on_disc": {
            "default": true,
            "description": "Save information about the persistent sessions on disc.<br/>If this option is enabled, persistent sessions will survive full restart of the cluster.<br/>Otherwise, all the data will be stored in RAM, and it will be lost when all the nodes in the cluster are stopped.",
            "summary": "Persist on disc",
            "type": "boolean"
          },
          "ram_cache": {
            "default": false,
            "description": "Maintain a copy of the data in RAM for faster access.",
            "summary": "RAM cache",
            "type": "boolean"
          },
          "backend": {
            "default": {
              "messages": {
                "ram_cache": "false"
              },
              "session": {
                "ram_cache": "true"
              },
              "session_messages": {
                "ram_cache": "true"
              },
              "type": "builtin"
            },
            "description": "Database management system used to store information about persistent sessions and messages.<br/>- `builtin`: Use the embedded database (mria)",
            "summary": "Backend",
            "oneOf": [
              {
                "$ref": "#/components/schemas/broker.persistent_session_builtin"
              }
            ]
          },
          "max_retain_undelivered": {
            "default": "1h",
            "description": "The time messages that was not delivered to a persistent session<br/>is stored before being garbage collected if the node the previous<br/>session was handled on restarts of is stopped.",
            "example": "12m",
            "summary": "Max retain undelivered",
            "type": "string"
          },
          "message_gc_interval": {
            "default": "1h",
            "description": "The starting interval for garbage collection of undelivered messages to<br/>a persistent session. This affects how often the \"max_retain_undelivered\"<br/>is checked for removal.",
            "example": "12m",
            "summary": "Message GC interval",
            "type": "string"
          },
          "session_message_gc_interval": {
            "default": "1m",
            "description": "The starting interval for garbage collection of transient data for<br/>persistent session messages. This does not affect the lifetime length<br/>of persistent session messages.",
            "example": "12m",
            "summary": "Session message GC interval",
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge_mysql.get": {
        "required": [
          "database",
          "name",
          "server",
          "type"
        ],
        "properties": {
          "status": {
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status.",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary": "Bridge Status",
            "type": "string"
          },
          "status_reason": {
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused",
            "summary": "Failure reason",
            "type": "string"
          },
          "node_status": {
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            },
            "summary": "Node Status",
            "type": "array"
          },
          "type": {
            "description": "The Bridge Type",
            "enum": [
              "mysql"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name, used as a human-readable description of the bridge.",
            "summary": "Bridge Name",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "sql": {
            "default": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, FROM_UNIXTIME(${timestamp}/1000))",
            "description": "SQL Template",
            "format": "sql",
            "summary": "SQL Template",
            "type": "string"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to MySQL. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The MySQL default port 3306 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "default": "root",
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "authn-http.get": {
        "required": [
          "backend",
          "mechanism",
          "method",
          "url"
        ],
        "properties": {
          "method": {
            "description": "HTTP request method.",
            "enum": [
              "get"
            ],
            "summary": "Request Method",
            "type": "string"
          },
          "headers": {
            "default": {
              "accept": "application/json",
              "cache-control": "no-cache",
              "connection": "keep-alive",
              "keep-alive": "timeout=30, max=1000"
            },
            "description": "List of HTTP headers (without <code>content-type</code>).",
            "example": {},
            "summary": "headers_no_content_type",
            "type": "object"
          },
          "mechanism": {
            "description": "Authentication mechanism.",
            "enum": [
              "password_based"
            ],
            "summary": "Authentication Mechanism",
            "type": "string"
          },
          "backend": {
            "description": "Backend type.",
            "enum": [
              "http"
            ],
            "summary": "Backend Type",
            "type": "string"
          },
          "url": {
            "description": "URL of the HTTP server.",
            "summary": "URL",
            "type": "string"
          },
          "body": {
            "description": "HTTP request body.",
            "example": {},
            "summary": "Request Body",
            "type": "object"
          },
          "request_timeout": {
            "default": "5s",
            "description": "HTTP request timeout.",
            "example": "32s",
            "summary": "Request Timeout",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
            "summary": "Enable",
            "type": "boolean"
          },
          "connect_timeout": {
            "default": "15s",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s",
            "summary": "Connect Timeout",
            "type": "string"
          },
          "enable_pipelining": {
            "default": 100,
            "description": "A positive integer. Whether to send HTTP requests continuously, when set to 1, it means that after each HTTP request is sent, you need to wait for the server to return and then continue to send the next request.",
            "minimum": 1,
            "summary": "HTTP Pipelineing",
            "type": "integer"
          },
          "max_retries": {
            "deprecated": true,
            "minimum": 0,
            "type": "integer"
          },
          "pool_size": {
            "default": 8,
            "description": "The pool size.",
            "minimum": 1,
            "summary": "Pool Size",
            "type": "integer"
          },
          "request": {
            "description": "Configure HTTP request parameters.",
            "summary": "Request",
            "$ref": "#/components/schemas/connector-http.request"
          },
          "retry_interval": {
            "deprecated": true,
            "example": "12m",
            "type": "string"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_publish.bad_request": {
        "properties": {
          "code": {
            "description": "BAD_REQUEST",
            "type": "string"
          },
          "message": {
            "description": "Describes the failure reason in detail.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "authn-postgresql.authentication": {
        "required": [
          "backend",
          "database",
          "mechanism",
          "query",
          "server"
        ],
        "properties": {
          "mechanism": {
            "description": "Authentication mechanism.",
            "enum": [
              "password_based"
            ],
            "summary": "Authentication Mechanism",
            "type": "string"
          },
          "backend": {
            "description": "Backend type.",
            "enum": [
              "postgresql"
            ],
            "summary": "Backend Type",
            "type": "string"
          },
          "password_hash_algorithm": {
            "default": {
              "name": "sha256",
              "salt_position": "prefix"
            },
            "description": "Options for password hash verification.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn-hash.simple"
              },
              {
                "$ref": "#/components/schemas/authn-hash.pbkdf2"
              },
              {
                "$ref": "#/components/schemas/authn-hash.bcrypt"
              }
            ]
          },
          "query": {
            "description": "SQL used to query data for authentication, such as password hash.",
            "summary": "Query",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
            "summary": "Enable",
            "type": "boolean"
          },
          "server": {
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The PostgreSQL default port 5432 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "emqx_authn_schema.resource_metrics": {
        "properties": {
          "matched": {
            "description": "Count of this resource is queried.",
            "summary": "Matched",
            "type": "integer"
          },
          "success": {
            "description": "Count of query success.",
            "summary": "Success",
            "type": "integer"
          },
          "failed": {
            "description": "Count of query failed.",
            "summary": "Failed",
            "type": "integer"
          },
          "rate": {
            "description": "The rate of matched, times/second.",
            "summary": "Rate",
            "type": "number"
          },
          "rate_max": {
            "description": "The max rate of matched, times/second.",
            "summary": "Max Rate",
            "type": "number"
          },
          "rate_last5m": {
            "description": "The average rate of matched in the last 5 minutes, times/second.",
            "summary": "Rate in Last 5min",
            "type": "number"
          }
        },
        "type": "object"
      },
      "exhook.list_hook_info": {
        "properties": {
          "name": {
            "description": "The hook's name",
            "type": "string"
          },
          "params": {
            "description": "The parameters used when the hook is registered",
            "properties": {
              "$name": {
                "type": "string"
              }
            },
            "type": "object"
          },
          "metrics": {
            "description": "Metrics information of this hook in the current node",
            "$ref": "#/components/schemas/exhook.metrics"
          },
          "node_metrics": {
            "description": "Metrics information of this hook in all nodes",
            "items": {
              "$ref": "#/components/schemas/exhook.node_metrics"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "emqx_rule_api_schema.rule_engine": {
        "properties": {
          "ignore_sys_message": {
            "default": true,
            "description": "When set to 'true' (default), rule-engine will ignore messages published to $SYS topics.",
            "summary": "Ignore Sys Message",
            "type": "boolean"
          },
          "jq_function_default_timeout": {
            "default": "10s",
            "description": "Default timeout for the `jq` rule engine function",
            "example": "32s",
            "summary": "Rule engine jq function default timeout",
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge_redis.post_cluster": {
        "required": [
          "command_template",
          "name",
          "servers",
          "type"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to Redis. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "command_template": {
            "description": "Redis command template used to export messages. Each list element stands for a command name or its argument.<br/>For example, to push payloads in a Redis list by key `msgs`, the elements should be the following:<br/>`rpush`, `msgs`, `${payload}`.",
            "items": {
              "type": "string"
            },
            "summary": "Redis Command Template",
            "type": "array"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/bridge_redis.creation_opts_redis_cluster"
          },
          "servers": {
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The Redis default port 6379 is used if `[:Port]` is not specified.",
            "summary": "Servers",
            "type": "string"
          },
          "redis_type": {
            "default": "cluster",
            "description": "Cluster mode. Must be set to 'cluster' when Redis server is running in clustered mode.",
            "enum": [
              "cluster"
            ],
            "summary": "Cluster Mode",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          },
          "type": {
            "description": "The Bridge Type",
            "enum": [
              "redis_cluster"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name, used as a human-readable description of the bridge.",
            "summary": "Bridge Name",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api_listeners.udp_listener": {
        "properties": {
          "id": {
            "description": "Listener ID",
            "type": "string"
          },
          "type": {
            "description": "Listener Type",
            "enum": [
              "udp"
            ],
            "type": "string"
          },
          "name": {
            "description": "Listener Name",
            "type": "string"
          },
          "running": {
            "description": "Listener Running status",
            "type": "boolean"
          },
          "udp_options": {
            "$ref": "#/components/schemas/gateway.udp_opts"
          },
          "enable": {
            "default": true,
            "description": "Enable the listener.",
            "type": "boolean"
          },
          "bind": {
            "description": "The IP address and port that the listener will bind.",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "max_connections": {
            "default": 1024,
            "description": "Maximum number of concurrent connections.",
            "type": "integer"
          },
          "max_conn_rate": {
            "default": 1000,
            "description": "Maximum connections per second.",
            "type": "integer"
          },
          "enable_authn": {
            "default": true,
            "description": "Set <code>true</code> (default) to enable client authentication on this listener. <br/>When set to <code>false</code> clients will be allowed to connect without authentication.",
            "type": "boolean"
          },
          "mountpoint": {
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message is delivered to the subscriber.<br/>The mountpoint is a way that users can use to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,<br/>then the client actually subscribes to the topic `some_tenant/t`.<br/>Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,<br/>the message is routed to all the clients subscribed `some_tenant/t`,<br/>so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.<br/>Variables in mountpoint string:<br/><br/>  - <code>${clientid}</code>: clientid<br/><br/>  - <code>${username}</code>: username",
            "type": "string"
          },
          "access_rules": {
            "default": "",
            "description": "The access control rules for this listener.<br/>See: https://github.com/emqtt/esockd#allowdeny",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "status": {
            "description": "listener status",
            "$ref": "#/components/schemas/listeners.status"
          },
          "node_status": {
            "description": "listener status of each node in the cluster",
            "items": {
              "$ref": "#/components/schemas/listeners.node_status"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_mnesia.rule_item": {
        "required": [
          "action",
          "permission",
          "topic"
        ],
        "properties": {
          "topic": {
            "description": "Rule on specific topic",
            "example": "test/topic/1",
            "summary": "topic",
            "type": "string"
          },
          "permission": {
            "description": "Permission",
            "enum": [
              "allow",
              "deny"
            ],
            "example": "allow",
            "summary": "permission",
            "type": "string"
          },
          "action": {
            "description": "Authorized action (pub/sub/all)",
            "enum": [
              "publish",
              "subscribe",
              "all"
            ],
            "example": "publish",
            "summary": "action",
            "type": "string"
          }
        },
        "type": "object"
      },
      "authn-jwt.jwks": {
        "required": [
          "endpoint",
          "mechanism",
          "use_jwks"
        ],
        "properties": {
          "use_jwks": {
            "description": "Whether to use JWKS.",
            "enum": [
              true
            ],
            "summary": "Whether to Use JWKS",
            "type": "string"
          },
          "endpoint": {
            "description": "JWKS endpoint, it's a read-only endpoint that returns the server's public key set in the JWKS format.",
            "summary": "JWKS Endpoint",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "refresh_interval": {
            "default": 300,
            "description": "JWKS refresh interval.",
            "summary": "JWKS Refresh Interval",
            "type": "integer"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL options.",
            "summary": "SSL Options",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          },
          "mechanism": {
            "description": "Authentication mechanism.",
            "enum": [
              "jwt"
            ],
            "summary": "Authentication Mechanism",
            "type": "string"
          },
          "acl_claim_name": {
            "default": "acl",
            "description": "JWT claim name to use for getting ACL rules.",
            "summary": "ACL claim name",
            "type": "string"
          },
          "verify_claims": {
            "default": {},
            "description": "A list of custom claims to validate, which is a list of name/value pairs.<br/>Values can use the following placeholders:<br/>- <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting<br/>- <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting<br/>Authentication will verify that the value of claims in the JWT (taken from the Password field) matches what is required in <code>verify_claims</code>.",
            "items": {
              "example": "any",
              "type": "string"
            },
            "summary": "Verify Claims",
            "type": "array"
          },
          "from": {
            "default": "password",
            "description": "Field to take JWT from.",
            "enum": [
              "username",
              "password"
            ],
            "summary": "From Field",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
            "summary": "Enable",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "trace.trace": {
        "required": [
          "name",
          "type"
        ],
        "properties": {
          "name": {
            "description": "Unique and format by [a-zA-Z0-9-_]",
            "example": "EMQX-TRACE-1",
            "type": "string"
          },
          "type": {
            "description": "Filter type",
            "enum": [
              "clientid",
              "topic",
              "ip_address"
            ],
            "example": "clientid",
            "type": "string"
          },
          "topic": {
            "description": "support mqtt wildcard topic.",
            "example": "/dev/#",
            "type": "string"
          },
          "clientid": {
            "description": "mqtt clientid.",
            "example": "dev-001",
            "type": "string"
          },
          "ip_address": {
            "description": "client ip address",
            "example": "127.0.0.1",
            "type": "string"
          },
          "status": {
            "description": "trace status",
            "enum": [
              "running",
              "stopped",
              "waiting"
            ],
            "example": "running",
            "type": "string"
          },
          "payload_encode": {
            "default": "text",
            "description": "Determine the format of the payload format in the trace file.<br/><br/>`text`: Text-based protocol or plain text protocol.<br/> It is recommended when payload is JSON encoded.<br/><br/>`hex`: Binary hexadecimal encode.It is recommended when payload is a custom binary protocol.<br/><br/>`hidden`: payload is obfuscated as `******`",
            "enum": [
              "hex",
              "text",
              "hidden"
            ],
            "type": "string"
          },
          "start_at": {
            "description": "rfc3339 timestamp or epoch second",
            "example": "2021-11-04T18:17:38+08:00",
            "oneOf": [
              {
                "description": "epoch-second",
                "example": 1640995200,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "end_at": {
            "description": "rfc3339 timestamp or epoch second",
            "example": "2021-11-05T18:17:38+08:00",
            "oneOf": [
              {
                "description": "epoch-second",
                "example": 1640995200,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "log_size": {
            "description": "trace log size",
            "example": [
              {
                "node": "emqx@127.0.0.1",
                "size": 1024
              }
            ],
            "items": {
              "example": {},
              "type": "object"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "gateway.udp_opts": {
        "properties": {
          "active_n": {
            "default": 100,
            "description": "Specify the {active, N} option for the socket.<br/>See: https://erlang.org/doc/man/inet.html#setopts-2",
            "type": "integer"
          },
          "recbuf": {
            "description": "Size of the kernel-space receive buffer for the socket.",
            "example": "32MB",
            "type": "string"
          },
          "sndbuf": {
            "description": "Size of the kernel-space send buffer for the socket.",
            "example": "32MB",
            "type": "string"
          },
          "buffer": {
            "description": "Size of the user-space buffer for the socket.",
            "example": "32MB",
            "type": "string"
          },
          "reuseaddr": {
            "default": true,
            "description": "Allow local reuse of port numbers.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.coap": {
        "properties": {
          "name": {
            "description": "Gateway Name",
            "enum": [
              "coap"
            ],
            "type": "string"
          },
          "heartbeat": {
            "default": "30s",
            "description": "The gateway server required minimum heartbeat interval.<br/>When connection mode is enabled, this parameter is used to set the minimum heartbeat interval for the connection to be alive",
            "example": "12m",
            "type": "string"
          },
          "connection_required": {
            "default": false,
            "description": "Enable or disable connection mode.<br/>Connection mode is a feature of non-standard protocols. When connection mode is enabled, it is necessary to maintain the creation, authentication and alive of connection resources",
            "type": "boolean"
          },
          "notify_type": {
            "default": "qos",
            "description": "The Notification Message will be delivered to the CoAP client if a new message received on an observed topic.<br/>The type of delivered coap message can be set to:<br/><br/>  - non: Non-confirmable;<br/><br/>  - con: Confirmable;<br/><br/>  - qos: Mapping from QoS type of received message, QoS0 -> non, QoS1,2 -> con",
            "enum": [
              "non",
              "con",
              "qos"
            ],
            "type": "string"
          },
          "subscribe_qos": {
            "default": "coap",
            "description": "The Default QoS Level indicator for subscribe request.<br/>This option specifies the QoS level for the CoAP Client when establishing a subscription membership, if the subscribe request is not carried `qos` option. The indicator can be set to:<br/><br/>  - qos0, qos1, qos2: Fixed default QoS level<br/><br/>  - coap: Dynamic QoS level by the message type of subscribe request<br/><br/>    * qos0: If the subscribe request is non-confirmable<br/><br/>    * qos1: If the subscribe request is confirmable",
            "enum": [
              "qos0",
              "qos1",
              "qos2",
              "coap"
            ],
            "type": "string"
          },
          "publish_qos": {
            "default": "coap",
            "description": "The Default QoS Level indicator for publish request.<br/>This option specifies the QoS level for the CoAP Client when publishing a message to EMQX PUB/SUB system, if the publish request is not carried `qos` option. The indicator can be set to:<br/><br/>  - qos0, qos1, qos2: Fixed default QoS level<br/><br/>  - coap: Dynamic QoS level by the message type of publish request<br/><br/>    * qos0: If the publish request is non-confirmable<br/><br/>    * qos1: If the publish request is confirmable",
            "enum": [
              "qos0",
              "qos1",
              "qos2",
              "coap"
            ],
            "type": "string"
          },
          "mountpoint": {
            "default": "",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message is delivered to the subscriber.<br/>The mountpoint is a way that users can use to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,<br/>then the client actually subscribes to the topic `some_tenant/t`.<br/>Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,<br/>the message is routed to all the clients subscribed `some_tenant/t`,<br/>so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.<br/>Variables in mountpoint string:<br/><br/>  - <code>${clientid}</code>: clientid<br/><br/>  - <code>${username}</code>: username",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Whether to enable this gateway",
            "type": "boolean"
          },
          "enable_stats": {
            "default": true,
            "description": "Whether to enable client process statistic",
            "type": "boolean"
          },
          "idle_timeout": {
            "default": "30s",
            "description": "The idle time of the client connection process. It has two purposes:<br/>  1. A newly created client process that does not receive any client requests after that time will be closed directly.<br/>  2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.",
            "example": "12m",
            "type": "string"
          },
          "clientinfo_override": {
            "description": "ClientInfo override.",
            "$ref": "#/components/schemas/gateway.clientinfo_override"
          },
          "listeners": {
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/emqx_gateway_api.dtls_listener"
                },
                {
                  "$ref": "#/components/schemas/emqx_gateway_api.udp_listener"
                }
              ]
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "limiter.bucket_limit": {
        "properties": {
          "rate": {
            "default": "1000/s",
            "description": "Rate for this bucket.",
            "example": "10MB",
            "summary": "Rate",
            "type": "string"
          },
          "capacity": {
            "default": "1000",
            "description": "The capacity of this token bucket.",
            "example": "100MB",
            "summary": "Capacity",
            "type": "string"
          },
          "initial": {
            "default": "0",
            "description": "The initial number of tokens for this bucket.",
            "example": "0MB",
            "summary": "Initial",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_authn_schema.node_error": {
        "properties": {
          "node": {
            "description": "Node name.",
            "example": "emqx@127.0.0.1",
            "summary": "Node Name.",
            "type": "string"
          },
          "error": {
            "description": "The error of node.",
            "summary": "Error in Node",
            "type": "string"
          }
        },
        "type": "object"
      },
      "authn-mongodb.standalone": {
        "required": [
          "backend",
          "collection",
          "database",
          "mechanism",
          "server"
        ],
        "properties": {
          "mechanism": {
            "description": "Authentication mechanism.",
            "enum": [
              "password_based"
            ],
            "summary": "Authentication Mechanism",
            "type": "string"
          },
          "backend": {
            "description": "Backend type.",
            "enum": [
              "mongodb"
            ],
            "summary": "Backend Type",
            "type": "string"
          },
          "collection": {
            "description": "Collection used to store authentication data.",
            "summary": "Collection",
            "type": "string"
          },
          "filter": {
            "default": {},
            "description": "Conditional expression that defines the filter condition in the query.<br/>Filter supports the following placeholders:<br/>- <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting<br/>- <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting",
            "example": {},
            "summary": "Filter",
            "type": "object"
          },
          "password_hash_field": {
            "default": "password_hash",
            "description": "Document field that contains password hash.",
            "summary": "Password Hash Field",
            "type": "string"
          },
          "salt_field": {
            "default": "salt",
            "description": "Document field that contains the password salt.",
            "summary": "Salt Field",
            "type": "string"
          },
          "is_superuser_field": {
            "default": "is_superuser",
            "description": "Document field that defines if the user has superuser privileges.",
            "summary": "Is Superuser Field",
            "type": "string"
          },
          "password_hash_algorithm": {
            "default": {
              "name": "sha256",
              "salt_position": "prefix"
            },
            "description": "Options for password hash verification.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn-hash.simple"
              },
              {
                "$ref": "#/components/schemas/authn-hash.pbkdf2"
              },
              {
                "$ref": "#/components/schemas/authn-hash.bcrypt"
              }
            ]
          },
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
            "summary": "Enable",
            "type": "boolean"
          },
          "mongo_type": {
            "default": "single",
            "description": "Standalone instance. Must be set to 'single' when MongoDB server is running in standalone mode.",
            "enum": [
              "single"
            ],
            "summary": "Standalone instance",
            "type": "string"
          },
          "server": {
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The MongoDB default port 27017 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "w_mode": {
            "default": "unsafe",
            "description": "Write mode.",
            "enum": [
              "unsafe",
              "safe"
            ],
            "summary": "Write Mode",
            "type": "string"
          },
          "srv_record": {
            "default": false,
            "description": "Use DNS SRV record.",
            "summary": "Srv Record",
            "type": "boolean"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auth_source": {
            "description": "Database name associated with the user's credentials.",
            "summary": "Auth Source",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "topology": {
            "$ref": "#/components/schemas/emqx_connector_mongo.topology"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api_listeners.dtls_listener": {
        "properties": {
          "id": {
            "description": "Listener ID",
            "type": "string"
          },
          "type": {
            "description": "Listener Type",
            "enum": [
              "dtls"
            ],
            "type": "string"
          },
          "name": {
            "description": "Listener Name",
            "type": "string"
          },
          "running": {
            "description": "Listener Running status",
            "type": "boolean"
          },
          "acceptors": {
            "default": 16,
            "description": "Size of the acceptor pool.",
            "type": "integer"
          },
          "udp_options": {
            "$ref": "#/components/schemas/gateway.udp_opts"
          },
          "enable": {
            "default": true,
            "description": "Enable the listener.",
            "type": "boolean"
          },
          "bind": {
            "description": "The IP address and port that the listener will bind.",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "max_connections": {
            "default": 1024,
            "description": "Maximum number of concurrent connections.",
            "type": "integer"
          },
          "max_conn_rate": {
            "default": 1000,
            "description": "Maximum connections per second.",
            "type": "integer"
          },
          "enable_authn": {
            "default": true,
            "description": "Set <code>true</code> (default) to enable client authentication on this listener. <br/>When set to <code>false</code> clients will be allowed to connect without authentication.",
            "type": "boolean"
          },
          "mountpoint": {
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message is delivered to the subscriber.<br/>The mountpoint is a way that users can use to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,<br/>then the client actually subscribes to the topic `some_tenant/t`.<br/>Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,<br/>the message is routed to all the clients subscribed `some_tenant/t`,<br/>so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.<br/>Variables in mountpoint string:<br/><br/>  - <code>${clientid}</code>: clientid<br/><br/>  - <code>${username}</code>: username",
            "type": "string"
          },
          "access_rules": {
            "default": "",
            "description": "The access control rules for this listener.<br/>See: https://github.com/emqtt/esockd#allowdeny",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "dtls_options": {
            "description": "DTLS socket options",
            "$ref": "#/components/schemas/gateway.dtls_opts"
          },
          "status": {
            "description": "listener status",
            "$ref": "#/components/schemas/listeners.status"
          },
          "node_status": {
            "description": "listener status of each node in the cluster",
            "items": {
              "$ref": "#/components/schemas/listeners.node_status"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "emqx_rule_api_schema.ctx_connack": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "description": "Event Type",
            "enum": [
              "client_connack"
            ],
            "summary": "Event Type",
            "type": "string"
          },
          "reason_code": {
            "description": "The reason code",
            "summary": "Reason Code",
            "type": "string"
          },
          "clientid": {
            "description": "The Client ID",
            "summary": "Client ID",
            "type": "string"
          },
          "clean_start": {
            "default": true,
            "description": "Clean Start",
            "summary": "Clean Start",
            "type": "boolean"
          },
          "username": {
            "description": "Username",
            "summary": "Username",
            "type": "string"
          },
          "peername": {
            "description": "The IP Address and Port of the Peer Client",
            "summary": "IP Address And Port",
            "type": "string"
          },
          "sockname": {
            "description": "The IP Address and Port of the Local Listener",
            "summary": "IP Address And Port",
            "type": "string"
          },
          "proto_name": {
            "description": "Protocol Name",
            "summary": "Protocol Name",
            "type": "string"
          },
          "proto_ver": {
            "description": "Protocol Version",
            "summary": "Protocol Version",
            "type": "string"
          },
          "keepalive": {
            "description": "KeepAlive",
            "summary": "KeepAlive",
            "type": "integer"
          },
          "expiry_interval": {
            "description": "Expiry Interval",
            "summary": "Expiry Interval",
            "type": "integer"
          },
          "connected_at": {
            "description": "The Time that this Client is Connected",
            "summary": "Connected Time",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_schema.redis_single": {
        "required": [
          "cmd",
          "server",
          "type"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this ACL provider.",
            "summary": "enable",
            "type": "boolean"
          },
          "type": {
            "default": "redis",
            "description": "Backend type.",
            "enum": [
              "redis"
            ],
            "summary": "type",
            "type": "string"
          },
          "cmd": {
            "description": "Database query used to retrieve authorization data.",
            "example": "HGETALL mqtt_authz",
            "summary": "cmd",
            "type": "string"
          },
          "server": {
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The Redis default port 6379 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "redis_type": {
            "default": "single",
            "description": "Single mode. Must be set to 'single' when Redis server is running in single mode.",
            "enum": [
              "single"
            ],
            "summary": "Single Mode",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "database": {
            "default": 0,
            "description": "Redis database ID.",
            "summary": "Database ID",
            "type": "integer"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "prometheus.prometheus": {
        "required": [
          "enable",
          "interval",
          "job_name",
          "push_gateway_server"
        ],
        "properties": {
          "push_gateway_server": {
            "default": "http://127.0.0.1:9091",
            "description": "URL of Prometheus server",
            "type": "string"
          },
          "interval": {
            "default": "15s",
            "description": "Data reporting interval",
            "example": "32s",
            "type": "string"
          },
          "headers": {
            "default": {},
            "description": "A list of HTTP Headers when pushing to Push Gateway.<br/><br/>For example, <code> { Authorization = \"some-authz-tokens\"}</code>",
            "items": {
              "example": {},
              "type": "object"
            },
            "type": "array"
          },
          "job_name": {
            "default": "${name}/instance/${name}~${host}",
            "description": "Job Name that is pushed to the Push Gateway. Available variables:<br/><br/>- ${name}: Name of EMQX node.<br/><br/>- ${host}: Host name of EMQX node.<br/><br/>For example, when the EMQX node name is <code>emqx@127.0.0.1</code> then the <code>name</code> variable takes value <code>emqx</code> and the <code>host</code> variable takes value <code>127.0.0.1</code>.<br/><br/>Default value is: <code>${name}/instance/${name}~${host}</code>",
            "type": "string"
          },
          "enable": {
            "default": false,
            "description": "Turn Prometheus data pushing on or off",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "authz.metrics": {
        "properties": {
          "total": {
            "description": "The total number of times the authorization rule was triggered.",
            "summary": "The Total Number of Times the Authorization Rule was Triggered",
            "type": "integer"
          },
          "allow": {
            "description": "The number of times the authentication was successful.",
            "summary": "The Number of Times the Authentication was Successful",
            "type": "integer"
          },
          "deny": {
            "description": "The number of authentication failures.",
            "summary": "The Number of Authentication Failures",
            "type": "integer"
          },
          "nomatch": {
            "description": "The number of times that no authorization rules were matched.",
            "summary": "The Number of Times that no Authorization Rules were Matched",
            "type": "number"
          },
          "rate": {
            "description": "The rate of matched, times/second.",
            "summary": "Rate",
            "type": "number"
          },
          "rate_max": {
            "description": "The max rate of matched, times/second.",
            "summary": "Max Rate",
            "type": "number"
          },
          "rate_last5m": {
            "description": "The average rate of matched in the last 5 minutes, times/second.",
            "summary": "Rate in Last 5min",
            "type": "number"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.mqttsn": {
        "required": [
          "gateway_id"
        ],
        "properties": {
          "name": {
            "description": "Gateway Name",
            "enum": [
              "mqttsn"
            ],
            "type": "string"
          },
          "gateway_id": {
            "default": 1,
            "description": "MQTT-SN Gateway ID.<br/>When the <code>broadcast</code> option is enabled, the gateway will broadcast ADVERTISE message with this value",
            "type": "integer"
          },
          "broadcast": {
            "default": false,
            "description": "Whether to periodically broadcast ADVERTISE messages",
            "type": "boolean"
          },
          "enable_qos3": {
            "default": true,
            "description": "Allows connectionless clients to publish messages with a Qos of -1.<br/>This feature is defined for very simple client implementations which do not support any other features except this one. There is no connection setup nor tear down, no registration nor subscription. The client just sends its 'PUBLISH' messages to a GW",
            "type": "boolean"
          },
          "subs_resume": {
            "default": false,
            "description": "Whether to initiate all subscribed topic name registration messages to the client after the Session has been taken over by a new channel",
            "type": "boolean"
          },
          "predefined": {
            "default": "",
            "description": "The pre-defined topic IDs and topic names.<br/>A 'pre-defined' topic ID is a topic ID whose mapping to a topic name is known in advance by both the client's application and the gateway",
            "items": {
              "$ref": "#/components/schemas/emqx_mqttsn_schema.mqttsn_predefined"
            },
            "type": "array"
          },
          "mountpoint": {
            "default": "",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message is delivered to the subscriber.<br/>The mountpoint is a way that users can use to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,<br/>then the client actually subscribes to the topic `some_tenant/t`.<br/>Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,<br/>the message is routed to all the clients subscribed `some_tenant/t`,<br/>so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.<br/>Variables in mountpoint string:<br/><br/>  - <code>${clientid}</code>: clientid<br/><br/>  - <code>${username}</code>: username",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Whether to enable this gateway",
            "type": "boolean"
          },
          "enable_stats": {
            "default": true,
            "description": "Whether to enable client process statistic",
            "type": "boolean"
          },
          "idle_timeout": {
            "default": "30s",
            "description": "The idle time of the client connection process. It has two purposes:<br/>  1. A newly created client process that does not receive any client requests after that time will be closed directly.<br/>  2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.",
            "example": "12m",
            "type": "string"
          },
          "clientinfo_override": {
            "description": "ClientInfo override.",
            "$ref": "#/components/schemas/gateway.clientinfo_override"
          },
          "listeners": {
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/emqx_gateway_api.dtls_listener"
                },
                {
                  "$ref": "#/components/schemas/emqx_gateway_api.udp_listener"
                }
              ]
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "rule_engine.builtin_action_console": {
        "properties": {
          "function": {
            "description": "Print the actions to the console",
            "enum": [
              "console"
            ],
            "summary": "Console Function",
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge_mqtt.put": {
        "required": [
          "server"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/bridge_mqtt.creation_opts"
          },
          "mode": {
            "default": "cluster_shareload",
            "description": "The mode of the MQTT Bridge.<br/><br/>- cluster_shareload: create an MQTT connection on each node in the emqx cluster.<br/><br/>In 'cluster_shareload' mode, the incoming load from the remote broker is shared by<br/>using shared subscription.<br/><br/>Note that the 'clientid' is suffixed by the node name, this is to avoid<br/>clientid conflicts between different nodes. And we can only use shared subscription<br/>topic filters for <code>remote.topic</code> of ingress connections.",
            "enum": [
              "cluster_shareload"
            ],
            "summary": "MQTT Bridge Mode",
            "type": "string"
          },
          "server": {
            "description": "The host and port of the remote MQTT broker",
            "summary": "Broker IP And Port",
            "type": "string"
          },
          "clientid_prefix": {
            "description": "Optional prefix to prepend to the clientid used by egress bridges.",
            "summary": "Clientid Prefix",
            "type": "string"
          },
          "reconnect_interval": {
            "deprecated": true,
            "type": "string"
          },
          "proto_ver": {
            "default": "v4",
            "description": "The MQTT protocol version",
            "enum": [
              "v3",
              "v4",
              "v5"
            ],
            "summary": "Protocol Version",
            "type": "string"
          },
          "bridge_mode": {
            "default": false,
            "description": "If enable bridge mode.<br/>NOTE: This setting is only for MQTT protocol version older than 5.0, and the remote MQTT<br/>broker MUST support this feature.<br/>If bridge_mode is set to true, the bridge will indicate to the remote broker that it is a bridge not an ordinary client.<br/>This means that loop detection will be more effective and that retained messages will be propagated correctly.",
            "summary": "Bridge Mode",
            "type": "boolean"
          },
          "username": {
            "description": "The username of the MQTT protocol",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "The password of the MQTT protocol",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "clean_start": {
            "default": true,
            "description": "Whether to start a clean session when reconnecting a remote broker for ingress bridge",
            "summary": "Clean Session",
            "type": "boolean"
          },
          "keepalive": {
            "default": "300s",
            "description": "MQTT Keepalive. Time interval is a string that contains a number followed by time unit:<br/>- `ms` for milliseconds,<br/>- `s` for seconds,<br/>- `m` for minutes,<br/>- `h` for hours;<br/><br/>or combination of whereof: `1h5m0s`",
            "type": "string"
          },
          "retry_interval": {
            "default": "15s",
            "description": "Message retry interval. Delay for the MQTT bridge to retry sending the QoS1/QoS2 messages in case of ACK not received. Time interval is a string that contains a number followed by time unit:<br/>- `ms` for milliseconds,<br/>- `s` for seconds,<br/>- `m` for minutes,<br/>- `h` for hours;<br/><br/>or combination of whereof: `1h5m0s`",
            "type": "string"
          },
          "max_inflight": {
            "default": 32,
            "description": "Max inflight (sent, but un-acked) messages of the MQTT protocol",
            "minimum": 0,
            "summary": "Max Inflight Message",
            "type": "integer"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          },
          "ingress": {
            "description": "The ingress config defines how this bridge receive messages from the remote MQTT broker, and then<br/>        send them to the local broker.<br/><br/>        Template with variables is allowed in 'remote.qos', 'local.topic', 'local.qos', 'local.retain', 'local.payload'.<br/><br/>        NOTE: if this bridge is used as the input of a rule, and also 'local.topic' is<br/>        configured, then messages got from the remote broker will be sent to both the 'local.topic' and<br/>        the rule.",
            "summary": "Ingress Configs",
            "$ref": "#/components/schemas/connector-mqtt.ingress"
          },
          "egress": {
            "description": "The egress config defines how this bridge forwards messages from the local broker to the remote broker.<br/><br/>Template with variables is allowed in 'remote.topic', 'local.qos', 'local.retain', 'local.payload'.<br/><br/>NOTE: if this bridge is used as the action of a rule, and also 'local.topic'<br/>is configured, then both the data got from the rule and the MQTT messages that matches<br/>'local.topic' will be forwarded.",
            "summary": "Egress Configs",
            "$ref": "#/components/schemas/connector-mqtt.egress"
          }
        },
        "type": "object"
      },
      "authn-hash.bcrypt": {
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "description": "BCRYPT password hashing.",
            "enum": [
              "bcrypt"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "exhook.ssl_conf": {
        "properties": {
          "cacertfile": {
            "description": "Trusted PEM format CA certificates bundle file.<br/><br/>The certificates in this file are used to verify the TLS peer's certificates.<br/>Append new certificates to the file if new CAs are to be trusted.<br/>There is no need to restart EMQX to have the updated file loaded, because<br/>the system regularly checks if file has been updated (and reload).<br/><br/>NOTE: invalidating (deleting) a certificate from the file will not affect<br/>already established connections.",
            "summary": "CACertfile",
            "type": "string"
          },
          "certfile": {
            "description": "PEM format certificates chain file.<br/><br/>The certificates in this file should be in reversed order of the certificate<br/>issue chain. That is, the host's certificate should be placed in the beginning<br/>of the file, followed by the immediate issuer certificate and so on.<br/>Although the root CA certificate is optional, it should be placed at the end of<br/>the file if it is to be added.",
            "summary": "Certfile",
            "type": "string"
          },
          "keyfile": {
            "description": "PEM format private key file.",
            "summary": "Keyfile",
            "type": "string"
          },
          "verify": {
            "default": "verify_none",
            "description": "Enable or disable peer verification.",
            "enum": [
              "verify_peer",
              "verify_none"
            ],
            "summary": "Verify peer",
            "type": "string"
          },
          "reuse_sessions": {
            "default": true,
            "description": "Enable TLS session reuse.",
            "summary": "TLS session reuse",
            "type": "boolean"
          },
          "depth": {
            "default": 10,
            "description": "Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path.<br/>So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly;<br/><br/>if 1 the path can be PEER, Intermediate-CA, ROOT-CA;<br/><br/>if 2 the path can be PEER, Intermediate-CA1, Intermediate-CA2, ROOT-CA.",
            "summary": "CACert Depth",
            "type": "integer"
          },
          "password": {
            "description": "String containing the user's password. Only used if the private key file is password-protected.",
            "example": "",
            "format": "password",
            "summary": "Keyfile passphrase",
            "type": "string"
          },
          "versions": {
            "default": [
              "tlsv1.3",
              "tlsv1.2",
              "tlsv1.1",
              "tlsv1"
            ],
            "description": "All TLS/DTLS versions to be supported.<br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.<br/><br/>In case PSK cipher suites are intended, make sure to configure<br/><code>['tlsv1.2', 'tlsv1.1']</code> here.",
            "items": {
              "type": "string"
            },
            "summary": "SSL versions",
            "type": "array"
          },
          "ciphers": {
            "default": "",
            "description": "This config holds TLS cipher suite names separated by comma,<br/>or as an array of strings. e.g.<br/><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or<br/><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.<br/><br/><br/>Ciphers (and their ordering) define the way in which the<br/>client and server encrypts information over the network connection.<br/>Selecting a good cipher suite is critical for the<br/>application's data security, confidentiality and performance.<br/><br/>The names should be in OpenSSL string format (not RFC format).<br/>All default values and examples provided by EMQX config<br/>documentation are all in OpenSSL format.<br/><br/><br/>NOTE: Certain cipher suites are only compatible with<br/>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')<br/>incompatible cipher suites will be silently dropped.<br/>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,<br/>configuring cipher suites for other versions will have no effect.<br/><br/><br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br/><br/>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.<br/><br/>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,<br/>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,<br/>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,<br/>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code>",
            "items": {
              "type": "string"
            },
            "summary": "",
            "type": "array"
          },
          "secure_renegotiate": {
            "default": true,
            "description": "SSL parameter renegotiation is a feature that allows a client and a server<br/>to renegotiate the parameters of the SSL connection on the fly.<br/>RFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,<br/>you drop support for the insecure renegotiation, prone to MitM attacks.",
            "summary": "SSL renegotiate",
            "type": "boolean"
          },
          "hibernate_after": {
            "default": "5s",
            "description": "Hibernate the SSL process after idling for amount of time reducing its memory footprint.",
            "example": "12m",
            "summary": "hibernate after",
            "type": "string"
          },
          "enable": {
            "default": false,
            "description": "Enable TLS.",
            "summary": "Enable TLS.",
            "type": "boolean"
          },
          "server_name_indication": {
            "description": "Specify the host name to be used in TLS Server Name Indication extension.<br/><br/>For instance, when connecting to \"server.example.net\", the genuine server<br/>which accepts the connection and performs TLS handshake may differ from the<br/>host the TLS client initially connects to, e.g. when connecting to an IP address<br/>or when the host has multiple resolvable DNS records <br/><br/>If not specified, it will default to the host name string which is used<br/>to establish the connection, unless it is IP addressed used.<br/><br/>The host name is then also used in the host name verification of the peer<br/>certificate.<br/> The special value 'disable' prevents the Server Name<br/>Indication extension from being sent and disables the hostname<br/>verification check.",
            "example": "disable",
            "summary": "Server Name Indication",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "enum": [
                  "disable"
                ],
                "type": "string"
              }
            ]
          }
        },
        "type": "object"
      },
      "bridge_hstreamdb.get": {
        "required": [
          "connector",
          "name",
          "type"
        ],
        "properties": {
          "status": {
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status.",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary": "Bridge Status",
            "type": "string"
          },
          "status_reason": {
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused",
            "summary": "Failure reason",
            "type": "string"
          },
          "node_status": {
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            },
            "summary": "Node Status",
            "type": "array"
          },
          "type": {
            "description": "The Bridge Type",
            "enum": [
              "hstreamdb"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name, used as a human-readable description of the bridge.",
            "summary": "Bridge Name",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "direction": {
            "default": "egress",
            "description": "The direction of this bridge, MUST be 'egress'",
            "enum": [
              "egress"
            ],
            "summary": "Bridge Direction",
            "type": "string"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to the HStreamDB. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "payload": {
            "default": "${payload}",
            "description": "The payload to be forwarded to the HStreamDB. Placeholders supported.",
            "summary": "Payload",
            "type": "string"
          },
          "connector": {
            "description": "Generic configuration for the connector.",
            "example": "hstreamdb:demo",
            "summary": "Connector Generic Configuration",
            "oneOf": [
              {
                "$ref": "#/components/schemas/connector_hstreamdb.config"
              },
              {
                "type": "string"
              }
            ]
          }
        },
        "type": "object"
      },
      "lwm2m.resource": {
        "properties": {
          "operations": {
            "description": "Resource Operations",
            "example": "E",
            "type": "string"
          },
          "dataType": {
            "description": "Data Type",
            "enum": [
              "Integer",
              "Float",
              "Time",
              "String",
              "Boolean",
              "Opaque",
              "Objlnk"
            ],
            "example": "Integer",
            "type": "string"
          },
          "path": {
            "description": "Resource Path",
            "example": "urn:oma:lwm2m:oma:2",
            "type": "string"
          },
          "name": {
            "description": "Resource Name",
            "example": "lwm2m-test",
            "type": "string"
          }
        },
        "type": "object"
      },
      "listeners.ssl_required_bind": {
        "required": [
          "bind",
          "id",
          "type"
        ],
        "properties": {
          "type": {
            "description": "Listener type",
            "enum": [
              "ssl"
            ],
            "type": "string"
          },
          "running": {
            "description": "Listener status",
            "type": "boolean"
          },
          "id": {
            "description": "Listener id",
            "type": "string"
          },
          "current_connections": {
            "description": "Current connections",
            "minimum": 0,
            "type": "integer"
          },
          "enabled": {
            "default": true,
            "description": "Enable listener.",
            "summary": "Enable listener",
            "type": "boolean"
          },
          "bind": {
            "default": 8883,
            "description": "IP address and port for the listening socket.",
            "summary": "IP address and port",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "acceptors": {
            "default": 16,
            "description": "The size of the listener's receiving pool.",
            "minimum": 1,
            "summary": "Acceptors Num",
            "type": "integer"
          },
          "max_connections": {
            "default": 5000000,
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "summary": "Max connections",
            "oneOf": [
              {
                "minimum": 1,
                "type": "integer"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message<br/>is delivered to the subscriber. The mountpoint is a way that users can use<br/>to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`<br/>set to `some_tenant`, then the client actually subscribes to the topic<br/>`some_tenant/t`. Similarly, if another client B (connected to the same listener<br/>as the client A) sends a message to topic `t`, the message is routed<br/>to all the clients subscribed `some_tenant/t`, so client A will receive the<br/>message, with topic name `t`.<br/><br/>Set to `\"\"` to disable the feature.<br/><br/><br/>Variables in mountpoint string:<br/>  - <code>${clientid}</code>: clientid<br/>  - <code>${username}</code>: username",
            "summary": "mountpoint",
            "type": "string"
          },
          "zone": {
            "default": "default",
            "description": "The configuration zone to which the listener belongs.",
            "summary": "Zone",
            "type": "string"
          },
          "limiter": {
            "description": "Type of the rate limit.",
            "summary": "Type of the rate limit.",
            "$ref": "#/components/schemas/limiter.listener_fields"
          },
          "enable_authn": {
            "default": true,
            "description": "Set <code>true</code> (default) to enable client authentication on this listener, the authentication<br/>process goes through the configured authentication chain.<br/>When set to <code>false</code> to allow any clients with or without authentication information such as username or password to log in.<br/>When set to <code>quick_deny_anonymous</code>, it behaves like when set to <code>true</code>, but clients will be<br/>denied immediately without going through any authenticators if <code>username</code> is not provided. This is useful to fence off<br/>anonymous clients early.",
            "enum": [
              true,
              false,
              "quick_deny_anonymous"
            ],
            "summary": "Enable authentication",
            "type": "string"
          },
          "access_rules": {
            "default": [
              "allow all"
            ],
            "description": "The access control rules for this listener.<br/>See: https://github.com/emqtt/esockd#allowdeny",
            "items": {
              "type": "string"
            },
            "summary": "Access rules",
            "type": "array"
          },
          "proxy_protocol": {
            "default": false,
            "description": "Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.<br/><br/>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/",
            "summary": "Proxy protocol",
            "type": "boolean"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "description": "Timeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.",
            "example": "12m",
            "summary": "Proxy protocol timeout",
            "type": "string"
          },
          "tcp_options": {
            "$ref": "#/components/schemas/broker.tcp_opts"
          },
          "ssl_options": {
            "$ref": "#/components/schemas/broker.listener_ssl_opts"
          }
        },
        "type": "object"
      },
      "retainer.message_summary": {
        "properties": {
          "msgid": {
            "description": "Message ID.",
            "type": "string"
          },
          "topic": {
            "description": "Topic.",
            "type": "string"
          },
          "qos": {
            "description": "QoS.",
            "example": 0,
            "maximum": 2,
            "minimum": 0,
            "type": "integer"
          },
          "publish_at": {
            "description": "Message publish time, RFC 3339 format.",
            "type": "string"
          },
          "from_clientid": {
            "description": "The clientid of publisher.",
            "type": "string"
          },
          "from_username": {
            "description": "The username of publisher.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge_redis.creation_opts_redis_sentinel": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 0,
            "summary": "Buffer Pool Size",
            "type": "integer"
          },
          "health_check_interval": {
            "default": "15s",
            "description": "Health check interval.",
            "example": "32s",
            "summary": "Health Check Interval",
            "type": "string"
          },
          "start_after_created": {
            "default": "true",
            "description": "Whether start the resource right after created.",
            "summary": "Start After Created",
            "type": "boolean"
          },
          "start_timeout": {
            "default": "5s",
            "description": "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "example": "32s",
            "summary": "Start Timeout",
            "type": "string"
          },
          "auto_restart_interval": {
            "default": "60s",
            "description": "The auto restart interval after the resource is disconnected.",
            "summary": "Auto Restart Interval",
            "oneOf": [
              {
                "example": "32s",
                "type": "string"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "query_mode": {
            "default": "async",
            "description": "Query mode. Optional 'sync/async', default 'async'.",
            "enum": [
              "sync",
              "async"
            ],
            "summary": "Query mode",
            "type": "string"
          },
          "request_timeout": {
            "default": "15s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "summary": "Request Expiry",
            "oneOf": [
              {
                "example": "32s",
                "type": "string"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1,
            "summary": "Inflight window",
            "type": "integer"
          },
          "enable_batch": {
            "default": true,
            "deprecated": true,
            "description": "Batch mode enabled.",
            "summary": "Enable batch",
            "type": "boolean"
          },
          "batch_size": {
            "default": 1,
            "description": "Maximum batch count. If equal to 1, there's effectively no batching.",
            "minimum": 1,
            "summary": "Max batch size",
            "type": "integer"
          },
          "batch_time": {
            "default": "0ms",
            "description": "Maximum waiting interval when accumulating a batch at a low message rates for more efficient resource usage.",
            "example": "32s",
            "summary": "Max batch wait time",
            "type": "string"
          },
          "enable_queue": {
            "default": false,
            "deprecated": true,
            "description": "Enable disk buffer queue (only applicable for egress bridges).<br/>When Enabled, messages will be buffered on disk when the bridge connection is down.<br/>When disabled the messages are buffered in RAM only.",
            "summary": "Enable disk buffer queue",
            "type": "boolean"
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB",
            "summary": "Max buffer queue size",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_topics.topic": {
        "required": [
          "node",
          "topic"
        ],
        "properties": {
          "topic": {
            "description": "Topic Name",
            "type": "string"
          },
          "node": {
            "description": "Node",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_rule_api_schema.ctx_connected": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "description": "Event Type",
            "enum": [
              "client_connected"
            ],
            "summary": "Event Type",
            "type": "string"
          },
          "clientid": {
            "description": "The Client ID",
            "summary": "Client ID",
            "type": "string"
          },
          "username": {
            "description": "Username",
            "summary": "Username",
            "type": "string"
          },
          "mountpoint": {
            "description": "The Mountpoint",
            "summary": "Mountpoint",
            "type": "string"
          },
          "peername": {
            "description": "The IP Address and Port of the Peer Client",
            "summary": "IP Address And Port",
            "type": "string"
          },
          "sockname": {
            "description": "The IP Address and Port of the Local Listener",
            "summary": "IP Address And Port",
            "type": "string"
          },
          "proto_name": {
            "description": "Protocol Name",
            "summary": "Protocol Name",
            "type": "string"
          },
          "proto_ver": {
            "description": "Protocol Version",
            "summary": "Protocol Version",
            "type": "string"
          },
          "keepalive": {
            "description": "KeepAlive",
            "summary": "KeepAlive",
            "type": "integer"
          },
          "clean_start": {
            "default": true,
            "description": "Clean Start",
            "summary": "Clean Start",
            "type": "boolean"
          },
          "expiry_interval": {
            "description": "Expiry Interval",
            "summary": "Expiry Interval",
            "type": "integer"
          },
          "is_bridge": {
            "default": false,
            "description": "Is Bridge",
            "summary": "Is Bridge",
            "type": "boolean"
          },
          "connected_at": {
            "description": "The Time that this Client is Connected",
            "summary": "Connected Time",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "bridge_sqlserver.post": {
        "required": [
          "database",
          "name",
          "server",
          "type"
        ],
        "properties": {
          "type": {
            "description": "The Bridge Type",
            "enum": [
              "sqlserver"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name.",
            "summary": "Bridge Name",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "sql": {
            "default": "insert into t_mqtt_msg(msgid, topic, qos, payload) values ( ${id}, ${topic}, ${qos}, ${payload} )",
            "description": "SQL Template",
            "format": "sql",
            "summary": "SQL Template",
            "type": "string"
          },
          "driver": {
            "default": "ms-sql",
            "description": "SQL Server Driver Name",
            "summary": "SQL Server Driver Name",
            "type": "string"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to Microsoft SQL Server. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/bridge_sqlserver.creation_opts"
          },
          "server": {
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The SQL Server default port 1433 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "default": "sa",
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "listeners.listener_id_status": {
        "required": [
          "bind",
          "enable",
          "id",
          "name",
          "type"
        ],
        "properties": {
          "id": {
            "description": "Listener id",
            "example": "tcp:demo",
            "type": "string"
          },
          "type": {
            "description": "Listener type",
            "enum": [
              "tcp",
              "ssl",
              "ws",
              "wss",
              "quic"
            ],
            "type": "string"
          },
          "name": {
            "description": "Listener name",
            "type": "string"
          },
          "enable": {
            "description": "Listener enable",
            "type": "boolean"
          },
          "number": {
            "description": "ListenerId counter",
            "minimum": 1,
            "type": "integer"
          },
          "bind": {
            "description": "Listener bind addr",
            "example": "127.0.0.1:80",
            "type": "string"
          },
          "acceptors": {
            "description": "ListenerId acceptors",
            "minimum": 1,
            "type": "integer"
          },
          "status": {
            "$ref": "#/components/schemas/listeners.status"
          },
          "node_status": {
            "items": {
              "$ref": "#/components/schemas/listeners.node_status"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "bridge_pgsql.get": {
        "required": [
          "database",
          "name",
          "server",
          "type"
        ],
        "properties": {
          "status": {
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status.",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary": "Bridge Status",
            "type": "string"
          },
          "status_reason": {
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused",
            "summary": "Failure reason",
            "type": "string"
          },
          "node_status": {
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            },
            "summary": "Node Status",
            "type": "array"
          },
          "type": {
            "description": "The Bridge Type",
            "enum": [
              "pgsql"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name.",
            "summary": "Bridge Name",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "sql": {
            "default": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
            "description": "SQL Template",
            "format": "sql",
            "summary": "SQL Template",
            "type": "string"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to PostgreSQL. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The PostgreSQL default port 5432 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "emqx_dashboard_monitor_api.sampler_current": {
        "properties": {
          "dropped_msg_rate": {
            "description": "Dropped messages per 10 seconds",
            "type": "integer"
          },
          "received_msg_rate": {
            "description": "Dropped messages per 10 seconds",
            "type": "integer"
          },
          "sent_msg_rate": {
            "description": "Sent messages per 10 seconds",
            "type": "integer"
          },
          "subscriptions": {
            "description": "Subscriptions at the time of sampling. Can only represent the approximate state",
            "type": "integer"
          },
          "topics": {
            "description": "Count topics at the time of sampling. Can only represent the approximate state",
            "type": "integer"
          },
          "connections": {
            "description": "Connections at the time of sampling. Can only represent the approximate state",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "bridge_matrix.get": {
        "required": [
          "database",
          "name",
          "server",
          "type"
        ],
        "properties": {
          "status": {
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status.",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary": "Bridge Status",
            "type": "string"
          },
          "status_reason": {
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused",
            "summary": "Failure reason",
            "type": "string"
          },
          "node_status": {
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            },
            "summary": "Node Status",
            "type": "array"
          },
          "type": {
            "description": "The Bridge Type",
            "enum": [
              "pgsql"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name.",
            "summary": "Bridge Name",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "sql": {
            "default": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
            "description": "SQL Template",
            "format": "sql",
            "summary": "SQL Template",
            "type": "string"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to PostgreSQL. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The PostgreSQL default port 5432 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "emqx_telemetry_api.telemetry": {
        "properties": {
          "emqx_version": {
            "description": "Get emqx version",
            "example": "5.0.0-beta.3-32d1547c",
            "type": "string"
          },
          "license": {
            "description": "Get license information",
            "example": {
              "edition": "opensource"
            },
            "type": "object"
          },
          "os_name": {
            "description": "Get OS name",
            "example": "Linux",
            "type": "string"
          },
          "os_version": {
            "description": "Get OS version",
            "example": "20.04",
            "type": "string"
          },
          "otp_version": {
            "description": "Get Erlang OTP version",
            "example": "24",
            "type": "string"
          },
          "up_time": {
            "description": "Get uptime",
            "example": 20220113,
            "type": "integer"
          },
          "uuid": {
            "description": "Get UUID",
            "example": "AAAAAAAA-BBBB-CCCC-2022-DDDDEEEEFFF",
            "type": "string"
          },
          "nodes_uuid": {
            "description": "Get nodes UUID",
            "example": [
              "AAAAAAAA-BBBB-CCCC-2022-DDDDEEEEFFF",
              "ZZZZZZZZ-CCCC-BBBB-2022-DDDDEEEEFFF"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "active_plugins": {
            "description": "Get active plugins",
            "example": [
              "Plugin A",
              "Plugin B"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "active_modules": {
            "description": "Get active modules",
            "example": [
              "Module A",
              "Module B"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "num_clients": {
            "description": "Get number of clients",
            "example": 20220113,
            "type": "integer"
          },
          "messages_received": {
            "description": "Get number of messages received",
            "example": 2022,
            "type": "integer"
          },
          "messages_sent": {
            "description": "Get number of messages sent",
            "example": 2022,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "listeners.node_status": {
        "properties": {
          "node": {
            "description": "Node name",
            "example": "emqx@127.0.0.1",
            "type": "string"
          },
          "status": {
            "$ref": "#/components/schemas/listeners.status"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_clients.client": {
        "properties": {
          "awaiting_rel_cnt": {
            "description": "v4 api name [awaiting_rel] Number of awaiting PUBREC packet",
            "type": "integer"
          },
          "awaiting_rel_max": {
            "description": "v4 api name [max_awaiting_rel]. Maximum allowed number of awaiting PUBREC packet",
            "type": "integer"
          },
          "clean_start": {
            "description": "Indicate whether the client is using a brand new session",
            "type": "boolean"
          },
          "clientid": {
            "description": "Client identifier",
            "type": "string"
          },
          "connected": {
            "description": "Whether the client is connected",
            "type": "boolean"
          },
          "connected_at": {
            "description": "Client connection time, rfc3339 or timestamp(millisecond)",
            "oneOf": [
              {
                "description": "epoch-millisecond",
                "example": 1640995200000,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "created_at": {
            "description": "Session creation time, rfc3339 or timestamp(millisecond)",
            "oneOf": [
              {
                "description": "epoch-millisecond",
                "example": 1640995200000,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "disconnected_at": {
            "description": "Client offline time. It's Only valid and returned when connected is false, rfc3339 or timestamp(millisecond)",
            "oneOf": [
              {
                "description": "epoch-millisecond",
                "example": 1640995200000,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "expiry_interval": {
            "description": "Session expiration interval, with the unit of second",
            "type": "integer"
          },
          "heap_size": {
            "description": "Process heap size with the unit of byte",
            "type": "integer"
          },
          "inflight_cnt": {
            "description": "Current length of inflight",
            "type": "integer"
          },
          "inflight_max": {
            "description": "v4 api name [max_inflight]. Maximum length of inflight",
            "type": "integer"
          },
          "ip_address": {
            "description": "Client's IP address",
            "type": "string"
          },
          "is_bridge": {
            "description": "Indicates whether the client is connectedvia bridge",
            "type": "boolean"
          },
          "keepalive": {
            "description": "keepalive time, with the unit of second",
            "type": "integer"
          },
          "mailbox_len": {
            "description": "Process mailbox size",
            "type": "integer"
          },
          "mqueue_dropped": {
            "description": "Number of messages dropped by the message queue due to exceeding the length",
            "type": "integer"
          },
          "mqueue_len": {
            "description": "Current length of message queue",
            "type": "integer"
          },
          "mqueue_max": {
            "description": "v4 api name [max_mqueue]. Maximum length of message queue",
            "type": "integer"
          },
          "node": {
            "description": "Name of the node to which the client is connected",
            "type": "string"
          },
          "port": {
            "description": "Client's port",
            "type": "integer"
          },
          "proto_name": {
            "description": "Client protocol name",
            "type": "string"
          },
          "proto_ver": {
            "description": "Protocol version used by the client",
            "type": "integer"
          },
          "recv_cnt": {
            "description": "Number of TCP packets received",
            "type": "integer"
          },
          "recv_msg": {
            "description": "Number of PUBLISH packets received",
            "type": "integer"
          },
          "recv_msg.dropped": {
            "description": "Number of dropped PUBLISH packets",
            "type": "integer"
          },
          "recv_msg.dropped.await_pubrel_timeout": {
            "description": "Number of dropped PUBLISH packets due to expired",
            "type": "integer"
          },
          "recv_msg.qos0": {
            "description": "Number of PUBLISH QoS0 packets received",
            "type": "integer"
          },
          "recv_msg.qos1": {
            "description": "Number of PUBLISH QoS1 packets received",
            "type": "integer"
          },
          "recv_msg.qos2": {
            "description": "Number of PUBLISH QoS2 packets received",
            "type": "integer"
          },
          "recv_oct": {
            "description": "Number of bytes received",
            "type": "integer"
          },
          "recv_pkt": {
            "description": "Number of MQTT packets received",
            "type": "integer"
          },
          "reductions": {
            "description": "Erlang reduction",
            "type": "integer"
          },
          "send_cnt": {
            "description": "Number of TCP packets sent",
            "type": "integer"
          },
          "send_msg": {
            "description": "Number of PUBLISH packets sent",
            "type": "integer"
          },
          "send_msg.dropped": {
            "description": "Number of dropped PUBLISH packets",
            "type": "integer"
          },
          "send_msg.dropped.expired": {
            "description": "Number of dropped PUBLISH packets due to expired",
            "type": "integer"
          },
          "send_msg.dropped.queue_full": {
            "description": "Number of dropped PUBLISH packets due to queue full",
            "type": "integer"
          },
          "send_msg.dropped.too_large": {
            "description": "Number of dropped PUBLISH packets due to packet length too large",
            "type": "integer"
          },
          "send_msg.qos0": {
            "description": "Number of PUBLISH QoS0 packets sent",
            "type": "integer"
          },
          "send_msg.qos1": {
            "description": "Number of PUBLISH QoS1 packets sent",
            "type": "integer"
          },
          "send_msg.qos2": {
            "description": "Number of PUBLISH QoS2 packets sent",
            "type": "integer"
          },
          "send_oct": {
            "description": "Number of bytes sent",
            "type": "integer"
          },
          "send_pkt": {
            "description": "Number of MQTT packets sent",
            "type": "integer"
          },
          "subscriptions_cnt": {
            "description": "Number of subscriptions established by this client.",
            "type": "integer"
          },
          "subscriptions_max": {
            "description": "v4 api name [max_subscriptions] Maximum number of subscriptions allowed by this client",
            "type": "integer"
          },
          "username": {
            "description": "User name of client when connecting",
            "type": "string"
          },
          "mountpoint": {
            "description": "Topic mountpoint",
            "type": "string"
          },
          "zone": {
            "description": "Indicate the configuration group used by the client",
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge_mqtt.get": {
        "required": [
          "server"
        ],
        "properties": {
          "status": {
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status.",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary": "Bridge Status",
            "type": "string"
          },
          "status_reason": {
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused",
            "summary": "Failure reason",
            "type": "string"
          },
          "node_status": {
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            },
            "summary": "Node Status",
            "type": "array"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/bridge_mqtt.creation_opts"
          },
          "mode": {
            "default": "cluster_shareload",
            "description": "The mode of the MQTT Bridge.<br/><br/>- cluster_shareload: create an MQTT connection on each node in the emqx cluster.<br/><br/>In 'cluster_shareload' mode, the incoming load from the remote broker is shared by<br/>using shared subscription.<br/><br/>Note that the 'clientid' is suffixed by the node name, this is to avoid<br/>clientid conflicts between different nodes. And we can only use shared subscription<br/>topic filters for <code>remote.topic</code> of ingress connections.",
            "enum": [
              "cluster_shareload"
            ],
            "summary": "MQTT Bridge Mode",
            "type": "string"
          },
          "server": {
            "description": "The host and port of the remote MQTT broker",
            "summary": "Broker IP And Port",
            "type": "string"
          },
          "clientid_prefix": {
            "description": "Optional prefix to prepend to the clientid used by egress bridges.",
            "summary": "Clientid Prefix",
            "type": "string"
          },
          "reconnect_interval": {
            "deprecated": true,
            "type": "string"
          },
          "proto_ver": {
            "default": "v4",
            "description": "The MQTT protocol version",
            "enum": [
              "v3",
              "v4",
              "v5"
            ],
            "summary": "Protocol Version",
            "type": "string"
          },
          "bridge_mode": {
            "default": false,
            "description": "If enable bridge mode.<br/>NOTE: This setting is only for MQTT protocol version older than 5.0, and the remote MQTT<br/>broker MUST support this feature.<br/>If bridge_mode is set to true, the bridge will indicate to the remote broker that it is a bridge not an ordinary client.<br/>This means that loop detection will be more effective and that retained messages will be propagated correctly.",
            "summary": "Bridge Mode",
            "type": "boolean"
          },
          "username": {
            "description": "The username of the MQTT protocol",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "The password of the MQTT protocol",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "clean_start": {
            "default": true,
            "description": "Whether to start a clean session when reconnecting a remote broker for ingress bridge",
            "summary": "Clean Session",
            "type": "boolean"
          },
          "keepalive": {
            "default": "300s",
            "description": "MQTT Keepalive. Time interval is a string that contains a number followed by time unit:<br/>- `ms` for milliseconds,<br/>- `s` for seconds,<br/>- `m` for minutes,<br/>- `h` for hours;<br/><br/>or combination of whereof: `1h5m0s`",
            "type": "string"
          },
          "retry_interval": {
            "default": "15s",
            "description": "Message retry interval. Delay for the MQTT bridge to retry sending the QoS1/QoS2 messages in case of ACK not received. Time interval is a string that contains a number followed by time unit:<br/>- `ms` for milliseconds,<br/>- `s` for seconds,<br/>- `m` for minutes,<br/>- `h` for hours;<br/><br/>or combination of whereof: `1h5m0s`",
            "type": "string"
          },
          "max_inflight": {
            "default": 32,
            "description": "Max inflight (sent, but un-acked) messages of the MQTT protocol",
            "minimum": 0,
            "summary": "Max Inflight Message",
            "type": "integer"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          },
          "ingress": {
            "description": "The ingress config defines how this bridge receive messages from the remote MQTT broker, and then<br/>        send them to the local broker.<br/><br/>        Template with variables is allowed in 'remote.qos', 'local.topic', 'local.qos', 'local.retain', 'local.payload'.<br/><br/>        NOTE: if this bridge is used as the input of a rule, and also 'local.topic' is<br/>        configured, then messages got from the remote broker will be sent to both the 'local.topic' and<br/>        the rule.",
            "summary": "Ingress Configs",
            "$ref": "#/components/schemas/connector-mqtt.ingress"
          },
          "egress": {
            "description": "The egress config defines how this bridge forwards messages from the local broker to the remote broker.<br/><br/>Template with variables is allowed in 'remote.topic', 'local.qos', 'local.retain', 'local.payload'.<br/><br/>NOTE: if this bridge is used as the action of a rule, and also 'local.topic'<br/>is configured, then both the data got from the rule and the MQTT messages that matches<br/>'local.topic' will be forwarded.",
            "summary": "Egress Configs",
            "$ref": "#/components/schemas/connector-mqtt.egress"
          }
        },
        "type": "object"
      },
      "authz.resource_metrics": {
        "properties": {
          "matched": {
            "description": "Count of this resource is queried.",
            "summary": "Matched",
            "type": "integer"
          },
          "success": {
            "description": "Count of query success.",
            "summary": "Success",
            "type": "integer"
          },
          "failed": {
            "description": "Count of query failed.",
            "summary": "Failed",
            "type": "integer"
          },
          "rate": {
            "description": "The rate of matched, times/second.",
            "summary": "Rate",
            "type": "number"
          },
          "rate_max": {
            "description": "The max rate of matched, times/second.",
            "summary": "Max Rate",
            "type": "number"
          },
          "rate_last5m": {
            "description": "The average rate of matched in the last 5 minutes, times/second.",
            "summary": "Rate in Last 5min",
            "type": "number"
          }
        },
        "type": "object"
      },
      "bridge_dynamo.put": {
        "required": [
          "aws_access_key_id",
          "aws_secret_access_key",
          "table",
          "url"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "template": {
            "default": "",
            "description": "Template, the default value is empty. When this value is empty the whole message will be stored in the database",
            "summary": "Template",
            "type": "string"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to DynamoDB. All MQTT `PUBLISH` messages with the topic<br/>matching the `local_topic` will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also `local_topic` is<br/>configured, then both the data got from the rule and the MQTT messages that match `local_topic`<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/bridge_dynamo.creation_opts"
          },
          "url": {
            "description": "The url of DynamoDB endpoint.",
            "summary": "DynamoDB Endpoint",
            "type": "string"
          },
          "table": {
            "description": "DynamoDB Table.",
            "summary": "Table ",
            "type": "string"
          },
          "aws_access_key_id": {
            "description": "Access Key ID for connecting to DynamoDB.",
            "summary": "AWS Access Key ID",
            "type": "string"
          },
          "aws_secret_access_key": {
            "description": "AWS Secret Access Key for connecting to DynamoDB.",
            "summary": "AWS Secret Access Key",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_subscriptions.subscription": {
        "properties": {
          "node": {
            "description": "Access type",
            "type": "string"
          },
          "topic": {
            "description": "Topic name",
            "type": "string"
          },
          "clientid": {
            "description": "Client identifier",
            "type": "string"
          },
          "qos": {
            "description": "QoS",
            "example": 0,
            "maximum": 2,
            "minimum": 0,
            "type": "integer"
          },
          "nl": {
            "description": "No Local",
            "type": "integer"
          },
          "rap": {
            "description": "Retain as Published",
            "type": "integer"
          },
          "rh": {
            "description": "Retain Handling",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api_listeners.ssl_listener": {
        "properties": {
          "id": {
            "description": "Listener ID",
            "type": "string"
          },
          "type": {
            "description": "Listener Type",
            "enum": [
              "ssl"
            ],
            "type": "string"
          },
          "name": {
            "description": "Listener Name",
            "type": "string"
          },
          "running": {
            "description": "Listener Running status",
            "type": "boolean"
          },
          "acceptors": {
            "default": 16,
            "description": "Size of the acceptor pool.",
            "type": "integer"
          },
          "tcp_options": {
            "description": "Setting the TCP socket options.",
            "$ref": "#/components/schemas/broker.tcp_opts"
          },
          "proxy_protocol": {
            "default": false,
            "description": "Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.<br/>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/",
            "type": "boolean"
          },
          "proxy_protocol_timeout": {
            "default": "15s",
            "description": "Timeout for proxy protocol.<br/>EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.",
            "example": "12m",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable the listener.",
            "type": "boolean"
          },
          "bind": {
            "description": "The IP address and port that the listener will bind.",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "max_connections": {
            "default": 1024,
            "description": "Maximum number of concurrent connections.",
            "type": "integer"
          },
          "max_conn_rate": {
            "default": 1000,
            "description": "Maximum connections per second.",
            "type": "integer"
          },
          "enable_authn": {
            "default": true,
            "description": "Set <code>true</code> (default) to enable client authentication on this listener. <br/>When set to <code>false</code> clients will be allowed to connect without authentication.",
            "type": "boolean"
          },
          "mountpoint": {
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message is delivered to the subscriber.<br/>The mountpoint is a way that users can use to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,<br/>then the client actually subscribes to the topic `some_tenant/t`.<br/>Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,<br/>the message is routed to all the clients subscribed `some_tenant/t`,<br/>so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.<br/>Variables in mountpoint string:<br/><br/>  - <code>${clientid}</code>: clientid<br/><br/>  - <code>${username}</code>: username",
            "type": "string"
          },
          "access_rules": {
            "default": "",
            "description": "The access control rules for this listener.<br/>See: https://github.com/emqtt/esockd#allowdeny",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "ssl_options": {
            "description": "SSL Socket options.",
            "$ref": "#/components/schemas/broker.listener_ssl_opts"
          },
          "status": {
            "description": "listener status",
            "$ref": "#/components/schemas/listeners.status"
          },
          "node_status": {
            "description": "listener status of each node in the cluster",
            "items": {
              "$ref": "#/components/schemas/listeners.node_status"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "bridge_redis.put_sentinel": {
        "required": [
          "command_template",
          "sentinel",
          "servers"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to Redis. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "command_template": {
            "description": "Redis command template used to export messages. Each list element stands for a command name or its argument.<br/>For example, to push payloads in a Redis list by key `msgs`, the elements should be the following:<br/>`rpush`, `msgs`, `${payload}`.",
            "items": {
              "type": "string"
            },
            "summary": "Redis Command Template",
            "type": "array"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/bridge_redis.creation_opts_redis_sentinel"
          },
          "servers": {
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The Redis default port 6379 is used if `[:Port]` is not specified.",
            "summary": "Servers",
            "type": "string"
          },
          "redis_type": {
            "default": "sentinel",
            "description": "Sentinel mode. Must be set to 'sentinel' when Redis server is running in sentinel mode.",
            "enum": [
              "sentinel"
            ],
            "summary": "Sentinel Mode",
            "type": "string"
          },
          "sentinel": {
            "description": "The cluster name in Redis sentinel mode.",
            "summary": "Cluster Name",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "database": {
            "default": 0,
            "description": "Redis database ID.",
            "summary": "Database ID",
            "type": "integer"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "zone.mqtt": {
        "properties": {
          "idle_timeout": {
            "description": "Configure the duration of time that a connection can remain idle (i.e., without any data transfer) before being:<br/>  - Automatically disconnected  if no CONNECT package is received from the client yet.<br/>  - Put into hibernation mode to save resources if some CONNECT packages are already received.<br/>Note: Please set the parameter with caution as long idle time will lead to resource waste.",
            "summary": "Idle Timeout",
            "oneOf": [
              {
                "example": "12m",
                "type": "string"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "max_packet_size": {
            "description": "Maximum MQTT packet size allowed.",
            "example": "32MB",
            "summary": "Max Packet Size",
            "type": "string"
          },
          "max_clientid_len": {
            "description": "Maximum allowed length of MQTT Client ID.",
            "maximum": 65535,
            "minimum": 23,
            "summary": "Max Client ID Length",
            "type": "integer"
          },
          "max_topic_levels": {
            "description": "Maximum topic levels allowed.",
            "maximum": 65535,
            "minimum": 1,
            "summary": "Max Topic Levels",
            "type": "integer"
          },
          "max_qos_allowed": {
            "description": "Maximum QoS allowed.",
            "example": 0,
            "maximum": 2,
            "minimum": 0,
            "summary": "Max QoS",
            "type": "integer"
          },
          "max_topic_alias": {
            "description": "Maximum topic alias, 0 means no topic alias supported.",
            "maximum": 65535,
            "minimum": 0,
            "summary": "Max Topic Alias",
            "type": "integer"
          },
          "retain_available": {
            "description": "Whether to enable support for MQTT retained message.",
            "summary": "Retain Available",
            "type": "boolean"
          },
          "wildcard_subscription": {
            "description": "Whether to enable support for MQTT wildcard subscription.",
            "summary": "Wildcard Subscription Available",
            "type": "boolean"
          },
          "shared_subscription": {
            "description": "Whether to enable support for MQTT shared subscription.",
            "summary": "Shared Subscription Available",
            "type": "boolean"
          },
          "exclusive_subscription": {
            "description": "Whether to enable support for MQTT exclusive subscription.",
            "summary": "Exclusive Subscription",
            "type": "boolean"
          },
          "ignore_loop_deliver": {
            "description": "Whether the messages sent by the MQTT v3.1.1/v3.1.0 client will be looped back to the publisher itself, similar to <code>No Local</code> in MQTT 5.0.",
            "summary": "Ignore Loop Deliver",
            "type": "boolean"
          },
          "strict_mode": {
            "description": "Whether to parse MQTT messages in strict mode.<br/>In strict mode, invalid utf8 strings in for example client ID, topic name, etc. will cause the client to be disconnected.",
            "summary": "Strict Mode",
            "type": "boolean"
          },
          "response_information": {
            "description": "UTF-8 string, for creating the response topic, for example, if set to <code>reqrsp/</code>, the publisher/subscriber will communicate using the topic prefix <code>reqrsp/</code>.<br/>To disable this feature, input <code>\"\"</code> in the text box below. Only applicable to MQTT 5.0 clients.",
            "summary": "Response Information",
            "type": "string"
          },
          "server_keepalive": {
            "description": "The keep alive duration required by EMQX. To use the setting from the client side, choose disabled from the drop-down list. Only applicable to MQTT 5.0 clients.",
            "summary": "Server Keep Alive",
            "oneOf": [
              {
                "enum": [
                  "disabled"
                ],
                "type": "string"
              },
              {
                "type": "integer"
              }
            ]
          },
          "keepalive_backoff": {
            "description": "The coefficient EMQX uses to confirm whether the keep alive duration of the client expires. Formula: Keep Alive * Backoff * 2",
            "summary": "Keep Alive Backoff",
            "type": "number"
          },
          "max_subscriptions": {
            "description": "Maximum number of subscriptions allowed per client.",
            "summary": "Max Subscriptions",
            "oneOf": [
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              },
              {
                "minimum": 1,
                "type": "integer"
              }
            ]
          },
          "upgrade_qos": {
            "description": "Force upgrade of QoS level according to subscription.",
            "summary": "Upgrade QoS",
            "type": "boolean"
          },
          "max_inflight": {
            "description": "Maximum number of QoS 1 and QoS 2 messages that are allowed to be delivered simultaneously before completing the acknowledgment.",
            "maximum": 65535,
            "minimum": 1,
            "summary": "Max Inflight",
            "type": "integer"
          },
          "retry_interval": {
            "description": "Retry interval for QoS 1/2 message delivering.",
            "example": "12m",
            "summary": "Retry Interval",
            "type": "string"
          },
          "max_awaiting_rel": {
            "description": "For each publisher session, the maximum number of outstanding QoS 2 messages pending on the client to send PUBREL. After reaching this limit, new QoS 2 PUBLISH requests will be rejected with `147(0x93)` until either PUBREL is received or timed out.",
            "summary": "Max Awaiting PUBREL",
            "oneOf": [
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              },
              {
                "type": "integer"
              }
            ]
          },
          "await_rel_timeout": {
            "description": "For client to broker QoS 2 message, the time limit for the broker to wait before the `PUBREL` message is received. The wait is aborted after timed out, meaning the packet ID is freed for new `PUBLISH` requests. Receiving a stale `PUBREL` causes a warning level log. Note, the message is delivered to subscribers before entering the wait for PUBREL.",
            "example": "12m",
            "summary": "Max Awaiting PUBREL TIMEOUT",
            "type": "string"
          },
          "session_expiry_interval": {
            "description": "Specifies how long the session will expire after the connection is disconnected, only for non-MQTT 5.0 connections.",
            "example": "12m",
            "summary": "Session Expiry Interval",
            "type": "string"
          },
          "max_mqueue_len": {
            "description": "Maximum queue length. Enqueued messages when persistent client disconnected, or inflight window is full.",
            "summary": "Max Message Queue Length",
            "oneOf": [
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              },
              {
                "minimum": 0,
                "type": "integer"
              }
            ]
          },
          "mqueue_priorities": {
            "description": "Topic priorities. Priority number [1-255]<br/>There's no priority table by default, hence all messages are treated equal.<br/><br/>**NOTE**: Comma and equal signs are not allowed for priority topic names.<br/>**NOTE**: Messages for topics not in the priority table are treated as either highest or lowest priority depending on the configured value for <code>mqtt.mqueue_default_priority</code>.<br/><br/>**Examples**:<br/>To configure <code>\"topic/1\" > \"topic/2\"</code>:<br/><code>mqueue_priorities: {\"topic/1\": 10, \"topic/2\": 8}</code>",
            "summary": "Topic Priorities",
            "oneOf": [
              {
                "enum": [
                  "disabled"
                ],
                "type": "string"
              },
              {
                "example": {},
                "type": "object"
              }
            ]
          },
          "mqueue_default_priority": {
            "description": "Default topic priority, which will be used by topics not in <code>Topic Priorities</code> (<code>mqueue_priorities</code>).",
            "enum": [
              "highest",
              "lowest"
            ],
            "summary": "Default Topic Priorities",
            "type": "string"
          },
          "mqueue_store_qos0": {
            "description": "Specifies whether to store QoS 0 messages in the message queue while the connection is down but the session remains.",
            "summary": "Store QoS 0 Message",
            "type": "boolean"
          },
          "use_username_as_clientid": {
            "description": "Whether to use Username as Client ID.<br/>This setting takes effect later than <code>Use Peer Certificate as Username</code> and <code>Use peer certificate as Client ID</code>.",
            "summary": "Use Username as Client ID",
            "type": "boolean"
          },
          "peer_cert_as_username": {
            "description": "Use the CN, DN field in the peer certificate or the entire certificate content as Username. Only works for the TLS connection.<br/>Supported configurations are the following:<br/>- <code>cn</code>: CN field of the certificate<br/>- <code>dn</code>: DN field of the certificate<br/>- <code>crt</code>: Content of the <code>DER</code> or <code>PEM</code> certificate<br/>- <code>pem</code>: Convert <code>DER</code> certificate content to <code>PEM</code> format and use as Username<br/>- <code>md5</code>: MD5 value of the <code>DER</code> or <code>PEM</code> certificate",
            "enum": [
              "disabled",
              "cn",
              "dn",
              "crt",
              "pem",
              "md5"
            ],
            "summary": "Use Peer Certificate as Username",
            "type": "string"
          },
          "peer_cert_as_clientid": {
            "description": "Use the CN, DN field in the peer certificate or the entire certificate content as Client ID. Only works for the TLS connection.<br/>Supported configurations are the following:<br/>- <code>cn</code>: CN field of the certificate<br/>- <code>dn</code>: DN field of the certificate<br/>- <code>crt</code>: <code>DER</code> or <code>PEM</code> certificate<br/>- <code>pem</code>: Convert <code>DER</code> certificate content to <code>PEM</code> format and use as Client ID<br/>- <code>md5</code>: MD5 value of the <code>DER</code> or <code>PEM</code> certificate",
            "enum": [
              "disabled",
              "cn",
              "dn",
              "crt",
              "pem",
              "md5"
            ],
            "summary": "Use Peer Certificate as Client ID",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_topic_metrics_api.topic_metrics": {
        "required": [
          "create_time",
          "metrics",
          "topic"
        ],
        "properties": {
          "topic": {
            "description": "Topic",
            "example": "testtopic/1",
            "type": "string"
          },
          "create_time": {
            "description": "Create time",
            "example": "2022-01-14T21:48:47+08:00",
            "oneOf": [
              {
                "description": "epoch-second",
                "example": 1640995200,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "reset_time": {
            "description": "Reset time. In rfc3339. Nullable if never reset",
            "example": "2022-01-14T21:48:47+08:00",
            "oneOf": [
              {
                "description": "epoch-second",
                "example": 1640995200,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "metrics": {
            "description": "Metrics",
            "$ref": "#/components/schemas/emqx_topic_metrics_api.metrics"
          }
        },
        "type": "object"
      },
      "listeners.quic_required_bind": {
        "required": [
          "bind",
          "id",
          "type"
        ],
        "properties": {
          "type": {
            "description": "Listener type",
            "enum": [
              "quic"
            ],
            "type": "string"
          },
          "running": {
            "description": "Listener status",
            "type": "boolean"
          },
          "id": {
            "description": "Listener id",
            "type": "string"
          },
          "current_connections": {
            "description": "Current connections",
            "minimum": 0,
            "type": "integer"
          },
          "certfile": {
            "description": "Path to the certificate file. Will be deprecated in 5.1, use .ssl_options.certfile instead.",
            "summary": "Certificate file",
            "type": "string"
          },
          "keyfile": {
            "description": "Path to the secret key file. Will be deprecated in 5.1, use .ssl_options.keyfile instead.",
            "summary": "Key file",
            "type": "string"
          },
          "ciphers": {
            "default": [
              "TLS_AES_256_GCM_SHA384",
              "TLS_AES_128_GCM_SHA256",
              "TLS_CHACHA20_POLY1305_SHA256"
            ],
            "description": "This config holds TLS cipher suite names separated by comma,<br/>or as an array of strings. e.g.<br/><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or<br/><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.<br/><br/><br/>Ciphers (and their ordering) define the way in which the<br/>client and server encrypts information over the network connection.<br/>Selecting a good cipher suite is critical for the<br/>application's data security, confidentiality and performance.<br/><br/>The names should be in OpenSSL string format (not RFC format).<br/>All default values and examples provided by EMQX config<br/>documentation are all in OpenSSL format.<br/><br/><br/>NOTE: Certain cipher suites are only compatible with<br/>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')<br/>incompatible cipher suites will be silently dropped.<br/>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,<br/>configuring cipher suites for other versions will have no effect.<br/><br/><br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br/><br/>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.<br/><br/>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,<br/>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,<br/>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,<br/>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code><br/><br/><br/>NOTE: QUIC listener supports only 'tlsv1.3' ciphers",
            "items": {
              "type": "string"
            },
            "summary": "",
            "type": "array"
          },
          "idle_timeout": {
            "default": 0,
            "description": "How long a connection can go idle before it is gracefully shut down. 0 to disable",
            "example": "32s",
            "summary": "Idle Timeout",
            "type": "string"
          },
          "handshake_idle_timeout": {
            "default": "10s",
            "description": "How long a handshake can idle before it is discarded.",
            "example": "32s",
            "summary": "Handshake Idle Timeout",
            "type": "string"
          },
          "keep_alive_interval": {
            "default": 0,
            "description": "How often to send PING frames to keep a connection alive. 0 means disabled.",
            "example": "32s",
            "summary": "Keep Alive Interval",
            "type": "string"
          },
          "ssl_options": {
            "description": "TLS options for QUIC transport",
            "summary": "TLS Options",
            "$ref": "#/components/schemas/broker.listener_quic_ssl_opts"
          },
          "enabled": {
            "default": true,
            "description": "Enable listener.",
            "summary": "Enable listener",
            "type": "boolean"
          },
          "bind": {
            "default": 14567,
            "description": "IP address and port for the listening socket.",
            "summary": "IP address and port",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "acceptors": {
            "default": 16,
            "description": "The size of the listener's receiving pool.",
            "minimum": 1,
            "summary": "Acceptors Num",
            "type": "integer"
          },
          "max_connections": {
            "default": 5000000,
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "summary": "Max connections",
            "oneOf": [
              {
                "minimum": 1,
                "type": "integer"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message<br/>is delivered to the subscriber. The mountpoint is a way that users can use<br/>to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`<br/>set to `some_tenant`, then the client actually subscribes to the topic<br/>`some_tenant/t`. Similarly, if another client B (connected to the same listener<br/>as the client A) sends a message to topic `t`, the message is routed<br/>to all the clients subscribed `some_tenant/t`, so client A will receive the<br/>message, with topic name `t`.<br/><br/>Set to `\"\"` to disable the feature.<br/><br/><br/>Variables in mountpoint string:<br/>  - <code>${clientid}</code>: clientid<br/>  - <code>${username}</code>: username",
            "summary": "mountpoint",
            "type": "string"
          },
          "zone": {
            "default": "default",
            "description": "The configuration zone to which the listener belongs.",
            "summary": "Zone",
            "type": "string"
          },
          "limiter": {
            "description": "Type of the rate limit.",
            "summary": "Type of the rate limit.",
            "$ref": "#/components/schemas/limiter.listener_fields"
          },
          "enable_authn": {
            "default": true,
            "description": "Set <code>true</code> (default) to enable client authentication on this listener, the authentication<br/>process goes through the configured authentication chain.<br/>When set to <code>false</code> to allow any clients with or without authentication information such as username or password to log in.<br/>When set to <code>quick_deny_anonymous</code>, it behaves like when set to <code>true</code>, but clients will be<br/>denied immediately without going through any authenticators if <code>username</code> is not provided. This is useful to fence off<br/>anonymous clients early.",
            "enum": [
              true,
              false,
              "quick_deny_anonymous"
            ],
            "summary": "Enable authentication",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_mnesia.username_response_data": {
        "properties": {
          "data": {
            "items": {
              "$ref": "#/components/schemas/emqx_authz_api_mnesia.rules_for_username"
            },
            "type": "array"
          },
          "meta": {
            "$ref": "#/components/schemas/public.meta"
          }
        },
        "type": "object"
      },
      "emqx_lwm2m_schema.lwm2m_translators": {
        "required": [
          "command",
          "notify",
          "register",
          "response",
          "update"
        ],
        "properties": {
          "command": {
            "description": "The topic for receiving downstream commands.<br/>For each new LwM2M client that succeeds in going online, the gateway creates a subscription relationship to receive downstream commands and send it to the LwM2M client",
            "$ref": "#/components/schemas/emqx_lwm2m_schema.translator"
          },
          "response": {
            "description": "The topic for gateway to publish the acknowledge events from LwM2M client",
            "$ref": "#/components/schemas/emqx_lwm2m_schema.translator"
          },
          "notify": {
            "description": "The topic for gateway to publish the notify events from LwM2M client.<br/>After succeed observe a resource of LwM2M client, Gateway will send the notify events via this topic, if the client reports any resource changes",
            "$ref": "#/components/schemas/emqx_lwm2m_schema.translator"
          },
          "register": {
            "description": "The topic for gateway to publish the register events from LwM2M client.",
            "$ref": "#/components/schemas/emqx_lwm2m_schema.translator"
          },
          "update": {
            "description": "The topic for gateway to publish the update events from LwM2M client",
            "$ref": "#/components/schemas/emqx_lwm2m_schema.translator"
          }
        },
        "type": "object"
      },
      "authn-scram-builtin_db.authentication": {
        "required": [
          "backend",
          "mechanism"
        ],
        "properties": {
          "mechanism": {
            "description": "Authentication mechanism.",
            "enum": [
              "scram"
            ],
            "summary": "Authentication Mechanism",
            "type": "string"
          },
          "backend": {
            "description": "Backend type.",
            "enum": [
              "built_in_database"
            ],
            "summary": "Backend Type",
            "type": "string"
          },
          "algorithm": {
            "default": "sha256",
            "description": "Hashing algorithm.",
            "enum": [
              "sha256",
              "sha512"
            ],
            "type": "string"
          },
          "iteration_count": {
            "default": 4096,
            "description": "Iteration count.",
            "minimum": 0,
            "type": "integer"
          },
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
            "summary": "Enable",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "bridge_kafka.producer_kafka_opts": {
        "required": [
          "topic"
        ],
        "properties": {
          "topic": {
            "description": "Kafka topic name",
            "summary": "Kafka Topic Name",
            "type": "string"
          },
          "message": {
            "description": "Template to render a Kafka message.",
            "summary": "Kafka Message Template",
            "$ref": "#/components/schemas/bridge_kafka.kafka_message"
          },
          "max_batch_bytes": {
            "default": "896KB",
            "description": "Maximum bytes to collect in a Kafka message batch. Most of the Kafka brokers default to a limit of 1 MB batch size. EMQX's default value is less than 1 MB in order to compensate Kafka message encoding overheads (especially when each individual message is very small). When a single message is over the limit, it is still sent (as a single element batch).",
            "example": "32MB",
            "summary": "Max Batch Bytes",
            "type": "string"
          },
          "compression": {
            "default": "no_compression",
            "description": "Compression method.",
            "enum": [
              "no_compression",
              "snappy",
              "gzip"
            ],
            "summary": "Compression",
            "type": "string"
          },
          "partition_strategy": {
            "default": "random",
            "description": "Partition strategy is to tell the producer how to dispatch messages to Kafka partitions.<br/><br/><code>random</code>: Randomly pick a partition for each message<br/><code>key_dispatch</code>: Hash Kafka message key to a partition number",
            "enum": [
              "random",
              "key_dispatch"
            ],
            "summary": "Partition Strategy",
            "type": "string"
          },
          "required_acks": {
            "default": "all_isr",
            "description": "Required acknowledgements for Kafka partition leader to wait for its followers before it sends back the acknowledgement to EMQX Kafka producer<br/><br/><code>all_isr</code>: Require all in-sync replicas to acknowledge.<br/><code>leader_only</code>: Require only the partition-leader's acknowledgement.<br/><code>none</code>: No need for Kafka to acknowledge at all.",
            "enum": [
              "all_isr",
              "leader_only",
              "none"
            ],
            "summary": "Required Acks",
            "type": "string"
          },
          "partition_count_refresh_interval": {
            "default": "60s",
            "description": "The time interval for Kafka producer to discover increased number of partitions.<br/>After the number of partitions is increased in Kafka, EMQX will start taking the <br/>discovered partitions into account when dispatching messages per <code>partition_strategy</code>.",
            "example": "1h",
            "summary": "Partition Count Refresh Interval",
            "type": "string"
          },
          "max_inflight": {
            "default": 10,
            "description": "Maximum number of batches allowed for Kafka producer (per-partition) to send before receiving acknowledgement from Kafka. Greater value typically means better throughput. However, there can be a risk of message reordering when this value is greater than 1.",
            "minimum": 1,
            "summary": "Max Inflight",
            "type": "integer"
          },
          "buffer": {
            "description": "Configure producer message buffer.<br/><br/>Tell Kafka producer how to buffer messages when EMQX has more messages to send than Kafka can keep up, or when Kafka is down.",
            "summary": "Message Buffer",
            "$ref": "#/components/schemas/bridge_kafka.producer_buffer"
          }
        },
        "type": "object"
      },
      "bridge_tdengine.put": {
        "required": [
          "database",
          "password",
          "server"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "sql": {
            "default": "insert into t_mqtt_msg(ts, msgid, mqtt_topic, qos, payload, arrived) values (${ts}, ${id}, ${topic}, ${qos}, ${payload}, ${timestamp})",
            "description": "SQL Template",
            "format": "sql",
            "summary": "SQL Template",
            "type": "string"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to TDengine. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The TDengine default port 6041 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "default": "root",
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "bridge_mqtt.post": {
        "required": [
          "name",
          "server",
          "type"
        ],
        "properties": {
          "type": {
            "description": "The bridge type.",
            "enum": [
              "mqtt"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name, used as a human-readable description of the bridge.",
            "summary": "Bridge Name",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/bridge_mqtt.creation_opts"
          },
          "mode": {
            "default": "cluster_shareload",
            "description": "The mode of the MQTT Bridge.<br/><br/>- cluster_shareload: create an MQTT connection on each node in the emqx cluster.<br/><br/>In 'cluster_shareload' mode, the incoming load from the remote broker is shared by<br/>using shared subscription.<br/><br/>Note that the 'clientid' is suffixed by the node name, this is to avoid<br/>clientid conflicts between different nodes. And we can only use shared subscription<br/>topic filters for <code>remote.topic</code> of ingress connections.",
            "enum": [
              "cluster_shareload"
            ],
            "summary": "MQTT Bridge Mode",
            "type": "string"
          },
          "server": {
            "description": "The host and port of the remote MQTT broker",
            "summary": "Broker IP And Port",
            "type": "string"
          },
          "clientid_prefix": {
            "description": "Optional prefix to prepend to the clientid used by egress bridges.",
            "summary": "Clientid Prefix",
            "type": "string"
          },
          "reconnect_interval": {
            "deprecated": true,
            "type": "string"
          },
          "proto_ver": {
            "default": "v4",
            "description": "The MQTT protocol version",
            "enum": [
              "v3",
              "v4",
              "v5"
            ],
            "summary": "Protocol Version",
            "type": "string"
          },
          "bridge_mode": {
            "default": false,
            "description": "If enable bridge mode.<br/>NOTE: This setting is only for MQTT protocol version older than 5.0, and the remote MQTT<br/>broker MUST support this feature.<br/>If bridge_mode is set to true, the bridge will indicate to the remote broker that it is a bridge not an ordinary client.<br/>This means that loop detection will be more effective and that retained messages will be propagated correctly.",
            "summary": "Bridge Mode",
            "type": "boolean"
          },
          "username": {
            "description": "The username of the MQTT protocol",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "The password of the MQTT protocol",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "clean_start": {
            "default": true,
            "description": "Whether to start a clean session when reconnecting a remote broker for ingress bridge",
            "summary": "Clean Session",
            "type": "boolean"
          },
          "keepalive": {
            "default": "300s",
            "description": "MQTT Keepalive. Time interval is a string that contains a number followed by time unit:<br/>- `ms` for milliseconds,<br/>- `s` for seconds,<br/>- `m` for minutes,<br/>- `h` for hours;<br/><br/>or combination of whereof: `1h5m0s`",
            "type": "string"
          },
          "retry_interval": {
            "default": "15s",
            "description": "Message retry interval. Delay for the MQTT bridge to retry sending the QoS1/QoS2 messages in case of ACK not received. Time interval is a string that contains a number followed by time unit:<br/>- `ms` for milliseconds,<br/>- `s` for seconds,<br/>- `m` for minutes,<br/>- `h` for hours;<br/><br/>or combination of whereof: `1h5m0s`",
            "type": "string"
          },
          "max_inflight": {
            "default": 32,
            "description": "Max inflight (sent, but un-acked) messages of the MQTT protocol",
            "minimum": 0,
            "summary": "Max Inflight Message",
            "type": "integer"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          },
          "ingress": {
            "description": "The ingress config defines how this bridge receive messages from the remote MQTT broker, and then<br/>        send them to the local broker.<br/><br/>        Template with variables is allowed in 'remote.qos', 'local.topic', 'local.qos', 'local.retain', 'local.payload'.<br/><br/>        NOTE: if this bridge is used as the input of a rule, and also 'local.topic' is<br/>        configured, then messages got from the remote broker will be sent to both the 'local.topic' and<br/>        the rule.",
            "summary": "Ingress Configs",
            "$ref": "#/components/schemas/connector-mqtt.ingress"
          },
          "egress": {
            "description": "The egress config defines how this bridge forwards messages from the local broker to the remote broker.<br/><br/>Template with variables is allowed in 'remote.topic', 'local.qos', 'local.retain', 'local.payload'.<br/><br/>NOTE: if this bridge is used as the action of a rule, and also 'local.topic'<br/>is configured, then both the data got from the rule and the MQTT messages that matches<br/>'local.topic' will be forwarded.",
            "summary": "Egress Configs",
            "$ref": "#/components/schemas/connector-mqtt.egress"
          }
        },
        "type": "object"
      },
      "bridge_kafka.kafka_message": {
        "properties": {
          "key": {
            "default": "${.clientid}",
            "description": "Template to render Kafka message key. If the template is rendered into a NULL value (i.e. there is no such data field in Rule Engine context) then Kafka's <code>NULL</code> (but not empty string) is used.",
            "summary": "Message Key",
            "type": "string"
          },
          "value": {
            "default": "${.}",
            "description": "Template to render Kafka message value. If the template is rendered into a NULL value (i.e. there is no such data field in Rule Engine context) then Kafka's <code>NULL</code> (but not empty string) is used.",
            "summary": "Message Value",
            "type": "string"
          },
          "timestamp": {
            "default": "${.timestamp}",
            "description": "Which timestamp to use. The timestamp is expected to be a millisecond precision Unix epoch which can be in string format, e.g. <code>1661326462115</code> or <code>'1661326462115'</code>. When the desired data field for this template is not found, or if the found data is not a valid integer, the current system timestamp will be used.",
            "summary": "Message Timestamp",
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge_timescale.put": {
        "required": [
          "database",
          "server"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "sql": {
            "default": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
            "description": "SQL Template",
            "format": "sql",
            "summary": "SQL Template",
            "type": "string"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to PostgreSQL. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The PostgreSQL default port 5432 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "plugins.plugin": {
        "required": [
          "description",
          "name",
          "rel_apps",
          "rel_vsn",
          "running_status"
        ],
        "properties": {
          "name": {
            "description": "Name-Vsn: without .tar.gz",
            "example": "emqx_plugin_template-5.0-rc.1",
            "type": "string"
          },
          "author": {
            "example": [
              "EMQX Team"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "builder": {
            "$ref": "#/components/schemas/plugins.builder"
          },
          "built_on_otp_release": {
            "example": "24",
            "type": "string"
          },
          "compatibility": {
            "example": {
              "emqx": "~>5.0"
            },
            "type": "object"
          },
          "git_commit_or_build_date": {
            "description": "Last git commit date by `git log -1 --pretty=format:'%cd' --date=format:'%Y-%m-%d`.<br/> If the last commit date is not available, the build date will be presented.",
            "example": "2021-12-25",
            "type": "string"
          },
          "functionality": {
            "example": [
              "Demo"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "git_ref": {
            "example": "ddab50fafeed6b1faea70fc9ffd8c700d7e26ec1",
            "type": "string"
          },
          "metadata_vsn": {
            "example": "0.1.0",
            "type": "string"
          },
          "rel_vsn": {
            "description": "Plugins release version",
            "example": "5.0-rc.1",
            "type": "string"
          },
          "rel_apps": {
            "description": "Aplications in plugin.",
            "example": [
              "emqx_plugin_template-5.0.0",
              "map_sets-1.1.0"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "repo": {
            "example": "https://github.com/emqx/emqx-plugin-template",
            "type": "string"
          },
          "description": {
            "description": "Plugin description.",
            "example": "This is an demo plugin description",
            "type": "string"
          },
          "running_status": {
            "items": {
              "$ref": "#/components/schemas/plugins.running_status"
            },
            "type": "array"
          },
          "readme": {
            "description": "only return when `GET /plugins/{name}`.",
            "example": "This is an demo plugin.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge_mongodb.get_single": {
        "required": [
          "database",
          "name",
          "server",
          "type"
        ],
        "properties": {
          "status": {
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status.",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary": "Bridge Status",
            "type": "string"
          },
          "status_reason": {
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused",
            "summary": "Failure reason",
            "type": "string"
          },
          "node_status": {
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            },
            "summary": "Node Status",
            "type": "array"
          },
          "mongo_type": {
            "default": "single",
            "description": "Standalone instance. Must be set to 'single' when MongoDB server is running in standalone mode.",
            "enum": [
              "single"
            ],
            "summary": "Standalone instance",
            "type": "string"
          },
          "server": {
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The MongoDB default port 27017 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "w_mode": {
            "default": "unsafe",
            "description": "Write mode.",
            "enum": [
              "unsafe",
              "safe"
            ],
            "summary": "Write Mode",
            "type": "string"
          },
          "srv_record": {
            "default": false,
            "description": "Use DNS SRV record.",
            "summary": "Srv Record",
            "type": "boolean"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auth_source": {
            "description": "Database name associated with the user's credentials.",
            "summary": "Auth Source",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "topology": {
            "$ref": "#/components/schemas/emqx_connector_mongo.topology"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable this MongoDB Bridge",
            "summary": "Enable or disable",
            "type": "boolean"
          },
          "collection": {
            "default": "mqtt",
            "description": "The collection where data will be stored into",
            "summary": "Collection to be used",
            "type": "string"
          },
          "payload_template": {
            "description": "The template for formatting the outgoing messages.  If undefined, rule engine will use JSON format to serialize all visible inputs, such as clientid, topic, payload etc.",
            "summary": "Payload template",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "type": {
            "description": "The Bridge Type.",
            "enum": [
              "mongodb_single"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name.",
            "summary": "Bridge Name",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_mnesia.rules_for_clientid": {
        "required": [
          "clientid"
        ],
        "properties": {
          "rules": {
            "items": {
              "$ref": "#/components/schemas/emqx_authz_api_mnesia.rule_item"
            },
            "type": "array"
          },
          "clientid": {
            "description": "ClientID",
            "example": "client1",
            "summary": "clientid",
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge_rocketmq.get": {
        "required": [
          "name",
          "servers",
          "type"
        ],
        "properties": {
          "status": {
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status.",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary": "Bridge Status",
            "type": "string"
          },
          "status_reason": {
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused",
            "summary": "Failure reason",
            "type": "string"
          },
          "node_status": {
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            },
            "summary": "Node Status",
            "type": "array"
          },
          "type": {
            "description": "The Bridge Type",
            "enum": [
              "rocketmq"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name.",
            "summary": "Bridge Name",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "template": {
            "default": "",
            "description": "Template, the default value is empty. When this value is empty the whole message will be stored in the RocketMQ.<br><br/>            The template can be any valid string with placeholders, example:<br><br/>            - ${id}, ${username}, ${clientid}, ${timestamp}<br><br/>            - {\"id\" : ${id}, \"username\" : ${username}}",
            "summary": "Template",
            "type": "string"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to RocketMQ. All MQTT `PUBLISH` messages with the topic<br/>matching the `local_topic` will be forwarded.</br><br/>NOTE: if the bridge is used as a rule action, `local_topic` should be left empty otherwise the messages will be duplicated.",
            "summary": "Local Topic",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "servers": {
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The RocketMQ default port 9876 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "topic": {
            "default": "TopicTest",
            "description": "RocketMQ Topic",
            "summary": "RocketMQ Topic",
            "type": "string"
          },
          "access_key": {
            "default": "",
            "description": "RocketMQ server `accessKey`.",
            "summary": "AccessKey",
            "type": "string"
          },
          "secret_key": {
            "default": "",
            "description": "RocketMQ server `secretKey`.",
            "summary": "SecretKey",
            "type": "string"
          },
          "security_token": {
            "default": "",
            "description": "RocketMQ Server Security Token",
            "summary": "Security Token",
            "type": "string"
          },
          "sync_timeout": {
            "default": "3s",
            "description": "Timeout of RocketMQ driver synchronous call.",
            "example": "12m",
            "summary": "Sync Timeout",
            "type": "string"
          },
          "refresh_interval": {
            "default": "3s",
            "description": "RocketMQ Topic Route Refresh Interval.",
            "example": "12m",
            "summary": "Topic Route Refresh Interval",
            "type": "string"
          },
          "send_buffer": {
            "default": "1024KB",
            "description": "The socket send buffer size of the RocketMQ driver client.",
            "example": "32MB",
            "summary": "Send Buffer Size",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "emqx_rule_api_schema.ctx_pub": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "description": "Event Type",
            "enum": [
              "message_publish"
            ],
            "summary": "Event Type",
            "type": "string"
          },
          "id": {
            "description": "Message ID",
            "summary": "Message ID",
            "type": "string"
          },
          "clientid": {
            "description": "The Client ID",
            "summary": "Client ID",
            "type": "string"
          },
          "username": {
            "description": "Username",
            "summary": "Username",
            "type": "string"
          },
          "payload": {
            "description": "The Message Payload",
            "summary": "Message Payload",
            "type": "string"
          },
          "peerhost": {
            "description": "The IP Address of the Peer Client",
            "summary": "Peer IP Address",
            "type": "string"
          },
          "topic": {
            "description": "Message Topic",
            "summary": "Message Topic",
            "type": "string"
          },
          "publish_received_at": {
            "description": "The Time that this Message is Received",
            "summary": "Message Received Time",
            "type": "integer"
          },
          "qos": {
            "description": "The Message QoS",
            "example": 0,
            "maximum": 2,
            "minimum": 0,
            "summary": "Message QoS",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api_clients.coap_client": {
        "properties": {
          "node": {
            "description": "Name of the node to which the client is connected",
            "type": "string"
          },
          "clientid": {
            "description": "Client ID",
            "type": "string"
          },
          "username": {
            "description": "Username of client when connecting",
            "type": "string"
          },
          "mountpoint": {
            "description": "Topic mountpoint",
            "type": "string"
          },
          "proto_name": {
            "description": "Client protocol name",
            "type": "string"
          },
          "proto_ver": {
            "description": "Protocol version used by the client",
            "type": "string"
          },
          "ip_address": {
            "description": "Client's IP address",
            "type": "string"
          },
          "port": {
            "description": "Client's port",
            "type": "integer"
          },
          "is_bridge": {
            "description": "Indicates whether the client is connected via bridge",
            "type": "boolean"
          },
          "connected_at": {
            "description": "Client connection time",
            "oneOf": [
              {
                "description": "epoch-millisecond",
                "example": 1640995200000,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "disconnected_at": {
            "description": "Client offline time, This field is only valid and returned when connected is false",
            "oneOf": [
              {
                "description": "epoch-millisecond",
                "example": 1640995200000,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "connected": {
            "description": "Whether the client is connected",
            "type": "boolean"
          },
          "keepalive": {
            "description": "Keepalive time, with the unit of second",
            "type": "integer"
          },
          "clean_start": {
            "description": "Indicate whether the client is using a brand new session",
            "type": "boolean"
          },
          "expiry_interval": {
            "description": "Session expiration interval, with the unit of second",
            "type": "integer"
          },
          "created_at": {
            "description": "Session creation time",
            "oneOf": [
              {
                "description": "epoch-millisecond",
                "example": 1640995200000,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "subscriptions_cnt": {
            "description": "Number of subscriptions established by this client",
            "type": "integer"
          },
          "subscriptions_max": {
            "description": "Maximum number of subscriptions allowed by this client",
            "type": "integer"
          },
          "inflight_cnt": {
            "description": "Current length of inflight",
            "type": "integer"
          },
          "inflight_max": {
            "description": "Maximum length of inflight",
            "type": "integer"
          },
          "mqueue_len": {
            "description": "Current length of message queue",
            "type": "integer"
          },
          "mqueue_max": {
            "description": "Maximum length of message queue",
            "type": "integer"
          },
          "mqueue_dropped": {
            "description": "Number of messages dropped by the message queue due to exceeding the length",
            "type": "integer"
          },
          "awaiting_rel_cnt": {
            "description": "Number of awaiting acknowledge packet",
            "type": "integer"
          },
          "awaiting_rel_max": {
            "description": "Maximum allowed number of awaiting PUBREC packet",
            "type": "integer"
          },
          "recv_oct": {
            "description": "Number of bytes received",
            "type": "integer"
          },
          "recv_cnt": {
            "description": "Number of socket packets received",
            "type": "integer"
          },
          "recv_pkt": {
            "description": "Number of protocol packets received",
            "type": "integer"
          },
          "recv_msg": {
            "description": "Number of message packets received",
            "type": "integer"
          },
          "send_oct": {
            "description": "Number of bytes sent",
            "type": "integer"
          },
          "send_cnt": {
            "description": "Number of socket packets sent",
            "type": "integer"
          },
          "send_pkt": {
            "description": "Number of protocol packets sent",
            "type": "integer"
          },
          "send_msg": {
            "description": "Number of message packets sent",
            "type": "integer"
          },
          "mailbox_len": {
            "description": "Process mailbox size",
            "type": "integer"
          },
          "heap_size": {
            "description": "Process heap size with the unit of byte",
            "type": "integer"
          },
          "reductions": {
            "description": "Erlang reduction",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_clients.authz_cache": {
        "properties": {
          "access": {
            "description": "Access type",
            "type": "string"
          },
          "result": {
            "description": "Allow or deny",
            "type": "string"
          },
          "topic": {
            "description": "Topic name",
            "type": "string"
          },
          "updated_time": {
            "description": "Update time",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "emqx_rule_api_schema.rule_test": {
        "required": [
          "sql"
        ],
        "properties": {
          "context": {
            "default": {},
            "description": "The context of the event for testing",
            "summary": "Event Conetxt",
            "oneOf": [
              {
                "$ref": "#/components/schemas/emqx_rule_api_schema.ctx_bridge_mqtt"
              },
              {
                "$ref": "#/components/schemas/emqx_rule_api_schema.ctx_check_authz_complete"
              },
              {
                "$ref": "#/components/schemas/emqx_rule_api_schema.ctx_connack"
              },
              {
                "$ref": "#/components/schemas/emqx_rule_api_schema.ctx_disconnected"
              },
              {
                "$ref": "#/components/schemas/emqx_rule_api_schema.ctx_connected"
              },
              {
                "$ref": "#/components/schemas/emqx_rule_api_schema.ctx_dropped"
              },
              {
                "$ref": "#/components/schemas/emqx_rule_api_schema.ctx_acked"
              },
              {
                "$ref": "#/components/schemas/emqx_rule_api_schema.ctx_delivered"
              },
              {
                "$ref": "#/components/schemas/emqx_rule_api_schema.ctx_unsub"
              },
              {
                "$ref": "#/components/schemas/emqx_rule_api_schema.ctx_sub"
              },
              {
                "$ref": "#/components/schemas/emqx_rule_api_schema.ctx_pub"
              }
            ]
          },
          "sql": {
            "description": "The SQL of the rule for testing",
            "summary": "Test SQL",
            "type": "string"
          }
        },
        "type": "object"
      },
      "slow_subs.slow_subs": {
        "properties": {
          "enable": {
            "default": false,
            "description": "Enable this feature",
            "type": "boolean"
          },
          "threshold": {
            "default": "500ms",
            "description": "The latency threshold for statistics",
            "example": "32s",
            "type": "string"
          },
          "expire_interval": {
            "default": "300s",
            "description": "The eviction time of the record, which in the statistics record table",
            "example": "32s",
            "type": "string"
          },
          "top_k_num": {
            "default": 10,
            "description": "The maximum number of records in the slow subscription statistics record table",
            "minimum": 1,
            "type": "integer"
          },
          "stats_type": {
            "default": "whole",
            "description": "The method to calculate the latency",
            "enum": [
              "whole",
              "internal",
              "response"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_rule_api_schema.ctx_dropped": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "description": "Event Type",
            "enum": [
              "message_dropped"
            ],
            "summary": "Event Type",
            "type": "string"
          },
          "id": {
            "description": "Message ID",
            "summary": "Message ID",
            "type": "string"
          },
          "reason": {
            "description": "The Reason for Dropping",
            "summary": "Dropped Reason",
            "type": "string"
          },
          "clientid": {
            "description": "The Client ID",
            "summary": "Client ID",
            "type": "string"
          },
          "username": {
            "description": "Username",
            "summary": "Username",
            "type": "string"
          },
          "payload": {
            "description": "The Message Payload",
            "summary": "Message Payload",
            "type": "string"
          },
          "peerhost": {
            "description": "The IP Address of the Peer Client",
            "summary": "Peer IP Address",
            "type": "string"
          },
          "topic": {
            "description": "Message Topic",
            "summary": "Message Topic",
            "type": "string"
          },
          "publish_received_at": {
            "description": "The Time that this Message is Received",
            "summary": "Message Received Time",
            "type": "integer"
          },
          "qos": {
            "description": "The Message QoS",
            "example": 0,
            "maximum": 2,
            "minimum": 0,
            "summary": "Message QoS",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "limiter.client_fields": {
        "properties": {
          "bytes_in": {
            "default": {},
            "description": "The bytes_in limiter.<br/>This is used to limit the inbound bytes rate for this EMQX node.<br/>Once the limit is reached, the restricted client will be slow down even be hung for a while.",
            "summary": "Bytes In",
            "$ref": "#/components/schemas/limiter.client_opts"
          },
          "message_in": {
            "default": {},
            "description": "The message in limiter.<br/>This is used to limit the inbound message numbers for this EMQX node<br/>Once the limit is reached, the restricted client will be slow down even be hung for a while.",
            "summary": "Message In",
            "$ref": "#/components/schemas/limiter.client_opts"
          },
          "connection": {
            "default": {},
            "description": "The connection limiter.<br/>This is used to limit the connection rate for this EMQX node.<br/>Once the limit is reached, new connections will be refused",
            "summary": "Connection",
            "$ref": "#/components/schemas/limiter.client_opts"
          },
          "message_routing": {
            "default": {},
            "description": "The message routing limiter.<br/>This is used to limit the forwarding rate for this EMQX node.<br/>Once the limit is reached, new publish will be refused",
            "summary": "Message Routing",
            "$ref": "#/components/schemas/limiter.client_opts"
          },
          "internal": {
            "default": {},
            "description": "Limiter for EMQX internal app.",
            "$ref": "#/components/schemas/limiter.client_opts"
          }
        },
        "type": "object"
      },
      "limiter.limiter": {
        "properties": {
          "bytes_in": {
            "default": {},
            "description": "The bytes_in limiter.<br/>This is used to limit the inbound bytes rate for this EMQX node.<br/>Once the limit is reached, the restricted client will be slow down even be hung for a while.",
            "summary": "Bytes In",
            "$ref": "#/components/schemas/limiter.node_opts"
          },
          "message_in": {
            "default": {},
            "description": "The message in limiter.<br/>This is used to limit the inbound message numbers for this EMQX node<br/>Once the limit is reached, the restricted client will be slow down even be hung for a while.",
            "summary": "Message In",
            "$ref": "#/components/schemas/limiter.node_opts"
          },
          "connection": {
            "default": {},
            "description": "The connection limiter.<br/>This is used to limit the connection rate for this EMQX node.<br/>Once the limit is reached, new connections will be refused",
            "summary": "Connection",
            "$ref": "#/components/schemas/limiter.node_opts"
          },
          "message_routing": {
            "default": {},
            "description": "The message routing limiter.<br/>This is used to limit the forwarding rate for this EMQX node.<br/>Once the limit is reached, new publish will be refused",
            "summary": "Message Routing",
            "$ref": "#/components/schemas/limiter.node_opts"
          },
          "internal": {
            "default": {},
            "description": "Limiter for EMQX internal app.",
            "$ref": "#/components/schemas/limiter.node_opts"
          },
          "client": {
            "default": {
              "bytes_in": {},
              "connection": {},
              "internal": {},
              "message_in": {},
              "message_routing": {}
            },
            "description": "The rate limit for each user of the bucket",
            "summary": "Per Client",
            "$ref": "#/components/schemas/limiter.client_fields"
          }
        },
        "type": "object"
      },
      "broker.ws_opts": {
        "properties": {
          "mqtt_path": {
            "default": "/mqtt",
            "description": "WebSocket's MQTT protocol path. So the address of EMQX Broker's WebSocket is:<br/><code>ws://{ip}:{port}/mqtt</code>",
            "summary": "WS MQTT Path",
            "type": "string"
          },
          "mqtt_piggyback": {
            "default": "multiple",
            "description": "Whether a WebSocket message is allowed to contain multiple MQTT packets.",
            "enum": [
              "single",
              "multiple"
            ],
            "summary": "MQTT Piggyback",
            "type": "string"
          },
          "compress": {
            "default": false,
            "description": "If <code>true</code>, compress WebSocket messages using <code>zlib</code>.<br/><br/>The configuration items under <code>deflate_opts</code> belong to the compression-related parameter configuration.",
            "summary": "Ws compress",
            "type": "boolean"
          },
          "idle_timeout": {
            "default": "7200s",
            "description": "Close transport-layer connections from the clients that have not sent MQTT CONNECT message within this interval.",
            "example": "12m",
            "summary": "WS idle timeout",
            "type": "string"
          },
          "max_frame_size": {
            "default": "infinity",
            "description": "The maximum length of a single MQTT packet.",
            "summary": "Max frame size",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "fail_if_no_subprotocol": {
            "default": true,
            "description": "If <code>true</code>, the server will return an error when<br/> the client does not carry the <code>Sec-WebSocket-Protocol</code> field.<br/> <br/>Note: WeChat applet needs to disable this verification.",
            "summary": "Fail if no subprotocol",
            "type": "boolean"
          },
          "supported_subprotocols": {
            "default": "mqtt, mqtt-v3, mqtt-v3.1.1, mqtt-v5",
            "description": "Comma-separated list of supported subprotocols.",
            "example": "item1,item2",
            "summary": "Supported subprotocols",
            "type": "string"
          },
          "check_origin_enable": {
            "default": false,
            "description": "If <code>true</code>, <code>origin</code> HTTP header will be<br/> validated against the list of allowed origins configured in <code>check_origins</code><br/> parameter.",
            "summary": "Check origin",
            "type": "boolean"
          },
          "allow_origin_absence": {
            "default": true,
            "description": "If <code>false</code> and <code>check_origin_enable</code> is<br/> <code>true</code>, the server will reject requests that don't have <code>origin</code><br/> HTTP header.",
            "summary": "Allow origin absence",
            "type": "boolean"
          },
          "check_origins": {
            "default": "http://localhost:18083, http://127.0.0.1:18083",
            "description": "List of allowed origins.<br/>See <code>check_origin_enable</code>.",
            "example": "item1,item2",
            "summary": "Allowed origins",
            "type": "string"
          },
          "proxy_address_header": {
            "default": "x-forwarded-for",
            "description": "HTTP header used to pass information about the client IP address.<br/>Relevant when the EMQX cluster is deployed behind a load-balancer.",
            "summary": "Proxy address header",
            "type": "string"
          },
          "proxy_port_header": {
            "default": "x-forwarded-port",
            "description": "HTTP header used to pass information about the client port. Relevant when the EMQX cluster is deployed behind a load-balancer.",
            "summary": "Proxy port header",
            "type": "string"
          },
          "deflate_opts": {
            "$ref": "#/components/schemas/broker.deflate_opts"
          }
        },
        "type": "object"
      },
      "dashboard.https": {
        "required": [
          "bind",
          "enable"
        ],
        "properties": {
          "enable": {
            "default": false,
            "description": "Ignore or enable this listener",
            "summary": "Enable",
            "type": "boolean"
          },
          "bind": {
            "default": 18084,
            "description": "Port without IP(18083) or port with specified IP(127.0.0.1:18083).",
            "example": "0.0.0.0:18084",
            "summary": "Bind",
            "oneOf": [
              {
                "example": "127.0.0.1:80",
                "type": "string"
              },
              {
                "minimum": 0,
                "type": "integer"
              }
            ]
          },
          "num_acceptors": {
            "default": 8,
            "description": "Socket acceptor pool size for TCP protocols. Default is the number of schedulers online",
            "summary": "Number of acceptors",
            "type": "integer"
          },
          "max_connections": {
            "default": 512,
            "description": "Maximum number of simultaneous connections.",
            "summary": "Maximum connections",
            "type": "integer"
          },
          "backlog": {
            "default": 1024,
            "description": "Defines the maximum length that the queue of pending connections can grow to.",
            "summary": "Backlog",
            "type": "integer"
          },
          "send_timeout": {
            "default": "10s",
            "description": "Send timeout for the socket.",
            "example": "12m",
            "summary": "Send timeout",
            "type": "string"
          },
          "inet6": {
            "default": false,
            "description": "Enable IPv6 support, default is false, which means IPv4 only.",
            "summary": "IPv6",
            "type": "boolean"
          },
          "ipv6_v6only": {
            "default": false,
            "description": "Disable IPv4-to-IPv6 mapping for the listener.<br/>The configuration is only valid when the inet6 is true.",
            "summary": "IPv6 only",
            "type": "boolean"
          },
          "proxy_header": {
            "default": false,
            "description": "Enable support for `HAProxy` header. Be aware once enabled regular HTTP requests can't be handled anymore.",
            "summary": "Enable support for HAProxy header",
            "type": "boolean"
          },
          "cacertfile": {
            "description": "Trusted PEM format CA certificates bundle file.<br/><br/>The certificates in this file are used to verify the TLS peer's certificates.<br/>Append new certificates to the file if new CAs are to be trusted.<br/>There is no need to restart EMQX to have the updated file loaded, because<br/>the system regularly checks if file has been updated (and reload).<br/><br/>NOTE: invalidating (deleting) a certificate from the file will not affect<br/>already established connections.",
            "summary": "CACertfile",
            "type": "string"
          },
          "certfile": {
            "description": "PEM format certificates chain file.<br/><br/>The certificates in this file should be in reversed order of the certificate<br/>issue chain. That is, the host's certificate should be placed in the beginning<br/>of the file, followed by the immediate issuer certificate and so on.<br/>Although the root CA certificate is optional, it should be placed at the end of<br/>the file if it is to be added.",
            "summary": "Certfile",
            "type": "string"
          },
          "keyfile": {
            "description": "PEM format private key file.",
            "summary": "Keyfile",
            "type": "string"
          },
          "verify": {
            "default": "verify_none",
            "description": "Enable or disable peer verification.",
            "enum": [
              "verify_peer",
              "verify_none"
            ],
            "summary": "Verify peer",
            "type": "string"
          },
          "reuse_sessions": {
            "default": true,
            "description": "Enable TLS session reuse.",
            "summary": "TLS session reuse",
            "type": "boolean"
          },
          "depth": {
            "default": 10,
            "description": "Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path.<br/>So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly;<br/><br/>if 1 the path can be PEER, Intermediate-CA, ROOT-CA;<br/><br/>if 2 the path can be PEER, Intermediate-CA1, Intermediate-CA2, ROOT-CA.",
            "summary": "CACert Depth",
            "type": "integer"
          },
          "versions": {
            "default": [
              "tlsv1.3",
              "tlsv1.2",
              "tlsv1.1",
              "tlsv1"
            ],
            "description": "All TLS/DTLS versions to be supported.<br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.<br/><br/>In case PSK cipher suites are intended, make sure to configure<br/><code>['tlsv1.2', 'tlsv1.1']</code> here.",
            "items": {
              "type": "string"
            },
            "summary": "SSL versions",
            "type": "array"
          },
          "ciphers": {
            "default": "",
            "description": "This config holds TLS cipher suite names separated by comma,<br/>or as an array of strings. e.g.<br/><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or<br/><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.<br/><br/><br/>Ciphers (and their ordering) define the way in which the<br/>client and server encrypts information over the network connection.<br/>Selecting a good cipher suite is critical for the<br/>application's data security, confidentiality and performance.<br/><br/>The names should be in OpenSSL string format (not RFC format).<br/>All default values and examples provided by EMQX config<br/>documentation are all in OpenSSL format.<br/><br/><br/>NOTE: Certain cipher suites are only compatible with<br/>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')<br/>incompatible cipher suites will be silently dropped.<br/>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,<br/>configuring cipher suites for other versions will have no effect.<br/><br/><br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br/><br/>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.<br/><br/>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,<br/>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,<br/>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,<br/>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code>",
            "items": {
              "type": "string"
            },
            "summary": "",
            "type": "array"
          },
          "secure_renegotiate": {
            "default": true,
            "description": "SSL parameter renegotiation is a feature that allows a client and a server<br/>to renegotiate the parameters of the SSL connection on the fly.<br/>RFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,<br/>you drop support for the insecure renegotiation, prone to MitM attacks.",
            "summary": "SSL renegotiate",
            "type": "boolean"
          },
          "hibernate_after": {
            "default": "5s",
            "description": "Hibernate the SSL process after idling for amount of time reducing its memory footprint.",
            "example": "12m",
            "summary": "hibernate after",
            "type": "string"
          },
          "dhfile": {
            "description": "Path to a file containing PEM-encoded Diffie-Hellman parameters<br/>to be used by the server if a cipher suite using Diffie-Hellman<br/>key exchange is negotiated. If not specified, default parameters<br/>are used.<br/><br/>NOTE: The <code>dhfile</code> option is not supported by TLS 1.3.",
            "summary": "SSL dhfile",
            "type": "string"
          },
          "honor_cipher_order": {
            "default": true,
            "description": "An important security setting, it forces the cipher to be set based<br/> on the server-specified order instead of the client-specified order,<br/> hence enforcing the (usually more properly configured) security<br/> ordering of the server administrator.",
            "summary": "SSL honor cipher order",
            "type": "boolean"
          },
          "client_renegotiation": {
            "default": true,
            "description": "In protocols that support client-initiated renegotiation,<br/>the cost of resources of such an operation is higher for the server than the client.<br/>This can act as a vector for denial of service attacks.<br/>The SSL application already takes measures to counter-act such attempts,<br/>but client-initiated renegotiation can be strictly disabled by setting this option to false.<br/>The default value is true. Note that disabling renegotiation can result in<br/>long-lived connections becoming unusable due to limits on<br/>the number of messages the underlying cipher suite can encipher.",
            "summary": "SSL client renegotiation",
            "type": "boolean"
          },
          "handshake_timeout": {
            "default": "15s",
            "description": "Maximum time duration allowed for the handshake to complete",
            "example": "12m",
            "summary": "Handshake timeout",
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge_kafka.socket_opts": {
        "properties": {
          "sndbuf": {
            "default": "1MB",
            "description": "Fine tune the socket send buffer. The default value is tuned for high throughput.",
            "example": "32MB",
            "summary": "Socket Send Buffer Size",
            "type": "string"
          },
          "recbuf": {
            "default": "1MB",
            "description": "Fine tune the socket receive buffer. The default value is tuned for high throughput.",
            "example": "32MB",
            "summary": "Socket Receive Buffer Size",
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge_redis.post_single": {
        "required": [
          "command_template",
          "name",
          "server",
          "type"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to Redis. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "command_template": {
            "description": "Redis command template used to export messages. Each list element stands for a command name or its argument.<br/>For example, to push payloads in a Redis list by key `msgs`, the elements should be the following:<br/>`rpush`, `msgs`, `${payload}`.",
            "items": {
              "type": "string"
            },
            "summary": "Redis Command Template",
            "type": "array"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/bridge_redis.creation_opts_redis_single"
          },
          "server": {
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The Redis default port 6379 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "redis_type": {
            "default": "single",
            "description": "Single mode. Must be set to 'single' when Redis server is running in single mode.",
            "enum": [
              "single"
            ],
            "summary": "Single Mode",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "database": {
            "default": 0,
            "description": "Redis database ID.",
            "summary": "Database ID",
            "type": "integer"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          },
          "type": {
            "description": "The Bridge Type",
            "enum": [
              "redis_single"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name, used as a human-readable description of the bridge.",
            "summary": "Bridge Name",
            "type": "string"
          }
        },
        "type": "object"
      },
      "trace.log_file_detail": {
        "properties": {
          "node": {
            "description": "Node name",
            "example": "emqx@127.0.0.1",
            "type": "string"
          },
          "size": {
            "description": "file size",
            "type": "integer"
          },
          "mtime": {
            "description": "the modification and last access times of a file",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "emqx_conf_schema.log_rotation": {
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable log rotation feature.",
            "summary": "Rotation Enable",
            "type": "boolean"
          },
          "count": {
            "default": 10,
            "description": "Maximum number of log files.",
            "maximum": 2048,
            "minimum": 1,
            "summary": "Max Log Files Number",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_schema.mongo_single": {
        "required": [
          "collection",
          "database",
          "server",
          "type"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this ACL provider.",
            "summary": "enable",
            "type": "boolean"
          },
          "type": {
            "default": "mongodb",
            "description": "Backend type.",
            "enum": [
              "mongodb"
            ],
            "summary": "type",
            "type": "string"
          },
          "collection": {
            "description": "`MongoDB` collection containing the authorization data.",
            "summary": "collection",
            "type": "string"
          },
          "filter": {
            "default": {},
            "description": "Conditional expression that defines the filter condition in the query.<br/>Filter supports the following placeholders:<br/> - <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting;<br/> - <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting.",
            "example": {},
            "summary": "Filter",
            "type": "object"
          },
          "mongo_type": {
            "default": "single",
            "description": "Standalone instance. Must be set to 'single' when MongoDB server is running in standalone mode.",
            "enum": [
              "single"
            ],
            "summary": "Standalone instance",
            "type": "string"
          },
          "server": {
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The MongoDB default port 27017 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "w_mode": {
            "default": "unsafe",
            "description": "Write mode.",
            "enum": [
              "unsafe",
              "safe"
            ],
            "summary": "Write Mode",
            "type": "string"
          },
          "srv_record": {
            "default": false,
            "description": "Use DNS SRV record.",
            "summary": "Srv Record",
            "type": "boolean"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auth_source": {
            "description": "Database name associated with the user's credentials.",
            "summary": "Auth Source",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "topology": {
            "$ref": "#/components/schemas/emqx_connector_mongo.topology"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "emqx_authn_schema.node_metrics": {
        "properties": {
          "node": {
            "description": "Node name.",
            "example": "emqx@127.0.0.1",
            "summary": "Node Name.",
            "type": "string"
          },
          "metrics": {
            "description": "The metrics of the resource.",
            "summary": "Metrics",
            "$ref": "#/components/schemas/emqx_authn_schema.metrics"
          }
        },
        "type": "object"
      },
      "emqx_ee_schema_registry_schema.get_avro": {
        "required": [
          "name",
          "source",
          "type"
        ],
        "properties": {
          "name": {
            "description": "A name for the schema that will serve as its identifier.",
            "summary": "Schema name",
            "type": "string"
          },
          "type": {
            "description": "Schema type.",
            "enum": [
              "avro"
            ],
            "summary": "Schema type",
            "type": "string"
          },
          "source": {
            "description": "Source text for the schema.",
            "example": "{\"a\": [1,true]}",
            "summary": "Schema source",
            "type": "string"
          },
          "description": {
            "default": "",
            "description": "A description for this schema.",
            "summary": "Schema description",
            "type": "string"
          }
        },
        "type": "object"
      },
      "connector-mqtt.ingress_local": {
        "properties": {
          "topic": {
            "description": "Send messages to which topic of the local broker.<br/><br/>Template with variables is allowed.",
            "summary": "Local Topic",
            "type": "string"
          },
          "qos": {
            "default": "${qos}",
            "description": "The QoS of the MQTT message to be sent.<br/><br/>Template with variables is allowed.",
            "summary": "Local QoS",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "example": 0,
                "maximum": 2,
                "minimum": 0,
                "type": "integer"
              }
            ]
          },
          "retain": {
            "default": "${retain}",
            "description": "The 'retain' flag of the MQTT message to be sent.<br/><br/>Template with variables is allowed.",
            "summary": "Retain Flag",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "boolean"
              }
            ]
          },
          "payload": {
            "description": "The payload of the MQTT message to be sent.<br/><br/>Template with variables is allowed.",
            "summary": "Payload",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.dtls_listener": {
        "properties": {
          "id": {
            "description": "Listener ID",
            "type": "string"
          },
          "type": {
            "description": "Listener Type",
            "enum": [
              "dtls"
            ],
            "type": "string"
          },
          "name": {
            "description": "Listener Name",
            "type": "string"
          },
          "running": {
            "description": "Listener Running status",
            "type": "boolean"
          },
          "acceptors": {
            "default": 16,
            "description": "Size of the acceptor pool.",
            "type": "integer"
          },
          "udp_options": {
            "$ref": "#/components/schemas/gateway.udp_opts"
          },
          "enable": {
            "default": true,
            "description": "Enable the listener.",
            "type": "boolean"
          },
          "bind": {
            "description": "The IP address and port that the listener will bind.",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "max_connections": {
            "default": 1024,
            "description": "Maximum number of concurrent connections.",
            "type": "integer"
          },
          "max_conn_rate": {
            "default": 1000,
            "description": "Maximum connections per second.",
            "type": "integer"
          },
          "enable_authn": {
            "default": true,
            "description": "Set <code>true</code> (default) to enable client authentication on this listener. <br/>When set to <code>false</code> clients will be allowed to connect without authentication.",
            "type": "boolean"
          },
          "mountpoint": {
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message is delivered to the subscriber.<br/>The mountpoint is a way that users can use to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,<br/>then the client actually subscribes to the topic `some_tenant/t`.<br/>Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,<br/>the message is routed to all the clients subscribed `some_tenant/t`,<br/>so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.<br/>Variables in mountpoint string:<br/><br/>  - <code>${clientid}</code>: clientid<br/><br/>  - <code>${username}</code>: username",
            "type": "string"
          },
          "access_rules": {
            "default": "",
            "description": "The access control rules for this listener.<br/>See: https://github.com/emqtt/esockd#allowdeny",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "dtls_options": {
            "description": "DTLS socket options",
            "$ref": "#/components/schemas/gateway.dtls_opts"
          }
        },
        "type": "object"
      },
      "bridge_mysql.post": {
        "required": [
          "database",
          "name",
          "server",
          "type"
        ],
        "properties": {
          "type": {
            "description": "The Bridge Type",
            "enum": [
              "mysql"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name, used as a human-readable description of the bridge.",
            "summary": "Bridge Name",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "sql": {
            "default": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, FROM_UNIXTIME(${timestamp}/1000))",
            "description": "SQL Template",
            "format": "sql",
            "summary": "SQL Template",
            "type": "string"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to MySQL. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The MySQL default port 3306 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "default": "root",
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "bridge_webhook.post": {
        "required": [
          "name",
          "type",
          "url"
        ],
        "properties": {
          "type": {
            "description": "The Bridge Type",
            "enum": [
              "webhook"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name, used as a human-readable description of the bridge.",
            "summary": "Bridge Name",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/bridge_webhook.creation_opts"
          },
          "connect_timeout": {
            "default": "15s",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s",
            "summary": "Connect Timeout",
            "type": "string"
          },
          "retry_interval": {
            "deprecated": true,
            "example": "12m",
            "type": "string"
          },
          "pool_type": {
            "default": "random",
            "description": "The type of the pool. Can be one of `random`, `hash`.",
            "enum": [
              "random",
              "hash"
            ],
            "summary": "Pool Type",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "The pool size.",
            "minimum": 1,
            "summary": "Pool Size",
            "type": "integer"
          },
          "enable_pipelining": {
            "default": 100,
            "description": "A positive integer. Whether to send HTTP requests continuously, when set to 1, it means that after each HTTP request is sent, you need to wait for the server to return and then continue to send the next request.",
            "minimum": 1,
            "summary": "HTTP Pipelineing",
            "type": "integer"
          },
          "request": {
            "description": "Configure HTTP request parameters.",
            "summary": "Request",
            "$ref": "#/components/schemas/connector-http.request"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          },
          "url": {
            "description": "The URL of the HTTP Bridge.<br/><br/>Template with variables is allowed in the path, but variables cannot be used in the scheme, host,<br/>or port part.<br/><br/>For example, <code> http://localhost:9901/${topic} </code> is allowed, but<br/><code> http://${host}:9901/message </code> or <code> http://localhost:${port}/message </code><br/>is not allowed.",
            "summary": "HTTP Bridge",
            "type": "string"
          },
          "direction": {
            "deprecated": true,
            "description": "Deprecated, The direction of this bridge, MUST be 'egress'",
            "enum": [
              "egress"
            ],
            "summary": "Bridge Direction",
            "type": "string"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to the HTTP server. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "method": {
            "default": "post",
            "description": "The method of the HTTP request. All the available methods are: post, put, get, delete.<br/><br/>Template with variables is allowed.",
            "enum": [
              "post",
              "put",
              "get",
              "delete"
            ],
            "summary": "HTTP Method",
            "type": "string"
          },
          "headers": {
            "default": {
              "accept": "application/json",
              "cache-control": "no-cache",
              "connection": "keep-alive",
              "content-type": "application/json",
              "keep-alive": "timeout=5"
            },
            "description": "The headers of the HTTP request.<br/><br/>Template with variables is allowed.",
            "example": {},
            "summary": "HTTP Header",
            "type": "object"
          },
          "body": {
            "description": "The body of the HTTP request.<br/><br/>If not provided, the body will be a JSON object of all the available fields.<br/><br/>There, 'all the available fields' means the context of a MQTT message when<br/>this webhook is triggered by receiving a MQTT message (the `local_topic` is set),<br/>or the context of the event when this webhook is triggered by a rule (i.e. this<br/>webhook is used as an action of a rule).<br/><br/>Template with variables is allowed.",
            "summary": "HTTP Body",
            "type": "string"
          },
          "max_retries": {
            "default": 2,
            "description": "HTTP request max retry times if failed.",
            "minimum": 0,
            "summary": "HTTP Request Max Retries",
            "type": "integer"
          },
          "request_timeout": {
            "default": "15s",
            "description": "HTTP request timeout.",
            "example": "32s",
            "summary": "HTTP Request Timeout",
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge_sqlserver.creation_opts": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 0,
            "summary": "Buffer Pool Size",
            "type": "integer"
          },
          "health_check_interval": {
            "default": "15s",
            "description": "Health check interval.",
            "example": "32s",
            "summary": "Health Check Interval",
            "type": "string"
          },
          "start_after_created": {
            "default": "true",
            "description": "Whether start the resource right after created.",
            "summary": "Start After Created",
            "type": "boolean"
          },
          "start_timeout": {
            "default": "5s",
            "description": "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "example": "32s",
            "summary": "Start Timeout",
            "type": "string"
          },
          "auto_restart_interval": {
            "default": "60s",
            "description": "The auto restart interval after the resource is disconnected.",
            "summary": "Auto Restart Interval",
            "oneOf": [
              {
                "example": "32s",
                "type": "string"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "query_mode": {
            "default": "async",
            "description": "Query mode. Optional 'sync/async', default 'async'.",
            "enum": [
              "sync",
              "async"
            ],
            "summary": "Query mode",
            "type": "string"
          },
          "request_timeout": {
            "default": "15s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "summary": "Request Expiry",
            "oneOf": [
              {
                "example": "32s",
                "type": "string"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1,
            "summary": "Inflight window",
            "type": "integer"
          },
          "enable_batch": {
            "default": true,
            "deprecated": true,
            "description": "Batch mode enabled.",
            "summary": "Enable batch",
            "type": "boolean"
          },
          "batch_size": {
            "default": 1,
            "description": "Maximum batch count. If equal to 1, there's effectively no batching.",
            "minimum": 1,
            "summary": "Max batch size",
            "type": "integer"
          },
          "batch_time": {
            "default": "0ms",
            "description": "Maximum waiting interval when accumulating a batch at a low message rates for more efficient resource usage.",
            "example": "32s",
            "summary": "Max batch wait time",
            "type": "string"
          },
          "enable_queue": {
            "default": false,
            "deprecated": true,
            "description": "Enable disk buffer queue (only applicable for egress bridges).<br/>When Enabled, messages will be buffered on disk when the bridge connection is down.<br/>When disabled the messages are buffered in RAM only.",
            "summary": "Enable disk buffer queue",
            "type": "boolean"
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB",
            "summary": "Max buffer queue size",
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge_kafka.auth_gssapi_kerberos": {
        "required": [
          "kerberos_keytab_file",
          "kerberos_principal"
        ],
        "properties": {
          "kerberos_principal": {
            "description": "SASL GSSAPI authentication Kerberos principal. For example <code>client_name@MY.KERBEROS.REALM.MYDOMAIN.COM</code>, NOTE: The realm in use has to be configured in /etc/krb5.conf in EMQX nodes.",
            "summary": "Kerberos Principal",
            "type": "string"
          },
          "kerberos_keytab_file": {
            "description": "SASL GSSAPI authentication Kerberos keytab file path. NOTE: This file has to be placed in EMQX nodes, and the EMQX service runner user requires read permission.",
            "summary": "Kerberos keytab file",
            "type": "string"
          }
        },
        "type": "object"
      },
      "authn-builtin_db.authentication": {
        "required": [
          "backend",
          "mechanism",
          "user_id_type"
        ],
        "properties": {
          "mechanism": {
            "description": "Authentication mechanism.",
            "enum": [
              "password_based"
            ],
            "summary": "Authentication Mechanism",
            "type": "string"
          },
          "backend": {
            "description": "Backend type.",
            "enum": [
              "built_in_database"
            ],
            "summary": "Backend Type",
            "type": "string"
          },
          "user_id_type": {
            "default": "username",
            "description": "Specify whether to use `clientid` or `username` for authentication.",
            "enum": [
              "clientid",
              "username"
            ],
            "summary": "Authentication ID Type",
            "type": "string"
          },
          "password_hash_algorithm": {
            "default": {
              "name": "sha256",
              "salt_position": "prefix"
            },
            "description": "Options for password hash creation and verification.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn-hash.simple"
              },
              {
                "$ref": "#/components/schemas/authn-hash.pbkdf2"
              },
              {
                "$ref": "#/components/schemas/authn-hash.bcrypt_rw"
              }
            ]
          },
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
            "summary": "Enable",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "bridge_redis.put_single": {
        "required": [
          "command_template",
          "server"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to Redis. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "command_template": {
            "description": "Redis command template used to export messages. Each list element stands for a command name or its argument.<br/>For example, to push payloads in a Redis list by key `msgs`, the elements should be the following:<br/>`rpush`, `msgs`, `${payload}`.",
            "items": {
              "type": "string"
            },
            "summary": "Redis Command Template",
            "type": "array"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/bridge_redis.creation_opts_redis_single"
          },
          "server": {
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The Redis default port 6379 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "redis_type": {
            "default": "single",
            "description": "Single mode. Must be set to 'single' when Redis server is running in single mode.",
            "enum": [
              "single"
            ],
            "summary": "Single Mode",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "database": {
            "default": 0,
            "description": "Redis database ID.",
            "summary": "Database ID",
            "type": "integer"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "dashboard.user": {
        "properties": {
          "username": {
            "description": "Dashboard Username",
            "example": "admin",
            "maxLength": 100,
            "type": "string"
          },
          "description": {
            "description": "Dashboard User Description",
            "example": "administrator",
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge_kafka.get_consumer": {
        "required": [
          "bootstrap_hosts",
          "name",
          "topic_mapping",
          "type"
        ],
        "properties": {
          "status": {
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status.",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary": "Bridge Status",
            "type": "string"
          },
          "status_reason": {
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused",
            "summary": "Failure reason",
            "type": "string"
          },
          "node_status": {
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            },
            "summary": "Node Status",
            "type": "array"
          },
          "type": {
            "description": "The Bridge Type",
            "enum": [
              "kafka_consumer",
              "kafka"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name, used as a human-readable description of the bridge.",
            "summary": "Bridge Name",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable (true) or disable (false) this Kafka bridge.",
            "summary": "Enable or Disable",
            "type": "boolean"
          },
          "bootstrap_hosts": {
            "description": "A comma separated list of Kafka <code>host[:port]</code> endpoints to bootstrap the client. Default port number is 9092.",
            "summary": "Bootstrap Hosts",
            "type": "string"
          },
          "connect_timeout": {
            "default": "5s",
            "description": "Maximum wait time for TCP connection establishment (including authentication time if enabled).",
            "example": "32s",
            "summary": "Connect Timeout",
            "type": "string"
          },
          "min_metadata_refresh_interval": {
            "default": "3s",
            "description": "Minimum time interval the client has to wait before refreshing Kafka broker and topic metadata. Setting too small value may add extra load on Kafka.",
            "example": "32s",
            "summary": "Min Metadata Refresh Interval",
            "type": "string"
          },
          "metadata_request_timeout": {
            "default": "5s",
            "description": "Maximum wait time when fetching metadata from Kafka.",
            "example": "32s",
            "summary": "Metadata Request Timeout",
            "type": "string"
          },
          "authentication": {
            "default": "none",
            "description": "Authentication configs.",
            "summary": "Authentication",
            "oneOf": [
              {
                "$ref": "#/components/schemas/bridge_kafka.auth_gssapi_kerberos"
              },
              {
                "$ref": "#/components/schemas/bridge_kafka.auth_username_password"
              },
              {
                "enum": [
                  "none"
                ],
                "type": "string"
              }
            ]
          },
          "socket_opts": {
            "description": "Extra socket options.",
            "summary": "Socket Options",
            "$ref": "#/components/schemas/bridge_kafka.socket_opts"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          },
          "kafka": {
            "description": "Kafka consumer configs.",
            "summary": "Kafka Consumer",
            "$ref": "#/components/schemas/bridge_kafka.consumer_kafka_opts"
          },
          "topic_mapping": {
            "description": "Defines the mapping between Kafka topics and MQTT topics. Must contain at least one item.",
            "items": {
              "$ref": "#/components/schemas/bridge_kafka.consumer_topic_mapping"
            },
            "summary": "Topic Mapping",
            "type": "array"
          },
          "key_encoding_mode": {
            "default": "none",
            "description": "Defines how the key from the Kafka message is encoded before being forwarded via MQTT.<br/><code>none</code> Uses the key from the Kafka message unchanged.  Note: in this case, the key must be a valid UTF-8 string.<br/><code>base64</code> Uses base-64 encoding on the received key.",
            "enum": [
              "none",
              "base64"
            ],
            "summary": "Key Encoding Mode",
            "type": "string"
          },
          "value_encoding_mode": {
            "default": "none",
            "description": "Defines how the value from the Kafka message is encoded before being forwarded via MQTT.<br/><code>none</code> Uses the value from the Kafka message unchanged.  Note: in this case, the value must be a valid UTF-8 string.<br/><code>base64</code> Uses base-64 encoding on the received value.",
            "enum": [
              "none",
              "base64"
            ],
            "summary": "Value Encoding Mode",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api_clients.lwm2m_client": {
        "properties": {
          "endpoint_name": {
            "description": "The LwM2M client endpoint name",
            "type": "string"
          },
          "lifetime": {
            "description": "LwM2M Life time",
            "type": "integer"
          },
          "node": {
            "description": "Name of the node to which the client is connected",
            "type": "string"
          },
          "clientid": {
            "description": "Client ID",
            "type": "string"
          },
          "username": {
            "description": "Username of client when connecting",
            "type": "string"
          },
          "mountpoint": {
            "description": "Topic mountpoint",
            "type": "string"
          },
          "proto_name": {
            "description": "Client protocol name",
            "type": "string"
          },
          "proto_ver": {
            "description": "Protocol version used by the client",
            "type": "string"
          },
          "ip_address": {
            "description": "Client's IP address",
            "type": "string"
          },
          "port": {
            "description": "Client's port",
            "type": "integer"
          },
          "is_bridge": {
            "description": "Indicates whether the client is connected via bridge",
            "type": "boolean"
          },
          "connected_at": {
            "description": "Client connection time",
            "oneOf": [
              {
                "description": "epoch-millisecond",
                "example": 1640995200000,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "disconnected_at": {
            "description": "Client offline time, This field is only valid and returned when connected is false",
            "oneOf": [
              {
                "description": "epoch-millisecond",
                "example": 1640995200000,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "connected": {
            "description": "Whether the client is connected",
            "type": "boolean"
          },
          "keepalive": {
            "description": "Keepalive time, with the unit of second",
            "type": "integer"
          },
          "clean_start": {
            "description": "Indicate whether the client is using a brand new session",
            "type": "boolean"
          },
          "expiry_interval": {
            "description": "Session expiration interval, with the unit of second",
            "type": "integer"
          },
          "created_at": {
            "description": "Session creation time",
            "oneOf": [
              {
                "description": "epoch-millisecond",
                "example": 1640995200000,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "subscriptions_cnt": {
            "description": "Number of subscriptions established by this client",
            "type": "integer"
          },
          "subscriptions_max": {
            "description": "Maximum number of subscriptions allowed by this client",
            "type": "integer"
          },
          "inflight_cnt": {
            "description": "Current length of inflight",
            "type": "integer"
          },
          "inflight_max": {
            "description": "Maximum length of inflight",
            "type": "integer"
          },
          "mqueue_len": {
            "description": "Current length of message queue",
            "type": "integer"
          },
          "mqueue_max": {
            "description": "Maximum length of message queue",
            "type": "integer"
          },
          "mqueue_dropped": {
            "description": "Number of messages dropped by the message queue due to exceeding the length",
            "type": "integer"
          },
          "awaiting_rel_cnt": {
            "description": "Number of awaiting acknowledge packet",
            "type": "integer"
          },
          "awaiting_rel_max": {
            "description": "Maximum allowed number of awaiting PUBREC packet",
            "type": "integer"
          },
          "recv_oct": {
            "description": "Number of bytes received",
            "type": "integer"
          },
          "recv_cnt": {
            "description": "Number of socket packets received",
            "type": "integer"
          },
          "recv_pkt": {
            "description": "Number of protocol packets received",
            "type": "integer"
          },
          "recv_msg": {
            "description": "Number of message packets received",
            "type": "integer"
          },
          "send_oct": {
            "description": "Number of bytes sent",
            "type": "integer"
          },
          "send_cnt": {
            "description": "Number of socket packets sent",
            "type": "integer"
          },
          "send_pkt": {
            "description": "Number of protocol packets sent",
            "type": "integer"
          },
          "send_msg": {
            "description": "Number of message packets sent",
            "type": "integer"
          },
          "mailbox_len": {
            "description": "Process mailbox size",
            "type": "integer"
          },
          "heap_size": {
            "description": "Process heap size with the unit of byte",
            "type": "integer"
          },
          "reductions": {
            "description": "Erlang reduction",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "bridge_webhook.put": {
        "required": [
          "url"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/bridge_webhook.creation_opts"
          },
          "connect_timeout": {
            "default": "15s",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s",
            "summary": "Connect Timeout",
            "type": "string"
          },
          "retry_interval": {
            "deprecated": true,
            "example": "12m",
            "type": "string"
          },
          "pool_type": {
            "default": "random",
            "description": "The type of the pool. Can be one of `random`, `hash`.",
            "enum": [
              "random",
              "hash"
            ],
            "summary": "Pool Type",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "The pool size.",
            "minimum": 1,
            "summary": "Pool Size",
            "type": "integer"
          },
          "enable_pipelining": {
            "default": 100,
            "description": "A positive integer. Whether to send HTTP requests continuously, when set to 1, it means that after each HTTP request is sent, you need to wait for the server to return and then continue to send the next request.",
            "minimum": 1,
            "summary": "HTTP Pipelineing",
            "type": "integer"
          },
          "request": {
            "description": "Configure HTTP request parameters.",
            "summary": "Request",
            "$ref": "#/components/schemas/connector-http.request"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          },
          "url": {
            "description": "The URL of the HTTP Bridge.<br/><br/>Template with variables is allowed in the path, but variables cannot be used in the scheme, host,<br/>or port part.<br/><br/>For example, <code> http://localhost:9901/${topic} </code> is allowed, but<br/><code> http://${host}:9901/message </code> or <code> http://localhost:${port}/message </code><br/>is not allowed.",
            "summary": "HTTP Bridge",
            "type": "string"
          },
          "direction": {
            "deprecated": true,
            "description": "Deprecated, The direction of this bridge, MUST be 'egress'",
            "enum": [
              "egress"
            ],
            "summary": "Bridge Direction",
            "type": "string"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to the HTTP server. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "method": {
            "default": "post",
            "description": "The method of the HTTP request. All the available methods are: post, put, get, delete.<br/><br/>Template with variables is allowed.",
            "enum": [
              "post",
              "put",
              "get",
              "delete"
            ],
            "summary": "HTTP Method",
            "type": "string"
          },
          "headers": {
            "default": {
              "accept": "application/json",
              "cache-control": "no-cache",
              "connection": "keep-alive",
              "content-type": "application/json",
              "keep-alive": "timeout=5"
            },
            "description": "The headers of the HTTP request.<br/><br/>Template with variables is allowed.",
            "example": {},
            "summary": "HTTP Header",
            "type": "object"
          },
          "body": {
            "description": "The body of the HTTP request.<br/><br/>If not provided, the body will be a JSON object of all the available fields.<br/><br/>There, 'all the available fields' means the context of a MQTT message when<br/>this webhook is triggered by receiving a MQTT message (the `local_topic` is set),<br/>or the context of the event when this webhook is triggered by a rule (i.e. this<br/>webhook is used as an action of a rule).<br/><br/>Template with variables is allowed.",
            "summary": "HTTP Body",
            "type": "string"
          },
          "max_retries": {
            "default": 2,
            "description": "HTTP request max retry times if failed.",
            "minimum": 0,
            "summary": "HTTP Request Max Retries",
            "type": "integer"
          },
          "request_timeout": {
            "default": "15s",
            "description": "HTTP request timeout.",
            "example": "32s",
            "summary": "HTTP Request Timeout",
            "type": "string"
          }
        },
        "type": "object"
      },
      "auto_subscribe.topic": {
        "required": [
          "topic"
        ],
        "properties": {
          "topic": {
            "description": "Topic name, placeholders are supported. For example: client/${clientid}/username/${username}/host/${host}/port/${port}<br/>Required field, and cannot be empty string",
            "example": "/clientid/${clientid}/username/${username}/host/${host}/port/${port}",
            "summary": "Topic",
            "type": "string"
          },
          "qos": {
            "default": 0,
            "description": "Default value 0. Quality of service.<br/>At most once (0)<br/>At least once (1)<br/>Exactly once (2)",
            "example": 0,
            "maximum": 2,
            "minimum": 0,
            "summary": "Quality of Service",
            "type": "integer"
          },
          "rh": {
            "default": 0,
            "description": "Default value 0. This option is used to specify whether the server forwards the retained message to the client when establishing a subscription.<br/>Retain Handling is equal to 0, as long as the client successfully subscribes, the server will send the retained message.<br/>Retain Handling is equal to 1, if the client successfully subscribes and this subscription does not exist previously, the server sends the retained message. After all, sometimes the client re-initiate the subscription just to change the QoS, but it does not mean that it wants to receive the reserved messages again.<br/>Retain Handling is equal to 2, even if the client successfully subscribes, the server does not send the retained message.",
            "maximum": 2,
            "minimum": 0,
            "summary": "Retain Handling",
            "type": "integer"
          },
          "rap": {
            "default": 0,
            "description": "Default value 0. This option is used to specify whether the server retains the RETAIN mark when forwarding messages to the client, and this option does not affect the RETAIN mark in the retained message. Therefore, when the option Retain As Publish is set to 0, the client will directly distinguish whether this is a normal forwarded message or a retained message according to the RETAIN mark in the message, instead of judging whether this message is the first received after subscribing(the forwarded message may be sent before the retained message, which depends on the specific implementation of different brokers).",
            "maximum": 1,
            "minimum": 0,
            "summary": "Retain As Publish",
            "type": "integer"
          },
          "nl": {
            "default": 0,
            "description": "Default value 0.<br/>MQTT v3.1.1： if you subscribe to the topic published by yourself, you will receive all messages that you published.<br/>MQTT v5: if you set this option as 1 when subscribing, the server will not forward the message you published to you.",
            "maximum": 1,
            "minimum": 0,
            "summary": "No Local",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "bridge_kafka.consumer_kafka_opts": {
        "properties": {
          "max_batch_bytes": {
            "default": "896KB",
            "description": "Set how many bytes to pull from Kafka in each fetch request. Please note that if the configured value is smaller than the message size in Kafka, it may negatively impact the fetch performance.",
            "example": "32MB",
            "summary": "Fetch Bytes",
            "type": "string"
          },
          "offset_reset_policy": {
            "default": "latest",
            "description": "Defines from which offset a consumer should start fetching when there is no commit history or when the commit history becomes invalid.",
            "enum": [
              "latest",
              "earliest"
            ],
            "summary": "Offset Reset Policy",
            "type": "string"
          },
          "offset_commit_interval_seconds": {
            "default": 5,
            "description": "Defines the time interval between two offset commit requests sent for each consumer group.",
            "minimum": 1,
            "summary": "Offset Commit Interval",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "broker.listener_ssl_opts": {
        "properties": {
          "cacertfile": {
            "description": "Trusted PEM format CA certificates bundle file.<br/><br/>The certificates in this file are used to verify the TLS peer's certificates.<br/>Append new certificates to the file if new CAs are to be trusted.<br/>There is no need to restart EMQX to have the updated file loaded, because<br/>the system regularly checks if file has been updated (and reload).<br/><br/>NOTE: invalidating (deleting) a certificate from the file will not affect<br/>already established connections.",
            "summary": "CACertfile",
            "type": "string"
          },
          "certfile": {
            "description": "PEM format certificates chain file.<br/><br/>The certificates in this file should be in reversed order of the certificate<br/>issue chain. That is, the host's certificate should be placed in the beginning<br/>of the file, followed by the immediate issuer certificate and so on.<br/>Although the root CA certificate is optional, it should be placed at the end of<br/>the file if it is to be added.",
            "summary": "Certfile",
            "type": "string"
          },
          "keyfile": {
            "description": "PEM format private key file.",
            "summary": "Keyfile",
            "type": "string"
          },
          "verify": {
            "default": "verify_none",
            "description": "Enable or disable peer verification.",
            "enum": [
              "verify_peer",
              "verify_none"
            ],
            "summary": "Verify peer",
            "type": "string"
          },
          "reuse_sessions": {
            "default": true,
            "description": "Enable TLS session reuse.",
            "summary": "TLS session reuse",
            "type": "boolean"
          },
          "depth": {
            "default": 10,
            "description": "Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path.<br/>So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly;<br/><br/>if 1 the path can be PEER, Intermediate-CA, ROOT-CA;<br/><br/>if 2 the path can be PEER, Intermediate-CA1, Intermediate-CA2, ROOT-CA.",
            "summary": "CACert Depth",
            "type": "integer"
          },
          "password": {
            "description": "String containing the user's password. Only used if the private key file is password-protected.",
            "example": "",
            "format": "password",
            "summary": "Keyfile passphrase",
            "type": "string"
          },
          "versions": {
            "default": [
              "tlsv1.3",
              "tlsv1.2",
              "tlsv1.1",
              "tlsv1"
            ],
            "description": "All TLS/DTLS versions to be supported.<br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.<br/><br/>In case PSK cipher suites are intended, make sure to configure<br/><code>['tlsv1.2', 'tlsv1.1']</code> here.",
            "items": {
              "type": "string"
            },
            "summary": "SSL versions",
            "type": "array"
          },
          "ciphers": {
            "default": "",
            "description": "This config holds TLS cipher suite names separated by comma,<br/>or as an array of strings. e.g.<br/><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or<br/><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.<br/><br/><br/>Ciphers (and their ordering) define the way in which the<br/>client and server encrypts information over the network connection.<br/>Selecting a good cipher suite is critical for the<br/>application's data security, confidentiality and performance.<br/><br/>The names should be in OpenSSL string format (not RFC format).<br/>All default values and examples provided by EMQX config<br/>documentation are all in OpenSSL format.<br/><br/><br/>NOTE: Certain cipher suites are only compatible with<br/>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')<br/>incompatible cipher suites will be silently dropped.<br/>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,<br/>configuring cipher suites for other versions will have no effect.<br/><br/><br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br/><br/>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.<br/><br/>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,<br/>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,<br/>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,<br/>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code>",
            "items": {
              "type": "string"
            },
            "summary": "",
            "type": "array"
          },
          "secure_renegotiate": {
            "default": true,
            "description": "SSL parameter renegotiation is a feature that allows a client and a server<br/>to renegotiate the parameters of the SSL connection on the fly.<br/>RFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,<br/>you drop support for the insecure renegotiation, prone to MitM attacks.",
            "summary": "SSL renegotiate",
            "type": "boolean"
          },
          "hibernate_after": {
            "default": "5s",
            "description": "Hibernate the SSL process after idling for amount of time reducing its memory footprint.",
            "example": "12m",
            "summary": "hibernate after",
            "type": "string"
          },
          "dhfile": {
            "description": "Path to a file containing PEM-encoded Diffie-Hellman parameters<br/>to be used by the server if a cipher suite using Diffie-Hellman<br/>key exchange is negotiated. If not specified, default parameters<br/>are used.<br/><br/>NOTE: The <code>dhfile</code> option is not supported by TLS 1.3.",
            "summary": "SSL dhfile",
            "type": "string"
          },
          "fail_if_no_peer_cert": {
            "default": false,
            "description": "Used together with {verify, verify_peer} by an TLS/DTLS server.<br/>If set to true, the server fails if the client does not have a<br/>certificate to send, that is, sends an empty certificate.<br/>If set to false, it fails only if the client sends an invalid<br/>certificate (an empty certificate is considered valid).",
            "summary": "SSL fail if no peer cert",
            "type": "boolean"
          },
          "honor_cipher_order": {
            "default": true,
            "description": "An important security setting, it forces the cipher to be set based<br/> on the server-specified order instead of the client-specified order,<br/> hence enforcing the (usually more properly configured) security<br/> ordering of the server administrator.",
            "summary": "SSL honor cipher order",
            "type": "boolean"
          },
          "client_renegotiation": {
            "default": true,
            "description": "In protocols that support client-initiated renegotiation,<br/>the cost of resources of such an operation is higher for the server than the client.<br/>This can act as a vector for denial of service attacks.<br/>The SSL application already takes measures to counter-act such attempts,<br/>but client-initiated renegotiation can be strictly disabled by setting this option to false.<br/>The default value is true. Note that disabling renegotiation can result in<br/>long-lived connections becoming unusable due to limits on<br/>the number of messages the underlying cipher suite can encipher.",
            "summary": "SSL client renegotiation",
            "type": "boolean"
          },
          "handshake_timeout": {
            "default": "15s",
            "description": "Maximum time duration allowed for the handshake to complete",
            "example": "12m",
            "summary": "Handshake timeout",
            "type": "string"
          },
          "gc_after_handshake": {
            "default": false,
            "description": "Memory usage tuning. If enabled, will immediately perform a garbage collection after the TLS/SSL handshake.",
            "summary": "Perform GC after handshake",
            "type": "boolean"
          },
          "ocsp": {
            "$ref": "#/components/schemas/broker.ocsp"
          },
          "enable_crl_check": {
            "default": false,
            "description": "Whether to enable CRL verification for this listener.",
            "summary": "Enable CRL Check",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.exproto": {
        "required": [
          "handler",
          "server"
        ],
        "properties": {
          "name": {
            "description": "Gateway Name",
            "enum": [
              "exproto"
            ],
            "type": "string"
          },
          "server": {
            "description": "Configurations for starting the <code>ConnectionAdapter</code> service",
            "$ref": "#/components/schemas/emqx_exproto_schema.exproto_grpc_server"
          },
          "handler": {
            "description": "Configurations for request to <code>ConnectionHandler</code> service",
            "$ref": "#/components/schemas/emqx_exproto_schema.exproto_grpc_handler"
          },
          "mountpoint": {
            "default": "",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message is delivered to the subscriber.<br/>The mountpoint is a way that users can use to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,<br/>then the client actually subscribes to the topic `some_tenant/t`.<br/>Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,<br/>the message is routed to all the clients subscribed `some_tenant/t`,<br/>so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.<br/>Variables in mountpoint string:<br/><br/>  - <code>${clientid}</code>: clientid<br/><br/>  - <code>${username}</code>: username",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Whether to enable this gateway",
            "type": "boolean"
          },
          "enable_stats": {
            "default": true,
            "description": "Whether to enable client process statistic",
            "type": "boolean"
          },
          "idle_timeout": {
            "default": "30s",
            "description": "The idle time of the client connection process. It has two purposes:<br/>  1. A newly created client process that does not receive any client requests after that time will be closed directly.<br/>  2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.",
            "example": "12m",
            "type": "string"
          },
          "clientinfo_override": {
            "description": "ClientInfo override.",
            "$ref": "#/components/schemas/gateway.clientinfo_override"
          },
          "listeners": {
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/emqx_gateway_api.dtls_listener"
                },
                {
                  "$ref": "#/components/schemas/emqx_gateway_api.udp_listener"
                },
                {
                  "$ref": "#/components/schemas/emqx_gateway_api.ssl_listener"
                },
                {
                  "$ref": "#/components/schemas/emqx_gateway_api.tcp_listener"
                }
              ]
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "bridge_rocketmq.put": {
        "required": [
          "servers"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "template": {
            "default": "",
            "description": "Template, the default value is empty. When this value is empty the whole message will be stored in the RocketMQ.<br><br/>            The template can be any valid string with placeholders, example:<br><br/>            - ${id}, ${username}, ${clientid}, ${timestamp}<br><br/>            - {\"id\" : ${id}, \"username\" : ${username}}",
            "summary": "Template",
            "type": "string"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to RocketMQ. All MQTT `PUBLISH` messages with the topic<br/>matching the `local_topic` will be forwarded.</br><br/>NOTE: if the bridge is used as a rule action, `local_topic` should be left empty otherwise the messages will be duplicated.",
            "summary": "Local Topic",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "servers": {
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The RocketMQ default port 9876 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "topic": {
            "default": "TopicTest",
            "description": "RocketMQ Topic",
            "summary": "RocketMQ Topic",
            "type": "string"
          },
          "access_key": {
            "default": "",
            "description": "RocketMQ server `accessKey`.",
            "summary": "AccessKey",
            "type": "string"
          },
          "secret_key": {
            "default": "",
            "description": "RocketMQ server `secretKey`.",
            "summary": "SecretKey",
            "type": "string"
          },
          "security_token": {
            "default": "",
            "description": "RocketMQ Server Security Token",
            "summary": "Security Token",
            "type": "string"
          },
          "sync_timeout": {
            "default": "3s",
            "description": "Timeout of RocketMQ driver synchronous call.",
            "example": "12m",
            "summary": "Sync Timeout",
            "type": "string"
          },
          "refresh_interval": {
            "default": "3s",
            "description": "RocketMQ Topic Route Refresh Interval.",
            "example": "12m",
            "summary": "Topic Route Refresh Interval",
            "type": "string"
          },
          "send_buffer": {
            "default": "1024KB",
            "description": "The socket send buffer size of the RocketMQ driver client.",
            "example": "32MB",
            "summary": "Send Buffer Size",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "bridge_cassa.post": {
        "required": [
          "keyspace",
          "name",
          "servers",
          "type"
        ],
        "properties": {
          "type": {
            "description": "The Bridge Type",
            "enum": [
              "cassandra"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name.",
            "summary": "Bridge Name",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "cql": {
            "default": "insert into mqtt_msg(topic, msgid, sender, qos, payload, arrived, retain) values (${topic}, ${id}, ${clientid}, ${qos}, ${payload}, ${timestamp}, ${flags.retain})",
            "description": "CQL Template",
            "format": "sql",
            "summary": "CQL Template",
            "type": "string"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to Cassandra. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "servers": {
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port][,Host2:Port]`.<br/><br/>The Cassandra default port 9042 is used if `[:Port]` is not specified.",
            "summary": "Servers",
            "type": "string"
          },
          "keyspace": {
            "description": "Keyspace name to connect to.",
            "summary": "Keyspace",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "rule_engine.user_provided_function": {
        "required": [
          "function"
        ],
        "properties": {
          "function": {
            "description": "The user provided function. Should be in the format: '{module}:{function}'.<br/>Where {module} is the Erlang callback module and {function} is the Erlang function.<br/><br/>To write your own function, checkout the function <code>console</code> and<br/><code>republish</code> in the source file:<br/><code>apps/emqx_rule_engine/src/emqx_rule_actions.erl</code> as an example.",
            "example": "module:function",
            "summary": "User Provided Function",
            "type": "string"
          },
          "args": {
            "default": {},
            "description": "The args will be passed as the 3rd argument to module:function/3,<br/>checkout the function <code>console</code> and <code>republish</code> in the source file:<br/><code>apps/emqx_rule_engine/src/emqx_rule_actions.erl</code> as an example.",
            "example": {},
            "summary": "User Provided Function Args",
            "type": "object"
          }
        },
        "type": "object"
      },
      "emqx_authn_schema.node_resource_metrics": {
        "properties": {
          "node": {
            "description": "Node name.",
            "example": "emqx@127.0.0.1",
            "summary": "Node Name.",
            "type": "string"
          },
          "metrics": {
            "description": "The metrics of the resource.",
            "summary": "Metrics",
            "$ref": "#/components/schemas/emqx_authn_schema.resource_metrics"
          }
        },
        "type": "object"
      },
      "bridge_tdengine.get": {
        "required": [
          "database",
          "name",
          "password",
          "server",
          "type"
        ],
        "properties": {
          "status": {
            "description": "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status.",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary": "Bridge Status",
            "type": "string"
          },
          "status_reason": {
            "description": "This is the reason given in case a bridge is failing to connect.",
            "example": "Connection refused",
            "summary": "Failure reason",
            "type": "string"
          },
          "node_status": {
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            },
            "summary": "Node Status",
            "type": "array"
          },
          "type": {
            "description": "The Bridge Type",
            "enum": [
              "tdengine"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name.",
            "summary": "Bridge Name",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "sql": {
            "default": "insert into t_mqtt_msg(ts, msgid, mqtt_topic, qos, payload, arrived) values (${ts}, ${id}, ${topic}, ${qos}, ${payload}, ${timestamp})",
            "description": "SQL Template",
            "format": "sql",
            "summary": "SQL Template",
            "type": "string"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to TDengine. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The TDengine default port 6041 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "default": "root",
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "listeners.quic_required_bind(with_name)": {
        "required": [
          "bind",
          "name",
          "type"
        ],
        "properties": {
          "type": {
            "description": "Listener type",
            "enum": [
              "quic"
            ],
            "type": "string"
          },
          "running": {
            "description": "Listener status",
            "type": "boolean"
          },
          "name": {
            "description": "Listener name",
            "type": "string"
          },
          "current_connections": {
            "description": "Current connections",
            "minimum": 0,
            "type": "integer"
          },
          "certfile": {
            "description": "Path to the certificate file. Will be deprecated in 5.1, use .ssl_options.certfile instead.",
            "summary": "Certificate file",
            "type": "string"
          },
          "keyfile": {
            "description": "Path to the secret key file. Will be deprecated in 5.1, use .ssl_options.keyfile instead.",
            "summary": "Key file",
            "type": "string"
          },
          "ciphers": {
            "default": [
              "TLS_AES_256_GCM_SHA384",
              "TLS_AES_128_GCM_SHA256",
              "TLS_CHACHA20_POLY1305_SHA256"
            ],
            "description": "This config holds TLS cipher suite names separated by comma,<br/>or as an array of strings. e.g.<br/><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or<br/><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.<br/><br/><br/>Ciphers (and their ordering) define the way in which the<br/>client and server encrypts information over the network connection.<br/>Selecting a good cipher suite is critical for the<br/>application's data security, confidentiality and performance.<br/><br/>The names should be in OpenSSL string format (not RFC format).<br/>All default values and examples provided by EMQX config<br/>documentation are all in OpenSSL format.<br/><br/><br/>NOTE: Certain cipher suites are only compatible with<br/>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')<br/>incompatible cipher suites will be silently dropped.<br/>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,<br/>configuring cipher suites for other versions will have no effect.<br/><br/><br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br/><br/>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.<br/><br/>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,<br/>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,<br/>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,<br/>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code><br/><br/><br/>NOTE: QUIC listener supports only 'tlsv1.3' ciphers",
            "items": {
              "type": "string"
            },
            "summary": "",
            "type": "array"
          },
          "idle_timeout": {
            "default": 0,
            "description": "How long a connection can go idle before it is gracefully shut down. 0 to disable",
            "example": "32s",
            "summary": "Idle Timeout",
            "type": "string"
          },
          "handshake_idle_timeout": {
            "default": "10s",
            "description": "How long a handshake can idle before it is discarded.",
            "example": "32s",
            "summary": "Handshake Idle Timeout",
            "type": "string"
          },
          "keep_alive_interval": {
            "default": 0,
            "description": "How often to send PING frames to keep a connection alive. 0 means disabled.",
            "example": "32s",
            "summary": "Keep Alive Interval",
            "type": "string"
          },
          "ssl_options": {
            "description": "TLS options for QUIC transport",
            "summary": "TLS Options",
            "$ref": "#/components/schemas/broker.listener_quic_ssl_opts"
          },
          "enabled": {
            "default": true,
            "description": "Enable listener.",
            "summary": "Enable listener",
            "type": "boolean"
          },
          "bind": {
            "default": 14567,
            "description": "IP address and port for the listening socket.",
            "summary": "IP address and port",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "acceptors": {
            "default": 16,
            "description": "The size of the listener's receiving pool.",
            "minimum": 1,
            "summary": "Acceptors Num",
            "type": "integer"
          },
          "max_connections": {
            "default": 5000000,
            "description": "The maximum number of concurrent connections allowed by the listener.",
            "summary": "Max connections",
            "oneOf": [
              {
                "minimum": 1,
                "type": "integer"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message<br/>is delivered to the subscriber. The mountpoint is a way that users can use<br/>to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`<br/>set to `some_tenant`, then the client actually subscribes to the topic<br/>`some_tenant/t`. Similarly, if another client B (connected to the same listener<br/>as the client A) sends a message to topic `t`, the message is routed<br/>to all the clients subscribed `some_tenant/t`, so client A will receive the<br/>message, with topic name `t`.<br/><br/>Set to `\"\"` to disable the feature.<br/><br/><br/>Variables in mountpoint string:<br/>  - <code>${clientid}</code>: clientid<br/>  - <code>${username}</code>: username",
            "summary": "mountpoint",
            "type": "string"
          },
          "zone": {
            "default": "default",
            "description": "The configuration zone to which the listener belongs.",
            "summary": "Zone",
            "type": "string"
          },
          "limiter": {
            "description": "Type of the rate limit.",
            "summary": "Type of the rate limit.",
            "$ref": "#/components/schemas/limiter.listener_fields"
          },
          "enable_authn": {
            "default": true,
            "description": "Set <code>true</code> (default) to enable client authentication on this listener, the authentication<br/>process goes through the configured authentication chain.<br/>When set to <code>false</code> to allow any clients with or without authentication information such as username or password to log in.<br/>When set to <code>quick_deny_anonymous</code>, it behaves like when set to <code>true</code>, but clients will be<br/>denied immediately without going through any authenticators if <code>username</code> is not provided. This is useful to fence off<br/>anonymous clients early.",
            "enum": [
              true,
              false,
              "quick_deny_anonymous"
            ],
            "summary": "Enable authentication",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.udp_listener": {
        "properties": {
          "id": {
            "description": "Listener ID",
            "type": "string"
          },
          "type": {
            "description": "Listener Type",
            "enum": [
              "udp"
            ],
            "type": "string"
          },
          "name": {
            "description": "Listener Name",
            "type": "string"
          },
          "running": {
            "description": "Listener Running status",
            "type": "boolean"
          },
          "udp_options": {
            "$ref": "#/components/schemas/gateway.udp_opts"
          },
          "enable": {
            "default": true,
            "description": "Enable the listener.",
            "type": "boolean"
          },
          "bind": {
            "description": "The IP address and port that the listener will bind.",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "max_connections": {
            "default": 1024,
            "description": "Maximum number of concurrent connections.",
            "type": "integer"
          },
          "max_conn_rate": {
            "default": 1000,
            "description": "Maximum connections per second.",
            "type": "integer"
          },
          "enable_authn": {
            "default": true,
            "description": "Set <code>true</code> (default) to enable client authentication on this listener. <br/>When set to <code>false</code> clients will be allowed to connect without authentication.",
            "type": "boolean"
          },
          "mountpoint": {
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message is delivered to the subscriber.<br/>The mountpoint is a way that users can use to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,<br/>then the client actually subscribes to the topic `some_tenant/t`.<br/>Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,<br/>the message is routed to all the clients subscribed `some_tenant/t`,<br/>so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.<br/>Variables in mountpoint string:<br/><br/>  - <code>${clientid}</code>: clientid<br/><br/>  - <code>${username}</code>: username",
            "type": "string"
          },
          "access_rules": {
            "default": "",
            "description": "The access control rules for this listener.<br/>See: https://github.com/emqtt/esockd#allowdeny",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api_listeners.tcp_listener": {
        "properties": {
          "id": {
            "description": "Listener ID",
            "type": "string"
          },
          "type": {
            "description": "Listener Type",
            "enum": [
              "tcp"
            ],
            "type": "string"
          },
          "name": {
            "description": "Listener Name",
            "type": "string"
          },
          "running": {
            "description": "Listener Running status",
            "type": "boolean"
          },
          "acceptors": {
            "default": 16,
            "description": "Size of the acceptor pool.",
            "type": "integer"
          },
          "tcp_options": {
            "description": "Setting the TCP socket options.",
            "$ref": "#/components/schemas/broker.tcp_opts"
          },
          "proxy_protocol": {
            "default": false,
            "description": "Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.<br/>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/",
            "type": "boolean"
          },
          "proxy_protocol_timeout": {
            "default": "15s",
            "description": "Timeout for proxy protocol.<br/>EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.",
            "example": "12m",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable the listener.",
            "type": "boolean"
          },
          "bind": {
            "description": "The IP address and port that the listener will bind.",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "max_connections": {
            "default": 1024,
            "description": "Maximum number of concurrent connections.",
            "type": "integer"
          },
          "max_conn_rate": {
            "default": 1000,
            "description": "Maximum connections per second.",
            "type": "integer"
          },
          "enable_authn": {
            "default": true,
            "description": "Set <code>true</code> (default) to enable client authentication on this listener. <br/>When set to <code>false</code> clients will be allowed to connect without authentication.",
            "type": "boolean"
          },
          "mountpoint": {
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message is delivered to the subscriber.<br/>The mountpoint is a way that users can use to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,<br/>then the client actually subscribes to the topic `some_tenant/t`.<br/>Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,<br/>the message is routed to all the clients subscribed `some_tenant/t`,<br/>so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.<br/>Variables in mountpoint string:<br/><br/>  - <code>${clientid}</code>: clientid<br/><br/>  - <code>${username}</code>: username",
            "type": "string"
          },
          "access_rules": {
            "default": "",
            "description": "The access control rules for this listener.<br/>See: https://github.com/emqtt/esockd#allowdeny",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "status": {
            "description": "listener status",
            "$ref": "#/components/schemas/listeners.status"
          },
          "node_status": {
            "description": "listener status of each node in the cluster",
            "items": {
              "$ref": "#/components/schemas/listeners.node_status"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "bridge_kafka.put_producer": {
        "required": [
          "bootstrap_hosts",
          "kafka"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable (true) or disable (false) this Kafka bridge.",
            "summary": "Enable or Disable",
            "type": "boolean"
          },
          "bootstrap_hosts": {
            "description": "A comma separated list of Kafka <code>host[:port]</code> endpoints to bootstrap the client. Default port number is 9092.",
            "summary": "Bootstrap Hosts",
            "type": "string"
          },
          "connect_timeout": {
            "default": "5s",
            "description": "Maximum wait time for TCP connection establishment (including authentication time if enabled).",
            "example": "32s",
            "summary": "Connect Timeout",
            "type": "string"
          },
          "min_metadata_refresh_interval": {
            "default": "3s",
            "description": "Minimum time interval the client has to wait before refreshing Kafka broker and topic metadata. Setting too small value may add extra load on Kafka.",
            "example": "32s",
            "summary": "Min Metadata Refresh Interval",
            "type": "string"
          },
          "metadata_request_timeout": {
            "default": "5s",
            "description": "Maximum wait time when fetching metadata from Kafka.",
            "example": "32s",
            "summary": "Metadata Request Timeout",
            "type": "string"
          },
          "authentication": {
            "default": "none",
            "description": "Authentication configs.",
            "summary": "Authentication",
            "oneOf": [
              {
                "$ref": "#/components/schemas/bridge_kafka.auth_gssapi_kerberos"
              },
              {
                "$ref": "#/components/schemas/bridge_kafka.auth_username_password"
              },
              {
                "enum": [
                  "none"
                ],
                "type": "string"
              }
            ]
          },
          "socket_opts": {
            "description": "Extra socket options.",
            "summary": "Socket Options",
            "$ref": "#/components/schemas/bridge_kafka.socket_opts"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          },
          "local_topic": {
            "description": "MQTT topic or topic filter as data source (bridge input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in Kafka.",
            "summary": "Source MQTT Topic",
            "type": "string"
          },
          "kafka": {
            "description": "Kafka producer configs.",
            "summary": "Kafka Producer",
            "$ref": "#/components/schemas/bridge_kafka.producer_kafka_opts"
          }
        },
        "type": "object"
      },
      "connector_hstreamdb.config": {
        "required": [
          "pool_size",
          "stream",
          "url"
        ],
        "properties": {
          "url": {
            "description": "HStreamDB Server URL",
            "summary": "HStreamDB Server URL",
            "type": "string"
          },
          "stream": {
            "description": "HStreamDB Stream Name",
            "summary": "HStreamDB Stream Name",
            "type": "string"
          },
          "ordering_key": {
            "description": "HStreamDB Ordering Key",
            "summary": "HStreamDB Ordering Key",
            "type": "string"
          },
          "pool_size": {
            "description": "HStreamDB Pool Size",
            "minimum": 1,
            "summary": "HStreamDB Pool Size",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "resource_schema.creation_opts": {
        "properties": {
          "worker_pool_size": {
            "default": 16,
            "description": "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "minimum": 0,
            "summary": "Buffer Pool Size",
            "type": "integer"
          },
          "health_check_interval": {
            "default": "15s",
            "description": "Health check interval.",
            "example": "32s",
            "summary": "Health Check Interval",
            "type": "string"
          },
          "start_after_created": {
            "default": "true",
            "description": "Whether start the resource right after created.",
            "summary": "Start After Created",
            "type": "boolean"
          },
          "start_timeout": {
            "default": "5s",
            "description": "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "example": "32s",
            "summary": "Start Timeout",
            "type": "string"
          },
          "auto_restart_interval": {
            "default": "60s",
            "description": "The auto restart interval after the resource is disconnected.",
            "summary": "Auto Restart Interval",
            "oneOf": [
              {
                "example": "32s",
                "type": "string"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "query_mode": {
            "default": "async",
            "description": "Query mode. Optional 'sync/async', default 'async'.",
            "enum": [
              "sync",
              "async"
            ],
            "summary": "Query mode",
            "type": "string"
          },
          "request_timeout": {
            "default": "15s",
            "description": "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "summary": "Request Expiry",
            "oneOf": [
              {
                "example": "32s",
                "type": "string"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "inflight_window": {
            "default": 100,
            "description": "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "minimum": 1,
            "summary": "Inflight window",
            "type": "integer"
          },
          "enable_batch": {
            "default": true,
            "deprecated": true,
            "description": "Batch mode enabled.",
            "summary": "Enable batch",
            "type": "boolean"
          },
          "batch_size": {
            "default": 1,
            "description": "Maximum batch count. If equal to 1, there's effectively no batching.",
            "minimum": 1,
            "summary": "Max batch size",
            "type": "integer"
          },
          "batch_time": {
            "default": "0ms",
            "description": "Maximum waiting interval when accumulating a batch at a low message rates for more efficient resource usage.",
            "example": "32s",
            "summary": "Max batch wait time",
            "type": "string"
          },
          "enable_queue": {
            "default": false,
            "deprecated": true,
            "description": "Enable disk buffer queue (only applicable for egress bridges).<br/>When Enabled, messages will be buffered on disk when the bridge connection is down.<br/>When disabled the messages are buffered in RAM only.",
            "summary": "Enable disk buffer queue",
            "type": "boolean"
          },
          "max_buffer_bytes": {
            "default": "256MB",
            "description": "Maximum number of bytes to buffer for each buffer worker.",
            "example": "32MB",
            "summary": "Max buffer queue size",
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge_timescale.post": {
        "required": [
          "database",
          "name",
          "server",
          "type"
        ],
        "properties": {
          "type": {
            "description": "The Bridge Type",
            "enum": [
              "timescale"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name.",
            "summary": "Bridge Name",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "sql": {
            "default": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
            "description": "SQL Template",
            "format": "sql",
            "summary": "SQL Template",
            "type": "string"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to PostgreSQL. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "server": {
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The PostgreSQL default port 5432 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "emqx_delayed_api.message": {
        "properties": {
          "msgid": {
            "description": "Delayed Message ID",
            "type": "integer"
          },
          "node": {
            "description": "The node where message from",
            "type": "string"
          },
          "publish_at": {
            "description": "Clinet publish message time, in RFC 3339 format",
            "type": "string"
          },
          "delayed_interval": {
            "description": "Delayed interval(second)",
            "minimum": 1,
            "type": "integer"
          },
          "delayed_remaining": {
            "description": "Delayed remaining(second)",
            "minimum": 0,
            "type": "integer"
          },
          "expected_at": {
            "description": "Expect publish time, in RFC 3339 format",
            "type": "string"
          },
          "topic": {
            "description": "Topic",
            "example": "/sys/#",
            "type": "string"
          },
          "qos": {
            "description": "QoS",
            "example": 0,
            "maximum": 2,
            "minimum": 0,
            "type": "integer"
          },
          "from_clientid": {
            "description": "From ClientID",
            "type": "string"
          },
          "from_username": {
            "description": "From Username",
            "type": "string"
          },
          "payload": {
            "description": "Payload, base64 encoded. Payload will be set to 'PAYLOAD_TO_LARGE' if its length is larger than 2048 bytes",
            "type": "string"
          }
        },
        "type": "object"
      },
      "broker.persistent_table_mria_opts": {
        "properties": {
          "ram_cache": {
            "default": true,
            "description": "Maintain a copy of the data in RAM for faster access.",
            "summary": "RAM cache",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "bridge_sqlserver.put": {
        "required": [
          "database",
          "server"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "sql": {
            "default": "insert into t_mqtt_msg(msgid, topic, qos, payload) values ( ${id}, ${topic}, ${qos}, ${payload} )",
            "description": "SQL Template",
            "format": "sql",
            "summary": "SQL Template",
            "type": "string"
          },
          "driver": {
            "default": "ms-sql",
            "description": "SQL Server Driver Name",
            "summary": "SQL Server Driver Name",
            "type": "string"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to Microsoft SQL Server. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/bridge_sqlserver.creation_opts"
          },
          "server": {
            "description": "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The SQL Server default port 1433 is used if `[:Port]` is not specified.",
            "summary": "Server Host",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "default": "sa",
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auto_reconnect": {
            "default": true,
            "deprecated": true,
            "description": "Deprecated. Enable automatic reconnect to the database.",
            "summary": "Deprecated. Auto Reconnect Database",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "authn-hash.pbkdf2": {
        "required": [
          "iterations",
          "mac_fun",
          "name"
        ],
        "properties": {
          "name": {
            "description": "PBKDF2 password hashing.",
            "enum": [
              "pbkdf2"
            ],
            "type": "string"
          },
          "mac_fun": {
            "description": "Specifies mac_fun for PBKDF2 hashing algorithm.",
            "enum": [
              "md4",
              "md5",
              "ripemd160",
              "sha",
              "sha224",
              "sha256",
              "sha384",
              "sha512"
            ],
            "type": "string"
          },
          "iterations": {
            "description": "Iteration count for PBKDF2 hashing algorithm.",
            "type": "integer"
          },
          "dk_length": {
            "description": "Derived length for PBKDF2 hashing algorithm. If not specified, calculated automatically based on `mac_fun`.",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_publish.message_properties": {
        "properties": {
          "payload_format_indicator": {
            "description": "0 (0x00) Byte Indicates that the Payload is unspecified bytes, which is equivalent to not sending a Payload Format Indicator.<br/>1 (0x01) Byte Indicates that the Payload is UTF-8 Encoded Character Data. The UTF-8 data in the Payload MUST be well-formed UTF-8 as defined by the Unicode specification and restated in RFC 3629.",
            "example": 0,
            "maximum": 1,
            "minimum": 0,
            "type": "integer"
          },
          "message_expiry_interval": {
            "description": "Identifier of the Message Expiry Interval. If the Message Expiry Interval has passed and the Server has not managed to start onward delivery to a matching subscriber, then it MUST delete the copy of the message for that subscriber.",
            "type": "integer"
          },
          "response_topic": {
            "description": "Identifier of the Response Topic.The Response Topic MUST be a UTF-8 Encoded, It MUST NOT contain wildcard characters.",
            "example": "some_other_topic",
            "type": "string"
          },
          "correlation_data": {
            "description": "Identifier of the Correlation Data. The Server MUST send the Correlation Data unaltered to all subscribers receiving the Application Message.",
            "type": "string"
          },
          "user_properties": {
            "description": "The User-Property key-value pairs. Note: in case there are duplicated keys, only the last one will be used.",
            "example": {
              "foo": "bar"
            },
            "type": "object"
          },
          "content_type": {
            "description": "The Content Type MUST be a UTF-8 Encoded String.",
            "example": "text/plain",
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge_gcp_pubsub.post": {
        "required": [
          "name",
          "pubsub_topic",
          "service_account_json",
          "type"
        ],
        "properties": {
          "type": {
            "description": "The Bridge Type",
            "enum": [
              "gcp_pubsub"
            ],
            "summary": "Bridge Type",
            "type": "string"
          },
          "name": {
            "description": "Bridge name, used as a human-readable description of the bridge.",
            "summary": "Bridge Name",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "summary": "Enable Or Disable Bridge",
            "type": "boolean"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          },
          "connect_timeout": {
            "default": "15s",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s",
            "summary": "Connect Timeout",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "The pool size.",
            "minimum": 1,
            "summary": "Pool Size",
            "type": "integer"
          },
          "pipelining": {
            "default": 100,
            "description": "A positive integer. Whether to send HTTP requests continuously, when set to 1, it means that after each HTTP request is sent, you need to wait for the server to return and then continue to send the next request.",
            "minimum": 1,
            "summary": "HTTP Pipelineing",
            "type": "integer"
          },
          "max_retries": {
            "default": 2,
            "description": "Max retry times if an error occurs when sending a request.",
            "minimum": 0,
            "summary": "Max Retries",
            "type": "integer"
          },
          "request_timeout": {
            "default": "15s",
            "deprecated": true,
            "description": "Deprecated: Configure the request timeout in the buffer settings.",
            "example": "32s",
            "summary": "Request Timeout",
            "type": "string"
          },
          "payload_template": {
            "default": "",
            "description": "The template for formatting the outgoing messages.  If undefined, will send all the available context in JSON format.",
            "summary": "Payload template",
            "type": "string"
          },
          "local_topic": {
            "description": "The MQTT topic filter to be forwarded to GCP PubSub. All MQTT 'PUBLISH' messages with the topic<br/>matching `local_topic` will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded.",
            "summary": "Local Topic",
            "type": "string"
          },
          "pubsub_topic": {
            "description": "The GCP PubSub topic to publish messages to.",
            "summary": "GCP PubSub Topic",
            "type": "string"
          },
          "service_account_json": {
            "description": "JSON containing the GCP Service Account credentials to be used with PubSub.<br/>When a GCP Service Account is created (as described in https://developers.google.com/identity/protocols/oauth2/service-account#creatinganaccount), you have the option of downloading the credentials in JSON form.  That's the file needed.",
            "example": {},
            "summary": "GCP Service Account Credentials",
            "type": "object"
          }
        },
        "type": "object"
      },
      "limiter.client_opts": {
        "properties": {
          "rate": {
            "default": "infinity",
            "description": "Rate for this bucket.",
            "example": "10MB",
            "summary": "Rate",
            "type": "string"
          },
          "initial": {
            "default": "0",
            "description": "The initial number of tokens for this bucket.",
            "example": "0MB",
            "summary": "Initial",
            "type": "string"
          },
          "low_watermark": {
            "default": "0",
            "description": "If the remaining tokens are lower than this value,<br/>the check/consume will succeed, but it will be forced to wait for a short period of time.",
            "example": "0MB",
            "summary": "Low Watermark",
            "type": "string"
          },
          "capacity": {
            "default": "infinity",
            "description": "The capacity of per user.",
            "example": "100MB",
            "summary": "Capacity",
            "type": "string"
          },
          "divisible": {
            "default": false,
            "description": "Is it possible to split the number of requested tokens?",
            "summary": "Divisible",
            "type": "boolean"
          },
          "max_retry_time": {
            "default": "10s",
            "description": "The maximum retry time when acquire failed.",
            "example": "12m",
            "summary": "Max Retry Time",
            "type": "string"
          },
          "failure_strategy": {
            "default": "force",
            "description": "The strategy when all the retries failed.",
            "example": "force",
            "summary": "Failure Strategy",
            "type": "string"
          }
        },
        "type": "object"
      },
      "authn-mongodb.sharded-cluster": {
        "required": [
          "backend",
          "collection",
          "database",
          "mechanism",
          "servers"
        ],
        "properties": {
          "mechanism": {
            "description": "Authentication mechanism.",
            "enum": [
              "password_based"
            ],
            "summary": "Authentication Mechanism",
            "type": "string"
          },
          "backend": {
            "description": "Backend type.",
            "enum": [
              "mongodb"
            ],
            "summary": "Backend Type",
            "type": "string"
          },
          "collection": {
            "description": "Collection used to store authentication data.",
            "summary": "Collection",
            "type": "string"
          },
          "filter": {
            "default": {},
            "description": "Conditional expression that defines the filter condition in the query.<br/>Filter supports the following placeholders:<br/>- <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting<br/>- <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting",
            "example": {},
            "summary": "Filter",
            "type": "object"
          },
          "password_hash_field": {
            "default": "password_hash",
            "description": "Document field that contains password hash.",
            "summary": "Password Hash Field",
            "type": "string"
          },
          "salt_field": {
            "default": "salt",
            "description": "Document field that contains the password salt.",
            "summary": "Salt Field",
            "type": "string"
          },
          "is_superuser_field": {
            "default": "is_superuser",
            "description": "Document field that defines if the user has superuser privileges.",
            "summary": "Is Superuser Field",
            "type": "string"
          },
          "password_hash_algorithm": {
            "default": {
              "name": "sha256",
              "salt_position": "prefix"
            },
            "description": "Options for password hash verification.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn-hash.simple"
              },
              {
                "$ref": "#/components/schemas/authn-hash.pbkdf2"
              },
              {
                "$ref": "#/components/schemas/authn-hash.bcrypt"
              }
            ]
          },
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
            "summary": "Enable",
            "type": "boolean"
          },
          "mongo_type": {
            "default": "sharded",
            "description": "Sharded cluster. Must be set to 'sharded' when MongoDB server is running in 'sharded' mode.",
            "enum": [
              "sharded"
            ],
            "summary": "Sharded cluster",
            "type": "string"
          },
          "servers": {
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The MongoDB default port 27017 is used if `[:Port]` is not specified.",
            "summary": "Servers",
            "type": "string"
          },
          "w_mode": {
            "default": "unsafe",
            "description": "Write mode.",
            "enum": [
              "unsafe",
              "safe"
            ],
            "summary": "Write Mode",
            "type": "string"
          },
          "srv_record": {
            "default": false,
            "description": "Use DNS SRV record.",
            "summary": "Srv Record",
            "type": "boolean"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auth_source": {
            "description": "Database name associated with the user's credentials.",
            "summary": "Auth Source",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "topology": {
            "$ref": "#/components/schemas/emqx_connector_mongo.topology"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.gateway_overview": {
        "properties": {
          "name": {
            "description": "Gateway Name",
            "type": "string"
          },
          "status": {
            "description": "Gateway status",
            "enum": [
              "running",
              "stopped",
              "unloaded"
            ],
            "type": "string"
          },
          "created_at": {
            "description": "The Gateway created datetime",
            "type": "string"
          },
          "started_at": {
            "description": "The Gateway started datetime",
            "type": "string"
          },
          "stopped_at": {
            "description": "The Gateway stopped datetime",
            "type": "string"
          },
          "max_connections": {
            "description": "The Gateway allowed maximum connections/clients",
            "minimum": 1,
            "type": "integer"
          },
          "current_connections": {
            "description": "The Gateway current connected connections/clients",
            "minimum": 0,
            "type": "integer"
          },
          "listeners": {
            "description": "The Gateway listeners overview",
            "items": {
              "$ref": "#/components/schemas/emqx_gateway_api.gateway_listener_overview"
            },
            "type": "array"
          },
          "node_status": {
            "description": "The status of the gateway on each node in the cluster",
            "items": {
              "$ref": "#/components/schemas/emqx_gateway_api.gateway_node_status"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "dashboard.dashboard": {
        "properties": {
          "listeners": {
            "description": "HTTP(s) listeners are identified by their protocol type and are<br/>used to serve dashboard UI and restful HTTP API.<br/>Listeners must have a unique combination of port number and IP address.<br/>For example, an HTTP listener can listen on all configured IP addresses<br/>on a given port for a machine by specifying the IP address 0.0.0.0.<br/>Alternatively, the HTTP listener can specify a unique IP address for each listener,<br/>but use the same port.",
            "summary": "Listeners",
            "$ref": "#/components/schemas/dashboard.listeners"
          },
          "token_expired_time": {
            "default": "60m",
            "description": "JWT token expiration time. Default is 60 minutes",
            "example": "12m",
            "summary": "Token expired time",
            "type": "string"
          },
          "cors": {
            "default": false,
            "description": "Support Cross-Origin Resource Sharing (CORS).<br/>Allows a server to indicate any origins (domain, scheme, or port) other than<br/>its own from which a browser should permit loading resources.",
            "summary": "CORS",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "broker.sys_topics": {
        "properties": {
          "sys_msg_interval": {
            "default": "1m",
            "description": "Time interval of publishing `$SYS` messages.",
            "oneOf": [
              {
                "example": "12m",
                "type": "string"
              },
              {
                "enum": [
                  "disabled"
                ],
                "type": "string"
              }
            ]
          },
          "sys_heartbeat_interval": {
            "default": "30s",
            "description": "Time interval for publishing following heartbeat messages:<br/>  - `$SYS/brokers/<node>/uptime`<br/>  - `$SYS/brokers/<node>/datetime`",
            "oneOf": [
              {
                "example": "12m",
                "type": "string"
              },
              {
                "enum": [
                  "disabled"
                ],
                "type": "string"
              }
            ]
          },
          "sys_event_messages": {
            "description": "Client events messages.",
            "$ref": "#/components/schemas/broker.event_names"
          }
        },
        "type": "object"
      },
      "authz.node_resource_metrics": {
        "properties": {
          "node": {
            "description": "Node name.",
            "example": "emqx@127.0.0.1",
            "summary": "Node Name.",
            "type": "string"
          },
          "metrics": {
            "description": "The metrics of the resource.",
            "summary": "Metrics",
            "$ref": "#/components/schemas/authz.resource_metrics"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.gateway_node_status": {
        "properties": {
          "node": {
            "description": "Node Name",
            "enum": [
              "emqx@127.0.0.1"
            ],
            "type": "string"
          },
          "status": {
            "description": "Gateway status",
            "enum": [
              "running",
              "stopped",
              "unloaded"
            ],
            "type": "string"
          },
          "max_connections": {
            "description": "The Gateway allowed maximum connections/clients",
            "minimum": 1,
            "type": "integer"
          },
          "current_connections": {
            "description": "The Gateway current connected connections/clients",
            "minimum": 0,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "bridge_mongodb.put_sharded": {
        "required": [
          "database",
          "servers"
        ],
        "properties": {
          "mongo_type": {
            "default": "sharded",
            "description": "Sharded cluster. Must be set to 'sharded' when MongoDB server is running in 'sharded' mode.",
            "enum": [
              "sharded"
            ],
            "summary": "Sharded cluster",
            "type": "string"
          },
          "servers": {
            "description": "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The MongoDB default port 27017 is used if `[:Port]` is not specified.",
            "summary": "Servers",
            "type": "string"
          },
          "w_mode": {
            "default": "unsafe",
            "description": "Write mode.",
            "enum": [
              "unsafe",
              "safe"
            ],
            "summary": "Write Mode",
            "type": "string"
          },
          "srv_record": {
            "default": false,
            "description": "Use DNS SRV record.",
            "summary": "Srv Record",
            "type": "boolean"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool towards the bridge target service.",
            "minimum": 1,
            "summary": "Connection Pool Size",
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "summary": "Username",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "format": "password",
            "summary": "Password",
            "type": "string"
          },
          "auth_source": {
            "description": "Database name associated with the user's credentials.",
            "summary": "Auth Source",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "summary": "Database Name",
            "type": "string"
          },
          "topology": {
            "$ref": "#/components/schemas/emqx_connector_mongo.topology"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "summary": "Enable SSL",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable this MongoDB Bridge",
            "summary": "Enable or disable",
            "type": "boolean"
          },
          "collection": {
            "default": "mqtt",
            "description": "The collection where data will be stored into",
            "summary": "Collection to be used",
            "type": "string"
          },
          "payload_template": {
            "description": "The template for formatting the outgoing messages.  If undefined, rule engine will use JSON format to serialize all visible inputs, such as clientid, topic, payload etc.",
            "summary": "Payload template",
            "type": "string"
          },
          "resource_opts": {
            "default": {},
            "description": "Resource options.",
            "summary": "Resource Options",
            "$ref": "#/components/schemas/resource_schema.creation_opts"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.lwm2m": {
        "required": [
          "translators",
          "xml_dir"
        ],
        "properties": {
          "name": {
            "description": "Gateway Name",
            "enum": [
              "lwm2m"
            ],
            "type": "string"
          },
          "xml_dir": {
            "description": "The Directory for LwM2M Resource definition.",
            "example": "/etc/emqx/lwm2m_xml",
            "type": "string"
          },
          "lifetime_min": {
            "default": "15s",
            "description": "Minimum value of lifetime allowed to be set by the LwM2M client.",
            "example": "12m",
            "type": "string"
          },
          "lifetime_max": {
            "default": "86400s",
            "description": "Maximum value of lifetime allowed to be set by the LwM2M client.",
            "example": "12m",
            "type": "string"
          },
          "qmode_time_window": {
            "default": "22s",
            "description": "The value of the time window during which the network link is considered valid by the LwM2M Gateway in QMode mode.<br/>For example, after receiving an update message from a client, any messages within this time window are sent directly to the LwM2M client, and all messages beyond this time window are temporarily stored in memory.",
            "example": "1h",
            "type": "string"
          },
          "auto_observe": {
            "default": false,
            "description": "Automatically observe the object list of REGISTER packet.",
            "type": "boolean"
          },
          "update_msg_publish_condition": {
            "default": "contains_object_list",
            "description": "Policy for publishing UPDATE event message.<br/><br/>  - always: send update events as long as the UPDATE request is received.<br/><br/>  - contains_object_list: send update events only if the UPDATE request carries any Object List",
            "enum": [
              "always",
              "contains_object_list"
            ],
            "type": "string"
          },
          "translators": {
            "description": "Topic configuration for LwM2M's gateway publishing and subscription.",
            "$ref": "#/components/schemas/emqx_lwm2m_schema.lwm2m_translators"
          },
          "mountpoint": {
            "default": "lwm2m/${endpoint_name}/",
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.<br/>The prefixed string will be removed from the topic name when the message is delivered to the subscriber.<br/>The mountpoint is a way that users can use to implement isolation of message routing between different listeners.<br/>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`,<br/>then the client actually subscribes to the topic `some_tenant/t`.<br/>Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,<br/>the message is routed to all the clients subscribed `some_tenant/t`,<br/>so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.<br/>Variables in mountpoint string:<br/><br/>  - <code>${clientid}</code>: clientid<br/><br/>  - <code>${username}</code>: username",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Whether to enable this gateway",
            "type": "boolean"
          },
          "enable_stats": {
            "default": true,
            "description": "Whether to enable client process statistic",
            "type": "boolean"
          },
          "idle_timeout": {
            "default": "30s",
            "description": "The idle time of the client connection process. It has two purposes:<br/>  1. A newly created client process that does not receive any client requests after that time will be closed directly.<br/>  2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.",
            "example": "12m",
            "type": "string"
          },
          "clientinfo_override": {
            "description": "ClientInfo override.",
            "$ref": "#/components/schemas/gateway.clientinfo_override"
          },
          "listeners": {
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/emqx_gateway_api.dtls_listener"
                },
                {
                  "$ref": "#/components/schemas/emqx_gateway_api.udp_listener"
                }
              ]
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "zone.force_shutdown": {
        "properties": {
          "enable": {
            "description": "Enable `force_shutdown` feature.",
            "summary": "Enable `force_shutdown` feature",
            "type": "boolean"
          },
          "max_message_queue_len": {
            "description": "Maximum message queue length.",
            "minimum": 0,
            "summary": "Maximum mailbox queue length of process.",
            "type": "integer"
          },
          "max_heap_size": {
            "description": "Total heap size",
            "example": "1024KB",
            "summary": "Total heap size",
            "type": "string"
          }
        },
        "type": "object"
      }
    },
    "securitySchemes": {
      "basicAuth": {
        "description": "Authorize with [API Keys](https://www.emqx.io/docs/en/v5.0/admin/api.html#api-keys)",
        "scheme": "basic",
        "type": "http"
      }
    }
  },
  "info": {
    "title": "EMQX API",
    "version": "5.0"
  },
  "openapi": "3.0.0",
  "paths": {
    "/authentication/{id}/position/{position}": {
      "put": {
        "description": "Move authenticator in global authentication chain.",
        "parameters": [
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Position of authenticator in chain. Possible values are 'front', 'rear', 'before:{other_authenticator}', 'after:{other_authenticator}'.",
            "example": "before:password_based:built_in_database",
            "in": "path",
            "name": "position",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Authenticator moved"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Authentication"
        ]
      }
    },
    "/metrics": {
      "get": {
        "description": "EMQX metrics",
        "parameters": [
          {
            "description": "Whether to aggregate all nodes Metrics",
            "in": "query",
            "name": "aggregate",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "items": {
                        "$ref": "#/components/schemas/emqx_mgmt_api_metrics.node_metrics"
                      },
                      "type": "array"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_mgmt_api_metrics.aggregated_metrics"
                    }
                  ]
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Metrics"
        ]
      }
    },
    "/authentication/{id}/users/{user_id}": {
      "delete": {
        "description": "Delete user in authenticator in global authentication chain.",
        "parameters": [
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "User ID.",
            "in": "path",
            "name": "user_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "User deleted"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Authentication"
        ]
      },
      "get": {
        "description": "Get user from authenticator in global authentication chain.",
        "parameters": [
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "User ID.",
            "in": "path",
            "name": "user_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "regular_user": {
                    "summary": "Regular user",
                    "value": {
                      "user_id": "user1"
                    }
                  },
                  "super_user": {
                    "summary": "Superuser",
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Authentication"
        ]
      },
      "put": {
        "description": "Update user in authenticator in global authentication chain.",
        "parameters": [
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "User ID.",
            "in": "path",
            "name": "user_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "regular_user": {
                  "summary": "Update regular user",
                  "value": {
                    "password": "******"
                  }
                },
                "super_user": {
                  "summary": "Update user and promote to superuser",
                  "value": {
                    "is_superuser": true,
                    "password": "******"
                  }
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authn_api.request_user_update"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "regular_user": {
                    "summary": "Regular user",
                    "value": {
                      "user_id": "user1"
                    }
                  },
                  "super_user": {
                    "summary": "Superuser",
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Authentication"
        ]
      }
    },
    "/authentication/{id}/import_users": {
      "post": {
        "description": "Import users into authenticator in global authentication chain.",
        "parameters": [
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "multipart/form-data": {
              "schema": {
                "properties": {
                  "filename": {
                    "format": "binary",
                    "type": "string"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Users imported"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Authentication"
        ]
      }
    },
    "/mqtt/delayed": {
      "get": {
        "description": "Get delayed status",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/modules.delayed"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "MQTT"
        ]
      },
      "put": {
        "description": "Enable or disable delayed, set max delayed messages",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/modules.delayed"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Enable or disable delayed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/modules.delayed"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Max limit illegality",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "MQTT"
        ]
      }
    },
    "/configs/limiter": {
      "get": {
        "description": "Get the sub-configurations under *limiter*",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/limiter.limiter"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "config not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Configs"
        ]
      },
      "put": {
        "description": "Update the sub-configurations under *limiter*",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/limiter.limiter"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/limiter.limiter"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "UPDATE_FAILED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "403": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "UPDATE_FAILED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Configs"
        ]
      }
    },
    "/gateways/lwm2m/clients/{clientid}/observe": {
      "post": {
        "description": "Observe or Cancel observe a resource",
        "parameters": [
          {
            "example": "urn:oma:lwm2m:oma:2",
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "example": "/3/0/7",
            "in": "query",
            "name": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "example": true,
            "in": "query",
            "name": "enable",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "CLIENT_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Clientid not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Observe a Resource",
        "tags": [
          "LwM2M Gateways"
        ]
      }
    },
    "/plugins/{name}": {
      "delete": {
        "description": "Uninstalls a previously uploaded plugin package.",
        "parameters": [
          {
            "$ref": "#/components/parameters/plugins.name"
          }
        ],
        "responses": {
          "204": {
            "description": "Uninstall successfully"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Plugin Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Delete a plugin",
        "tags": [
          "Plugins"
        ]
      },
      "get": {
        "description": "Describs plugin according to its `release.json` and `README.md`.",
        "parameters": [
          {
            "$ref": "#/components/parameters/plugins.name"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/plugins.plugin"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Plugin Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Get a plugin description",
        "tags": [
          "Plugins"
        ]
      }
    },
    "/bridges/{id}/metrics/reset": {
      "put": {
        "description": "Reset a bridge metrics by Id",
        "parameters": [
          {
            "description": "The bridge Id. Must be of format {type}:{name}",
            "example": "webhook:webhook_example",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            },
            "summary": "Bridge ID"
          }
        ],
        "responses": {
          "204": {
            "description": "Reset success"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bridge not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Reset Bridge Metrics",
        "tags": [
          "Bridges"
        ]
      }
    },
    "/status": {
      "get": {
        "description": "Serves as a health check for the node.  Returns a plain text response describing the status of the node.  This endpoint requires no authentication.<br/><br/>Returns status code 200 if the EMQX application is up and running, 503 otherwise.<br/>This API was introduced in v5.0.10.<br/>The GET `/status` endpoint (without the `/api/...` prefix) is also an alias to this endpoint and works in the same way.  This alias has been available since v5.0.0.",
        "parameters": [],
        "responses": {
          "200": {
            "description": "Node emqx@127.0.0.1 is started<br/>emqx is running"
          },
          "503": {
            "description": "Node emqx@127.0.0.1 is stopped<br/>emqx is not_running"
          }
        },
        "security": [],
        "summary": "Service health check",
        "tags": [
          "Status"
        ]
      }
    },
    "/topics/{topic}": {
      "get": {
        "description": "Lookup topic info by name",
        "parameters": [
          {
            "description": "Topic Name",
            "example": "",
            "in": "path",
            "name": "topic",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/emqx_mgmt_api_topics.topic"
                  },
                  "type": "array"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "TOPIC_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Topic not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Topics"
        ]
      }
    },
    "/stats": {
      "get": {
        "description": "EMQX stats",
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_mgmt_api_stats.aggregate"
          }
        ],
        "responses": {
          "200": {
            "description": "List stats ok",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "items": {
                        "$ref": "#/components/schemas/emqx_mgmt_api_stats.aggergate_data"
                      },
                      "type": "array"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_mgmt_api_stats.node_stats_data"
                    }
                  ]
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Metrics"
        ]
      }
    },
    "/monitor_current": {
      "get": {
        "description": "Current status. Gauge and rate.",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_dashboard_monitor_api.sampler_current"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Metrics"
        ]
      }
    },
    "/listeners/{listener_id}/authentication/{id}": {
      "delete": {
        "description": "Delete authenticator from listener authentication chain.",
        "parameters": [
          {
            "description": "Listener ID.",
            "example": "tcp:default",
            "in": "path",
            "name": "listener_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Authenticator deleted"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Listener Authentication"
        ]
      },
      "get": {
        "description": "Get authenticator from listener authentication chain.",
        "parameters": [
          {
            "description": "Listener ID.",
            "example": "tcp:default",
            "in": "path",
            "name": "listener_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "jwt": {
                    "summary": "JWT authentication",
                    "value": {
                      "algorithm": "hmac-based",
                      "mechanism": "jwt",
                      "secret": "mysecret",
                      "secret_base64_encoded": false,
                      "use_jwks": false,
                      "verify_claims": {
                        "username": "${username}"
                      }
                    }
                  },
                  "password_based:built_in_database": {
                    "summary": "Built-in password_based authentication",
                    "value": {
                      "backend": "built_in_database",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "user_id_type": "username"
                    }
                  },
                  "password_based:http": {
                    "summary": "password_based authentication through external HTTP API",
                    "value": {
                      "backend": "http",
                      "body": {
                        "password": "${password}",
                        "username": "${username}"
                      },
                      "connect_timeout": 5000,
                      "enable_pipelining": 100,
                      "headers": {
                        "content-type": "application/json"
                      },
                      "mechanism": "password_based",
                      "method": "post",
                      "pool_size": 8,
                      "request_timeout": 5000,
                      "ssl": {
                        "enable": false
                      },
                      "url": "http://127.0.0.1:18083"
                    }
                  },
                  "password_based:mongodb": {
                    "summary": "password_based authentication with MongoDB backend",
                    "value": {
                      "backend": "mongodb",
                      "collection": "users",
                      "database": "example",
                      "filter": {
                        "username": "${username}"
                      },
                      "is_superuser_field": "is_superuser",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "password_hash_field": "password_hash",
                      "salt_field": "salt",
                      "server": "127.0.0.1:27017"
                    }
                  },
                  "password_based:redis": {
                    "summary": "password_based authentication with Redis backend",
                    "value": {
                      "backend": "redis",
                      "cmd": "HMGET ${username} password_hash salt",
                      "database": 0,
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "redis_type": "single",
                      "server": "127.0.0.1:6379"
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.jwks"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.public-key"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.hmac-based"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.post"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.get"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.replica-set"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-postgresql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mysql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-builtin_db.authentication"
                    }
                  ]
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Listener Authentication"
        ]
      },
      "put": {
        "description": "Update authenticator from listener authentication chain.",
        "parameters": [
          {
            "description": "Listener ID.",
            "example": "tcp:default",
            "in": "path",
            "name": "listener_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "jwt": {
                  "summary": "JWT authentication",
                  "value": {
                    "algorithm": "hmac-based",
                    "mechanism": "jwt",
                    "secret": "mysecret",
                    "secret_base64_encoded": false,
                    "use_jwks": false,
                    "verify_claims": {
                      "username": "${username}"
                    }
                  }
                },
                "password_based:built_in_database": {
                  "summary": "Built-in password_based authentication",
                  "value": {
                    "backend": "built_in_database",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "user_id_type": "username"
                  }
                },
                "password_based:http": {
                  "summary": "password_based authentication through external HTTP API",
                  "value": {
                    "backend": "http",
                    "body": {
                      "password": "${password}",
                      "username": "${username}"
                    },
                    "connect_timeout": 5000,
                    "enable_pipelining": 100,
                    "headers": {
                      "content-type": "application/json"
                    },
                    "mechanism": "password_based",
                    "method": "post",
                    "pool_size": 8,
                    "request_timeout": 5000,
                    "ssl": {
                      "enable": false
                    },
                    "url": "http://127.0.0.1:18083"
                  }
                },
                "password_based:mongodb": {
                  "summary": "password_based authentication with MongoDB backend",
                  "value": {
                    "backend": "mongodb",
                    "collection": "users",
                    "database": "example",
                    "filter": {
                      "username": "${username}"
                    },
                    "is_superuser_field": "is_superuser",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "password_hash_field": "password_hash",
                    "salt_field": "salt",
                    "server": "127.0.0.1:27017"
                  }
                },
                "password_based:redis": {
                  "summary": "password_based authentication with Redis backend",
                  "value": {
                    "backend": "redis",
                    "cmd": "HMGET ${username} password_hash salt",
                    "database": 0,
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "redis_type": "single",
                    "server": "127.0.0.1:6379"
                  }
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.jwks"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.public-key"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.hmac-based"
                  },
                  {
                    "$ref": "#/components/schemas/authn-http.post"
                  },
                  {
                    "$ref": "#/components/schemas/authn-http.get"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.standalone"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.replica-set"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.standalone"
                  },
                  {
                    "$ref": "#/components/schemas/authn-postgresql.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mysql.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-builtin_db.authentication"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Authenticator updated"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "409": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "ALREADY_EXISTS"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "ALREADY_EXISTS",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Listener Authentication"
        ]
      }
    },
    "/authorization/sources/built_in_database/rules/users": {
      "get": {
        "description": "Show the list of rules for users",
        "parameters": [
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          },
          {
            "description": "Fuzzy search `username` as substring",
            "in": "query",
            "name": "like_username",
            "required": false,
            "schema": {
              "type": "string"
            },
            "summary": "fuzzy_username"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "password_based:built_in_database": {
                    "summary": "Username",
                    "value": {
                      "data": [
                        {
                          "rules": [
                            {
                              "action": "publish",
                              "permission": "allow",
                              "topic": "test/toopic/1"
                            },
                            {
                              "action": "subscribe",
                              "permission": "allow",
                              "topic": "test/toopic/2"
                            },
                            {
                              "action": "all",
                              "permission": "deny",
                              "topic": "eq test/#"
                            }
                          ],
                          "username": "user1"
                        }
                      ],
                      "meta": {
                        "count": 1,
                        "limit": 100,
                        "page": 1
                      }
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authz_api_mnesia.username_response_data"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Authorization"
        ]
      },
      "post": {
        "description": "Add new rule for 'username'",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "password_based:built_in_database": {
                  "summary": "Username",
                  "value": [
                    {
                      "rules": [
                        {
                          "action": "publish",
                          "permission": "allow",
                          "topic": "test/toopic/1"
                        },
                        {
                          "action": "subscribe",
                          "permission": "allow",
                          "topic": "test/toopic/2"
                        },
                        {
                          "action": "all",
                          "permission": "deny",
                          "topic": "eq test/#"
                        }
                      ],
                      "username": "user1"
                    }
                  ]
                }
              },
              "schema": {
                "items": {
                  "$ref": "#/components/schemas/emqx_authz_api_mnesia.rules_for_username"
                },
                "type": "array"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Created"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad username or bad rule schema",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "409": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "ALREADY_EXISTS"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "ALREADY_EXISTS",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Authorization"
        ]
      }
    },
    "/nodes/{node}/stats": {
      "get": {
        "description": "Get node stats",
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_mgmt_api_nodes.node_name"
          }
        ],
        "responses": {
          "200": {
            "description": "Get node stats successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_stats.node_stats_data"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Node not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Nodes"
        ]
      }
    },
    "/exhooks/{name}": {
      "delete": {
        "description": "Delete the server",
        "parameters": [
          {
            "description": "The Exhook server name",
            "example": "default",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": ""
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Server not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "500": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_RPC"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad RPC",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "ExHook"
        ]
      },
      "get": {
        "description": "Get the detail information of Exhook server",
        "parameters": [
          {
            "description": "The Exhook server name",
            "example": "default",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/exhook.detail_server_info"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Server not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "ExHook"
        ]
      },
      "put": {
        "description": "Update the server",
        "parameters": [
          {
            "description": "The Exhook server name",
            "example": "default",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "example": {
                "auto_reconnect": "60s",
                "enable": true,
                "failed_action": "deny",
                "name": "default",
                "pool_size": 8,
                "request_timeout": "5s",
                "ssl": {
                  "cacertfile": "/etc/emqx/certs/cacert.pem",
                  "certfile": "/etc/emqx/certs/cert.pem",
                  "enable": false,
                  "keyfile": "/etc/emqx/certs/key.pem"
                },
                "url": "http://127.0.0.1:8081"
              },
              "schema": {
                "$ref": "#/components/schemas/exhook.server_config"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/exhook.detail_server_info"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Server not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "500": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_RPC"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad RPC",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "ExHook"
        ]
      }
    },
    "/prometheus": {
      "get": {
        "description": "Get Prometheus config info",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "enable": true,
                  "headers": {
                    "header-name": "header-value"
                  },
                  "interval": "15s",
                  "job_name": "${name}/instance/${name}~${host}",
                  "mnesia_collector": "enabled",
                  "push_gateway_server": "http://127.0.0.1:9091",
                  "vm_dist_collector": "enabled",
                  "vm_memory_collector": "enabled",
                  "vm_msacc_collector": "enabled",
                  "vm_statistics_collector": "enabled",
                  "vm_system_info_collector": "enabled"
                },
                "schema": {
                  "$ref": "#/components/schemas/prometheus.prometheus"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Monitor"
        ]
      },
      "put": {
        "description": "Update Prometheus config",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "example": {
                "enable": true,
                "headers": {
                  "header-name": "header-value"
                },
                "interval": "15s",
                "job_name": "${name}/instance/${name}~${host}",
                "mnesia_collector": "enabled",
                "push_gateway_server": "http://127.0.0.1:9091",
                "vm_dist_collector": "enabled",
                "vm_memory_collector": "enabled",
                "vm_msacc_collector": "enabled",
                "vm_statistics_collector": "enabled",
                "vm_system_info_collector": "enabled"
              },
              "schema": {
                "$ref": "#/components/schemas/prometheus.prometheus"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "enable": true,
                  "headers": {
                    "header-name": "header-value"
                  },
                  "interval": "15s",
                  "job_name": "${name}/instance/${name}~${host}",
                  "mnesia_collector": "enabled",
                  "push_gateway_server": "http://127.0.0.1:9091",
                  "vm_dist_collector": "enabled",
                  "vm_memory_collector": "enabled",
                  "vm_msacc_collector": "enabled",
                  "vm_statistics_collector": "enabled",
                  "vm_system_info_collector": "enabled"
                },
                "schema": {
                  "$ref": "#/components/schemas/prometheus.prometheus"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Monitor"
        ]
      }
    },
    "/mqtt/auto_subscribe": {
      "get": {
        "description": "Get auto subscribe topic list",
        "parameters": [],
        "responses": {
          "200": {
            "description": "After the device logs in successfully, the subscription is automatically completed for the device through the pre-defined subscription representation. Supports the use of placeholders.",
            "summary": "Auto Subscribe",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/auto_subscribe.topic"
                  },
                  "type": "array"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Auto Subscribe"
        ]
      },
      "put": {
        "description": "Update auto subscribe topic list",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "items": {
                  "$ref": "#/components/schemas/auto_subscribe.topic"
                },
                "type": "array"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "After the device logs in successfully, the subscription is automatically completed for the device through the pre-defined subscription representation. Supports the use of placeholders.",
            "summary": "Auto Subscribe",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/auto_subscribe.topic"
                  },
                  "type": "array"
                }
              }
            }
          },
          "409": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "EXCEED_LIMIT"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Auto Subscribe topics max limit",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Auto Subscribe"
        ]
      }
    },
    "/gateways/{name}/listeners/{id}/authentication": {
      "delete": {
        "description": "Remove authenticator for the listener.",
        "parameters": [
          {
            "description": "Gateway Name.<br/><br/>It's enum with `stomp`, `mqttsn`, `coap`, `lwm2m`, `exproto`",
            "example": "stomp",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Listener ID",
            "example": "",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Delete the listener's authenticator",
        "tags": [
          "Gateway Listeners"
        ]
      },
      "get": {
        "description": "Get the listener's authenticator configs.",
        "parameters": [
          {
            "description": "Gateway Name.<br/><br/>It's enum with `stomp`, `mqttsn`, `coap`, `lwm2m`, `exproto`",
            "example": "stomp",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Listener ID",
            "example": "",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "jwt": {
                    "summary": "JWT authentication",
                    "value": {
                      "algorithm": "hmac-based",
                      "mechanism": "jwt",
                      "secret": "mysecret",
                      "secret_base64_encoded": false,
                      "use_jwks": false,
                      "verify_claims": {
                        "username": "${username}"
                      }
                    }
                  },
                  "password_based:built_in_database": {
                    "summary": "Built-in password_based authentication",
                    "value": {
                      "backend": "built_in_database",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "user_id_type": "username"
                    }
                  },
                  "password_based:http": {
                    "summary": "password_based authentication through external HTTP API",
                    "value": {
                      "backend": "http",
                      "body": {
                        "password": "${password}",
                        "username": "${username}"
                      },
                      "connect_timeout": 5000,
                      "enable_pipelining": 100,
                      "headers": {
                        "content-type": "application/json"
                      },
                      "mechanism": "password_based",
                      "method": "post",
                      "pool_size": 8,
                      "request_timeout": 5000,
                      "ssl": {
                        "enable": false
                      },
                      "url": "http://127.0.0.1:18083"
                    }
                  },
                  "password_based:mongodb": {
                    "summary": "password_based authentication with MongoDB backend",
                    "value": {
                      "backend": "mongodb",
                      "collection": "users",
                      "database": "example",
                      "filter": {
                        "username": "${username}"
                      },
                      "is_superuser_field": "is_superuser",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "password_hash_field": "password_hash",
                      "salt_field": "salt",
                      "server": "127.0.0.1:27017"
                    }
                  },
                  "password_based:redis": {
                    "summary": "password_based authentication with Redis backend",
                    "value": {
                      "backend": "redis",
                      "cmd": "HMGET ${username} password_hash salt",
                      "database": 0,
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "redis_type": "single",
                      "server": "127.0.0.1:6379"
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authn-jwt.jwks"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.public-key"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.hmac-based"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.post"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.get"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.replica-set"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-postgresql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mysql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-builtin_db.authentication"
                    }
                  ]
                }
              }
            }
          },
          "204": {
            "description": "Authentication or listener does not existed"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Get the listener's authenticator",
        "tags": [
          "Gateway Listeners"
        ]
      },
      "post": {
        "description": "Enable authenticator for specified listener for client authentication.<br/><br/>When authenticator is enabled for a listener, all clients connecting to that listener will use that authenticator for authentication.",
        "parameters": [
          {
            "description": "Gateway Name.<br/><br/>It's enum with `stomp`, `mqttsn`, `coap`, `lwm2m`, `exproto`",
            "example": "stomp",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Listener ID",
            "example": "",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "jwt": {
                  "summary": "JWT authentication",
                  "value": {
                    "algorithm": "hmac-based",
                    "mechanism": "jwt",
                    "secret": "mysecret",
                    "secret_base64_encoded": false,
                    "use_jwks": false,
                    "verify_claims": {
                      "username": "${username}"
                    }
                  }
                },
                "password_based:built_in_database": {
                  "summary": "Built-in password_based authentication",
                  "value": {
                    "backend": "built_in_database",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "user_id_type": "username"
                  }
                },
                "password_based:http": {
                  "summary": "password_based authentication through external HTTP API",
                  "value": {
                    "backend": "http",
                    "body": {
                      "password": "${password}",
                      "username": "${username}"
                    },
                    "connect_timeout": 5000,
                    "enable_pipelining": 100,
                    "headers": {
                      "content-type": "application/json"
                    },
                    "mechanism": "password_based",
                    "method": "post",
                    "pool_size": 8,
                    "request_timeout": 5000,
                    "ssl": {
                      "enable": false
                    },
                    "url": "http://127.0.0.1:18083"
                  }
                },
                "password_based:mongodb": {
                  "summary": "password_based authentication with MongoDB backend",
                  "value": {
                    "backend": "mongodb",
                    "collection": "users",
                    "database": "example",
                    "filter": {
                      "username": "${username}"
                    },
                    "is_superuser_field": "is_superuser",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "password_hash_field": "password_hash",
                    "salt_field": "salt",
                    "server": "127.0.0.1:27017"
                  }
                },
                "password_based:redis": {
                  "summary": "password_based authentication with Redis backend",
                  "value": {
                    "backend": "redis",
                    "cmd": "HMGET ${username} password_hash salt",
                    "database": 0,
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "redis_type": "single",
                    "server": "127.0.0.1:6379"
                  }
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/authn-jwt.jwks"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.public-key"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.hmac-based"
                  },
                  {
                    "$ref": "#/components/schemas/authn-http.post"
                  },
                  {
                    "$ref": "#/components/schemas/authn-http.get"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.standalone"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.replica-set"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.standalone"
                  },
                  {
                    "$ref": "#/components/schemas/authn-postgresql.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mysql.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-builtin_db.authentication"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "jwt": {
                    "summary": "JWT authentication",
                    "value": {
                      "algorithm": "hmac-based",
                      "mechanism": "jwt",
                      "secret": "mysecret",
                      "secret_base64_encoded": false,
                      "use_jwks": false,
                      "verify_claims": {
                        "username": "${username}"
                      }
                    }
                  },
                  "password_based:built_in_database": {
                    "summary": "Built-in password_based authentication",
                    "value": {
                      "backend": "built_in_database",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "user_id_type": "username"
                    }
                  },
                  "password_based:http": {
                    "summary": "password_based authentication through external HTTP API",
                    "value": {
                      "backend": "http",
                      "body": {
                        "password": "${password}",
                        "username": "${username}"
                      },
                      "connect_timeout": 5000,
                      "enable_pipelining": 100,
                      "headers": {
                        "content-type": "application/json"
                      },
                      "mechanism": "password_based",
                      "method": "post",
                      "pool_size": 8,
                      "request_timeout": 5000,
                      "ssl": {
                        "enable": false
                      },
                      "url": "http://127.0.0.1:18083"
                    }
                  },
                  "password_based:mongodb": {
                    "summary": "password_based authentication with MongoDB backend",
                    "value": {
                      "backend": "mongodb",
                      "collection": "users",
                      "database": "example",
                      "filter": {
                        "username": "${username}"
                      },
                      "is_superuser_field": "is_superuser",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "password_hash_field": "password_hash",
                      "salt_field": "salt",
                      "server": "127.0.0.1:27017"
                    }
                  },
                  "password_based:redis": {
                    "summary": "password_based authentication with Redis backend",
                    "value": {
                      "backend": "redis",
                      "cmd": "HMGET ${username} password_hash salt",
                      "database": 0,
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "redis_type": "single",
                      "server": "127.0.0.1:6379"
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authn-jwt.jwks"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.public-key"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.hmac-based"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.post"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.get"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.replica-set"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-postgresql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mysql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-builtin_db.authentication"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Create authenticator for listener",
        "tags": [
          "Gateway Listeners"
        ]
      },
      "put": {
        "description": "Update authenticator configs for the listener, or disable/enable it.",
        "parameters": [
          {
            "description": "Gateway Name.<br/><br/>It's enum with `stomp`, `mqttsn`, `coap`, `lwm2m`, `exproto`",
            "example": "stomp",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Listener ID",
            "example": "",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "jwt": {
                  "summary": "JWT authentication",
                  "value": {
                    "algorithm": "hmac-based",
                    "mechanism": "jwt",
                    "secret": "mysecret",
                    "secret_base64_encoded": false,
                    "use_jwks": false,
                    "verify_claims": {
                      "username": "${username}"
                    }
                  }
                },
                "password_based:built_in_database": {
                  "summary": "Built-in password_based authentication",
                  "value": {
                    "backend": "built_in_database",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "user_id_type": "username"
                  }
                },
                "password_based:http": {
                  "summary": "password_based authentication through external HTTP API",
                  "value": {
                    "backend": "http",
                    "body": {
                      "password": "${password}",
                      "username": "${username}"
                    },
                    "connect_timeout": 5000,
                    "enable_pipelining": 100,
                    "headers": {
                      "content-type": "application/json"
                    },
                    "mechanism": "password_based",
                    "method": "post",
                    "pool_size": 8,
                    "request_timeout": 5000,
                    "ssl": {
                      "enable": false
                    },
                    "url": "http://127.0.0.1:18083"
                  }
                },
                "password_based:mongodb": {
                  "summary": "password_based authentication with MongoDB backend",
                  "value": {
                    "backend": "mongodb",
                    "collection": "users",
                    "database": "example",
                    "filter": {
                      "username": "${username}"
                    },
                    "is_superuser_field": "is_superuser",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "password_hash_field": "password_hash",
                    "salt_field": "salt",
                    "server": "127.0.0.1:27017"
                  }
                },
                "password_based:redis": {
                  "summary": "password_based authentication with Redis backend",
                  "value": {
                    "backend": "redis",
                    "cmd": "HMGET ${username} password_hash salt",
                    "database": 0,
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "redis_type": "single",
                    "server": "127.0.0.1:6379"
                  }
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/authn-jwt.jwks"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.public-key"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.hmac-based"
                  },
                  {
                    "$ref": "#/components/schemas/authn-http.post"
                  },
                  {
                    "$ref": "#/components/schemas/authn-http.get"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.standalone"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.replica-set"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.standalone"
                  },
                  {
                    "$ref": "#/components/schemas/authn-postgresql.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mysql.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-builtin_db.authentication"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "jwt": {
                    "summary": "JWT authentication",
                    "value": {
                      "algorithm": "hmac-based",
                      "mechanism": "jwt",
                      "secret": "mysecret",
                      "secret_base64_encoded": false,
                      "use_jwks": false,
                      "verify_claims": {
                        "username": "${username}"
                      }
                    }
                  },
                  "password_based:built_in_database": {
                    "summary": "Built-in password_based authentication",
                    "value": {
                      "backend": "built_in_database",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "user_id_type": "username"
                    }
                  },
                  "password_based:http": {
                    "summary": "password_based authentication through external HTTP API",
                    "value": {
                      "backend": "http",
                      "body": {
                        "password": "${password}",
                        "username": "${username}"
                      },
                      "connect_timeout": 5000,
                      "enable_pipelining": 100,
                      "headers": {
                        "content-type": "application/json"
                      },
                      "mechanism": "password_based",
                      "method": "post",
                      "pool_size": 8,
                      "request_timeout": 5000,
                      "ssl": {
                        "enable": false
                      },
                      "url": "http://127.0.0.1:18083"
                    }
                  },
                  "password_based:mongodb": {
                    "summary": "password_based authentication with MongoDB backend",
                    "value": {
                      "backend": "mongodb",
                      "collection": "users",
                      "database": "example",
                      "filter": {
                        "username": "${username}"
                      },
                      "is_superuser_field": "is_superuser",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "password_hash_field": "password_hash",
                      "salt_field": "salt",
                      "server": "127.0.0.1:27017"
                    }
                  },
                  "password_based:redis": {
                    "summary": "password_based authentication with Redis backend",
                    "value": {
                      "backend": "redis",
                      "cmd": "HMGET ${username} password_hash salt",
                      "database": 0,
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "redis_type": "single",
                      "server": "127.0.0.1:6379"
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authn-jwt.jwks"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.public-key"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.hmac-based"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.post"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.get"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.replica-set"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-postgresql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mysql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-builtin_db.authentication"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Update config of authenticator for listener",
        "tags": [
          "Gateway Listeners"
        ]
      }
    },
    "/gateways/{name}/listeners": {
      "get": {
        "description": "Gets a list of gateway listeners. This interface returns all the configs of the listener (including the authenticator on that listener), as well as the status of that listener running in the cluster.",
        "parameters": [
          {
            "description": "Gateway Name.<br/><br/>It's enum with `stomp`, `mqttsn`, `coap`, `lwm2m`, `exproto`",
            "example": "stomp",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": [
                  {
                    "acceptors": 16,
                    "access_rules": [
                      "allow all"
                    ],
                    "bind": "22213",
                    "dtls_options": {
                      "cacertfile": "/etc/emqx/certs/cacert.pem",
                      "certfile": "/etc/emqx/certs/cert.pem",
                      "fail_if_no_peer_cert": false,
                      "keyfile": "/etc/emqx/certs/key.pem",
                      "verify": "verify_none",
                      "versions": [
                        "dtlsv1.2",
                        "dtlsv1"
                      ]
                    },
                    "max_conn_rate": 1000,
                    "max_connections": 1024000,
                    "name": "dtls-def",
                    "node_status": [
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "current_connections": 10,
                          "max_connections": 1024000,
                          "running": true
                        }
                      }
                    ],
                    "status": {
                      "current_connections": 10,
                      "max_connections": 1024000,
                      "running": true
                    },
                    "type": "dtls",
                    "udp_options": {
                      "active_n": 100,
                      "backlog": 1024
                    }
                  },
                  {
                    "acceptors": 16,
                    "bind": "22214",
                    "dtls_options": {
                      "cacertfile": "/etc/emqx/certs/cacert.pem",
                      "certfile": "/etc/emqx/certs/cert.pem",
                      "ciphers": "RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA",
                      "fail_if_no_peer_cert": false,
                      "keyfile": "/etc/emqx/certs/key.pem",
                      "user_lookup_fun": "emqx_tls_psk:lookup",
                      "verify": "verify_none",
                      "versions": [
                        "dtlsv1.2",
                        "dtlsv1"
                      ]
                    },
                    "max_conn_rate": 1000,
                    "max_connections": 1024000,
                    "name": "dtls-psk",
                    "node_status": [
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "current_connections": 10,
                          "max_connections": 1024000,
                          "running": true
                        }
                      }
                    ],
                    "status": {
                      "current_connections": 10,
                      "max_connections": 1024000,
                      "running": true
                    },
                    "type": "dtls"
                  },
                  {
                    "acceptors": 16,
                    "authentication": {
                      "backend": "built_in_database",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256"
                      },
                      "user_id_type": "username"
                    },
                    "bind": "22215",
                    "max_conn_rate": 1000,
                    "max_connections": 1024000,
                    "name": "tcp-with-authn",
                    "node_status": [
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "current_connections": 10,
                          "max_connections": 1024000,
                          "running": true
                        }
                      }
                    ],
                    "status": {
                      "current_connections": 10,
                      "max_connections": 1024000,
                      "running": true
                    },
                    "type": "tcp"
                  },
                  {
                    "acceptors": 16,
                    "access_rules": [
                      "allow all"
                    ],
                    "bind": "22211",
                    "max_conn_rate": 1000,
                    "max_connections": 1024000,
                    "name": "ssl-def",
                    "node_status": [
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "current_connections": 10,
                          "max_connections": 1024000,
                          "running": true
                        }
                      }
                    ],
                    "ssl_options": {
                      "cacertfile": "/etc/emqx/certs/cacert.pem",
                      "certfile": "/etc/emqx/certs/cert.pem",
                      "fail_if_no_peer_cert": false,
                      "keyfile": "/etc/emqx/certs/key.pem",
                      "verify": "verify_none",
                      "versions": [
                        "tlsv1.3",
                        "tlsv1.2",
                        "tlsv1.1",
                        "tlsv1"
                      ]
                    },
                    "status": {
                      "current_connections": 10,
                      "max_connections": 1024000,
                      "running": true
                    },
                    "tcp_options": {
                      "active_n": 100,
                      "backlog": 1024
                    },
                    "type": "ssl"
                  },
                  {
                    "acceptors": 16,
                    "bind": "22210",
                    "max_conn_rate": 1000,
                    "max_connections": 1024000,
                    "name": "tcp-def",
                    "node_status": [
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "current_connections": 10,
                          "max_connections": 1024000,
                          "running": true
                        }
                      }
                    ],
                    "status": {
                      "current_connections": 10,
                      "max_connections": 1024000,
                      "running": true
                    },
                    "tcp_options": {
                      "active_n": 100,
                      "backlog": 1024,
                      "buffer": "10KB",
                      "high_watermark": "1MB",
                      "nodelay": false,
                      "recbuf": "10KB",
                      "reuseaddr": true,
                      "send_timeout": "15s",
                      "send_timeout_close": true,
                      "sndbuf": "10KB"
                    },
                    "type": "tcp"
                  },
                  {
                    "bind": "22212",
                    "name": "udp-def",
                    "node_status": [
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "current_connections": 10,
                          "max_connections": 1024000,
                          "running": true
                        }
                      }
                    ],
                    "status": {
                      "current_connections": 10,
                      "max_connections": 1024000,
                      "running": true
                    },
                    "type": "udp",
                    "udp_options": {
                      "active_n": 100,
                      "buffer": "10KB",
                      "recbuf": "10KB",
                      "reuseaddr": true,
                      "sndbuf": "10KB"
                    }
                  }
                ],
                "schema": {
                  "items": {
                    "oneOf": [
                      {
                        "$ref": "#/components/schemas/emqx_gateway_api_listeners.dtls_listener"
                      },
                      {
                        "$ref": "#/components/schemas/emqx_gateway_api_listeners.udp_listener"
                      },
                      {
                        "$ref": "#/components/schemas/emqx_gateway_api_listeners.ssl_listener"
                      },
                      {
                        "$ref": "#/components/schemas/emqx_gateway_api_listeners.tcp_listener"
                      }
                    ]
                  },
                  "type": "array"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "List all listeners",
        "tags": [
          "Gateway Listeners"
        ]
      },
      "post": {
        "description": "Create the gateway listener.<br/><br/>Note: For listener types not supported by a gateway, this API returns `400: BAD_REQUEST`.",
        "parameters": [
          {
            "description": "Gateway Name.<br/><br/>It's enum with `stomp`, `mqttsn`, `coap`, `lwm2m`, `exproto`",
            "example": "stomp",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "dtls_listener": {
                  "summary": "A simple DTLS listener example",
                  "value": {
                    "acceptors": 16,
                    "access_rules": [
                      "allow all"
                    ],
                    "bind": "22213",
                    "dtls_options": {
                      "cacertfile": "/etc/emqx/certs/cacert.pem",
                      "certfile": "/etc/emqx/certs/cert.pem",
                      "fail_if_no_peer_cert": false,
                      "keyfile": "/etc/emqx/certs/key.pem",
                      "verify": "verify_none",
                      "versions": [
                        "dtlsv1.2",
                        "dtlsv1"
                      ]
                    },
                    "max_conn_rate": 1000,
                    "max_connections": 1024000,
                    "name": "dtls-def",
                    "type": "dtls",
                    "udp_options": {
                      "active_n": 100,
                      "backlog": 1024
                    }
                  }
                },
                "dtls_listener_with_psk_ciphers": {
                  "summary": "A DTLS listener with PSK example",
                  "value": {
                    "acceptors": 16,
                    "bind": "22214",
                    "dtls_options": {
                      "cacertfile": "/etc/emqx/certs/cacert.pem",
                      "certfile": "/etc/emqx/certs/cert.pem",
                      "ciphers": "RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA",
                      "fail_if_no_peer_cert": false,
                      "keyfile": "/etc/emqx/certs/key.pem",
                      "user_lookup_fun": "emqx_tls_psk:lookup",
                      "verify": "verify_none",
                      "versions": [
                        "dtlsv1.2",
                        "dtlsv1"
                      ]
                    },
                    "max_conn_rate": 1000,
                    "max_connections": 1024000,
                    "name": "dtls-psk",
                    "type": "dtls"
                  }
                },
                "lisetner_with_authn": {
                  "summary": "A TCP listener with authentication example",
                  "value": {
                    "acceptors": 16,
                    "authentication": {
                      "backend": "built_in_database",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256"
                      },
                      "user_id_type": "username"
                    },
                    "bind": "22215",
                    "max_conn_rate": 1000,
                    "max_connections": 1024000,
                    "name": "tcp-with-authn",
                    "type": "tcp"
                  }
                },
                "ssl_listener": {
                  "summary": "A simple SSL listener example",
                  "value": {
                    "acceptors": 16,
                    "access_rules": [
                      "allow all"
                    ],
                    "bind": "22211",
                    "max_conn_rate": 1000,
                    "max_connections": 1024000,
                    "name": "ssl-def",
                    "ssl_options": {
                      "cacertfile": "/etc/emqx/certs/cacert.pem",
                      "certfile": "/etc/emqx/certs/cert.pem",
                      "fail_if_no_peer_cert": false,
                      "keyfile": "/etc/emqx/certs/key.pem",
                      "verify": "verify_none",
                      "versions": [
                        "tlsv1.3",
                        "tlsv1.2",
                        "tlsv1.1",
                        "tlsv1"
                      ]
                    },
                    "tcp_options": {
                      "active_n": 100,
                      "backlog": 1024
                    },
                    "type": "ssl"
                  }
                },
                "tcp_listener": {
                  "summary": "A simple TCP listener example",
                  "value": {
                    "acceptors": 16,
                    "bind": "22210",
                    "max_conn_rate": 1000,
                    "max_connections": 1024000,
                    "name": "tcp-def",
                    "tcp_options": {
                      "active_n": 100,
                      "backlog": 1024,
                      "buffer": "10KB",
                      "high_watermark": "1MB",
                      "nodelay": false,
                      "recbuf": "10KB",
                      "reuseaddr": true,
                      "send_timeout": "15s",
                      "send_timeout_close": true,
                      "sndbuf": "10KB"
                    },
                    "type": "tcp"
                  }
                },
                "udp_listener": {
                  "summary": "A simple UDP listener example",
                  "value": {
                    "bind": "22212",
                    "name": "udp-def",
                    "type": "udp",
                    "udp_options": {
                      "active_n": 100,
                      "buffer": "10KB",
                      "recbuf": "10KB",
                      "reuseaddr": true,
                      "sndbuf": "10KB"
                    }
                  }
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.dtls_listener"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.udp_listener"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.ssl_listener"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.tcp_listener"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "dtls_listener": {
                    "summary": "A simple DTLS listener example",
                    "value": {
                      "acceptors": 16,
                      "access_rules": [
                        "allow all"
                      ],
                      "bind": "22213",
                      "dtls_options": {
                        "cacertfile": "/etc/emqx/certs/cacert.pem",
                        "certfile": "/etc/emqx/certs/cert.pem",
                        "fail_if_no_peer_cert": false,
                        "keyfile": "/etc/emqx/certs/key.pem",
                        "verify": "verify_none",
                        "versions": [
                          "dtlsv1.2",
                          "dtlsv1"
                        ]
                      },
                      "max_conn_rate": 1000,
                      "max_connections": 1024000,
                      "name": "dtls-def",
                      "type": "dtls",
                      "udp_options": {
                        "active_n": 100,
                        "backlog": 1024
                      }
                    }
                  },
                  "dtls_listener_with_psk_ciphers": {
                    "summary": "A DTLS listener with PSK example",
                    "value": {
                      "acceptors": 16,
                      "bind": "22214",
                      "dtls_options": {
                        "cacertfile": "/etc/emqx/certs/cacert.pem",
                        "certfile": "/etc/emqx/certs/cert.pem",
                        "ciphers": "RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA",
                        "fail_if_no_peer_cert": false,
                        "keyfile": "/etc/emqx/certs/key.pem",
                        "user_lookup_fun": "emqx_tls_psk:lookup",
                        "verify": "verify_none",
                        "versions": [
                          "dtlsv1.2",
                          "dtlsv1"
                        ]
                      },
                      "max_conn_rate": 1000,
                      "max_connections": 1024000,
                      "name": "dtls-psk",
                      "type": "dtls"
                    }
                  },
                  "lisetner_with_authn": {
                    "summary": "A TCP listener with authentication example",
                    "value": {
                      "acceptors": 16,
                      "authentication": {
                        "backend": "built_in_database",
                        "mechanism": "password_based",
                        "password_hash_algorithm": {
                          "name": "sha256"
                        },
                        "user_id_type": "username"
                      },
                      "bind": "22215",
                      "max_conn_rate": 1000,
                      "max_connections": 1024000,
                      "name": "tcp-with-authn",
                      "type": "tcp"
                    }
                  },
                  "ssl_listener": {
                    "summary": "A simple SSL listener example",
                    "value": {
                      "acceptors": 16,
                      "access_rules": [
                        "allow all"
                      ],
                      "bind": "22211",
                      "max_conn_rate": 1000,
                      "max_connections": 1024000,
                      "name": "ssl-def",
                      "ssl_options": {
                        "cacertfile": "/etc/emqx/certs/cacert.pem",
                        "certfile": "/etc/emqx/certs/cert.pem",
                        "fail_if_no_peer_cert": false,
                        "keyfile": "/etc/emqx/certs/key.pem",
                        "verify": "verify_none",
                        "versions": [
                          "tlsv1.3",
                          "tlsv1.2",
                          "tlsv1.1",
                          "tlsv1"
                        ]
                      },
                      "tcp_options": {
                        "active_n": 100,
                        "backlog": 1024
                      },
                      "type": "ssl"
                    }
                  },
                  "tcp_listener": {
                    "summary": "A simple TCP listener example",
                    "value": {
                      "acceptors": 16,
                      "bind": "22210",
                      "max_conn_rate": 1000,
                      "max_connections": 1024000,
                      "name": "tcp-def",
                      "tcp_options": {
                        "active_n": 100,
                        "backlog": 1024,
                        "buffer": "10KB",
                        "high_watermark": "1MB",
                        "nodelay": false,
                        "recbuf": "10KB",
                        "reuseaddr": true,
                        "send_timeout": "15s",
                        "send_timeout_close": true,
                        "sndbuf": "10KB"
                      },
                      "type": "tcp"
                    }
                  },
                  "udp_listener": {
                    "summary": "A simple UDP listener example",
                    "value": {
                      "bind": "22212",
                      "name": "udp-def",
                      "type": "udp",
                      "udp_options": {
                        "active_n": 100,
                        "buffer": "10KB",
                        "recbuf": "10KB",
                        "reuseaddr": true,
                        "sndbuf": "10KB"
                      }
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.dtls_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.udp_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.ssl_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.tcp_listener"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Add listener",
        "tags": [
          "Gateway Listeners"
        ]
      }
    },
    "/configs/sys_topics": {
      "get": {
        "description": "Get the sub-configurations under *sys_topics*",
        "parameters": [],
        "responses": {
          "200": {
            "description": "System topics configuration.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/broker.sys_topics"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "config not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Configs"
        ]
      },
      "put": {
        "description": "Update the sub-configurations under *sys_topics*",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/broker.sys_topics"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "System topics configuration.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/broker.sys_topics"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "UPDATE_FAILED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "403": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "UPDATE_FAILED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Configs"
        ]
      }
    },
    "/authorization/sources/built_in_database/rules/clients": {
      "get": {
        "description": "Show the list of rules for clients",
        "parameters": [
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          },
          {
            "description": "Fuzzy search `clientid` as substring",
            "in": "query",
            "name": "like_clientid",
            "required": false,
            "schema": {
              "type": "string"
            },
            "summary": "fuzzy_clientid"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "password_based:built_in_database": {
                    "summary": "ClientID",
                    "value": {
                      "data": [
                        {
                          "clientid": "client1",
                          "rules": [
                            {
                              "action": "publish",
                              "permission": "allow",
                              "topic": "test/toopic/1"
                            },
                            {
                              "action": "subscribe",
                              "permission": "allow",
                              "topic": "test/toopic/2"
                            },
                            {
                              "action": "all",
                              "permission": "deny",
                              "topic": "eq test/#"
                            }
                          ]
                        }
                      ],
                      "meta": {
                        "count": 1,
                        "limit": 100,
                        "page": 1
                      }
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authz_api_mnesia.clientid_response_data"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Authorization"
        ]
      },
      "post": {
        "description": "Add new rule for 'clientid'",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "password_based:built_in_database": {
                  "summary": "ClientID",
                  "value": [
                    {
                      "clientid": "client1",
                      "rules": [
                        {
                          "action": "publish",
                          "permission": "allow",
                          "topic": "test/toopic/1"
                        },
                        {
                          "action": "subscribe",
                          "permission": "allow",
                          "topic": "test/toopic/2"
                        },
                        {
                          "action": "all",
                          "permission": "deny",
                          "topic": "eq test/#"
                        }
                      ]
                    }
                  ]
                }
              },
              "schema": {
                "items": {
                  "$ref": "#/components/schemas/emqx_authz_api_mnesia.rules_for_clientid"
                },
                "type": "array"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Created"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad clientid or bad rule schema",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Authorization"
        ]
      }
    },
    "/schema_registry": {
      "get": {
        "description": "List all registered schemas",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "sample": {
                    "value": [
                      {
                        "description": "My Avro Schema",
                        "name": "my_avro_schema",
                        "source": "{\"type\":\"record\",\"fields\":[{\"type\":\"int\",\"name\":\"i\"},{\"type\":\"string\",\"name\":\"s\"}]}",
                        "type": "avro"
                      }
                    ]
                  }
                },
                "schema": {
                  "items": {
                    "oneOf": [
                      {
                        "$ref": "#/components/schemas/emqx_ee_schema_registry_schema.get_avro"
                      }
                    ]
                  },
                  "type": "array"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "List schemas",
        "tags": [
          "Schema_registry"
        ]
      },
      "post": {
        "description": "Register a new schema",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "avro_schema": {
                  "summary": "Avro",
                  "value": {
                    "description": "My Avro Schema",
                    "name": "my_avro_schema",
                    "source": "{\"type\":\"record\",\"fields\":[{\"type\":\"int\",\"name\":\"i\"},{\"type\":\"string\",\"name\":\"s\"}]}",
                    "type": "avro"
                  }
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/emqx_ee_schema_registry_schema.get_avro"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "avro_schema": {
                    "summary": "Avro",
                    "value": {
                      "description": "My Avro Schema",
                      "name": "my_avro_schema",
                      "source": "{\"type\":\"record\",\"fields\":[{\"type\":\"int\",\"name\":\"i\"},{\"type\":\"string\",\"name\":\"s\"}]}",
                      "type": "avro"
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/emqx_ee_schema_registry_schema.get_avro"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "ALREADY_EXISTS"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Schema already exists",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Register schema",
        "tags": [
          "Schema_registry"
        ]
      }
    },
    "/mqtt/delayed/messages/{node}/{msgid}": {
      "delete": {
        "description": "Delete delayed message",
        "parameters": [
          {
            "description": "The node where message from",
            "in": "path",
            "name": "node",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Delayed Message ID",
            "in": "path",
            "name": "msgid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Delete delayed message success"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "MESSAGE_ID_SCHEMA_ERROR",
                        "INVALID_NODE"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Message ID format",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "MESSAGE_ID_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Message ID not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "MQTT"
        ]
      },
      "get": {
        "description": "View delayed message",
        "parameters": [
          {
            "description": "The node where message from",
            "in": "path",
            "name": "node",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Delayed Message ID",
            "in": "path",
            "name": "msgid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_delayed_api.message_without_payload"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "MESSAGE_ID_SCHEMA_ERROR",
                        "INVALID_NODE"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Message ID format",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "MESSAGE_ID_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Message ID not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "MQTT"
        ]
      }
    },
    "/monitor_current/nodes/{node}": {
      "get": {
        "description": "Node current status. Gauge and rate.",
        "parameters": [
          {
            "description": "EMQX node name.",
            "example": "emqx@127.0.0.1",
            "in": "path",
            "name": "node",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_dashboard_monitor_api.sampler_current"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Node not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Metrics"
        ]
      }
    },
    "/telemetry/status": {
      "get": {
        "description": "Get telemetry status",
        "parameters": [],
        "responses": {
          "200": {
            "description": "Get telemetry status",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_telemetry_api.status"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Telemetry"
        ]
      },
      "put": {
        "description": "Enable or disable telemetry",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx_telemetry_api.status"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Enable or disable telemetry",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_telemetry_api.status"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Telemetry"
        ]
      }
    },
    "/authentication/{id}/users": {
      "get": {
        "description": "List users in authenticator in global authentication chain.",
        "parameters": [
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          },
          {
            "description": "Fuzzy search user_id (username or clientid).",
            "in": "query",
            "name": "like_user_id",
            "required": false,
            "schema": {
              "type": "string"
            },
            "summary": "like_user_id"
          },
          {
            "description": "Is superuser",
            "in": "query",
            "name": "is_superuser",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "data": [
                    {
                      "user_id": "user1"
                    },
                    {
                      "is_superuser": true,
                      "user_id": "user2"
                    }
                  ],
                  "meta": {
                    "count": 300,
                    "limit": 20,
                    "page": 0
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_users"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Authentication"
        ]
      },
      "post": {
        "description": "Create users for authenticator in global authentication chain.",
        "parameters": [
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "regular_user": {
                  "summary": "Regular user",
                  "value": {
                    "password": "******",
                    "user_id": "user1"
                  }
                },
                "super_user": {
                  "summary": "Superuser",
                  "value": {
                    "is_superuser": true,
                    "password": "******",
                    "user_id": "user2"
                  }
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authn_api.request_user_create"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "regular_user": {
                    "summary": "Regular user",
                    "value": {
                      "user_id": "user1"
                    }
                  },
                  "super_user": {
                    "summary": "Superuser",
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Authentication"
        ]
      }
    },
    "/cluster": {
      "get": {
        "description": "Get cluster info",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "name": {
                      "description": "Cluster name",
                      "type": "string"
                    },
                    "nodes": {
                      "description": "Node name",
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    "self": {
                      "description": "Self node name",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Cluster"
        ]
      }
    },
    "/plugins/{name}/{action}": {
      "put": {
        "description": "start/stop a installed plugin.<br/>- **start**: start the plugin.<br/>- **stop**: stop the plugin.<br/>",
        "parameters": [
          {
            "$ref": "#/components/parameters/plugins.name"
          },
          {
            "description": "Action",
            "in": "path",
            "name": "action",
            "required": true,
            "schema": {
              "enum": [
                "start",
                "stop"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Plugin Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Trigger action on an installed plugin",
        "tags": [
          "Plugins"
        ]
      }
    },
    "/gateways/{name}/clients/{clientid}": {
      "delete": {
        "description": "Kick out the gateway client",
        "parameters": [
          {
            "description": "Client ID",
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Gateway Name",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Kicked"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Kick out client",
        "tags": [
          "Gateway Clients"
        ]
      },
      "get": {
        "description": "Get the gateway client information",
        "parameters": [
          {
            "description": "Client ID",
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Gateway Name",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "general_client": {
                    "summary": "General client info",
                    "value": {
                      "ip_address": "127.0.0.1",
                      "inflight_cnt": 0,
                      "connected_at": "2021-12-07T10:44:02.721+08:00",
                      "keepalive": 0,
                      "recv_cnt": 1,
                      "recv_pkt": 1,
                      "created_at": "2021-12-07T10:44:02.721+08:00",
                      "proto_ver": "1.0",
                      "recv_msg": 0,
                      "connected": true,
                      "mailbox_len": 0,
                      "proto_name": "STOMP",
                      "username": "guest",
                      "subscriptions_max": "infinity",
                      "disconnected_at": null,
                      "subscriptions_cnt": 0,
                      "mqueue_max": "infinity",
                      "expiry_interval": 0,
                      "clientid": "MzAyMzEzNTUwNzk1NDA1MzYyMzIwNzUxNjQwMTY1NzQ0NjE",
                      "reductions": 72022,
                      "awaiting_rel_max": "infinity",
                      "mqueue_dropped": 0,
                      "send_oct": 61,
                      "mqueue_len": 0,
                      "send_pkt": 1,
                      "is_bridge": false,
                      "clean_start": true,
                      "send_cnt": 1,
                      "node": "emqx@127.0.0.1",
                      "awaiting_rel_cnt": 0,
                      "heap_size": 4185,
                      "port": 50675,
                      "inflight_max": "infinity",
                      "send_msg": 0,
                      "recv_oct": 56
                    }
                  },
                  "lwm2m_client": {
                    "summary": "LwM2M client info",
                    "value": {
                      "ip_address": "127.0.0.1",
                      "inflight_cnt": 0,
                      "connected_at": "2021-12-07T10:44:02.721+08:00",
                      "keepalive": 0,
                      "recv_cnt": 1,
                      "recv_pkt": 1,
                      "created_at": "2021-12-07T10:44:02.721+08:00",
                      "proto_ver": "1.0",
                      "recv_msg": 0,
                      "connected": true,
                      "mailbox_len": 0,
                      "proto_name": "LwM2M",
                      "username": "guest",
                      "subscriptions_max": "infinity",
                      "disconnected_at": null,
                      "subscriptions_cnt": 0,
                      "endpoint_name": "urn:imei:154928475237123",
                      "mqueue_max": "infinity",
                      "expiry_interval": 0,
                      "clientid": "MzAyMzEzNTUwNzk1NDA1MzYyMzIwNzUxNjQwMTY1NzQ0NjE",
                      "reductions": 72022,
                      "awaiting_rel_max": "infinity",
                      "mqueue_dropped": 0,
                      "send_oct": 61,
                      "mqueue_len": 0,
                      "send_pkt": 1,
                      "is_bridge": false,
                      "clean_start": true,
                      "send_cnt": 1,
                      "node": "emqx@127.0.0.1",
                      "awaiting_rel_cnt": 0,
                      "heap_size": 4185,
                      "port": 50675,
                      "inflight_max": "infinity",
                      "send_msg": 0,
                      "recv_oct": 56,
                      "lifetime": 86400
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api_clients.exproto_client"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api_clients.lwm2m_client"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api_clients.coap_client"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api_clients.mqttsn_client"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api_clients.stomp_client"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Get client info",
        "tags": [
          "Gateway Clients"
        ]
      }
    },
    "/publish/bulk": {
      "post": {
        "description": "Possible HTTP response status code are:<br/><br/>200: All messages are delivered to at least one subscriber;<br/><br/>202: At least one message was not delivered to any subscriber;<br/><br/>400: At least one message is invalid. For example bad topic name, or QoS is out of range;<br/><br/>503: Failed to deliver at least one of the messages;<br/><br/><br/>In case there is at lest one invalid message in the batch, the HTTP response body<br/>is the same as for <code>/publish</code> API.<br/><br/>Otherwise the HTTP response body is an array of JSON objects indicating the publish<br/>result of each individual message in the batch.",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "items": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_publish.publish_message"
                },
                "type": "array"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/emqx_mgmt_api_publish.publish_ok"
                  },
                  "type": "array"
                }
              }
            }
          },
          "202": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/emqx_mgmt_api_publish.publish_error"
                  },
                  "type": "array"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "items": {
                        "$ref": "#/components/schemas/emqx_mgmt_api_publish.publish_error"
                      },
                      "type": "array"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_mgmt_api_publish.bad_request"
                    }
                  ]
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/emqx_mgmt_api_publish.publish_error"
                  },
                  "type": "array"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Publish a batch of messages",
        "tags": [
          "Publish"
        ]
      }
    },
    "/nodes/{node}/bridges/{id}/{operation}": {
      "post": {
        "description": "Stop/Restart bridges on a specific node.",
        "parameters": [
          {
            "description": "The node name, e.g. emqx@127.0.0.1",
            "example": "emqx@127.0.0.1",
            "in": "path",
            "name": "node",
            "required": true,
            "schema": {
              "type": "string"
            },
            "summary": "The node name"
          },
          {
            "description": "The bridge Id. Must be of format {type}:{name}",
            "example": "webhook:webhook_example",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            },
            "summary": "Bridge ID"
          },
          {
            "description": "Operations can be one of: stop, restart",
            "example": "start",
            "in": "path",
            "name": "operation",
            "required": true,
            "schema": {
              "enum": [
                "start",
                "stop",
                "restart"
              ],
              "type": "string"
            },
            "summary": "Node Operation "
          }
        ],
        "responses": {
          "204": {
            "description": "Operation success"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Problem with configuration of external service or bridge not enabled",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bridge or node not found or invalid operation",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "501": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_IMPLEMENTED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Implemented",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Service unavailable",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Node Bridge Operate",
        "tags": [
          "Bridges"
        ]
      }
    },
    "/rule_test": {
      "post": {
        "description": "Test a rule",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx_rule_api_schema.rule_test"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Rule Test Pass"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Invalid Parameters",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "412": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_MATCH"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "SQL Not Match",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Test Rule",
        "tags": [
          "Rules"
        ]
      }
    },
    "/authorization/sources/built_in_database/rules/clients/{clientid}": {
      "delete": {
        "description": "Delete rule for 'clientid'",
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_authz_api_mnesia.clientid"
          }
        ],
        "responses": {
          "204": {
            "description": "Deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad clientid",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "ClientID Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Authorization"
        ]
      },
      "get": {
        "description": "Get rule for 'clientid'",
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_authz_api_mnesia.clientid"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "password_based:built_in_database": {
                    "summary": "ClientID",
                    "value": {
                      "clientid": "client1",
                      "rules": [
                        {
                          "action": "publish",
                          "permission": "allow",
                          "topic": "test/toopic/1"
                        },
                        {
                          "action": "subscribe",
                          "permission": "allow",
                          "topic": "test/toopic/2"
                        },
                        {
                          "action": "all",
                          "permission": "deny",
                          "topic": "eq test/#"
                        }
                      ]
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authz_api_mnesia.rules_for_clientid"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Authorization"
        ]
      },
      "put": {
        "description": "Set rule for 'clientid'",
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_authz_api_mnesia.clientid"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "password_based:built_in_database": {
                  "summary": "ClientID",
                  "value": {
                    "clientid": "client1",
                    "rules": [
                      {
                        "action": "publish",
                        "permission": "allow",
                        "topic": "test/toopic/1"
                      },
                      {
                        "action": "subscribe",
                        "permission": "allow",
                        "topic": "test/toopic/2"
                      },
                      {
                        "action": "all",
                        "permission": "deny",
                        "topic": "eq test/#"
                      }
                    ]
                  }
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authz_api_mnesia.rules_for_clientid"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Updated"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad clientid or bad rule schema",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Authorization"
        ]
      }
    },
    "/configs/sysmon": {
      "get": {
        "description": "Get the sub-configurations under *sysmon*",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/broker.sysmon"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "config not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Configs"
        ]
      },
      "put": {
        "description": "Update the sub-configurations under *sysmon*",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/broker.sysmon"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/broker.sysmon"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "UPDATE_FAILED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "403": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "UPDATE_FAILED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Configs"
        ]
      }
    },
    "/clients/{clientid}/authorization/cache": {
      "delete": {
        "description": "Clean client authz cache in the cluster.",
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Clean client authz cache successfully"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "CLIENTID_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Client ID not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Clients"
        ]
      },
      "get": {
        "description": "Get client authz cache in the cluster.",
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_clients.authz_cache"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "CLIENTID_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Client ID not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Clients"
        ]
      }
    },
    "/cluster/{node}/force_leave": {
      "delete": {
        "description": "Force leave node from cluster",
        "parameters": [
          {
            "$ref": "#/components/parameters/cluster.node"
          }
        ],
        "responses": {
          "204": {
            "description": "Delete successfully"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Cluster"
        ]
      }
    },
    "/gateways/{name}/listeners/{id}": {
      "delete": {
        "description": "Delete the gateway listener. All connected clients under the deleted listener will be disconnected.",
        "parameters": [
          {
            "description": "Gateway Name.<br/><br/>It's enum with `stomp`, `mqttsn`, `coap`, `lwm2m`, `exproto`",
            "example": "stomp",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Listener ID",
            "example": "",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Delete listener",
        "tags": [
          "Gateway Listeners"
        ]
      },
      "get": {
        "description": "Get the gateway listener configs",
        "parameters": [
          {
            "description": "Gateway Name.<br/><br/>It's enum with `stomp`, `mqttsn`, `coap`, `lwm2m`, `exproto`",
            "example": "stomp",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Listener ID",
            "example": "",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "dtls_listener": {
                    "summary": "A simple DTLS listener example",
                    "value": {
                      "acceptors": 16,
                      "access_rules": [
                        "allow all"
                      ],
                      "bind": "22213",
                      "dtls_options": {
                        "cacertfile": "/etc/emqx/certs/cacert.pem",
                        "certfile": "/etc/emqx/certs/cert.pem",
                        "fail_if_no_peer_cert": false,
                        "keyfile": "/etc/emqx/certs/key.pem",
                        "verify": "verify_none",
                        "versions": [
                          "dtlsv1.2",
                          "dtlsv1"
                        ]
                      },
                      "max_conn_rate": 1000,
                      "max_connections": 1024000,
                      "name": "dtls-def",
                      "type": "dtls",
                      "udp_options": {
                        "active_n": 100,
                        "backlog": 1024
                      }
                    }
                  },
                  "dtls_listener_with_psk_ciphers": {
                    "summary": "A DTLS listener with PSK example",
                    "value": {
                      "acceptors": 16,
                      "bind": "22214",
                      "dtls_options": {
                        "cacertfile": "/etc/emqx/certs/cacert.pem",
                        "certfile": "/etc/emqx/certs/cert.pem",
                        "ciphers": "RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA",
                        "fail_if_no_peer_cert": false,
                        "keyfile": "/etc/emqx/certs/key.pem",
                        "user_lookup_fun": "emqx_tls_psk:lookup",
                        "verify": "verify_none",
                        "versions": [
                          "dtlsv1.2",
                          "dtlsv1"
                        ]
                      },
                      "max_conn_rate": 1000,
                      "max_connections": 1024000,
                      "name": "dtls-psk",
                      "type": "dtls"
                    }
                  },
                  "lisetner_with_authn": {
                    "summary": "A TCP listener with authentication example",
                    "value": {
                      "acceptors": 16,
                      "authentication": {
                        "backend": "built_in_database",
                        "mechanism": "password_based",
                        "password_hash_algorithm": {
                          "name": "sha256"
                        },
                        "user_id_type": "username"
                      },
                      "bind": "22215",
                      "max_conn_rate": 1000,
                      "max_connections": 1024000,
                      "name": "tcp-with-authn",
                      "type": "tcp"
                    }
                  },
                  "ssl_listener": {
                    "summary": "A simple SSL listener example",
                    "value": {
                      "acceptors": 16,
                      "access_rules": [
                        "allow all"
                      ],
                      "bind": "22211",
                      "max_conn_rate": 1000,
                      "max_connections": 1024000,
                      "name": "ssl-def",
                      "ssl_options": {
                        "cacertfile": "/etc/emqx/certs/cacert.pem",
                        "certfile": "/etc/emqx/certs/cert.pem",
                        "fail_if_no_peer_cert": false,
                        "keyfile": "/etc/emqx/certs/key.pem",
                        "verify": "verify_none",
                        "versions": [
                          "tlsv1.3",
                          "tlsv1.2",
                          "tlsv1.1",
                          "tlsv1"
                        ]
                      },
                      "tcp_options": {
                        "active_n": 100,
                        "backlog": 1024
                      },
                      "type": "ssl"
                    }
                  },
                  "tcp_listener": {
                    "summary": "A simple TCP listener example",
                    "value": {
                      "acceptors": 16,
                      "bind": "22210",
                      "max_conn_rate": 1000,
                      "max_connections": 1024000,
                      "name": "tcp-def",
                      "tcp_options": {
                        "active_n": 100,
                        "backlog": 1024,
                        "buffer": "10KB",
                        "high_watermark": "1MB",
                        "nodelay": false,
                        "recbuf": "10KB",
                        "reuseaddr": true,
                        "send_timeout": "15s",
                        "send_timeout_close": true,
                        "sndbuf": "10KB"
                      },
                      "type": "tcp"
                    }
                  },
                  "udp_listener": {
                    "summary": "A simple UDP listener example",
                    "value": {
                      "bind": "22212",
                      "name": "udp-def",
                      "type": "udp",
                      "udp_options": {
                        "active_n": 100,
                        "buffer": "10KB",
                        "recbuf": "10KB",
                        "reuseaddr": true,
                        "sndbuf": "10KB"
                      }
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.dtls_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.udp_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.ssl_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.tcp_listener"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Get listener config",
        "tags": [
          "Gateway Listeners"
        ]
      },
      "put": {
        "description": "Update the gateway listener. The listener being updated performs a restart and all clients connected to that listener will be disconnected.",
        "parameters": [
          {
            "description": "Gateway Name.<br/><br/>It's enum with `stomp`, `mqttsn`, `coap`, `lwm2m`, `exproto`",
            "example": "stomp",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Listener ID",
            "example": "",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "dtls_listener": {
                  "summary": "A simple DTLS listener example",
                  "value": {
                    "acceptors": 16,
                    "access_rules": [
                      "allow all"
                    ],
                    "bind": "22213",
                    "dtls_options": {
                      "cacertfile": "/etc/emqx/certs/cacert.pem",
                      "certfile": "/etc/emqx/certs/cert.pem",
                      "fail_if_no_peer_cert": false,
                      "keyfile": "/etc/emqx/certs/key.pem",
                      "verify": "verify_none",
                      "versions": [
                        "dtlsv1.2",
                        "dtlsv1"
                      ]
                    },
                    "max_conn_rate": 1000,
                    "max_connections": 1024000,
                    "name": "dtls-def",
                    "type": "dtls",
                    "udp_options": {
                      "active_n": 100,
                      "backlog": 1024
                    }
                  }
                },
                "dtls_listener_with_psk_ciphers": {
                  "summary": "A DTLS listener with PSK example",
                  "value": {
                    "acceptors": 16,
                    "bind": "22214",
                    "dtls_options": {
                      "cacertfile": "/etc/emqx/certs/cacert.pem",
                      "certfile": "/etc/emqx/certs/cert.pem",
                      "ciphers": "RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA",
                      "fail_if_no_peer_cert": false,
                      "keyfile": "/etc/emqx/certs/key.pem",
                      "user_lookup_fun": "emqx_tls_psk:lookup",
                      "verify": "verify_none",
                      "versions": [
                        "dtlsv1.2",
                        "dtlsv1"
                      ]
                    },
                    "max_conn_rate": 1000,
                    "max_connections": 1024000,
                    "name": "dtls-psk",
                    "type": "dtls"
                  }
                },
                "lisetner_with_authn": {
                  "summary": "A TCP listener with authentication example",
                  "value": {
                    "acceptors": 16,
                    "authentication": {
                      "backend": "built_in_database",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256"
                      },
                      "user_id_type": "username"
                    },
                    "bind": "22215",
                    "max_conn_rate": 1000,
                    "max_connections": 1024000,
                    "name": "tcp-with-authn",
                    "type": "tcp"
                  }
                },
                "ssl_listener": {
                  "summary": "A simple SSL listener example",
                  "value": {
                    "acceptors": 16,
                    "access_rules": [
                      "allow all"
                    ],
                    "bind": "22211",
                    "max_conn_rate": 1000,
                    "max_connections": 1024000,
                    "name": "ssl-def",
                    "ssl_options": {
                      "cacertfile": "/etc/emqx/certs/cacert.pem",
                      "certfile": "/etc/emqx/certs/cert.pem",
                      "fail_if_no_peer_cert": false,
                      "keyfile": "/etc/emqx/certs/key.pem",
                      "verify": "verify_none",
                      "versions": [
                        "tlsv1.3",
                        "tlsv1.2",
                        "tlsv1.1",
                        "tlsv1"
                      ]
                    },
                    "tcp_options": {
                      "active_n": 100,
                      "backlog": 1024
                    },
                    "type": "ssl"
                  }
                },
                "tcp_listener": {
                  "summary": "A simple TCP listener example",
                  "value": {
                    "acceptors": 16,
                    "bind": "22210",
                    "max_conn_rate": 1000,
                    "max_connections": 1024000,
                    "name": "tcp-def",
                    "tcp_options": {
                      "active_n": 100,
                      "backlog": 1024,
                      "buffer": "10KB",
                      "high_watermark": "1MB",
                      "nodelay": false,
                      "recbuf": "10KB",
                      "reuseaddr": true,
                      "send_timeout": "15s",
                      "send_timeout_close": true,
                      "sndbuf": "10KB"
                    },
                    "type": "tcp"
                  }
                },
                "udp_listener": {
                  "summary": "A simple UDP listener example",
                  "value": {
                    "bind": "22212",
                    "name": "udp-def",
                    "type": "udp",
                    "udp_options": {
                      "active_n": 100,
                      "buffer": "10KB",
                      "recbuf": "10KB",
                      "reuseaddr": true,
                      "sndbuf": "10KB"
                    }
                  }
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.dtls_listener"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.udp_listener"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.ssl_listener"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.tcp_listener"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "dtls_listener": {
                    "summary": "A simple DTLS listener example",
                    "value": {
                      "acceptors": 16,
                      "access_rules": [
                        "allow all"
                      ],
                      "bind": "22213",
                      "dtls_options": {
                        "cacertfile": "/etc/emqx/certs/cacert.pem",
                        "certfile": "/etc/emqx/certs/cert.pem",
                        "fail_if_no_peer_cert": false,
                        "keyfile": "/etc/emqx/certs/key.pem",
                        "verify": "verify_none",
                        "versions": [
                          "dtlsv1.2",
                          "dtlsv1"
                        ]
                      },
                      "max_conn_rate": 1000,
                      "max_connections": 1024000,
                      "name": "dtls-def",
                      "type": "dtls",
                      "udp_options": {
                        "active_n": 100,
                        "backlog": 1024
                      }
                    }
                  },
                  "dtls_listener_with_psk_ciphers": {
                    "summary": "A DTLS listener with PSK example",
                    "value": {
                      "acceptors": 16,
                      "bind": "22214",
                      "dtls_options": {
                        "cacertfile": "/etc/emqx/certs/cacert.pem",
                        "certfile": "/etc/emqx/certs/cert.pem",
                        "ciphers": "RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA",
                        "fail_if_no_peer_cert": false,
                        "keyfile": "/etc/emqx/certs/key.pem",
                        "user_lookup_fun": "emqx_tls_psk:lookup",
                        "verify": "verify_none",
                        "versions": [
                          "dtlsv1.2",
                          "dtlsv1"
                        ]
                      },
                      "max_conn_rate": 1000,
                      "max_connections": 1024000,
                      "name": "dtls-psk",
                      "type": "dtls"
                    }
                  },
                  "lisetner_with_authn": {
                    "summary": "A TCP listener with authentication example",
                    "value": {
                      "acceptors": 16,
                      "authentication": {
                        "backend": "built_in_database",
                        "mechanism": "password_based",
                        "password_hash_algorithm": {
                          "name": "sha256"
                        },
                        "user_id_type": "username"
                      },
                      "bind": "22215",
                      "max_conn_rate": 1000,
                      "max_connections": 1024000,
                      "name": "tcp-with-authn",
                      "type": "tcp"
                    }
                  },
                  "ssl_listener": {
                    "summary": "A simple SSL listener example",
                    "value": {
                      "acceptors": 16,
                      "access_rules": [
                        "allow all"
                      ],
                      "bind": "22211",
                      "max_conn_rate": 1000,
                      "max_connections": 1024000,
                      "name": "ssl-def",
                      "ssl_options": {
                        "cacertfile": "/etc/emqx/certs/cacert.pem",
                        "certfile": "/etc/emqx/certs/cert.pem",
                        "fail_if_no_peer_cert": false,
                        "keyfile": "/etc/emqx/certs/key.pem",
                        "verify": "verify_none",
                        "versions": [
                          "tlsv1.3",
                          "tlsv1.2",
                          "tlsv1.1",
                          "tlsv1"
                        ]
                      },
                      "tcp_options": {
                        "active_n": 100,
                        "backlog": 1024
                      },
                      "type": "ssl"
                    }
                  },
                  "tcp_listener": {
                    "summary": "A simple TCP listener example",
                    "value": {
                      "acceptors": 16,
                      "bind": "22210",
                      "max_conn_rate": 1000,
                      "max_connections": 1024000,
                      "name": "tcp-def",
                      "tcp_options": {
                        "active_n": 100,
                        "backlog": 1024,
                        "buffer": "10KB",
                        "high_watermark": "1MB",
                        "nodelay": false,
                        "recbuf": "10KB",
                        "reuseaddr": true,
                        "send_timeout": "15s",
                        "send_timeout_close": true,
                        "sndbuf": "10KB"
                      },
                      "type": "tcp"
                    }
                  },
                  "udp_listener": {
                    "summary": "A simple UDP listener example",
                    "value": {
                      "bind": "22212",
                      "name": "udp-def",
                      "type": "udp",
                      "udp_options": {
                        "active_n": 100,
                        "buffer": "10KB",
                        "recbuf": "10KB",
                        "reuseaddr": true,
                        "sndbuf": "10KB"
                      }
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.dtls_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.udp_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.ssl_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.tcp_listener"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Update listener config",
        "tags": [
          "Gateway Listeners"
        ]
      }
    },
    "/gateways/{name}/enable/{enable}": {
      "put": {
        "description": "Update the gateway basic configurations and running status.<br/><br/>Note: The Authentication and Listener configurations should be updated by other special APIs.",
        "parameters": [
          {
            "description": "Gateway Name.<br/><br/>It's enum with `stomp`, `mqttsn`, `coap`, `lwm2m`, `exproto`",
            "example": "stomp",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Whether to enable this gateway",
            "example": true,
            "in": "path",
            "name": "enable",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Gateway configuration updated"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Enable or disable gateway",
        "tags": [
          "Gateways"
        ]
      }
    },
    "/rules": {
      "get": {
        "description": "List all rules",
        "parameters": [
          {
            "description": "Filter enable/disable rules",
            "in": "query",
            "name": "enable",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Filter rules by from(topic), exact match",
            "in": "query",
            "name": "from",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter rules by id, Substring matching",
            "in": "query",
            "name": "like_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter rules by from(topic), Substring matching",
            "in": "query",
            "name": "like_from",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter rules by description, Substring matching",
            "in": "query",
            "name": "like_description",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter rules by from(topic), Mqtt topic matching",
            "in": "query",
            "name": "match_from",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "data": {
                      "description": "List of rules",
                      "items": {
                        "$ref": "#/components/schemas/emqx_rule_api_schema.rule_info"
                      },
                      "summary": "List Rules",
                      "type": "array"
                    },
                    "meta": {
                      "$ref": "#/components/schemas/public.meta"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Invalid Parameters",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "List All Rules",
        "tags": [
          "Rules"
        ]
      },
      "post": {
        "description": "Create a new rule using given Id",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx_rule_api_schema.rule_creation"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_rule_api_schema.rule_info"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Invalid Parameters",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Create Rule By ID",
        "tags": [
          "Rules"
        ]
      }
    },
    "/authentication/{id}/status": {
      "get": {
        "description": "Get authenticator status from global authentication chain.",
        "parameters": [
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "status_metrics": {
                    "summary": "Authn status metrics",
                    "value": {
                      "metrics": {
                        "failed": 0,
                        "nomatch": 0,
                        "rate": 0,
                        "rate_last5m": 0,
                        "rate_max": 0,
                        "success": 0,
                        "total": 0
                      },
                      "node_error": [],
                      "node_metrics": [
                        {
                          "metrics": {
                            "failed": 0,
                            "matched": 0,
                            "nomatch": 0,
                            "rate": 0,
                            "rate_last5m": 0,
                            "rate_max": 0,
                            "total": 0
                          },
                          "node": "emqx@127.0.0.1"
                        }
                      ],
                      "node_resource_metrics": [
                        {
                          "metrics": {
                            "failed": 0,
                            "matched": 0,
                            "rate": 0,
                            "rate_last5m": 0,
                            "rate_max": 0,
                            "success": 0
                          },
                          "node": "emqx@127.0.0.1"
                        }
                      ],
                      "node_status": [
                        {
                          "node": "emqx@127.0.0.1",
                          "status": "connected"
                        }
                      ],
                      "resource_metrics": {
                        "failed": 0,
                        "matched": 0,
                        "rate": 0,
                        "rate_last5m": 0,
                        "rate_max": 0,
                        "success": 0
                      },
                      "status": "connected"
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_schema.metrics_status_fields"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "500": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "INTERNAL_ERROR"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Internal Service Error",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Authentication"
        ]
      }
    },
    "/mqtt/topic_rewrite": {
      "get": {
        "description": "List all rewrite rules",
        "parameters": [],
        "responses": {
          "200": {
            "description": "List all rewrite rules",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/modules.rewrite"
                  },
                  "type": "array"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "MQTT"
        ]
      },
      "put": {
        "description": "Update all rewrite rules",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "items": {
                  "$ref": "#/components/schemas/modules.rewrite"
                },
                "type": "array"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Update all rewrite rules",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/modules.rewrite"
                  },
                  "type": "array"
                }
              }
            }
          },
          "413": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "EXCEED_LIMIT"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Rules count exceed max limit",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "MQTT"
        ]
      }
    },
    "/gateways": {
      "get": {
        "description": "This API returns an overview info for the specified or all gateways.<br/>including current running status, number of connections, listener status, etc.",
        "parameters": [
          {
            "description": "Filter gateways by status.<br/><br/>It is enum with `running`, `stopped`, `unloaded`",
            "example": "running",
            "in": "query",
            "name": "status",
            "required": false,
            "schema": {
              "enum": [
                "running",
                "stopped",
                "unloaded"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": [
                  {
                    "name": "coap",
                    "status": "unloaded"
                  },
                  {
                    "name": "exproto",
                    "status": "unloaded"
                  },
                  {
                    "created_at": "2021-12-08T14:41:26.171+08:00",
                    "current_connections": 0,
                    "listeners": [
                      {
                        "id": "lwm2m:udp:default",
                        "name": "default",
                        "running": true,
                        "type": "udp"
                      }
                    ],
                    "max_connections": 1024000,
                    "name": "lwm2m",
                    "node_status": [
                      {
                        "current_connections": 0,
                        "max_connections": 1024000,
                        "node": "node@127.0.0.1",
                        "status": "running"
                      }
                    ],
                    "started_at": "2021-12-08T14:41:26.202+08:00",
                    "status": "running"
                  },
                  {
                    "created_at": "2021-12-08T14:41:45.071+08:00",
                    "current_connections": 0,
                    "listeners": [
                      {
                        "id": "mqttsn:udp:default",
                        "name": "default",
                        "running": false,
                        "type": "udp"
                      }
                    ],
                    "max_connections": 1024000,
                    "name": "mqttsn",
                    "node_status": [
                      {
                        "current_connections": 0,
                        "max_connections": 1024000,
                        "node": "node@127.0.0.1",
                        "status": "running"
                      }
                    ],
                    "status": "stopped",
                    "stopped_at": "2021-12-08T14:56:35.576+08:00"
                  },
                  {
                    "created_at": "2021-12-08T14:42:15.272+08:00",
                    "current_connections": 0,
                    "listeners": [
                      {
                        "id": "stomp:tcp:default",
                        "name": "default",
                        "running": true,
                        "type": "tcp"
                      }
                    ],
                    "max_connections": 1024000,
                    "name": "stomp",
                    "node_status": [
                      {
                        "current_connections": 0,
                        "max_connections": 1024000,
                        "node": "node@127.0.0.1",
                        "status": "running"
                      }
                    ],
                    "started_at": "2021-12-08T14:42:15.274+08:00",
                    "status": "running"
                  }
                ],
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/emqx_gateway_api.gateway_overview"
                  },
                  "type": "array"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "List all gateways",
        "tags": [
          "Gateways"
        ]
      }
    },
    "/mqtt/topic_metrics/{topic}": {
      "delete": {
        "description": "Delete topic metrics",
        "parameters": [
          {
            "description": "Topic string. Notice: Topic string in url path must be encoded",
            "example": "testtopic/1",
            "in": "path",
            "name": "topic",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Delete topic metrics"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "TOPIC_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found. Topic metrics not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "MQTT"
        ]
      },
      "get": {
        "description": "Get topic metrics",
        "parameters": [
          {
            "description": "Topic string. Notice: Topic string in url path must be encoded",
            "example": "testtopic/1",
            "in": "path",
            "name": "topic",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Topic",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_topic_metrics_api.topic_metrics"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "TOPIC_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found. Topic metrics not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "MQTT"
        ]
      }
    },
    "/bridges_probe": {
      "post": {
        "description": "Test creating a new bridge by given ID </br><br/>The ID must be of format '{type}:{name}'",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "cassandra": {
                  "summary": "Cassandra Bridge",
                  "value": {
                    "cql": "insert into mqtt_msg(topic, msgid, sender, qos, payload, arrived, retain) values (${topic}, ${id}, ${clientid}, ${qos}, ${payload}, ${timestamp}, ${flags.retain})",
                    "enable": true,
                    "keyspace": "mqtt",
                    "local_topic": "local/topic/#",
                    "name": "foo",
                    "password": "******",
                    "pool_size": 8,
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "sync",
                      "worker_pool_size": 8
                    },
                    "servers": "127.0.0.1:9042",
                    "type": "cassandra",
                    "username": "root"
                  }
                },
                "clickhouse": {
                  "summary": "Clickhouse Bridge",
                  "value": {
                    "batch_value_separator": ", ",
                    "database": "mqtt",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "foo",
                    "password": "******",
                    "pool_size": 8,
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "async",
                      "worker_pool_size": 8
                    },
                    "server": "127.0.0.1:8123",
                    "sql": "INSERT INTO mqtt_test(payload, arrived) VALUES ('${payload}', ${timestamp})",
                    "type": "clickhouse",
                    "username": "default"
                  }
                },
                "dynamo": {
                  "summary": "DynamoDB Bridge",
                  "value": {
                    "aws_access_key_id": "root",
                    "aws_secret_access_key": "******",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "foo",
                    "pool_size": 8,
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "sync",
                      "worker_pool_size": 8
                    },
                    "table": "mqtt",
                    "template": "",
                    "type": "dynamo",
                    "url": "http://127.0.0.1:8000"
                  }
                },
                "gcp_pubsub": {
                  "summary": "GCP PubSub Bridge",
                  "value": {
                    "pubsub_topic": "mytopic",
                    "service_account_json": {
                      "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                      "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                      "client_email": "test@myproject.iam.gserviceaccount.com",
                      "client_id": "123812831923812319190",
                      "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/test%40myproject.iam.gserviceaccount.com",
                      "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQI...",
                      "private_key_id": "kid",
                      "project_id": "myproject",
                      "token_uri": "https://oauth2.googleapis.com/token",
                      "type": "service_account"
                    }
                  }
                },
                "hstreamdb": {
                  "summary": "HStreamDB Bridge",
                  "value": {
                    "connector": "hstreamdb:connector",
                    "direction": "egress",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "demo",
                    "payload": "${payload}",
                    "type": "hstreamdb"
                  }
                },
                "influxdb_api_v1": {
                  "summary": "InfluxDB HTTP API V1 Bridge",
                  "value": {
                    "database": "example_database",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "demo",
                    "password": "******",
                    "precision": "ms",
                    "resource_opts": {
                      "batch_size": 100,
                      "batch_time": "20ms"
                    },
                    "server": "127.0.0.1:8086",
                    "ssl": {
                      "enable": false
                    },
                    "type": "influxdb_api_v1",
                    "username": "example_username",
                    "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,bool=${payload.bool}"
                  }
                },
                "influxdb_api_v2": {
                  "summary": "InfluxDB HTTP API V2 Bridge",
                  "value": {
                    "bucket": "example_bucket",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "demo",
                    "org": "examlpe_org",
                    "precision": "ms",
                    "resource_opts": {
                      "batch_size": 100,
                      "batch_time": "20ms"
                    },
                    "server": "127.0.0.1:8086",
                    "ssl": {
                      "enable": false
                    },
                    "token": "example_token",
                    "type": "influxdb_api_v2",
                    "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,uint_value=${payload.uint_key}u,bool=${payload.bool}"
                  }
                },
                "kafka": {
                  "summary": "Kafka Producer Bridge",
                  "value": {
                    "authentication": {
                      "mechanism": "plain",
                      "password": "******",
                      "username": "username"
                    },
                    "bootstrap_hosts": "localhost:9092",
                    "connect_timeout": "5s",
                    "enable": true,
                    "kafka": {
                      "buffer": {
                        "memory_overload_protection": true,
                        "mode": "hybrid",
                        "per_partition_limit": "2GB",
                        "segment_bytes": "100MB"
                      },
                      "compression": "no_compression",
                      "max_batch_bytes": "896KB",
                      "max_inflight": 10,
                      "message": {
                        "key": "${.clientid}",
                        "timestamp": "${.timestamp}",
                        "value": "${.}"
                      },
                      "partition_count_refresh_interval": "60s",
                      "partition_strategy": "random",
                      "required_acks": "all_isr",
                      "topic": "kafka-topic"
                    },
                    "local_topic": "mqtt/local/topic",
                    "metadata_request_timeout": "4s",
                    "min_metadata_refresh_interval": "3s",
                    "socket_opts": {
                      "nodelay": true,
                      "recbuf": "1024KB",
                      "sndbuf": "1024KB"
                    }
                  }
                },
                "kafka_consumer": {
                  "summary": "Kafka Consumer Bridge",
                  "value": {
                    "authentication": {
                      "mechanism": "plain",
                      "password": "******",
                      "username": "username"
                    },
                    "bootstrap_hosts": "localhost:9092",
                    "connect_timeout": "5s",
                    "enable": true,
                    "kafka": {
                      "max_batch_bytes": "896KB",
                      "offset_commit_interval_seconds": 5,
                      "offset_reset_policy": "latest"
                    },
                    "key_encoding_mode": "none",
                    "metadata_request_timeout": "4s",
                    "min_metadata_refresh_interval": "3s",
                    "socket_opts": {
                      "nodelay": true,
                      "recbuf": "1024KB",
                      "sndbuf": "1024KB"
                    },
                    "topic_mapping": [
                      {
                        "kafka_topic": "kafka-topic-1",
                        "mqtt_topic": "mqtt/topic/1",
                        "payload_template": "${.}",
                        "qos": 1
                      },
                      {
                        "kafka_topic": "kafka-topic-2",
                        "mqtt_topic": "mqtt/topic/2",
                        "payload_template": "v = ${.value}",
                        "qos": 2
                      }
                    ],
                    "value_encoding_mode": "none"
                  }
                },
                "matrix": {
                  "summary": "Matrix Bridge",
                  "value": {
                    "database": "mqtt",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "foo",
                    "password": "******",
                    "pool_size": 8,
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "async",
                      "worker_pool_size": 8
                    },
                    "server": "127.0.0.1:5432",
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                    "type": "matrix",
                    "username": "root"
                  }
                },
                "mongodb_rs": {
                  "summary": "MongoDB (Replica Set) Bridge",
                  "value": {
                    "collection": "mycol",
                    "database": "mqtt",
                    "enable": true,
                    "mongo_type": "rs",
                    "name": "mongodb_rs_demo",
                    "password": "******",
                    "pool_size": 8,
                    "r_mode": "safe",
                    "replica_set_name": "rs",
                    "servers": "localhost:27017, localhost:27018",
                    "srv_record": false,
                    "type": "mongodb_rs",
                    "username": "myuser",
                    "w_mode": "safe"
                  }
                },
                "mongodb_sharded": {
                  "summary": "MongoDB (Sharded) Bridge",
                  "value": {
                    "collection": "mycol",
                    "database": "mqtt",
                    "enable": true,
                    "mongo_type": "sharded",
                    "name": "mongodb_sharded_demo",
                    "password": "******",
                    "pool_size": 8,
                    "servers": "localhost:27017, localhost:27018",
                    "srv_record": false,
                    "type": "mongodb_sharded",
                    "username": "myuser",
                    "w_mode": "safe"
                  }
                },
                "mongodb_single": {
                  "summary": "MongoDB (Standalone) Bridge",
                  "value": {
                    "collection": "mycol",
                    "database": "mqtt",
                    "enable": true,
                    "mongo_type": "single",
                    "name": "mongodb_single_demo",
                    "password": "******",
                    "pool_size": 8,
                    "server": "localhost:27017",
                    "srv_record": false,
                    "type": "mongodb_single",
                    "username": "myuser",
                    "w_mode": "safe"
                  }
                },
                "mqtt_example": {
                  "summary": "MQTT Bridge",
                  "value": {
                    "clean_start": true,
                    "egress": {
                      "local": {
                        "topic": "emqx/#"
                      },
                      "remote": {
                        "payload": "${payload}",
                        "qos": "${qos}",
                        "retain": false,
                        "topic": "from_emqx/${topic}"
                      }
                    },
                    "enable": true,
                    "ingress": {
                      "local": {
                        "payload": "${payload}",
                        "qos": "${qos}",
                        "retain": "${retain}",
                        "topic": "from_aws/${topic}"
                      },
                      "remote": {
                        "qos": 1,
                        "topic": "aws/#"
                      }
                    },
                    "keepalive": "300s",
                    "max_inflight": 100,
                    "mode": "cluster_shareload",
                    "name": "mqtt_example",
                    "password": "******",
                    "proto_ver": "v4",
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 104857600,
                      "query_mode": "sync"
                    },
                    "retry_interval": "15s",
                    "server": "127.0.0.1:1883",
                    "ssl": {
                      "enable": false
                    },
                    "type": "mqtt",
                    "username": "foo"
                  }
                },
                "mysql": {
                  "summary": "MySQL Bridge",
                  "value": {
                    "database": "test",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "foo",
                    "password": "******",
                    "pool_size": 8,
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "async",
                      "worker_pool_size": 1
                    },
                    "server": "127.0.0.1:3306",
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, FROM_UNIXTIME(${timestamp}/1000))",
                    "type": "mysql",
                    "username": "root"
                  }
                },
                "pgsql": {
                  "summary": "PostgreSQL Bridge",
                  "value": {
                    "database": "mqtt",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "foo",
                    "password": "******",
                    "pool_size": 8,
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "async",
                      "worker_pool_size": 8
                    },
                    "server": "127.0.0.1:5432",
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                    "type": "pgsql",
                    "username": "root"
                  }
                },
                "redis_cluster": {
                  "summary": "Redis Cluster Bridge",
                  "value": {
                    "command_template": [
                      "LPUSH",
                      "MSGS",
                      "${payload}"
                    ],
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "redis_bridge",
                    "password": "******",
                    "pool_size": 8,
                    "redis_type": "cluster",
                    "resource_opts": {},
                    "servers": [
                      "127.0.0.1:6379"
                    ],
                    "ssl": {
                      "enable": false
                    },
                    "type": "redis_cluster"
                  }
                },
                "redis_sentinel": {
                  "summary": "Redis Sentinel Bridge",
                  "value": {
                    "command_template": [
                      "LPUSH",
                      "MSGS",
                      "${payload}"
                    ],
                    "database": 1,
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "redis_bridge",
                    "password": "******",
                    "pool_size": 8,
                    "redis_type": "sentinel",
                    "resource_opts": {
                      "batch_size": 1,
                      "batch_time": "20ms"
                    },
                    "sentinel": "mymaster",
                    "servers": [
                      "127.0.0.1:26379"
                    ],
                    "ssl": {
                      "enable": false
                    },
                    "type": "redis_sentinel"
                  }
                },
                "redis_single": {
                  "summary": "Redis Single Node Bridge",
                  "value": {
                    "command_template": [
                      "LPUSH",
                      "MSGS",
                      "${payload}"
                    ],
                    "database": 1,
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "redis_bridge",
                    "password": "******",
                    "pool_size": 8,
                    "redis_type": "single",
                    "resource_opts": {
                      "batch_size": 1,
                      "batch_time": "20ms"
                    },
                    "server": "127.0.0.1:6379",
                    "ssl": {
                      "enable": false
                    },
                    "type": "redis_single"
                  }
                },
                "rocketmq": {
                  "summary": "RocketMQ Bridge",
                  "value": {
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "foo",
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "sync",
                      "worker_pool_size": 1
                    },
                    "server": "127.0.0.1:9876",
                    "template": "",
                    "topic": "TopicTest",
                    "type": "rocketmq"
                  }
                },
                "sqlserver": {
                  "summary": "Microsoft SQL Server Bridge",
                  "value": {
                    "database": "test",
                    "driver": "ms-sql",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "bar",
                    "password": "******",
                    "pool_size": 8,
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "async",
                      "worker_pool_size": 1
                    },
                    "server": "127.0.0.1:1433",
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload) values ( ${id}, ${topic}, ${qos}, ${payload} )",
                    "type": "sqlserver",
                    "username": "sa"
                  }
                },
                "tdengine": {
                  "summary": "TDengine Bridge",
                  "value": {
                    "database": "mqtt",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "foo",
                    "password": "taosdata",
                    "pool_size": 8,
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "sync",
                      "worker_pool_size": 8
                    },
                    "server": "127.0.0.1:6041",
                    "sql": "insert into t_mqtt_msg(ts, msgid, mqtt_topic, qos, payload, arrived) values (${ts}, ${id}, ${topic}, ${qos}, ${payload}, ${timestamp})",
                    "type": "tdengine",
                    "username": "root"
                  }
                },
                "timescale": {
                  "summary": "Timescale Bridge",
                  "value": {
                    "database": "mqtt",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "foo",
                    "password": "******",
                    "pool_size": 8,
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "async",
                      "worker_pool_size": 8
                    },
                    "server": "127.0.0.1:5432",
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                    "type": "timescale",
                    "username": "root"
                  }
                },
                "webhook_example": {
                  "summary": "WebHook",
                  "value": {
                    "body": "${payload}",
                    "connect_timeout": "15s",
                    "enable": true,
                    "enable_pipelining": 100,
                    "local_topic": "emqx_webhook/#",
                    "max_retries": 3,
                    "method": "post",
                    "name": "webhook_example",
                    "pool_size": 4,
                    "pool_type": "random",
                    "request_timeout": "15s",
                    "resource_opts": {
                      "auto_restart_interval": 15000,
                      "health_check_interval": 15000,
                      "inflight_window": 100,
                      "max_buffer_bytes": 104857600,
                      "query_mode": "async",
                      "worker_pool_size": 1
                    },
                    "ssl": {
                      "enable": false
                    },
                    "type": "webhook",
                    "url": "http://localhost:9901/messages/${topic}"
                  }
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/bridge_sqlserver.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_cassa.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_rocketmq.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_dynamo.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_clickhouse.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_tdengine.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_matrix.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_timescale.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_redis.post_cluster"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_redis.post_sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_redis.post_single"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_influxdb.post_api_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_influxdb.post_api_v1"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_hstreamdb.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mongodb.post_single"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mongodb.post_sharded"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mongodb.post_rs"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_pgsql.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mysql.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_kafka.post_producer"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_kafka.post_consumer"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_gcp_pubsub.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mqtt.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_webhook.post"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Test bridge OK"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "TEST_FAILED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "bridge test failed",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Test Bridge Creation",
        "tags": [
          "Bridges"
        ]
      }
    },
    "/monitor/nodes/{node}": {
      "get": {
        "description": "List the monitor data on the node.",
        "parameters": [
          {
            "description": "EMQX node name.",
            "example": "emqx@127.0.0.1",
            "in": "path",
            "name": "node",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The latest N seconds data. Like 300 for 5 min.",
            "example": 300,
            "in": "query",
            "name": "latest",
            "required": false,
            "schema": {
              "minimum": 1,
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/emqx_dashboard_monitor_api.sampler"
                  },
                  "type": "array"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Node not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Metrics"
        ]
      }
    },
    "/prometheus/stats": {
      "get": {
        "description": "Get Prometheus Data",
        "parameters": [],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              },
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            },
            "description": "Get Prometheus Data"
          }
        },
        "security": [],
        "tags": [
          "Monitor"
        ]
      }
    },
    "/trace/{name}/log_detail": {
      "get": {
        "description": "get trace log file's metadata, such as size, last update time",
        "parameters": [
          {
            "$ref": "#/components/parameters/trace.name"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/trace.log_file_detail"
                  },
                  "type": "array"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Trace Name Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Trace"
        ]
      }
    },
    "/authentication/{id}": {
      "delete": {
        "description": "Delete authenticator from global authentication chain.",
        "parameters": [
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Authenticator deleted"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Authentication"
        ]
      },
      "get": {
        "description": "Get authenticator from global authentication chain.",
        "parameters": [
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "jwt": {
                    "summary": "JWT authentication",
                    "value": {
                      "algorithm": "hmac-based",
                      "mechanism": "jwt",
                      "secret": "mysecret",
                      "secret_base64_encoded": false,
                      "use_jwks": false,
                      "verify_claims": {
                        "username": "${username}"
                      }
                    }
                  },
                  "password_based:built_in_database": {
                    "summary": "Built-in password_based authentication",
                    "value": {
                      "backend": "built_in_database",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "user_id_type": "username"
                    }
                  },
                  "password_based:http": {
                    "summary": "password_based authentication through external HTTP API",
                    "value": {
                      "backend": "http",
                      "body": {
                        "password": "${password}",
                        "username": "${username}"
                      },
                      "connect_timeout": 5000,
                      "enable_pipelining": 100,
                      "headers": {
                        "content-type": "application/json"
                      },
                      "mechanism": "password_based",
                      "method": "post",
                      "pool_size": 8,
                      "request_timeout": 5000,
                      "ssl": {
                        "enable": false
                      },
                      "url": "http://127.0.0.1:18083"
                    }
                  },
                  "password_based:mongodb": {
                    "summary": "password_based authentication with MongoDB backend",
                    "value": {
                      "backend": "mongodb",
                      "collection": "users",
                      "database": "example",
                      "filter": {
                        "username": "${username}"
                      },
                      "is_superuser_field": "is_superuser",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "password_hash_field": "password_hash",
                      "salt_field": "salt",
                      "server": "127.0.0.1:27017"
                    }
                  },
                  "password_based:redis": {
                    "summary": "password_based authentication with Redis backend",
                    "value": {
                      "backend": "redis",
                      "cmd": "HMGET ${username} password_hash salt",
                      "database": 0,
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "redis_type": "single",
                      "server": "127.0.0.1:6379"
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.jwks"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.public-key"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.hmac-based"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.post"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.get"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.replica-set"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-postgresql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mysql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-builtin_db.authentication"
                    }
                  ]
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Authentication"
        ]
      },
      "put": {
        "description": "Update authenticator from global authentication chain.",
        "parameters": [
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "jwt": {
                  "summary": "JWT authentication",
                  "value": {
                    "algorithm": "hmac-based",
                    "mechanism": "jwt",
                    "secret": "mysecret",
                    "secret_base64_encoded": false,
                    "use_jwks": false,
                    "verify_claims": {
                      "username": "${username}"
                    }
                  }
                },
                "password_based:built_in_database": {
                  "summary": "Built-in password_based authentication",
                  "value": {
                    "backend": "built_in_database",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "user_id_type": "username"
                  }
                },
                "password_based:http": {
                  "summary": "password_based authentication through external HTTP API",
                  "value": {
                    "backend": "http",
                    "body": {
                      "password": "${password}",
                      "username": "${username}"
                    },
                    "connect_timeout": 5000,
                    "enable_pipelining": 100,
                    "headers": {
                      "content-type": "application/json"
                    },
                    "mechanism": "password_based",
                    "method": "post",
                    "pool_size": 8,
                    "request_timeout": 5000,
                    "ssl": {
                      "enable": false
                    },
                    "url": "http://127.0.0.1:18083"
                  }
                },
                "password_based:mongodb": {
                  "summary": "password_based authentication with MongoDB backend",
                  "value": {
                    "backend": "mongodb",
                    "collection": "users",
                    "database": "example",
                    "filter": {
                      "username": "${username}"
                    },
                    "is_superuser_field": "is_superuser",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "password_hash_field": "password_hash",
                    "salt_field": "salt",
                    "server": "127.0.0.1:27017"
                  }
                },
                "password_based:redis": {
                  "summary": "password_based authentication with Redis backend",
                  "value": {
                    "backend": "redis",
                    "cmd": "HMGET ${username} password_hash salt",
                    "database": 0,
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "redis_type": "single",
                    "server": "127.0.0.1:6379"
                  }
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.jwks"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.public-key"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.hmac-based"
                  },
                  {
                    "$ref": "#/components/schemas/authn-http.post"
                  },
                  {
                    "$ref": "#/components/schemas/authn-http.get"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.standalone"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.replica-set"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.standalone"
                  },
                  {
                    "$ref": "#/components/schemas/authn-postgresql.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mysql.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-builtin_db.authentication"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Authenticator updated"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "409": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "ALREADY_EXISTS"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "ALREADY_EXISTS",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Authentication"
        ]
      }
    },
    "/schema_registry/{name}": {
      "delete": {
        "description": "Delete a schema",
        "parameters": [
          {
            "description": "The schema name",
            "example": "my_schema",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            },
            "summary": "Schema name"
          }
        ],
        "responses": {
          "204": {
            "description": "Schema deleted"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Schema not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Delete schema",
        "tags": [
          "Schema_registry"
        ]
      },
      "get": {
        "description": "Get a schema by its name",
        "parameters": [
          {
            "description": "The schema name",
            "example": "my_schema",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            },
            "summary": "Schema name"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "avro_schema": {
                    "summary": "Avro",
                    "value": {
                      "description": "My Avro Schema",
                      "name": "my_avro_schema",
                      "source": "{\"type\":\"record\",\"fields\":[{\"type\":\"int\",\"name\":\"i\"},{\"type\":\"string\",\"name\":\"s\"}]}",
                      "type": "avro"
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/emqx_ee_schema_registry_schema.get_avro"
                    }
                  ]
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Schema not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Get schema",
        "tags": [
          "Schema_registry"
        ]
      },
      "put": {
        "description": "Update an existing schema",
        "parameters": [
          {
            "description": "The schema name",
            "example": "my_schema",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            },
            "summary": "Schema name"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "avro_schema": {
                  "summary": "Avro",
                  "value": {
                    "description": "My Avro Schema",
                    "name": "my_avro_schema",
                    "source": "{\"type\":\"record\",\"fields\":[{\"type\":\"int\",\"name\":\"i\"},{\"type\":\"string\",\"name\":\"s\"}]}",
                    "type": "avro"
                  }
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/emqx_ee_schema_registry_schema.avro"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "avro_schema": {
                    "summary": "Avro",
                    "value": {
                      "description": "My Avro Schema",
                      "name": "my_avro_schema",
                      "source": "{\"type\":\"record\",\"fields\":[{\"type\":\"int\",\"name\":\"i\"},{\"type\":\"string\",\"name\":\"s\"}]}",
                      "type": "avro"
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/emqx_ee_schema_registry_schema.avro"
                    }
                  ]
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Schema not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Update schema",
        "tags": [
          "Schema_registry"
        ]
      }
    },
    "/publish": {
      "post": {
        "description": "Possible HTTP status response codes are:<br/><br/><code>200</code>: The message is delivered to at least one subscriber;<br/><br/><code>202</code>: No matched subscribers;<br/><br/><code>400</code>: Message is invalid. for example bad topic name, or QoS is out of range;<br/><br/><code>503</code>: Failed to deliver the message to subscriber(s)",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx_mgmt_api_publish.publish_message"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_publish.publish_ok"
                }
              }
            }
          },
          "202": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_publish.publish_error"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "items": {
                        "$ref": "#/components/schemas/emqx_mgmt_api_publish.publish_error"
                      },
                      "type": "array"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_mgmt_api_publish.bad_request"
                    }
                  ]
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_publish.publish_error"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Publish a message",
        "tags": [
          "Publish"
        ]
      }
    },
    "/nodes/{node}/metrics": {
      "get": {
        "description": "Get node metrics",
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_mgmt_api_nodes.node_name"
          }
        ],
        "responses": {
          "200": {
            "description": "Get node metrics successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_metrics.node_metrics"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Node not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Nodes"
        ]
      }
    },
    "/configs/global_zone": {
      "get": {
        "description": "Get the global zone configs",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "mqtt": {
                      "$ref": "#/components/schemas/zone.mqtt"
                    },
                    "force_shutdown": {
                      "$ref": "#/components/schemas/zone.force_shutdown"
                    },
                    "force_gc": {
                      "$ref": "#/components/schemas/zone.force_gc"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Configs"
        ]
      },
      "put": {
        "description": "Update globbal zone configs",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "mqtt": {
                    "$ref": "#/components/schemas/zone.mqtt"
                  },
                  "force_shutdown": {
                    "$ref": "#/components/schemas/zone.force_shutdown"
                  },
                  "force_gc": {
                    "$ref": "#/components/schemas/zone.force_gc"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "mqtt": {
                      "$ref": "#/components/schemas/zone.mqtt"
                    },
                    "force_shutdown": {
                      "$ref": "#/components/schemas/zone.force_shutdown"
                    },
                    "force_gc": {
                      "$ref": "#/components/schemas/zone.force_gc"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "UPDATE_FAILED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "403": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "UPDATE_FAILED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Configs"
        ]
      }
    },
    "/bridges/{id}/enable/{enable}": {
      "put": {
        "description": "Enable or Disable bridges on all nodes in the cluster.",
        "parameters": [
          {
            "description": "The bridge Id. Must be of format {type}:{name}",
            "example": "webhook:webhook_example",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            },
            "summary": "Bridge ID"
          },
          {
            "description": "Whether to enable this bridge",
            "example": true,
            "in": "path",
            "name": "enable",
            "required": true,
            "schema": {
              "type": "boolean"
            },
            "summary": "Enable bridge"
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bridge not found or invalid operation",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Service unavailable",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Cluster Bridge Enable",
        "tags": [
          "Bridges"
        ]
      }
    },
    "/bridges/{id}/metrics": {
      "get": {
        "description": "Get bridge metrics by Id",
        "parameters": [
          {
            "description": "The bridge Id. Must be of format {type}:{name}",
            "example": "webhook:webhook_example",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            },
            "summary": "Bridge ID"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "metrics": {
                      "description": "Bridge metrics.",
                      "summary": "Bridge Metrics",
                      "$ref": "#/components/schemas/bridge.metrics"
                    },
                    "node_metrics": {
                      "description": "Node metrics.",
                      "items": {
                        "$ref": "#/components/schemas/bridge.node_metrics"
                      },
                      "summary": "Node Metrics",
                      "type": "array"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bridge not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Get Bridge Metrics",
        "tags": [
          "Bridges"
        ]
      }
    },
    "/users": {
      "get": {
        "description": "Dashboard list users",
        "parameters": [],
        "responses": {
          "200": {
            "description": "Dashboard list users",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/dashboard.user"
                  },
                  "type": "array"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Dashboard"
        ]
      },
      "post": {
        "description": "Create dashboard user",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "username": {
                    "description": "Dashboard Username",
                    "example": "admin",
                    "maxLength": 100,
                    "type": "string"
                  },
                  "password": {
                    "description": "Dashboard Password",
                    "example": "public",
                    "maxLength": 100,
                    "type": "string"
                  },
                  "description": {
                    "description": "Dashboard User Description",
                    "example": "administrator",
                    "type": "string"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "username": {
                      "description": "Dashboard Username",
                      "example": "admin",
                      "maxLength": 100,
                      "type": "string"
                    },
                    "description": {
                      "description": "Dashboard User Description",
                      "example": "administrator",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Dashboard"
        ]
      }
    },
    "/authorization/sources/{type}/status": {
      "get": {
        "description": "Get a authorization source",
        "parameters": [
          {
            "description": "Authorization type",
            "in": "path",
            "name": "type",
            "required": true,
            "schema": {
              "enum": [
                "http",
                "mongodb",
                "redis",
                "built_in_database",
                "mysql",
                "postgresql",
                "file"
              ],
              "type": "string"
            },
            "summary": "source_type"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "metrics_example": {
                    "summary": "Showing a typical metrics example",
                    "value": {
                      "metrics": {
                        "allow": 0,
                        "deny": 0,
                        "nomatch": 0,
                        "rate": 0,
                        "rate_last5m": 0,
                        "rate_max": 0,
                        "total": 0
                      },
                      "node_metrics": [
                        {
                          "metrics": {
                            "allow": 0,
                            "deny": 0,
                            "nomatch": 0,
                            "rate": 0,
                            "rate_last5m": 0,
                            "rate_max": 0,
                            "total": 0
                          },
                          "node": "emqx@127.0.0.1"
                        }
                      ],
                      "node_resource_metrics": [
                        {
                          "metrics": {
                            "failed": 0,
                            "matched": 0,
                            "rate": 0,
                            "rate_last5m": 0,
                            "rate_max": 0,
                            "success": 0
                          },
                          "node": "emqx@127.0.0.1"
                        }
                      ],
                      "node_status": [
                        {
                          "node": "emqx@127.0.0.1",
                          "status": "connected"
                        }
                      ],
                      "resource_metrics": {
                        "failed": 0,
                        "matched": 0,
                        "rate": 0,
                        "rate_last5m": 0,
                        "rate_max": 0,
                        "success": 0
                      },
                      "status": "connected"
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/authz.metrics_status_fields"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Authorization"
        ]
      }
    },
    "/listeners": {
      "get": {
        "description": "List all running node's listeners for the specified type.",
        "parameters": [
          {
            "description": "Listener type",
            "example": "tcp",
            "in": "query",
            "name": "type",
            "required": false,
            "schema": {
              "enum": [
                "tcp",
                "ssl",
                "ws",
                "wss",
                "quic"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": [
                  {
                    "acceptors": 16,
                    "bind": "0.0.0.0:1884",
                    "enable": true,
                    "id": "tcp:demo",
                    "name": "demo",
                    "node_status": [
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "current_connections": 100,
                          "max_connections": 1024000,
                          "running": true
                        }
                      },
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "current_connections": 101,
                          "max_connections": 1024000,
                          "running": true
                        }
                      }
                    ],
                    "number": 2,
                    "status": {
                      "current_connections": 201,
                      "max_connections": 2048000,
                      "running": true
                    },
                    "type": "tcp"
                  },
                  {
                    "acceptors": 32,
                    "bind": "0.0.0.0:1883",
                    "enable": true,
                    "id": "tcp:default",
                    "name": "default",
                    "node_status": [
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "current_connections": 200,
                          "max_connections": "infinity",
                          "running": true
                        }
                      },
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "current_connections": 301,
                          "max_connections": "infinity",
                          "running": true
                        }
                      }
                    ],
                    "number": 2,
                    "status": {
                      "current_connections": 501,
                      "max_connections": "infinity",
                      "running": true
                    },
                    "type": "tcp"
                  }
                ],
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/listeners.listener_id_status"
                  },
                  "type": "array"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Listeners"
        ]
      },
      "post": {
        "description": "Create the specified listener on all nodes.",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "example": {
                "acceptors": 16,
                "access_rules": [
                  "allow all"
                ],
                "bind": "0.0.0.0:1884",
                "current_connections": 10240,
                "max_connections": 204800,
                "mountpoint": "/",
                "name": "demo",
                "proxy_protocol": false,
                "proxy_protocol_timeout": "3s",
                "running": true,
                "tcp_options": {
                  "active_n": 100,
                  "backlog": 1024,
                  "buffer": "4KB",
                  "high_watermark": "1MB",
                  "nodelay": false,
                  "reuseaddr": true,
                  "send_timeout": "15s",
                  "send_timeout_close": true
                },
                "type": "tcp",
                "zone": "default"
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/listeners.quic_required_bind(with_name)"
                  },
                  {
                    "$ref": "#/components/schemas/listeners.wss_required_bind(with_name)"
                  },
                  {
                    "$ref": "#/components/schemas/listeners.ws_required_bind(with_name)"
                  },
                  {
                    "$ref": "#/components/schemas/listeners.ssl_required_bind(with_name)"
                  },
                  {
                    "$ref": "#/components/schemas/listeners.tcp_required_bind(with_name)"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "acceptors": 16,
                  "access_rules": [
                    "allow all"
                  ],
                  "bind": "0.0.0.0:1884",
                  "current_connections": 10240,
                  "id": "tcp:demo",
                  "max_connections": 204800,
                  "mountpoint": "/",
                  "proxy_protocol": false,
                  "proxy_protocol_timeout": "3s",
                  "running": true,
                  "tcp_options": {
                    "active_n": 100,
                    "backlog": 1024,
                    "buffer": "4KB",
                    "high_watermark": "1MB",
                    "nodelay": false,
                    "reuseaddr": true,
                    "send_timeout": "15s",
                    "send_timeout_close": true
                  },
                  "type": "tcp",
                  "zone": "default"
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/listeners.quic_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.wss_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.ws_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.ssl_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.tcp_required_bind"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_LISTENER_ID",
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Listeners"
        ]
      }
    },
    "/trace/{name}/download": {
      "get": {
        "description": "Download trace log by name",
        "parameters": [
          {
            "$ref": "#/components/parameters/trace.name"
          },
          {
            "$ref": "#/components/parameters/trace.node"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/octet-stream": {
                "schema": {
                  "format": "binary",
                  "type": "string"
                }
              }
            },
            "description": "A trace zip file"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "NODE_ERROR"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Trace Name or Node Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Trace"
        ]
      }
    },
    "/clients/{clientid}": {
      "delete": {
        "description": "Kick out client by client ID",
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Kick out client successfully"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "CLIENTID_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Client ID not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Clients"
        ]
      },
      "get": {
        "description": "Get clients info by client ID",
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_clients.client"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "CLIENTID_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Client ID not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Clients"
        ]
      }
    },
    "/gateways/{name}/authentication": {
      "delete": {
        "description": "Delete the authenticator of the specified gateway.",
        "parameters": [
          {
            "description": "Gateway Name.<br/><br/>It's enum with `stomp`, `mqttsn`, `coap`, `lwm2m`, `exproto`",
            "example": "stomp",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Delete gateway authenticator",
        "tags": [
          "Gateway Authentication"
        ]
      },
      "get": {
        "description": "Gets the configuration of the specified gateway authenticator.<br/><br/>Returns 404 when gateway or authentication is not enabled.",
        "parameters": [
          {
            "description": "Gateway Name.<br/><br/>It's enum with `stomp`, `mqttsn`, `coap`, `lwm2m`, `exproto`",
            "example": "stomp",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "jwt": {
                    "summary": "JWT authentication",
                    "value": {
                      "algorithm": "hmac-based",
                      "mechanism": "jwt",
                      "secret": "mysecret",
                      "secret_base64_encoded": false,
                      "use_jwks": false,
                      "verify_claims": {
                        "username": "${username}"
                      }
                    }
                  },
                  "password_based:built_in_database": {
                    "summary": "Built-in password_based authentication",
                    "value": {
                      "backend": "built_in_database",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "user_id_type": "username"
                    }
                  },
                  "password_based:http": {
                    "summary": "password_based authentication through external HTTP API",
                    "value": {
                      "backend": "http",
                      "body": {
                        "password": "${password}",
                        "username": "${username}"
                      },
                      "connect_timeout": 5000,
                      "enable_pipelining": 100,
                      "headers": {
                        "content-type": "application/json"
                      },
                      "mechanism": "password_based",
                      "method": "post",
                      "pool_size": 8,
                      "request_timeout": 5000,
                      "ssl": {
                        "enable": false
                      },
                      "url": "http://127.0.0.1:18083"
                    }
                  },
                  "password_based:mongodb": {
                    "summary": "password_based authentication with MongoDB backend",
                    "value": {
                      "backend": "mongodb",
                      "collection": "users",
                      "database": "example",
                      "filter": {
                        "username": "${username}"
                      },
                      "is_superuser_field": "is_superuser",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "password_hash_field": "password_hash",
                      "salt_field": "salt",
                      "server": "127.0.0.1:27017"
                    }
                  },
                  "password_based:redis": {
                    "summary": "password_based authentication with Redis backend",
                    "value": {
                      "backend": "redis",
                      "cmd": "HMGET ${username} password_hash salt",
                      "database": 0,
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "redis_type": "single",
                      "server": "127.0.0.1:6379"
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authn-jwt.jwks"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.public-key"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.hmac-based"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.post"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.get"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.replica-set"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-postgresql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mysql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-builtin_db.authentication"
                    }
                  ]
                }
              }
            }
          },
          "204": {
            "description": "Authenticator not initialized"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Get authenticator configuration",
        "tags": [
          "Gateway Authentication"
        ]
      },
      "post": {
        "description": "Enables the authenticator for client authentication for the specified gateway. <br/><br/>When the authenticator is not configured or turned off, all client connections are assumed to be allowed. <br/><br/>Note: Only one authenticator is allowed to be enabled at a time in the gateway, rather than allowing multiple authenticators to be configured to form an authentication chain as in MQTT.",
        "parameters": [
          {
            "description": "Gateway Name.<br/><br/>It's enum with `stomp`, `mqttsn`, `coap`, `lwm2m`, `exproto`",
            "example": "stomp",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "jwt": {
                  "summary": "JWT authentication",
                  "value": {
                    "algorithm": "hmac-based",
                    "mechanism": "jwt",
                    "secret": "mysecret",
                    "secret_base64_encoded": false,
                    "use_jwks": false,
                    "verify_claims": {
                      "username": "${username}"
                    }
                  }
                },
                "password_based:built_in_database": {
                  "summary": "Built-in password_based authentication",
                  "value": {
                    "backend": "built_in_database",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "user_id_type": "username"
                  }
                },
                "password_based:http": {
                  "summary": "password_based authentication through external HTTP API",
                  "value": {
                    "backend": "http",
                    "body": {
                      "password": "${password}",
                      "username": "${username}"
                    },
                    "connect_timeout": 5000,
                    "enable_pipelining": 100,
                    "headers": {
                      "content-type": "application/json"
                    },
                    "mechanism": "password_based",
                    "method": "post",
                    "pool_size": 8,
                    "request_timeout": 5000,
                    "ssl": {
                      "enable": false
                    },
                    "url": "http://127.0.0.1:18083"
                  }
                },
                "password_based:mongodb": {
                  "summary": "password_based authentication with MongoDB backend",
                  "value": {
                    "backend": "mongodb",
                    "collection": "users",
                    "database": "example",
                    "filter": {
                      "username": "${username}"
                    },
                    "is_superuser_field": "is_superuser",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "password_hash_field": "password_hash",
                    "salt_field": "salt",
                    "server": "127.0.0.1:27017"
                  }
                },
                "password_based:redis": {
                  "summary": "password_based authentication with Redis backend",
                  "value": {
                    "backend": "redis",
                    "cmd": "HMGET ${username} password_hash salt",
                    "database": 0,
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "redis_type": "single",
                    "server": "127.0.0.1:6379"
                  }
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/authn-jwt.jwks"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.public-key"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.hmac-based"
                  },
                  {
                    "$ref": "#/components/schemas/authn-http.post"
                  },
                  {
                    "$ref": "#/components/schemas/authn-http.get"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.standalone"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.replica-set"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.standalone"
                  },
                  {
                    "$ref": "#/components/schemas/authn-postgresql.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mysql.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-builtin_db.authentication"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "jwt": {
                    "summary": "JWT authentication",
                    "value": {
                      "algorithm": "hmac-based",
                      "mechanism": "jwt",
                      "secret": "mysecret",
                      "secret_base64_encoded": false,
                      "use_jwks": false,
                      "verify_claims": {
                        "username": "${username}"
                      }
                    }
                  },
                  "password_based:built_in_database": {
                    "summary": "Built-in password_based authentication",
                    "value": {
                      "backend": "built_in_database",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "user_id_type": "username"
                    }
                  },
                  "password_based:http": {
                    "summary": "password_based authentication through external HTTP API",
                    "value": {
                      "backend": "http",
                      "body": {
                        "password": "${password}",
                        "username": "${username}"
                      },
                      "connect_timeout": 5000,
                      "enable_pipelining": 100,
                      "headers": {
                        "content-type": "application/json"
                      },
                      "mechanism": "password_based",
                      "method": "post",
                      "pool_size": 8,
                      "request_timeout": 5000,
                      "ssl": {
                        "enable": false
                      },
                      "url": "http://127.0.0.1:18083"
                    }
                  },
                  "password_based:mongodb": {
                    "summary": "password_based authentication with MongoDB backend",
                    "value": {
                      "backend": "mongodb",
                      "collection": "users",
                      "database": "example",
                      "filter": {
                        "username": "${username}"
                      },
                      "is_superuser_field": "is_superuser",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "password_hash_field": "password_hash",
                      "salt_field": "salt",
                      "server": "127.0.0.1:27017"
                    }
                  },
                  "password_based:redis": {
                    "summary": "password_based authentication with Redis backend",
                    "value": {
                      "backend": "redis",
                      "cmd": "HMGET ${username} password_hash salt",
                      "database": 0,
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "redis_type": "single",
                      "server": "127.0.0.1:6379"
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authn-jwt.jwks"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.public-key"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.hmac-based"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.post"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.get"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.replica-set"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-postgresql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mysql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-builtin_db.authentication"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Create authenticator for gateway",
        "tags": [
          "Gateway Authentication"
        ]
      },
      "put": {
        "description": "Update the configuration of the specified gateway authenticator, or disable the authenticator.",
        "parameters": [
          {
            "description": "Gateway Name.<br/><br/>It's enum with `stomp`, `mqttsn`, `coap`, `lwm2m`, `exproto`",
            "example": "stomp",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "jwt": {
                  "summary": "JWT authentication",
                  "value": {
                    "algorithm": "hmac-based",
                    "mechanism": "jwt",
                    "secret": "mysecret",
                    "secret_base64_encoded": false,
                    "use_jwks": false,
                    "verify_claims": {
                      "username": "${username}"
                    }
                  }
                },
                "password_based:built_in_database": {
                  "summary": "Built-in password_based authentication",
                  "value": {
                    "backend": "built_in_database",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "user_id_type": "username"
                  }
                },
                "password_based:http": {
                  "summary": "password_based authentication through external HTTP API",
                  "value": {
                    "backend": "http",
                    "body": {
                      "password": "${password}",
                      "username": "${username}"
                    },
                    "connect_timeout": 5000,
                    "enable_pipelining": 100,
                    "headers": {
                      "content-type": "application/json"
                    },
                    "mechanism": "password_based",
                    "method": "post",
                    "pool_size": 8,
                    "request_timeout": 5000,
                    "ssl": {
                      "enable": false
                    },
                    "url": "http://127.0.0.1:18083"
                  }
                },
                "password_based:mongodb": {
                  "summary": "password_based authentication with MongoDB backend",
                  "value": {
                    "backend": "mongodb",
                    "collection": "users",
                    "database": "example",
                    "filter": {
                      "username": "${username}"
                    },
                    "is_superuser_field": "is_superuser",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "password_hash_field": "password_hash",
                    "salt_field": "salt",
                    "server": "127.0.0.1:27017"
                  }
                },
                "password_based:redis": {
                  "summary": "password_based authentication with Redis backend",
                  "value": {
                    "backend": "redis",
                    "cmd": "HMGET ${username} password_hash salt",
                    "database": 0,
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "redis_type": "single",
                    "server": "127.0.0.1:6379"
                  }
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/authn-jwt.jwks"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.public-key"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.hmac-based"
                  },
                  {
                    "$ref": "#/components/schemas/authn-http.post"
                  },
                  {
                    "$ref": "#/components/schemas/authn-http.get"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.standalone"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.replica-set"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.standalone"
                  },
                  {
                    "$ref": "#/components/schemas/authn-postgresql.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mysql.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-builtin_db.authentication"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "jwt": {
                    "summary": "JWT authentication",
                    "value": {
                      "algorithm": "hmac-based",
                      "mechanism": "jwt",
                      "secret": "mysecret",
                      "secret_base64_encoded": false,
                      "use_jwks": false,
                      "verify_claims": {
                        "username": "${username}"
                      }
                    }
                  },
                  "password_based:built_in_database": {
                    "summary": "Built-in password_based authentication",
                    "value": {
                      "backend": "built_in_database",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "user_id_type": "username"
                    }
                  },
                  "password_based:http": {
                    "summary": "password_based authentication through external HTTP API",
                    "value": {
                      "backend": "http",
                      "body": {
                        "password": "${password}",
                        "username": "${username}"
                      },
                      "connect_timeout": 5000,
                      "enable_pipelining": 100,
                      "headers": {
                        "content-type": "application/json"
                      },
                      "mechanism": "password_based",
                      "method": "post",
                      "pool_size": 8,
                      "request_timeout": 5000,
                      "ssl": {
                        "enable": false
                      },
                      "url": "http://127.0.0.1:18083"
                    }
                  },
                  "password_based:mongodb": {
                    "summary": "password_based authentication with MongoDB backend",
                    "value": {
                      "backend": "mongodb",
                      "collection": "users",
                      "database": "example",
                      "filter": {
                        "username": "${username}"
                      },
                      "is_superuser_field": "is_superuser",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "password_hash_field": "password_hash",
                      "salt_field": "salt",
                      "server": "127.0.0.1:27017"
                    }
                  },
                  "password_based:redis": {
                    "summary": "password_based authentication with Redis backend",
                    "value": {
                      "backend": "redis",
                      "cmd": "HMGET ${username} password_hash salt",
                      "database": 0,
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "redis_type": "single",
                      "server": "127.0.0.1:6379"
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authn-jwt.jwks"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.public-key"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.hmac-based"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.post"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.get"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.replica-set"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-postgresql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mysql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-builtin_db.authentication"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Update authenticator configuration",
        "tags": [
          "Gateway Authentication"
        ]
      }
    },
    "/clients/{clientid}/unsubscribe/bulk": {
      "post": {
        "description": "Unsubscribe",
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "items": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_clients.unsubscribe"
                },
                "type": "array"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Unsubscribe OK"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "CLIENTID_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Client ID not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Clients"
        ]
      }
    },
    "/clients/{clientid}/subscribe/bulk": {
      "post": {
        "description": "Subscribe",
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "items": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_clients.subscribe"
                },
                "type": "array"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/emqx_mgmt_api_subscriptions.subscription"
                  },
                  "type": "array"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "CLIENTID_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Client ID not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Clients"
        ]
      }
    },
    "/configs/alarm": {
      "get": {
        "description": "Get the sub-configurations under *alarm*",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/broker.alarm"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "config not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Configs"
        ]
      },
      "put": {
        "description": "Update the sub-configurations under *alarm*",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/broker.alarm"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/broker.alarm"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "UPDATE_FAILED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "403": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "UPDATE_FAILED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Configs"
        ]
      }
    },
    "/nodes/{node}": {
      "get": {
        "description": "Get node info",
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_mgmt_api_nodes.node_name"
          }
        ],
        "responses": {
          "200": {
            "description": "Get node info successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_nodes.node_info"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Node not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Nodes"
        ]
      }
    },
    "/configs/persistent_session_store": {
      "get": {
        "description": "Get the sub-configurations under *persistent_session_store*",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/broker.persistent_session_store"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "config not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Configs"
        ]
      },
      "put": {
        "description": "Update the sub-configurations under *persistent_session_store*",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/broker.persistent_session_store"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/broker.persistent_session_store"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "UPDATE_FAILED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "403": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "UPDATE_FAILED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Configs"
        ]
      }
    },
    "/gateways/coap/clients/{clientid}/request": {
      "post": {
        "description": "Send a CoAP request message to the client",
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "token": {
                    "description": "Message token, can be empty",
                    "type": "string"
                  },
                  "method": {
                    "description": "Request method type",
                    "enum": [
                      "get",
                      "put",
                      "post",
                      "delete"
                    ],
                    "type": "string"
                  },
                  "timeout": {
                    "description": "Timespan for response",
                    "example": "32s",
                    "type": "string"
                  },
                  "content_type": {
                    "description": "Payload type",
                    "enum": [
                      "text/plain",
                      "application/json",
                      "application/octet-stream"
                    ],
                    "type": "string"
                  },
                  "payload": {
                    "description": "The content of the payload",
                    "type": "string"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "id": {
                      "description": "Message ID",
                      "type": "integer"
                    },
                    "token": {
                      "description": "Message token, can be empty",
                      "type": "string"
                    },
                    "method": {
                      "description": "Response code",
                      "type": "string"
                    },
                    "payload": {
                      "description": "The content of the payload",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "CLIENT_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Client not found error",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "504": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "CLIENT_NOT_RESPONSE"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Waiting for client response timeout",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Send a Request to a Client",
        "tags": [
          "CoAP Gateways"
        ]
      }
    },
    "/listeners/{id}/stop": {
      "post": {
        "description": "Stop the listener on all nodes.",
        "parameters": [
          {
            "$ref": "#/components/parameters/listeners.listener_id"
          }
        ],
        "responses": {
          "200": {
            "description": "Updated"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST",
                        "BAD_LISTENER_ID"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Listeners"
        ]
      }
    },
    "/topics": {
      "get": {
        "description": "Topics list",
        "parameters": [
          {
            "description": "Topic Name",
            "example": "",
            "in": "query",
            "name": "topic",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Node Name",
            "example": "emqx@127.0.0.1",
            "in": "query",
            "name": "node",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "data": {
                      "items": {
                        "$ref": "#/components/schemas/emqx_mgmt_api_topics.topic"
                      },
                      "type": "array"
                    },
                    "meta": {
                      "$ref": "#/components/schemas/public.meta"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Topics"
        ]
      }
    },
    "/authorization/sources": {
      "get": {
        "description": "List all authorization sources",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_authz_api_sources.sources"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Authorization"
        ]
      },
      "post": {
        "description": "Add a new source",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.file"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.postgresql"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.mysql"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.built_in_database"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.redis_cluster"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.redis_sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.redis_single"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.mongo_sharded"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.mongo_rs"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.mongo_single"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.http_post"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.http_get"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Authorization source created successfully"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Authorization"
        ]
      }
    },
    "/plugins": {
      "get": {
        "description": "Plugins are launched in top-down order.<br/>Use `POST /plugins/{name}/move` to change the boot order.",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/plugins.plugin"
                  },
                  "type": "array"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "List all installed plugins",
        "tags": [
          "Plugins"
        ]
      }
    },
    "/login": {
      "post": {
        "description": "Get Dashboard Auth Token.",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "username": {
                    "description": "Dashboard Username",
                    "example": "admin",
                    "maxLength": 100,
                    "type": "string"
                  },
                  "password": {
                    "description": "Dashboard Password",
                    "example": "public",
                    "maxLength": 100,
                    "type": "string"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "token": {
                      "description": "Dashboard Auth Token",
                      "type": "string"
                    },
                    "version": {
                      "description": "EMQX Version",
                      "example": "5.0.0",
                      "type": "string"
                    },
                    "license": {
                      "properties": {
                        "edition": {
                          "description": "EMQX License. opensource or enterprise",
                          "enum": [
                            "opensource",
                            "enterprise"
                          ],
                          "example": "opensource",
                          "type": "string"
                        }
                      },
                      "type": "object"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "401": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_USERNAME_OR_PWD"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Login failed. Bad username or password",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [],
        "summary": "Dashboard authentication",
        "tags": [
          "Dashboard"
        ]
      }
    },
    "/bridges/{id}": {
      "delete": {
        "description": "Delete a bridge by Id",
        "parameters": [
          {
            "description": "The bridge Id. Must be of format {type}:{name}",
            "example": "webhook:webhook_example",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            },
            "summary": "Bridge ID"
          }
        ],
        "responses": {
          "204": {
            "description": "Bridge deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Cannot delete bridge while active rules are defined for this bridge",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bridge not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Service unavailable",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Delete Bridge",
        "tags": [
          "Bridges"
        ]
      },
      "get": {
        "description": "Get a bridge by Id",
        "parameters": [
          {
            "description": "The bridge Id. Must be of format {type}:{name}",
            "example": "webhook:webhook_example",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            },
            "summary": "Bridge ID"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "cassandra": {
                    "summary": "Cassandra Bridge",
                    "value": {
                      "cql": "insert into mqtt_msg(topic, msgid, sender, qos, payload, arrived, retain) values (${topic}, ${id}, ${clientid}, ${qos}, ${payload}, ${timestamp}, ${flags.retain})",
                      "enable": true,
                      "keyspace": "mqtt",
                      "local_topic": "local/topic/#",
                      "name": "foo",
                      "password": "******",
                      "pool_size": 8,
                      "resource_opts": {
                        "auto_restart_interval": "60s",
                        "batch_size": 1,
                        "batch_time": 0,
                        "health_check_interval": "15s",
                        "max_buffer_bytes": 268435456,
                        "query_mode": "sync",
                        "worker_pool_size": 8
                      },
                      "servers": "127.0.0.1:9042",
                      "type": "cassandra",
                      "username": "root"
                    }
                  },
                  "clickhouse": {
                    "summary": "Clickhouse Bridge",
                    "value": {
                      "batch_value_separator": ", ",
                      "database": "mqtt",
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "foo",
                      "password": "******",
                      "pool_size": 8,
                      "resource_opts": {
                        "auto_restart_interval": "60s",
                        "batch_size": 1,
                        "batch_time": 0,
                        "health_check_interval": "15s",
                        "max_buffer_bytes": 268435456,
                        "query_mode": "async",
                        "worker_pool_size": 8
                      },
                      "server": "127.0.0.1:8123",
                      "sql": "INSERT INTO mqtt_test(payload, arrived) VALUES ('${payload}', ${timestamp})",
                      "type": "clickhouse",
                      "username": "default"
                    }
                  },
                  "dynamo": {
                    "summary": "DynamoDB Bridge",
                    "value": {
                      "aws_access_key_id": "root",
                      "aws_secret_access_key": "******",
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "foo",
                      "pool_size": 8,
                      "resource_opts": {
                        "auto_restart_interval": "60s",
                        "batch_size": 1,
                        "batch_time": 0,
                        "health_check_interval": "15s",
                        "max_buffer_bytes": 268435456,
                        "query_mode": "sync",
                        "worker_pool_size": 8
                      },
                      "table": "mqtt",
                      "template": "",
                      "type": "dynamo",
                      "url": "http://127.0.0.1:8000"
                    }
                  },
                  "gcp_pubsub": {
                    "summary": "GCP PubSub Bridge",
                    "value": {
                      "pubsub_topic": "mytopic",
                      "service_account_json": {
                        "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                        "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                        "client_email": "test@myproject.iam.gserviceaccount.com",
                        "client_id": "123812831923812319190",
                        "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/test%40myproject.iam.gserviceaccount.com",
                        "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQI...",
                        "private_key_id": "kid",
                        "project_id": "myproject",
                        "token_uri": "https://oauth2.googleapis.com/token",
                        "type": "service_account"
                      }
                    }
                  },
                  "hstreamdb": {
                    "summary": "HStreamDB Bridge",
                    "value": {
                      "connector": "hstreamdb:connector",
                      "direction": "egress",
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "demo",
                      "payload": "${payload}",
                      "type": "hstreamdb"
                    }
                  },
                  "influxdb_api_v1": {
                    "summary": "InfluxDB HTTP API V1 Bridge",
                    "value": {
                      "database": "example_database",
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "demo",
                      "password": "******",
                      "precision": "ms",
                      "resource_opts": {
                        "batch_size": 100,
                        "batch_time": "20ms"
                      },
                      "server": "127.0.0.1:8086",
                      "ssl": {
                        "enable": false
                      },
                      "type": "influxdb_api_v1",
                      "username": "example_username",
                      "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,bool=${payload.bool}"
                    }
                  },
                  "influxdb_api_v2": {
                    "summary": "InfluxDB HTTP API V2 Bridge",
                    "value": {
                      "bucket": "example_bucket",
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "demo",
                      "org": "examlpe_org",
                      "precision": "ms",
                      "resource_opts": {
                        "batch_size": 100,
                        "batch_time": "20ms"
                      },
                      "server": "127.0.0.1:8086",
                      "ssl": {
                        "enable": false
                      },
                      "token": "example_token",
                      "type": "influxdb_api_v2",
                      "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,uint_value=${payload.uint_key}u,bool=${payload.bool}"
                    }
                  },
                  "kafka": {
                    "summary": "Kafka Producer Bridge",
                    "value": {
                      "authentication": {
                        "mechanism": "plain",
                        "password": "******",
                        "username": "username"
                      },
                      "bootstrap_hosts": "localhost:9092",
                      "connect_timeout": "5s",
                      "enable": true,
                      "kafka": {
                        "buffer": {
                          "memory_overload_protection": true,
                          "mode": "hybrid",
                          "per_partition_limit": "2GB",
                          "segment_bytes": "100MB"
                        },
                        "compression": "no_compression",
                        "max_batch_bytes": "896KB",
                        "max_inflight": 10,
                        "message": {
                          "key": "${.clientid}",
                          "timestamp": "${.timestamp}",
                          "value": "${.}"
                        },
                        "partition_count_refresh_interval": "60s",
                        "partition_strategy": "random",
                        "required_acks": "all_isr",
                        "topic": "kafka-topic"
                      },
                      "local_topic": "mqtt/local/topic",
                      "metadata_request_timeout": "4s",
                      "min_metadata_refresh_interval": "3s",
                      "socket_opts": {
                        "nodelay": true,
                        "recbuf": "1024KB",
                        "sndbuf": "1024KB"
                      }
                    }
                  },
                  "kafka_consumer": {
                    "summary": "Kafka Consumer Bridge",
                    "value": {
                      "authentication": {
                        "mechanism": "plain",
                        "password": "******",
                        "username": "username"
                      },
                      "bootstrap_hosts": "localhost:9092",
                      "connect_timeout": "5s",
                      "enable": true,
                      "kafka": {
                        "max_batch_bytes": "896KB",
                        "offset_commit_interval_seconds": 5,
                        "offset_reset_policy": "latest"
                      },
                      "key_encoding_mode": "none",
                      "metadata_request_timeout": "4s",
                      "min_metadata_refresh_interval": "3s",
                      "socket_opts": {
                        "nodelay": true,
                        "recbuf": "1024KB",
                        "sndbuf": "1024KB"
                      },
                      "topic_mapping": [
                        {
                          "kafka_topic": "kafka-topic-1",
                          "mqtt_topic": "mqtt/topic/1",
                          "payload_template": "${.}",
                          "qos": 1
                        },
                        {
                          "kafka_topic": "kafka-topic-2",
                          "mqtt_topic": "mqtt/topic/2",
                          "payload_template": "v = ${.value}",
                          "qos": 2
                        }
                      ],
                      "value_encoding_mode": "none"
                    }
                  },
                  "matrix": {
                    "summary": "Matrix Bridge",
                    "value": {
                      "database": "mqtt",
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "foo",
                      "password": "******",
                      "pool_size": 8,
                      "resource_opts": {
                        "auto_restart_interval": "60s",
                        "batch_size": 1,
                        "batch_time": 0,
                        "health_check_interval": "15s",
                        "max_buffer_bytes": 268435456,
                        "query_mode": "async",
                        "worker_pool_size": 8
                      },
                      "server": "127.0.0.1:5432",
                      "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                      "type": "matrix",
                      "username": "root"
                    }
                  },
                  "mongodb_rs": {
                    "summary": "MongoDB (Replica Set) Bridge",
                    "value": {
                      "collection": "mycol",
                      "database": "mqtt",
                      "enable": true,
                      "mongo_type": "rs",
                      "name": "mongodb_rs_demo",
                      "password": "******",
                      "pool_size": 8,
                      "r_mode": "safe",
                      "replica_set_name": "rs",
                      "servers": "localhost:27017, localhost:27018",
                      "srv_record": false,
                      "type": "mongodb_rs",
                      "username": "myuser",
                      "w_mode": "safe"
                    }
                  },
                  "mongodb_sharded": {
                    "summary": "MongoDB (Sharded) Bridge",
                    "value": {
                      "collection": "mycol",
                      "database": "mqtt",
                      "enable": true,
                      "mongo_type": "sharded",
                      "name": "mongodb_sharded_demo",
                      "password": "******",
                      "pool_size": 8,
                      "servers": "localhost:27017, localhost:27018",
                      "srv_record": false,
                      "type": "mongodb_sharded",
                      "username": "myuser",
                      "w_mode": "safe"
                    }
                  },
                  "mongodb_single": {
                    "summary": "MongoDB (Standalone) Bridge",
                    "value": {
                      "collection": "mycol",
                      "database": "mqtt",
                      "enable": true,
                      "mongo_type": "single",
                      "name": "mongodb_single_demo",
                      "password": "******",
                      "pool_size": 8,
                      "server": "localhost:27017",
                      "srv_record": false,
                      "type": "mongodb_single",
                      "username": "myuser",
                      "w_mode": "safe"
                    }
                  },
                  "mqtt_example": {
                    "summary": "MQTT Bridge",
                    "value": {
                      "clean_start": true,
                      "egress": {
                        "local": {
                          "topic": "emqx/#"
                        },
                        "remote": {
                          "payload": "${payload}",
                          "qos": "${qos}",
                          "retain": false,
                          "topic": "from_emqx/${topic}"
                        }
                      },
                      "enable": true,
                      "ingress": {
                        "local": {
                          "payload": "${payload}",
                          "qos": "${qos}",
                          "retain": "${retain}",
                          "topic": "from_aws/${topic}"
                        },
                        "remote": {
                          "qos": 1,
                          "topic": "aws/#"
                        }
                      },
                      "keepalive": "300s",
                      "max_inflight": 100,
                      "mode": "cluster_shareload",
                      "name": "mqtt_example",
                      "password": "******",
                      "proto_ver": "v4",
                      "resource_opts": {
                        "auto_restart_interval": "60s",
                        "health_check_interval": "15s",
                        "max_buffer_bytes": 104857600,
                        "query_mode": "sync"
                      },
                      "retry_interval": "15s",
                      "server": "127.0.0.1:1883",
                      "ssl": {
                        "enable": false
                      },
                      "type": "mqtt",
                      "username": "foo"
                    }
                  },
                  "mysql": {
                    "summary": "MySQL Bridge",
                    "value": {
                      "database": "test",
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "foo",
                      "password": "******",
                      "pool_size": 8,
                      "resource_opts": {
                        "auto_restart_interval": "60s",
                        "batch_size": 1,
                        "batch_time": 0,
                        "health_check_interval": "15s",
                        "max_buffer_bytes": 268435456,
                        "query_mode": "async",
                        "worker_pool_size": 1
                      },
                      "server": "127.0.0.1:3306",
                      "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, FROM_UNIXTIME(${timestamp}/1000))",
                      "type": "mysql",
                      "username": "root"
                    }
                  },
                  "pgsql": {
                    "summary": "PostgreSQL Bridge",
                    "value": {
                      "database": "mqtt",
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "foo",
                      "password": "******",
                      "pool_size": 8,
                      "resource_opts": {
                        "auto_restart_interval": "60s",
                        "batch_size": 1,
                        "batch_time": 0,
                        "health_check_interval": "15s",
                        "max_buffer_bytes": 268435456,
                        "query_mode": "async",
                        "worker_pool_size": 8
                      },
                      "server": "127.0.0.1:5432",
                      "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                      "type": "pgsql",
                      "username": "root"
                    }
                  },
                  "redis_cluster": {
                    "summary": "Redis Cluster Bridge",
                    "value": {
                      "command_template": [
                        "LPUSH",
                        "MSGS",
                        "${payload}"
                      ],
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "redis_bridge",
                      "password": "******",
                      "pool_size": 8,
                      "redis_type": "cluster",
                      "resource_opts": {},
                      "servers": [
                        "127.0.0.1:6379"
                      ],
                      "ssl": {
                        "enable": false
                      },
                      "type": "redis_cluster"
                    }
                  },
                  "redis_sentinel": {
                    "summary": "Redis Sentinel Bridge",
                    "value": {
                      "command_template": [
                        "LPUSH",
                        "MSGS",
                        "${payload}"
                      ],
                      "database": 1,
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "redis_bridge",
                      "password": "******",
                      "pool_size": 8,
                      "redis_type": "sentinel",
                      "resource_opts": {
                        "batch_size": 1,
                        "batch_time": "20ms"
                      },
                      "sentinel": "mymaster",
                      "servers": [
                        "127.0.0.1:26379"
                      ],
                      "ssl": {
                        "enable": false
                      },
                      "type": "redis_sentinel"
                    }
                  },
                  "redis_single": {
                    "summary": "Redis Single Node Bridge",
                    "value": {
                      "command_template": [
                        "LPUSH",
                        "MSGS",
                        "${payload}"
                      ],
                      "database": 1,
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "redis_bridge",
                      "password": "******",
                      "pool_size": 8,
                      "redis_type": "single",
                      "resource_opts": {
                        "batch_size": 1,
                        "batch_time": "20ms"
                      },
                      "server": "127.0.0.1:6379",
                      "ssl": {
                        "enable": false
                      },
                      "type": "redis_single"
                    }
                  },
                  "rocketmq": {
                    "summary": "RocketMQ Bridge",
                    "value": {
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "foo",
                      "resource_opts": {
                        "auto_restart_interval": "60s",
                        "batch_size": 1,
                        "batch_time": 0,
                        "health_check_interval": "15s",
                        "max_buffer_bytes": 268435456,
                        "query_mode": "sync",
                        "worker_pool_size": 1
                      },
                      "server": "127.0.0.1:9876",
                      "template": "",
                      "topic": "TopicTest",
                      "type": "rocketmq"
                    }
                  },
                  "sqlserver": {
                    "summary": "Microsoft SQL Server Bridge",
                    "value": {
                      "database": "test",
                      "driver": "ms-sql",
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "bar",
                      "password": "******",
                      "pool_size": 8,
                      "resource_opts": {
                        "auto_restart_interval": "60s",
                        "batch_size": 1,
                        "batch_time": 0,
                        "health_check_interval": "15s",
                        "max_buffer_bytes": 268435456,
                        "query_mode": "async",
                        "worker_pool_size": 1
                      },
                      "server": "127.0.0.1:1433",
                      "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload) values ( ${id}, ${topic}, ${qos}, ${payload} )",
                      "type": "sqlserver",
                      "username": "sa"
                    }
                  },
                  "tdengine": {
                    "summary": "TDengine Bridge",
                    "value": {
                      "database": "mqtt",
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "foo",
                      "password": "taosdata",
                      "pool_size": 8,
                      "resource_opts": {
                        "auto_restart_interval": "60s",
                        "batch_size": 1,
                        "batch_time": 0,
                        "health_check_interval": "15s",
                        "max_buffer_bytes": 268435456,
                        "query_mode": "sync",
                        "worker_pool_size": 8
                      },
                      "server": "127.0.0.1:6041",
                      "sql": "insert into t_mqtt_msg(ts, msgid, mqtt_topic, qos, payload, arrived) values (${ts}, ${id}, ${topic}, ${qos}, ${payload}, ${timestamp})",
                      "type": "tdengine",
                      "username": "root"
                    }
                  },
                  "timescale": {
                    "summary": "Timescale Bridge",
                    "value": {
                      "database": "mqtt",
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "foo",
                      "password": "******",
                      "pool_size": 8,
                      "resource_opts": {
                        "auto_restart_interval": "60s",
                        "batch_size": 1,
                        "batch_time": 0,
                        "health_check_interval": "15s",
                        "max_buffer_bytes": 268435456,
                        "query_mode": "async",
                        "worker_pool_size": 8
                      },
                      "server": "127.0.0.1:5432",
                      "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                      "type": "timescale",
                      "username": "root"
                    }
                  },
                  "webhook_example": {
                    "summary": "WebHook",
                    "value": {
                      "body": "${payload}",
                      "connect_timeout": "15s",
                      "enable": true,
                      "enable_pipelining": 100,
                      "local_topic": "emqx_webhook/#",
                      "max_retries": 3,
                      "method": "post",
                      "name": "webhook_example",
                      "pool_size": 4,
                      "pool_type": "random",
                      "request_timeout": "15s",
                      "resource_opts": {
                        "auto_restart_interval": 15000,
                        "health_check_interval": 15000,
                        "inflight_window": 100,
                        "max_buffer_bytes": 104857600,
                        "query_mode": "async",
                        "worker_pool_size": 1
                      },
                      "ssl": {
                        "enable": false
                      },
                      "type": "webhook",
                      "url": "http://localhost:9901/messages/${topic}"
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/bridge_sqlserver.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_cassa.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_rocketmq.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_dynamo.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_clickhouse.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_tdengine.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_matrix.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_timescale.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_redis.get_cluster"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_redis.get_sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_redis.get_single"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_influxdb.get_api_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_influxdb.get_api_v1"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_hstreamdb.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mongodb.get_single"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mongodb.get_sharded"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mongodb.get_rs"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_pgsql.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mysql.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_kafka.get_producer"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_kafka.get_consumer"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_gcp_pubsub.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mqtt.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_webhook.get"
                    }
                  ]
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bridge not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Get Bridge",
        "tags": [
          "Bridges"
        ]
      },
      "put": {
        "description": "Update a bridge by Id",
        "parameters": [
          {
            "description": "The bridge Id. Must be of format {type}:{name}",
            "example": "webhook:webhook_example",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            },
            "summary": "Bridge ID"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "cassandra": {
                  "summary": "Cassandra Bridge",
                  "value": {
                    "cql": "insert into mqtt_msg(topic, msgid, sender, qos, payload, arrived, retain) values (${topic}, ${id}, ${clientid}, ${qos}, ${payload}, ${timestamp}, ${flags.retain})",
                    "enable": true,
                    "keyspace": "mqtt",
                    "local_topic": "local/topic/#",
                    "name": "foo",
                    "password": "******",
                    "pool_size": 8,
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "sync",
                      "worker_pool_size": 8
                    },
                    "servers": "127.0.0.1:9042",
                    "type": "cassandra",
                    "username": "root"
                  }
                },
                "clickhouse": {
                  "summary": "Clickhouse Bridge",
                  "value": {
                    "batch_value_separator": ", ",
                    "database": "mqtt",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "foo",
                    "password": "******",
                    "pool_size": 8,
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "async",
                      "worker_pool_size": 8
                    },
                    "server": "127.0.0.1:8123",
                    "sql": "INSERT INTO mqtt_test(payload, arrived) VALUES ('${payload}', ${timestamp})",
                    "type": "clickhouse",
                    "username": "default"
                  }
                },
                "dynamo": {
                  "summary": "DynamoDB Bridge",
                  "value": {
                    "aws_access_key_id": "root",
                    "aws_secret_access_key": "******",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "foo",
                    "pool_size": 8,
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "sync",
                      "worker_pool_size": 8
                    },
                    "table": "mqtt",
                    "template": "",
                    "type": "dynamo",
                    "url": "http://127.0.0.1:8000"
                  }
                },
                "gcp_pubsub": {
                  "summary": "GCP PubSub Bridge",
                  "value": {
                    "pubsub_topic": "mytopic",
                    "service_account_json": {
                      "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                      "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                      "client_email": "test@myproject.iam.gserviceaccount.com",
                      "client_id": "123812831923812319190",
                      "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/test%40myproject.iam.gserviceaccount.com",
                      "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQI...",
                      "private_key_id": "kid",
                      "project_id": "myproject",
                      "token_uri": "https://oauth2.googleapis.com/token",
                      "type": "service_account"
                    }
                  }
                },
                "hstreamdb": {
                  "summary": "HStreamDB Bridge",
                  "value": {
                    "connector": "hstreamdb:connector",
                    "direction": "egress",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "demo",
                    "payload": "${payload}",
                    "type": "hstreamdb"
                  }
                },
                "influxdb_api_v1": {
                  "summary": "InfluxDB HTTP API V1 Bridge",
                  "value": {
                    "database": "example_database",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "demo",
                    "password": "******",
                    "precision": "ms",
                    "resource_opts": {
                      "batch_size": 100,
                      "batch_time": "20ms"
                    },
                    "server": "127.0.0.1:8086",
                    "ssl": {
                      "enable": false
                    },
                    "type": "influxdb_api_v1",
                    "username": "example_username",
                    "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,bool=${payload.bool}"
                  }
                },
                "influxdb_api_v2": {
                  "summary": "InfluxDB HTTP API V2 Bridge",
                  "value": {
                    "bucket": "example_bucket",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "demo",
                    "org": "examlpe_org",
                    "precision": "ms",
                    "resource_opts": {
                      "batch_size": 100,
                      "batch_time": "20ms"
                    },
                    "server": "127.0.0.1:8086",
                    "ssl": {
                      "enable": false
                    },
                    "token": "example_token",
                    "type": "influxdb_api_v2",
                    "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,uint_value=${payload.uint_key}u,bool=${payload.bool}"
                  }
                },
                "kafka": {
                  "summary": "Kafka Producer Bridge",
                  "value": {
                    "authentication": {
                      "mechanism": "plain",
                      "password": "******",
                      "username": "username"
                    },
                    "bootstrap_hosts": "localhost:9092",
                    "connect_timeout": "5s",
                    "enable": true,
                    "kafka": {
                      "buffer": {
                        "memory_overload_protection": true,
                        "mode": "hybrid",
                        "per_partition_limit": "2GB",
                        "segment_bytes": "100MB"
                      },
                      "compression": "no_compression",
                      "max_batch_bytes": "896KB",
                      "max_inflight": 10,
                      "message": {
                        "key": "${.clientid}",
                        "timestamp": "${.timestamp}",
                        "value": "${.}"
                      },
                      "partition_count_refresh_interval": "60s",
                      "partition_strategy": "random",
                      "required_acks": "all_isr",
                      "topic": "kafka-topic"
                    },
                    "local_topic": "mqtt/local/topic",
                    "metadata_request_timeout": "4s",
                    "min_metadata_refresh_interval": "3s",
                    "socket_opts": {
                      "nodelay": true,
                      "recbuf": "1024KB",
                      "sndbuf": "1024KB"
                    }
                  }
                },
                "kafka_consumer": {
                  "summary": "Kafka Consumer Bridge",
                  "value": {
                    "authentication": {
                      "mechanism": "plain",
                      "password": "******",
                      "username": "username"
                    },
                    "bootstrap_hosts": "localhost:9092",
                    "connect_timeout": "5s",
                    "enable": true,
                    "kafka": {
                      "max_batch_bytes": "896KB",
                      "offset_commit_interval_seconds": 5,
                      "offset_reset_policy": "latest"
                    },
                    "key_encoding_mode": "none",
                    "metadata_request_timeout": "4s",
                    "min_metadata_refresh_interval": "3s",
                    "socket_opts": {
                      "nodelay": true,
                      "recbuf": "1024KB",
                      "sndbuf": "1024KB"
                    },
                    "topic_mapping": [
                      {
                        "kafka_topic": "kafka-topic-1",
                        "mqtt_topic": "mqtt/topic/1",
                        "payload_template": "${.}",
                        "qos": 1
                      },
                      {
                        "kafka_topic": "kafka-topic-2",
                        "mqtt_topic": "mqtt/topic/2",
                        "payload_template": "v = ${.value}",
                        "qos": 2
                      }
                    ],
                    "value_encoding_mode": "none"
                  }
                },
                "matrix": {
                  "summary": "Matrix Bridge",
                  "value": {
                    "database": "mqtt",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "foo",
                    "password": "******",
                    "pool_size": 8,
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "async",
                      "worker_pool_size": 8
                    },
                    "server": "127.0.0.1:5432",
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                    "type": "matrix",
                    "username": "root"
                  }
                },
                "mongodb_rs": {
                  "summary": "MongoDB (Replica Set) Bridge",
                  "value": {
                    "collection": "mycol",
                    "database": "mqtt",
                    "enable": true,
                    "mongo_type": "rs",
                    "name": "mongodb_rs_demo",
                    "password": "******",
                    "pool_size": 8,
                    "r_mode": "safe",
                    "replica_set_name": "rs",
                    "servers": "localhost:27017, localhost:27018",
                    "srv_record": false,
                    "type": "mongodb_rs",
                    "username": "myuser",
                    "w_mode": "safe"
                  }
                },
                "mongodb_sharded": {
                  "summary": "MongoDB (Sharded) Bridge",
                  "value": {
                    "collection": "mycol",
                    "database": "mqtt",
                    "enable": true,
                    "mongo_type": "sharded",
                    "name": "mongodb_sharded_demo",
                    "password": "******",
                    "pool_size": 8,
                    "servers": "localhost:27017, localhost:27018",
                    "srv_record": false,
                    "type": "mongodb_sharded",
                    "username": "myuser",
                    "w_mode": "safe"
                  }
                },
                "mongodb_single": {
                  "summary": "MongoDB (Standalone) Bridge",
                  "value": {
                    "collection": "mycol",
                    "database": "mqtt",
                    "enable": true,
                    "mongo_type": "single",
                    "name": "mongodb_single_demo",
                    "password": "******",
                    "pool_size": 8,
                    "server": "localhost:27017",
                    "srv_record": false,
                    "type": "mongodb_single",
                    "username": "myuser",
                    "w_mode": "safe"
                  }
                },
                "mqtt_example": {
                  "summary": "MQTT Bridge",
                  "value": {
                    "clean_start": true,
                    "egress": {
                      "local": {
                        "topic": "emqx/#"
                      },
                      "remote": {
                        "payload": "${payload}",
                        "qos": "${qos}",
                        "retain": false,
                        "topic": "from_emqx/${topic}"
                      }
                    },
                    "enable": true,
                    "ingress": {
                      "local": {
                        "payload": "${payload}",
                        "qos": "${qos}",
                        "retain": "${retain}",
                        "topic": "from_aws/${topic}"
                      },
                      "remote": {
                        "qos": 1,
                        "topic": "aws/#"
                      }
                    },
                    "keepalive": "300s",
                    "max_inflight": 100,
                    "mode": "cluster_shareload",
                    "password": "******",
                    "proto_ver": "v4",
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 104857600,
                      "query_mode": "sync"
                    },
                    "retry_interval": "15s",
                    "server": "127.0.0.1:1883",
                    "ssl": {
                      "enable": false
                    },
                    "username": "foo"
                  }
                },
                "mysql": {
                  "summary": "MySQL Bridge",
                  "value": {
                    "database": "test",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "foo",
                    "password": "******",
                    "pool_size": 8,
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "async",
                      "worker_pool_size": 1
                    },
                    "server": "127.0.0.1:3306",
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, FROM_UNIXTIME(${timestamp}/1000))",
                    "type": "mysql",
                    "username": "root"
                  }
                },
                "pgsql": {
                  "summary": "PostgreSQL Bridge",
                  "value": {
                    "database": "mqtt",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "foo",
                    "password": "******",
                    "pool_size": 8,
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "async",
                      "worker_pool_size": 8
                    },
                    "server": "127.0.0.1:5432",
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                    "type": "pgsql",
                    "username": "root"
                  }
                },
                "redis_cluster": {
                  "summary": "Redis Cluster Bridge",
                  "value": {
                    "command_template": [
                      "LPUSH",
                      "MSGS",
                      "${payload}"
                    ],
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "password": "******",
                    "pool_size": 8,
                    "redis_type": "cluster",
                    "resource_opts": {},
                    "servers": [
                      "127.0.0.1:6379"
                    ],
                    "ssl": {
                      "enable": false
                    }
                  }
                },
                "redis_sentinel": {
                  "summary": "Redis Sentinel Bridge",
                  "value": {
                    "command_template": [
                      "LPUSH",
                      "MSGS",
                      "${payload}"
                    ],
                    "database": 1,
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "password": "******",
                    "pool_size": 8,
                    "redis_type": "sentinel",
                    "resource_opts": {
                      "batch_size": 1,
                      "batch_time": "20ms"
                    },
                    "sentinel": "mymaster",
                    "servers": [
                      "127.0.0.1:26379"
                    ],
                    "ssl": {
                      "enable": false
                    }
                  }
                },
                "redis_single": {
                  "summary": "Redis Single Node Bridge",
                  "value": {
                    "command_template": [
                      "LPUSH",
                      "MSGS",
                      "${payload}"
                    ],
                    "database": 1,
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "password": "******",
                    "pool_size": 8,
                    "redis_type": "single",
                    "resource_opts": {
                      "batch_size": 1,
                      "batch_time": "20ms"
                    },
                    "server": "127.0.0.1:6379",
                    "ssl": {
                      "enable": false
                    }
                  }
                },
                "rocketmq": {
                  "summary": "RocketMQ Bridge",
                  "value": {
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "foo",
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "sync",
                      "worker_pool_size": 1
                    },
                    "server": "127.0.0.1:9876",
                    "template": "",
                    "topic": "TopicTest",
                    "type": "rocketmq"
                  }
                },
                "sqlserver": {
                  "summary": "Microsoft SQL Server Bridge",
                  "value": {
                    "database": "test",
                    "driver": "ms-sql",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "bar",
                    "password": "******",
                    "pool_size": 8,
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "async",
                      "worker_pool_size": 1
                    },
                    "server": "127.0.0.1:1433",
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload) values ( ${id}, ${topic}, ${qos}, ${payload} )",
                    "type": "sqlserver",
                    "username": "sa"
                  }
                },
                "tdengine": {
                  "summary": "TDengine Bridge",
                  "value": {
                    "database": "mqtt",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "foo",
                    "password": "taosdata",
                    "pool_size": 8,
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "sync",
                      "worker_pool_size": 8
                    },
                    "server": "127.0.0.1:6041",
                    "sql": "insert into t_mqtt_msg(ts, msgid, mqtt_topic, qos, payload, arrived) values (${ts}, ${id}, ${topic}, ${qos}, ${payload}, ${timestamp})",
                    "type": "tdengine",
                    "username": "root"
                  }
                },
                "timescale": {
                  "summary": "Timescale Bridge",
                  "value": {
                    "database": "mqtt",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "foo",
                    "password": "******",
                    "pool_size": 8,
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "async",
                      "worker_pool_size": 8
                    },
                    "server": "127.0.0.1:5432",
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                    "type": "timescale",
                    "username": "root"
                  }
                },
                "webhook_example": {
                  "summary": "WebHook",
                  "value": {
                    "body": "${payload}",
                    "connect_timeout": "15s",
                    "enable": true,
                    "enable_pipelining": 100,
                    "local_topic": "emqx_webhook/#",
                    "max_retries": 3,
                    "method": "post",
                    "pool_size": 4,
                    "pool_type": "random",
                    "request_timeout": "15s",
                    "resource_opts": {
                      "auto_restart_interval": 15000,
                      "health_check_interval": 15000,
                      "inflight_window": 100,
                      "max_buffer_bytes": 104857600,
                      "query_mode": "async",
                      "worker_pool_size": 1
                    },
                    "ssl": {
                      "enable": false
                    },
                    "url": "http://localhost:9901/messages/${topic}"
                  }
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/bridge_sqlserver.put"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_cassa.put"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_rocketmq.put"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_dynamo.put"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_clickhouse.put"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_tdengine.put"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_matrix.put"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_timescale.put"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_redis.put_cluster"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_redis.put_sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_redis.put_single"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_influxdb.put_api_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_influxdb.put_api_v1"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_hstreamdb.put"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mongodb.put_single"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mongodb.put_sharded"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mongodb.put_rs"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_pgsql.put"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mysql.put"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_kafka.put_producer"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_kafka.put_consumer"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_gcp_pubsub.put"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mqtt.put"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_webhook.put"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "cassandra": {
                    "summary": "Cassandra Bridge",
                    "value": {
                      "cql": "insert into mqtt_msg(topic, msgid, sender, qos, payload, arrived, retain) values (${topic}, ${id}, ${clientid}, ${qos}, ${payload}, ${timestamp}, ${flags.retain})",
                      "enable": true,
                      "keyspace": "mqtt",
                      "local_topic": "local/topic/#",
                      "name": "foo",
                      "password": "******",
                      "pool_size": 8,
                      "resource_opts": {
                        "auto_restart_interval": "60s",
                        "batch_size": 1,
                        "batch_time": 0,
                        "health_check_interval": "15s",
                        "max_buffer_bytes": 268435456,
                        "query_mode": "sync",
                        "worker_pool_size": 8
                      },
                      "servers": "127.0.0.1:9042",
                      "type": "cassandra",
                      "username": "root"
                    }
                  },
                  "clickhouse": {
                    "summary": "Clickhouse Bridge",
                    "value": {
                      "batch_value_separator": ", ",
                      "database": "mqtt",
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "foo",
                      "password": "******",
                      "pool_size": 8,
                      "resource_opts": {
                        "auto_restart_interval": "60s",
                        "batch_size": 1,
                        "batch_time": 0,
                        "health_check_interval": "15s",
                        "max_buffer_bytes": 268435456,
                        "query_mode": "async",
                        "worker_pool_size": 8
                      },
                      "server": "127.0.0.1:8123",
                      "sql": "INSERT INTO mqtt_test(payload, arrived) VALUES ('${payload}', ${timestamp})",
                      "type": "clickhouse",
                      "username": "default"
                    }
                  },
                  "dynamo": {
                    "summary": "DynamoDB Bridge",
                    "value": {
                      "aws_access_key_id": "root",
                      "aws_secret_access_key": "******",
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "foo",
                      "pool_size": 8,
                      "resource_opts": {
                        "auto_restart_interval": "60s",
                        "batch_size": 1,
                        "batch_time": 0,
                        "health_check_interval": "15s",
                        "max_buffer_bytes": 268435456,
                        "query_mode": "sync",
                        "worker_pool_size": 8
                      },
                      "table": "mqtt",
                      "template": "",
                      "type": "dynamo",
                      "url": "http://127.0.0.1:8000"
                    }
                  },
                  "gcp_pubsub": {
                    "summary": "GCP PubSub Bridge",
                    "value": {
                      "pubsub_topic": "mytopic",
                      "service_account_json": {
                        "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                        "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                        "client_email": "test@myproject.iam.gserviceaccount.com",
                        "client_id": "123812831923812319190",
                        "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/test%40myproject.iam.gserviceaccount.com",
                        "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQI...",
                        "private_key_id": "kid",
                        "project_id": "myproject",
                        "token_uri": "https://oauth2.googleapis.com/token",
                        "type": "service_account"
                      }
                    }
                  },
                  "hstreamdb": {
                    "summary": "HStreamDB Bridge",
                    "value": {
                      "connector": "hstreamdb:connector",
                      "direction": "egress",
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "demo",
                      "payload": "${payload}",
                      "type": "hstreamdb"
                    }
                  },
                  "influxdb_api_v1": {
                    "summary": "InfluxDB HTTP API V1 Bridge",
                    "value": {
                      "database": "example_database",
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "demo",
                      "password": "******",
                      "precision": "ms",
                      "resource_opts": {
                        "batch_size": 100,
                        "batch_time": "20ms"
                      },
                      "server": "127.0.0.1:8086",
                      "ssl": {
                        "enable": false
                      },
                      "type": "influxdb_api_v1",
                      "username": "example_username",
                      "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,bool=${payload.bool}"
                    }
                  },
                  "influxdb_api_v2": {
                    "summary": "InfluxDB HTTP API V2 Bridge",
                    "value": {
                      "bucket": "example_bucket",
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "demo",
                      "org": "examlpe_org",
                      "precision": "ms",
                      "resource_opts": {
                        "batch_size": 100,
                        "batch_time": "20ms"
                      },
                      "server": "127.0.0.1:8086",
                      "ssl": {
                        "enable": false
                      },
                      "token": "example_token",
                      "type": "influxdb_api_v2",
                      "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,uint_value=${payload.uint_key}u,bool=${payload.bool}"
                    }
                  },
                  "kafka": {
                    "summary": "Kafka Producer Bridge",
                    "value": {
                      "authentication": {
                        "mechanism": "plain",
                        "password": "******",
                        "username": "username"
                      },
                      "bootstrap_hosts": "localhost:9092",
                      "connect_timeout": "5s",
                      "enable": true,
                      "kafka": {
                        "buffer": {
                          "memory_overload_protection": true,
                          "mode": "hybrid",
                          "per_partition_limit": "2GB",
                          "segment_bytes": "100MB"
                        },
                        "compression": "no_compression",
                        "max_batch_bytes": "896KB",
                        "max_inflight": 10,
                        "message": {
                          "key": "${.clientid}",
                          "timestamp": "${.timestamp}",
                          "value": "${.}"
                        },
                        "partition_count_refresh_interval": "60s",
                        "partition_strategy": "random",
                        "required_acks": "all_isr",
                        "topic": "kafka-topic"
                      },
                      "local_topic": "mqtt/local/topic",
                      "metadata_request_timeout": "4s",
                      "min_metadata_refresh_interval": "3s",
                      "socket_opts": {
                        "nodelay": true,
                        "recbuf": "1024KB",
                        "sndbuf": "1024KB"
                      }
                    }
                  },
                  "kafka_consumer": {
                    "summary": "Kafka Consumer Bridge",
                    "value": {
                      "authentication": {
                        "mechanism": "plain",
                        "password": "******",
                        "username": "username"
                      },
                      "bootstrap_hosts": "localhost:9092",
                      "connect_timeout": "5s",
                      "enable": true,
                      "kafka": {
                        "max_batch_bytes": "896KB",
                        "offset_commit_interval_seconds": 5,
                        "offset_reset_policy": "latest"
                      },
                      "key_encoding_mode": "none",
                      "metadata_request_timeout": "4s",
                      "min_metadata_refresh_interval": "3s",
                      "socket_opts": {
                        "nodelay": true,
                        "recbuf": "1024KB",
                        "sndbuf": "1024KB"
                      },
                      "topic_mapping": [
                        {
                          "kafka_topic": "kafka-topic-1",
                          "mqtt_topic": "mqtt/topic/1",
                          "payload_template": "${.}",
                          "qos": 1
                        },
                        {
                          "kafka_topic": "kafka-topic-2",
                          "mqtt_topic": "mqtt/topic/2",
                          "payload_template": "v = ${.value}",
                          "qos": 2
                        }
                      ],
                      "value_encoding_mode": "none"
                    }
                  },
                  "matrix": {
                    "summary": "Matrix Bridge",
                    "value": {
                      "database": "mqtt",
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "foo",
                      "password": "******",
                      "pool_size": 8,
                      "resource_opts": {
                        "auto_restart_interval": "60s",
                        "batch_size": 1,
                        "batch_time": 0,
                        "health_check_interval": "15s",
                        "max_buffer_bytes": 268435456,
                        "query_mode": "async",
                        "worker_pool_size": 8
                      },
                      "server": "127.0.0.1:5432",
                      "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                      "type": "matrix",
                      "username": "root"
                    }
                  },
                  "mongodb_rs": {
                    "summary": "MongoDB (Replica Set) Bridge",
                    "value": {
                      "collection": "mycol",
                      "database": "mqtt",
                      "enable": true,
                      "mongo_type": "rs",
                      "name": "mongodb_rs_demo",
                      "password": "******",
                      "pool_size": 8,
                      "r_mode": "safe",
                      "replica_set_name": "rs",
                      "servers": "localhost:27017, localhost:27018",
                      "srv_record": false,
                      "type": "mongodb_rs",
                      "username": "myuser",
                      "w_mode": "safe"
                    }
                  },
                  "mongodb_sharded": {
                    "summary": "MongoDB (Sharded) Bridge",
                    "value": {
                      "collection": "mycol",
                      "database": "mqtt",
                      "enable": true,
                      "mongo_type": "sharded",
                      "name": "mongodb_sharded_demo",
                      "password": "******",
                      "pool_size": 8,
                      "servers": "localhost:27017, localhost:27018",
                      "srv_record": false,
                      "type": "mongodb_sharded",
                      "username": "myuser",
                      "w_mode": "safe"
                    }
                  },
                  "mongodb_single": {
                    "summary": "MongoDB (Standalone) Bridge",
                    "value": {
                      "collection": "mycol",
                      "database": "mqtt",
                      "enable": true,
                      "mongo_type": "single",
                      "name": "mongodb_single_demo",
                      "password": "******",
                      "pool_size": 8,
                      "server": "localhost:27017",
                      "srv_record": false,
                      "type": "mongodb_single",
                      "username": "myuser",
                      "w_mode": "safe"
                    }
                  },
                  "mqtt_example": {
                    "summary": "MQTT Bridge",
                    "value": {
                      "clean_start": true,
                      "egress": {
                        "local": {
                          "topic": "emqx/#"
                        },
                        "remote": {
                          "payload": "${payload}",
                          "qos": "${qos}",
                          "retain": false,
                          "topic": "from_emqx/${topic}"
                        }
                      },
                      "enable": true,
                      "ingress": {
                        "local": {
                          "payload": "${payload}",
                          "qos": "${qos}",
                          "retain": "${retain}",
                          "topic": "from_aws/${topic}"
                        },
                        "remote": {
                          "qos": 1,
                          "topic": "aws/#"
                        }
                      },
                      "keepalive": "300s",
                      "max_inflight": 100,
                      "mode": "cluster_shareload",
                      "name": "mqtt_example",
                      "password": "******",
                      "proto_ver": "v4",
                      "resource_opts": {
                        "auto_restart_interval": "60s",
                        "health_check_interval": "15s",
                        "max_buffer_bytes": 104857600,
                        "query_mode": "sync"
                      },
                      "retry_interval": "15s",
                      "server": "127.0.0.1:1883",
                      "ssl": {
                        "enable": false
                      },
                      "type": "mqtt",
                      "username": "foo"
                    }
                  },
                  "mysql": {
                    "summary": "MySQL Bridge",
                    "value": {
                      "database": "test",
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "foo",
                      "password": "******",
                      "pool_size": 8,
                      "resource_opts": {
                        "auto_restart_interval": "60s",
                        "batch_size": 1,
                        "batch_time": 0,
                        "health_check_interval": "15s",
                        "max_buffer_bytes": 268435456,
                        "query_mode": "async",
                        "worker_pool_size": 1
                      },
                      "server": "127.0.0.1:3306",
                      "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, FROM_UNIXTIME(${timestamp}/1000))",
                      "type": "mysql",
                      "username": "root"
                    }
                  },
                  "pgsql": {
                    "summary": "PostgreSQL Bridge",
                    "value": {
                      "database": "mqtt",
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "foo",
                      "password": "******",
                      "pool_size": 8,
                      "resource_opts": {
                        "auto_restart_interval": "60s",
                        "batch_size": 1,
                        "batch_time": 0,
                        "health_check_interval": "15s",
                        "max_buffer_bytes": 268435456,
                        "query_mode": "async",
                        "worker_pool_size": 8
                      },
                      "server": "127.0.0.1:5432",
                      "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                      "type": "pgsql",
                      "username": "root"
                    }
                  },
                  "redis_cluster": {
                    "summary": "Redis Cluster Bridge",
                    "value": {
                      "command_template": [
                        "LPUSH",
                        "MSGS",
                        "${payload}"
                      ],
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "redis_bridge",
                      "password": "******",
                      "pool_size": 8,
                      "redis_type": "cluster",
                      "resource_opts": {},
                      "servers": [
                        "127.0.0.1:6379"
                      ],
                      "ssl": {
                        "enable": false
                      },
                      "type": "redis_cluster"
                    }
                  },
                  "redis_sentinel": {
                    "summary": "Redis Sentinel Bridge",
                    "value": {
                      "command_template": [
                        "LPUSH",
                        "MSGS",
                        "${payload}"
                      ],
                      "database": 1,
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "redis_bridge",
                      "password": "******",
                      "pool_size": 8,
                      "redis_type": "sentinel",
                      "resource_opts": {
                        "batch_size": 1,
                        "batch_time": "20ms"
                      },
                      "sentinel": "mymaster",
                      "servers": [
                        "127.0.0.1:26379"
                      ],
                      "ssl": {
                        "enable": false
                      },
                      "type": "redis_sentinel"
                    }
                  },
                  "redis_single": {
                    "summary": "Redis Single Node Bridge",
                    "value": {
                      "command_template": [
                        "LPUSH",
                        "MSGS",
                        "${payload}"
                      ],
                      "database": 1,
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "redis_bridge",
                      "password": "******",
                      "pool_size": 8,
                      "redis_type": "single",
                      "resource_opts": {
                        "batch_size": 1,
                        "batch_time": "20ms"
                      },
                      "server": "127.0.0.1:6379",
                      "ssl": {
                        "enable": false
                      },
                      "type": "redis_single"
                    }
                  },
                  "rocketmq": {
                    "summary": "RocketMQ Bridge",
                    "value": {
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "foo",
                      "resource_opts": {
                        "auto_restart_interval": "60s",
                        "batch_size": 1,
                        "batch_time": 0,
                        "health_check_interval": "15s",
                        "max_buffer_bytes": 268435456,
                        "query_mode": "sync",
                        "worker_pool_size": 1
                      },
                      "server": "127.0.0.1:9876",
                      "template": "",
                      "topic": "TopicTest",
                      "type": "rocketmq"
                    }
                  },
                  "sqlserver": {
                    "summary": "Microsoft SQL Server Bridge",
                    "value": {
                      "database": "test",
                      "driver": "ms-sql",
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "bar",
                      "password": "******",
                      "pool_size": 8,
                      "resource_opts": {
                        "auto_restart_interval": "60s",
                        "batch_size": 1,
                        "batch_time": 0,
                        "health_check_interval": "15s",
                        "max_buffer_bytes": 268435456,
                        "query_mode": "async",
                        "worker_pool_size": 1
                      },
                      "server": "127.0.0.1:1433",
                      "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload) values ( ${id}, ${topic}, ${qos}, ${payload} )",
                      "type": "sqlserver",
                      "username": "sa"
                    }
                  },
                  "tdengine": {
                    "summary": "TDengine Bridge",
                    "value": {
                      "database": "mqtt",
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "foo",
                      "password": "taosdata",
                      "pool_size": 8,
                      "resource_opts": {
                        "auto_restart_interval": "60s",
                        "batch_size": 1,
                        "batch_time": 0,
                        "health_check_interval": "15s",
                        "max_buffer_bytes": 268435456,
                        "query_mode": "sync",
                        "worker_pool_size": 8
                      },
                      "server": "127.0.0.1:6041",
                      "sql": "insert into t_mqtt_msg(ts, msgid, mqtt_topic, qos, payload, arrived) values (${ts}, ${id}, ${topic}, ${qos}, ${payload}, ${timestamp})",
                      "type": "tdengine",
                      "username": "root"
                    }
                  },
                  "timescale": {
                    "summary": "Timescale Bridge",
                    "value": {
                      "database": "mqtt",
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "foo",
                      "password": "******",
                      "pool_size": 8,
                      "resource_opts": {
                        "auto_restart_interval": "60s",
                        "batch_size": 1,
                        "batch_time": 0,
                        "health_check_interval": "15s",
                        "max_buffer_bytes": 268435456,
                        "query_mode": "async",
                        "worker_pool_size": 8
                      },
                      "server": "127.0.0.1:5432",
                      "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                      "type": "timescale",
                      "username": "root"
                    }
                  },
                  "webhook_example": {
                    "summary": "WebHook",
                    "value": {
                      "body": "${payload}",
                      "connect_timeout": "15s",
                      "enable": true,
                      "enable_pipelining": 100,
                      "local_topic": "emqx_webhook/#",
                      "max_retries": 3,
                      "method": "post",
                      "name": "webhook_example",
                      "pool_size": 4,
                      "pool_type": "random",
                      "request_timeout": "15s",
                      "resource_opts": {
                        "auto_restart_interval": 15000,
                        "health_check_interval": 15000,
                        "inflight_window": 100,
                        "max_buffer_bytes": 104857600,
                        "query_mode": "async",
                        "worker_pool_size": 1
                      },
                      "ssl": {
                        "enable": false
                      },
                      "type": "webhook",
                      "url": "http://localhost:9901/messages/${topic}"
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/bridge_sqlserver.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_cassa.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_rocketmq.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_dynamo.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_clickhouse.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_tdengine.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_matrix.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_timescale.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_redis.get_cluster"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_redis.get_sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_redis.get_single"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_influxdb.get_api_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_influxdb.get_api_v1"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_hstreamdb.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mongodb.get_single"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mongodb.get_sharded"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mongodb.get_rs"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_pgsql.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mysql.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_kafka.get_producer"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_kafka.get_consumer"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_gcp_pubsub.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mqtt.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_webhook.get"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Update bridge failed",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bridge not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Update Bridge",
        "tags": [
          "Bridges"
        ]
      }
    },
    "/configs/dashboard": {
      "get": {
        "description": "Get the sub-configurations under *dashboard*",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/dashboard.dashboard"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "config not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Configs"
        ]
      },
      "put": {
        "description": "Update the sub-configurations under *dashboard*",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/dashboard.dashboard"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/dashboard.dashboard"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "UPDATE_FAILED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "403": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "UPDATE_FAILED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Configs"
        ]
      }
    },
    "/gateways/{name}/clients/{clientid}/subscriptions": {
      "get": {
        "description": "Get the gateway client subscriptions",
        "parameters": [
          {
            "description": "Client ID",
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Gateway Name",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "general_subscription_list": {
                    "summary": "A general subscription list",
                    "value": [
                      {
                        "nl": 0,
                        "qos": 1,
                        "rap": 0,
                        "rh": 0,
                        "topic": "test/topic"
                      }
                    ]
                  },
                  "stomp_subscription_list": {
                    "summary": "The STOMP subscription list",
                    "value": [
                      "example_stomp_subscription"
                    ]
                  }
                },
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/emqx_gateway_api_clients.subscription"
                  },
                  "type": "array"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "List client's subscription",
        "tags": [
          "Gateway Clients"
        ]
      },
      "post": {
        "description": "Create a subscription membership",
        "parameters": [
          {
            "description": "Client ID",
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Gateway Name",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "general_subscription": {
                  "summary": "A general subscription",
                  "value": {
                    "nl": 0,
                    "qos": 1,
                    "rap": 0,
                    "rh": 0,
                    "topic": "test/topic"
                  }
                },
                "stomp_subscription": {
                  "summary": "A STOMP subscription",
                  "value": {
                    "nl": 0,
                    "qos": 1,
                    "rap": 0,
                    "rh": 0,
                    "sub_props": {
                      "subid": "10"
                    },
                    "topic": "stomp/topic"
                  }
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_gateway_api_clients.subscription"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "general_subscription": {
                    "summary": "A general subscription",
                    "value": {
                      "nl": 0,
                      "qos": 1,
                      "rap": 0,
                      "rh": 0,
                      "topic": "test/topic"
                    }
                  },
                  "stomp_subscription": {
                    "summary": "A STOMP subscription",
                    "value": {
                      "nl": 0,
                      "qos": 1,
                      "rap": 0,
                      "rh": 0,
                      "sub_props": {
                        "subid": "10"
                      },
                      "topic": "stomp/topic"
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_gateway_api_clients.subscription"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Add subscription for client",
        "tags": [
          "Gateway Clients"
        ]
      }
    },
    "/cluster/{node}/invite": {
      "put": {
        "description": "Invite node to cluster",
        "parameters": [
          {
            "$ref": "#/components/parameters/cluster.node"
          }
        ],
        "responses": {
          "200": {
            "description": "ok"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Cluster"
        ]
      }
    },
    "/listeners/{listener_id}/authentication/{id}/position/{position}": {
      "put": {
        "description": "Move authenticator in listener authentication chain.",
        "parameters": [
          {
            "description": "Listener ID.",
            "example": "tcp:default",
            "in": "path",
            "name": "listener_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Position of authenticator in chain. Possible values are 'front', 'rear', 'before:{other_authenticator}', 'after:{other_authenticator}'.",
            "example": "before:password_based:built_in_database",
            "in": "path",
            "name": "position",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Authenticator moved"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Listener Authentication"
        ]
      }
    },
    "/configs/zones": {
      "get": {
        "description": "Get the sub-configurations under *zones*",
        "parameters": [],
        "responses": {
          "200": {
            "description": "A zone is a set of configs grouped by the zone <code>name</code>.<br/>For flexible configuration mapping, the <code>name</code> can be set to a listener's <code>zone</code> config.<br/>NOTE: A built-in zone named <code>default</code> is auto created and can not be deleted.",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "$name": {
                      "$ref": "#/components/schemas/broker.zone"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "config not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Configs"
        ]
      },
      "put": {
        "description": "Update the sub-configurations under *zones*",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "$name": {
                    "$ref": "#/components/schemas/broker.zone"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "A zone is a set of configs grouped by the zone <code>name</code>.<br/>For flexible configuration mapping, the <code>name</code> can be set to a listener's <code>zone</code> config.<br/>NOTE: A built-in zone named <code>default</code> is auto created and can not be deleted.",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "$name": {
                      "$ref": "#/components/schemas/broker.zone"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "UPDATE_FAILED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "403": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "UPDATE_FAILED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Configs"
        ]
      }
    },
    "/mqtt/retainer/messages": {
      "get": {
        "description": "List retained messages.",
        "parameters": [
          {
            "description": "Page number of the results to fetch.",
            "example": 1,
            "in": "query",
            "name": "page",
            "schema": {
              "default": 1,
              "minimum": 1,
              "type": "integer"
            }
          },
          {
            "description": "Results per page(max 1000)",
            "example": 50,
            "in": "query",
            "name": "limit",
            "schema": {
              "default": 100,
              "maximum": 1000,
              "minimum": 1,
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "data": {
                      "description": "Retained messages list.",
                      "items": {
                        "$ref": "#/components/schemas/retainer.message_summary"
                      },
                      "type": "array"
                    },
                    "meta": {
                      "$ref": "#/components/schemas/public.meta"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Unsupported backend.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Retainer"
        ]
      }
    },
    "/plugins/{name}/move": {
      "post": {
        "description": "Setting the boot order of plugins.",
        "parameters": [
          {
            "$ref": "#/components/parameters/plugins.name"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "move_to_after": {
                  "summary": "move plugin after other plugins",
                  "value": {
                    "position": "after:emqx_plugin_demo-5.1-rc.2"
                  }
                },
                "move_to_before": {
                  "summary": "move plugin before other plugins",
                  "value": {
                    "position": "before:emqx_plugin_demo-5.1-rc.2"
                  }
                },
                "move_to_front": {
                  "summary": "move plugin on the front",
                  "value": {
                    "position": "front"
                  }
                },
                "move_to_rear": {
                  "summary": "move plugin on the rear",
                  "value": {
                    "position": "rear"
                  }
                }
              },
              "schema": {
                "$ref": "#/components/schemas/plugins.position"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Move plugin within plugin hiearchy",
        "tags": [
          "Plugins"
        ]
      }
    },
    "/statsd": {
      "get": {
        "description": "List the configuration of StatsD metrics collection and push service.",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "enable": true,
                  "flush_time_interval": "30s",
                  "sample_time_interval": "30s",
                  "server": "127.0.0.1:8125",
                  "tags": {}
                },
                "schema": {
                  "$ref": "#/components/schemas/statsd.statsd"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Monitor"
        ]
      },
      "put": {
        "description": "Update the configuration of StatsD metrics collection and push service.",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "example": {
                "enable": true,
                "flush_time_interval": "30s",
                "sample_time_interval": "30s",
                "server": "127.0.0.1:8125",
                "tags": {}
              },
              "schema": {
                "$ref": "#/components/schemas/statsd.statsd"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "enable": true,
                  "flush_time_interval": "30s",
                  "sample_time_interval": "30s",
                  "server": "127.0.0.1:8125",
                  "tags": {}
                },
                "schema": {
                  "$ref": "#/components/schemas/statsd.statsd"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Monitor"
        ]
      }
    },
    "/alarms": {
      "delete": {
        "description": "Remove all historical alarms.",
        "parameters": [],
        "responses": {
          "204": {
            "description": "Historical alarms have been cleared successfully."
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Alarms"
        ]
      },
      "get": {
        "description": "List currently activated alarms or historical alarms, determined by query parameters.",
        "parameters": [
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          },
          {
            "description": "It is used to specify the alarm type of the query.<br/>When true, it returns the currently activated alarm,<br/>and when it is false, it returns the historical alarm.<br/>The default is false.",
            "in": "query",
            "name": "activated",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "data": {
                      "items": {
                        "$ref": "#/components/schemas/emqx_mgmt_api_alarms.alarm"
                      },
                      "type": "array"
                    },
                    "meta": {
                      "$ref": "#/components/schemas/public.meta"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Alarms"
        ]
      }
    },
    "/authorization/sources/built_in_database/rules/users/{username}": {
      "delete": {
        "description": "Delete rule for 'username'",
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_authz_api_mnesia.username"
          }
        ],
        "responses": {
          "204": {
            "description": "Deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad username",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Username Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Authorization"
        ]
      },
      "get": {
        "description": "Get rule for 'username'",
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_authz_api_mnesia.username"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "password_based:built_in_database": {
                    "summary": "Username",
                    "value": {
                      "rules": [
                        {
                          "action": "publish",
                          "permission": "allow",
                          "topic": "test/toopic/1"
                        },
                        {
                          "action": "subscribe",
                          "permission": "allow",
                          "topic": "test/toopic/2"
                        },
                        {
                          "action": "all",
                          "permission": "deny",
                          "topic": "eq test/#"
                        }
                      ],
                      "username": "user1"
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authz_api_mnesia.rules_for_username"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Authorization"
        ]
      },
      "put": {
        "description": "Set rule for 'username'",
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_authz_api_mnesia.username"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "password_based:built_in_database": {
                  "summary": "Username",
                  "value": {
                    "rules": [
                      {
                        "action": "publish",
                        "permission": "allow",
                        "topic": "test/toopic/1"
                      },
                      {
                        "action": "subscribe",
                        "permission": "allow",
                        "topic": "test/toopic/2"
                      },
                      {
                        "action": "all",
                        "permission": "deny",
                        "topic": "eq test/#"
                      }
                    ],
                    "username": "user1"
                  }
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authz_api_mnesia.rules_for_username"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Updated"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad username or bad rule schema",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Authorization"
        ]
      }
    },
    "/subscriptions": {
      "get": {
        "description": "List subscriptions",
        "parameters": [
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          },
          {
            "description": "Node name",
            "example": "emqx@127.0.0.1",
            "in": "query",
            "name": "node",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Client ID",
            "in": "query",
            "name": "clientid",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "QoS",
            "in": "query",
            "name": "qos",
            "required": false,
            "schema": {
              "example": 0,
              "maximum": 2,
              "minimum": 0,
              "type": "integer"
            }
          },
          {
            "description": "Topic, url encoding",
            "in": "query",
            "name": "topic",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Match topic string, url encoding",
            "in": "query",
            "name": "match_topic",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Shared subscription group name",
            "in": "query",
            "name": "share_group",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/emqx_mgmt_api_subscriptions.subscription"
                  },
                  "type": "array"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "INVALID_PARAMETER"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Invalid parameter",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "500": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NODE_DOWN"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad RPC",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Subscriptions"
        ]
      }
    },
    "/error_codes": {
      "get": {
        "description": "API Error Codes",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/dashboard.error_code"
                  },
                  "type": "array"
                }
              }
            }
          }
        },
        "security": [],
        "tags": [
          "Error Codes"
        ]
      }
    },
    "/authorization/sources/built_in_database/rules": {
      "delete": {
        "description": "Delete all rules for all 'users', 'clients' and 'all'",
        "parameters": [],
        "responses": {
          "204": {
            "description": "Deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Authorization"
        ]
      }
    },
    "/listeners/{listener_id}/authentication/{id}/users/{user_id}": {
      "delete": {
        "description": "Delete user in authenticator in listener authentication chain.",
        "parameters": [
          {
            "description": "Listener ID.",
            "example": "tcp:default",
            "in": "path",
            "name": "listener_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "User ID.",
            "in": "path",
            "name": "user_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "User deleted"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Listener Authentication"
        ]
      },
      "get": {
        "description": "Get user from authenticator in listener authentication chain.",
        "parameters": [
          {
            "description": "Listener ID.",
            "example": "tcp:default",
            "in": "path",
            "name": "listener_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "User ID.",
            "in": "path",
            "name": "user_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "regular_user": {
                    "summary": "Regular user",
                    "value": {
                      "user_id": "user1"
                    }
                  },
                  "super_user": {
                    "summary": "Superuser",
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Listener Authentication"
        ]
      },
      "put": {
        "description": "Update user in authenticator in listener authentication chain.",
        "parameters": [
          {
            "description": "Listener ID.",
            "example": "tcp:default",
            "in": "path",
            "name": "listener_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "User ID.",
            "in": "path",
            "name": "user_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "example": {
                "regular_user": {
                  "summary": "Update regular user",
                  "value": {
                    "password": "******"
                  }
                },
                "super_user": {
                  "summary": "Update user and promote to superuser",
                  "value": {
                    "is_superuser": true,
                    "password": "******"
                  }
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authn_api.request_user_update"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "regular_user": {
                    "summary": "Regular user",
                    "value": {
                      "user_id": "user1"
                    }
                  },
                  "super_user": {
                    "summary": "Superuser",
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Listener Authentication"
        ]
      }
    },
    "/authorization/sources/{type}/move": {
      "post": {
        "description": "Change the exection order of sources",
        "parameters": [
          {
            "description": "Authorization type",
            "in": "path",
            "name": "type",
            "required": true,
            "schema": {
              "enum": [
                "http",
                "mongodb",
                "redis",
                "built_in_database",
                "mysql",
                "postgresql",
                "file"
              ],
              "type": "string"
            },
            "summary": "source_type"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "front": {
                  "summary": "front example",
                  "value": {
                    "position": "front"
                  }
                },
                "rear": {
                  "summary": "rear example",
                  "value": {
                    "position": "rear"
                  }
                },
                "relative_after": {
                  "summary": "relative example",
                  "value": {
                    "position": "after:file"
                  }
                },
                "relative_before": {
                  "summary": "relative example",
                  "value": {
                    "position": "before:file"
                  }
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authz_api_schema.position"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Authorization"
        ]
      }
    },
    "/listeners/{listener_id}/authentication/{id}/import_users": {
      "post": {
        "description": "Import users into authenticator in listener authentication chain.",
        "parameters": [
          {
            "description": "Listener ID.",
            "example": "tcp:default",
            "in": "path",
            "name": "listener_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "multipart/form-data": {
              "schema": {
                "properties": {
                  "filename": {
                    "format": "binary",
                    "type": "string"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Users imported"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Listener Authentication"
        ]
      }
    },
    "/telemetry/data": {
      "get": {
        "description": "Get telemetry data",
        "parameters": [],
        "responses": {
          "200": {
            "description": "Get telemetry data",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_telemetry_api.telemetry"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Telemetry is not enabled",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Telemetry"
        ]
      }
    },
    "/gateways/{name}/listeners/{id}/authentication/users/{uid}": {
      "delete": {
        "description": "Delete the user for the gateway authenticator (only supports built_in_database)",
        "parameters": [
          {
            "description": "Gateway Name.<br/><br/>It's enum with `stomp`, `mqttsn`, `coap`, `lwm2m`, `exproto`",
            "example": "stomp",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Listener ID",
            "example": "",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "User ID",
            "example": "",
            "in": "path",
            "name": "uid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Delete user",
        "tags": [
          "Gateway Listeners"
        ]
      },
      "get": {
        "description": "Get user info from the gateway authenticator (only supports built_in_database)",
        "parameters": [
          {
            "description": "Gateway Name.<br/><br/>It's enum with `stomp`, `mqttsn`, `coap`, `lwm2m`, `exproto`",
            "example": "stomp",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Listener ID",
            "example": "",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "User ID",
            "example": "",
            "in": "path",
            "name": "uid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "regular_user": {
                    "summary": "Regular user",
                    "value": {
                      "user_id": "user1"
                    }
                  },
                  "super_user": {
                    "summary": "Superuser",
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Get user info",
        "tags": [
          "Gateway Listeners"
        ]
      },
      "put": {
        "description": "Update the user info for the gateway authenticator (only supports built_in_database)",
        "parameters": [
          {
            "description": "Gateway Name.<br/><br/>It's enum with `stomp`, `mqttsn`, `coap`, `lwm2m`, `exproto`",
            "example": "stomp",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Listener ID",
            "example": "",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "User ID",
            "example": "",
            "in": "path",
            "name": "uid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "regular_user": {
                  "summary": "Update regular user",
                  "value": {
                    "password": "******"
                  }
                },
                "super_user": {
                  "summary": "Update user and promote to superuser",
                  "value": {
                    "is_superuser": true,
                    "password": "******"
                  }
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authn_api.request_user_update"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "regular_user": {
                    "summary": "Regular user",
                    "value": {
                      "user_id": "user1"
                    }
                  },
                  "super_user": {
                    "summary": "Superuser",
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Update user info",
        "tags": [
          "Gateway Listeners"
        ]
      }
    },
    "/authentication": {
      "get": {
        "description": "List authenticators for global authentication.",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": [
                  {
                    "algorithm": "hmac-based",
                    "mechanism": "jwt",
                    "secret": "mysecret",
                    "secret_base64_encoded": false,
                    "use_jwks": false,
                    "verify_claims": {
                      "username": "${username}"
                    }
                  },
                  {
                    "backend": "built_in_database",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "user_id_type": "username"
                  },
                  {
                    "backend": "http",
                    "body": {
                      "password": "${password}",
                      "username": "${username}"
                    },
                    "connect_timeout": 5000,
                    "enable_pipelining": 100,
                    "headers": {
                      "content-type": "application/json"
                    },
                    "mechanism": "password_based",
                    "method": "post",
                    "pool_size": 8,
                    "request_timeout": 5000,
                    "ssl": {
                      "enable": false
                    },
                    "url": "http://127.0.0.1:18083"
                  },
                  {
                    "backend": "mongodb",
                    "collection": "users",
                    "database": "example",
                    "filter": {
                      "username": "${username}"
                    },
                    "is_superuser_field": "is_superuser",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "password_hash_field": "password_hash",
                    "salt_field": "salt",
                    "server": "127.0.0.1:27017"
                  },
                  {
                    "backend": "redis",
                    "cmd": "HMGET ${username} password_hash salt",
                    "database": 0,
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "redis_type": "single",
                    "server": "127.0.0.1:6379"
                  }
                ],
                "schema": {
                  "items": {
                    "oneOf": [
                      {
                        "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
                      },
                      {
                        "$ref": "#/components/schemas/authn-jwt.jwks"
                      },
                      {
                        "$ref": "#/components/schemas/authn-jwt.public-key"
                      },
                      {
                        "$ref": "#/components/schemas/authn-jwt.hmac-based"
                      },
                      {
                        "$ref": "#/components/schemas/authn-http.post"
                      },
                      {
                        "$ref": "#/components/schemas/authn-http.get"
                      },
                      {
                        "$ref": "#/components/schemas/authn-redis.sentinel"
                      },
                      {
                        "$ref": "#/components/schemas/authn-redis.cluster"
                      },
                      {
                        "$ref": "#/components/schemas/authn-redis.standalone"
                      },
                      {
                        "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                      },
                      {
                        "$ref": "#/components/schemas/authn-mongodb.replica-set"
                      },
                      {
                        "$ref": "#/components/schemas/authn-mongodb.standalone"
                      },
                      {
                        "$ref": "#/components/schemas/authn-postgresql.authentication"
                      },
                      {
                        "$ref": "#/components/schemas/authn-mysql.authentication"
                      },
                      {
                        "$ref": "#/components/schemas/authn-builtin_db.authentication"
                      }
                    ]
                  },
                  "type": "array"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Authentication"
        ]
      },
      "post": {
        "description": "Create authenticator for global authentication.",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "jwt": {
                  "summary": "JWT authentication",
                  "value": {
                    "algorithm": "hmac-based",
                    "mechanism": "jwt",
                    "secret": "mysecret",
                    "secret_base64_encoded": false,
                    "use_jwks": false,
                    "verify_claims": {
                      "username": "${username}"
                    }
                  }
                },
                "password_based:built_in_database": {
                  "summary": "Built-in password_based authentication",
                  "value": {
                    "backend": "built_in_database",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "user_id_type": "username"
                  }
                },
                "password_based:http": {
                  "summary": "password_based authentication through external HTTP API",
                  "value": {
                    "backend": "http",
                    "body": {
                      "password": "${password}",
                      "username": "${username}"
                    },
                    "connect_timeout": 5000,
                    "enable_pipelining": 100,
                    "headers": {
                      "content-type": "application/json"
                    },
                    "mechanism": "password_based",
                    "method": "post",
                    "pool_size": 8,
                    "request_timeout": 5000,
                    "ssl": {
                      "enable": false
                    },
                    "url": "http://127.0.0.1:18083"
                  }
                },
                "password_based:mongodb": {
                  "summary": "password_based authentication with MongoDB backend",
                  "value": {
                    "backend": "mongodb",
                    "collection": "users",
                    "database": "example",
                    "filter": {
                      "username": "${username}"
                    },
                    "is_superuser_field": "is_superuser",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "password_hash_field": "password_hash",
                    "salt_field": "salt",
                    "server": "127.0.0.1:27017"
                  }
                },
                "password_based:redis": {
                  "summary": "password_based authentication with Redis backend",
                  "value": {
                    "backend": "redis",
                    "cmd": "HMGET ${username} password_hash salt",
                    "database": 0,
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "redis_type": "single",
                    "server": "127.0.0.1:6379"
                  }
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.jwks"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.public-key"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.hmac-based"
                  },
                  {
                    "$ref": "#/components/schemas/authn-http.post"
                  },
                  {
                    "$ref": "#/components/schemas/authn-http.get"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.standalone"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.replica-set"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.standalone"
                  },
                  {
                    "$ref": "#/components/schemas/authn-postgresql.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mysql.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-builtin_db.authentication"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "jwt": {
                    "summary": "JWT authentication",
                    "value": {
                      "algorithm": "hmac-based",
                      "mechanism": "jwt",
                      "secret": "mysecret",
                      "secret_base64_encoded": false,
                      "use_jwks": false,
                      "verify_claims": {
                        "username": "${username}"
                      }
                    }
                  },
                  "password_based:built_in_database": {
                    "summary": "Built-in password_based authentication",
                    "value": {
                      "backend": "built_in_database",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "user_id_type": "username"
                    }
                  },
                  "password_based:http": {
                    "summary": "password_based authentication through external HTTP API",
                    "value": {
                      "backend": "http",
                      "body": {
                        "password": "${password}",
                        "username": "${username}"
                      },
                      "connect_timeout": 5000,
                      "enable_pipelining": 100,
                      "headers": {
                        "content-type": "application/json"
                      },
                      "mechanism": "password_based",
                      "method": "post",
                      "pool_size": 8,
                      "request_timeout": 5000,
                      "ssl": {
                        "enable": false
                      },
                      "url": "http://127.0.0.1:18083"
                    }
                  },
                  "password_based:mongodb": {
                    "summary": "password_based authentication with MongoDB backend",
                    "value": {
                      "backend": "mongodb",
                      "collection": "users",
                      "database": "example",
                      "filter": {
                        "username": "${username}"
                      },
                      "is_superuser_field": "is_superuser",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "password_hash_field": "password_hash",
                      "salt_field": "salt",
                      "server": "127.0.0.1:27017"
                    }
                  },
                  "password_based:redis": {
                    "summary": "password_based authentication with Redis backend",
                    "value": {
                      "backend": "redis",
                      "cmd": "HMGET ${username} password_hash salt",
                      "database": 0,
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "redis_type": "single",
                      "server": "127.0.0.1:6379"
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.jwks"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.public-key"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.hmac-based"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.post"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.get"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.replica-set"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-postgresql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mysql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-builtin_db.authentication"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "409": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "ALREADY_EXISTS"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "ALREADY_EXISTS",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Authentication"
        ]
      }
    },
    "/clients/{clientid}/subscribe": {
      "post": {
        "description": "Subscribe",
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx_mgmt_api_clients.subscribe"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_subscriptions.subscription"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "CLIENTID_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Client ID not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Clients"
        ]
      }
    },
    "/trace": {
      "delete": {
        "description": "Clear all traces",
        "parameters": [],
        "responses": {
          "204": {
            "description": "No Content"
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Trace"
        ]
      },
      "get": {
        "description": "List all trace",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/trace.trace"
                  },
                  "type": "array"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Trace"
        ]
      },
      "post": {
        "description": "Create new trace",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "required": [
                  "name",
                  "type"
                ],
                "properties": {
                  "name": {
                    "description": "Unique and format by [a-zA-Z0-9-_]",
                    "example": "EMQX-TRACE-1",
                    "type": "string"
                  },
                  "type": {
                    "description": "Filter type",
                    "enum": [
                      "clientid",
                      "topic",
                      "ip_address"
                    ],
                    "example": "clientid",
                    "type": "string"
                  },
                  "topic": {
                    "description": "support mqtt wildcard topic.",
                    "example": "/dev/#",
                    "type": "string"
                  },
                  "clientid": {
                    "description": "mqtt clientid.",
                    "example": "dev-001",
                    "type": "string"
                  },
                  "ip_address": {
                    "description": "client ip address",
                    "example": "127.0.0.1",
                    "type": "string"
                  },
                  "payload_encode": {
                    "default": "text",
                    "description": "Determine the format of the payload format in the trace file.<br/><br/>`text`: Text-based protocol or plain text protocol.<br/> It is recommended when payload is JSON encoded.<br/><br/>`hex`: Binary hexadecimal encode.It is recommended when payload is a custom binary protocol.<br/><br/>`hidden`: payload is obfuscated as `******`",
                    "enum": [
                      "hex",
                      "text",
                      "hidden"
                    ],
                    "type": "string"
                  },
                  "start_at": {
                    "description": "rfc3339 timestamp or epoch second",
                    "example": "2021-11-04T18:17:38+08:00",
                    "oneOf": [
                      {
                        "description": "epoch-second",
                        "example": 1640995200,
                        "type": "integer"
                      },
                      {
                        "example": "2022-01-01T00:00:00.000Z",
                        "format": "date-time",
                        "type": "string"
                      }
                    ]
                  },
                  "end_at": {
                    "description": "rfc3339 timestamp or epoch second",
                    "example": "2021-11-05T18:17:38+08:00",
                    "oneOf": [
                      {
                        "description": "epoch-second",
                        "example": 1640995200,
                        "type": "integer"
                      },
                      {
                        "example": "2022-01-01T00:00:00.000Z",
                        "format": "date-time",
                        "type": "string"
                      }
                    ]
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/trace.trace"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "INVALID_PARAMS"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "invalid trace params",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "409": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "ALREADY_EXISTS",
                        "DUPLICATE_CONDITION",
                        "BAD_TYPE"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "trace already exists",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Trace"
        ]
      }
    },
    "/exhooks/{name}/move": {
      "post": {
        "description": "Move the server.<br/>NOTE: The position should be \"front | rear | before:{name} | after:{name}",
        "parameters": [
          {
            "description": "The Exhook server name",
            "example": "default",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "front": {
                  "summary": "absolute position 'front'",
                  "value": {
                    "position": "front"
                  }
                },
                "rear": {
                  "summary": "absolute position 'rear'",
                  "value": {
                    "position": "rear"
                  }
                },
                "related_after": {
                  "summary": "relative position 'after'",
                  "value": {
                    "position": "after:default"
                  }
                },
                "related_before": {
                  "summary": "relative position 'before'",
                  "value": {
                    "position": "before:default"
                  }
                }
              },
              "schema": {
                "$ref": "#/components/schemas/exhook.move_req"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "500": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_RPC"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad RPC",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Change order of execution for registered Exhook server",
        "tags": [
          "ExHook"
        ]
      }
    },
    "/slow_subscriptions/settings": {
      "get": {
        "description": "View slow subs settings",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/slow_subs.slow_subs"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Slow Subscriptions"
        ]
      },
      "put": {
        "description": "Update slow subs settings",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/slow_subs.slow_subs"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/slow_subs.slow_subs"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Slow Subscriptions"
        ]
      }
    },
    "/mqtt/topic_metrics": {
      "get": {
        "description": "List topic metrics",
        "parameters": [],
        "responses": {
          "200": {
            "description": "List topic metrics",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/emqx_topic_metrics_api.topic_metrics"
                  },
                  "type": "array"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "MQTT"
        ]
      },
      "post": {
        "description": "Create topic metrics",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "required": [
                  "topic"
                ],
                "properties": {
                  "topic": {
                    "description": "Raw topic string",
                    "example": "testtopic/1",
                    "type": "string"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Create topic metrics"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST",
                        "BAD_TOPIC"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request. Already exists or bad topic name",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "409": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "EXCEED_LIMIT"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Conflict. Topic metrics exceeded max limit 512",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "MQTT"
        ]
      },
      "put": {
        "description": "Reset telemetry status",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "reset_all_topic_metrics": {
                  "summary": "reset_all_topic_metrics",
                  "value": {
                    "action": "reset"
                  }
                },
                "reset_specific_one_topic_metrics": {
                  "summary": "reset_specific_one_topic_metrics",
                  "value": {
                    "action": "reset",
                    "topic": "testtopic/1"
                  }
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_topic_metrics_api.reset"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Reset telemetry status"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "TOPIC_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found. Topic metrics not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "MQTT"
        ]
      }
    },
    "/configs/trace": {
      "get": {
        "description": "Get the sub-configurations under *trace*",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/broker.trace"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "config not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Configs"
        ]
      },
      "put": {
        "description": "Update the sub-configurations under *trace*",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/broker.trace"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/broker.trace"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "UPDATE_FAILED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "403": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "UPDATE_FAILED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Configs"
        ]
      }
    },
    "/error_codes/{code}": {
      "get": {
        "description": "API Error Codes",
        "parameters": [
          {
            "description": "API Error Codes",
            "example": "BAD_USERNAME_OR_PWD",
            "in": "path",
            "name": "code",
            "required": true,
            "schema": {
              "enum": [
                "BAD_USERNAME_OR_PWD",
                "BAD_API_KEY_OR_SECRET",
                "BAD_REQUEST",
                "NOT_MATCH",
                "ALREADY_EXISTS",
                "BAD_CONFIG_SCHEMA",
                "BAD_LISTENER_ID",
                "BAD_NODE_NAME",
                "BAD_RPC",
                "BAD_TOPIC",
                "EXCEED_LIMIT",
                "INVALID_PARAMETER",
                "CONFLICT",
                "NO_DEFAULT_VALUE",
                "DEPENDENCY_EXISTS",
                "MESSAGE_ID_SCHEMA_ERROR",
                "INVALID_ID",
                "MESSAGE_ID_NOT_FOUND",
                "NOT_FOUND",
                "CLIENTID_NOT_FOUND",
                "CLIENT_NOT_FOUND",
                "RESOURCE_NOT_FOUND",
                "TOPIC_NOT_FOUND",
                "USER_NOT_FOUND",
                "INTERNAL_ERROR",
                "SERVICE_UNAVAILABLE",
                "SOURCE_ERROR",
                "UPDATE_FAILED",
                "REST_FAILED",
                "CLIENT_NOT_RESPONSE"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/dashboard.error_code"
                }
              }
            }
          }
        },
        "security": [],
        "tags": [
          "Error Codes"
        ]
      }
    },
    "/bridges/{id}/{operation}": {
      "post": {
        "description": "Stop/Restart bridges on all nodes in the cluster.",
        "parameters": [
          {
            "description": "The bridge Id. Must be of format {type}:{name}",
            "example": "webhook:webhook_example",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            },
            "summary": "Bridge ID"
          },
          {
            "description": "Operations can be one of: stop, restart",
            "example": "start",
            "in": "path",
            "name": "operation",
            "required": true,
            "schema": {
              "enum": [
                "start",
                "stop",
                "restart"
              ],
              "type": "string"
            },
            "summary": "Cluster Operation"
          }
        ],
        "responses": {
          "204": {
            "description": "Operation success"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Problem with configuration of external service",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bridge not found or invalid operation",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "501": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_IMPLEMENTED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Implemented",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Service unavailable",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Cluster Bridge Operate",
        "tags": [
          "Bridges"
        ]
      }
    },
    "/gateways/{name}/clients/{clientid}/subscriptions/{topic}": {
      "delete": {
        "description": "Delete a subscriptions membership",
        "parameters": [
          {
            "description": "Topic Filter/Name",
            "in": "path",
            "name": "topic",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Client ID",
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Gateway Name",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Unsubscribed"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Delete client's subscription",
        "tags": [
          "Gateway Clients"
        ]
      }
    },
    "/mqtt/delayed/messages": {
      "get": {
        "description": "List delayed messages",
        "parameters": [
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "data": {
                      "items": {
                        "$ref": "#/components/schemas/emqx_delayed_api.message"
                      },
                      "type": "array"
                    },
                    "meta": {
                      "properties": {
                        "page": {
                          "description": "View page",
                          "minimum": 1,
                          "type": "integer"
                        },
                        "limit": {
                          "description": "Page limit",
                          "minimum": 1,
                          "type": "integer"
                        },
                        "count": {
                          "description": "Count of delayed messages",
                          "minimum": 0,
                          "type": "integer"
                        }
                      },
                      "type": "object"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "MQTT"
        ]
      }
    },
    "/users/{username}": {
      "delete": {
        "description": "Delete dashboard user",
        "parameters": [
          {
            "description": "Dashboard Username",
            "example": "admin",
            "in": "path",
            "name": "username",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Delete User successfully"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST",
                        "NOT_ALLOWED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Login failed. Bad username or password",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "USER_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Dashboard user not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Dashboard"
        ]
      },
      "put": {
        "description": "Update dashboard user description",
        "parameters": [
          {
            "description": "Dashboard Username",
            "example": "admin",
            "in": "path",
            "name": "username",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "description": {
                    "description": "Dashboard User Description",
                    "example": "administrator",
                    "type": "string"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "username": {
                      "description": "Dashboard Username",
                      "example": "admin",
                      "maxLength": 100,
                      "type": "string"
                    },
                    "description": {
                      "description": "Dashboard User Description",
                      "example": "administrator",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "USER_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Dashboard user not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Dashboard"
        ]
      }
    },
    "/exhooks": {
      "get": {
        "description": "List all servers",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/exhook.detail_server_info"
                  },
                  "type": "array"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "ExHook"
        ]
      },
      "post": {
        "description": "Add a server",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "example": {
                "auto_reconnect": "60s",
                "enable": true,
                "failed_action": "deny",
                "name": "default",
                "pool_size": 8,
                "request_timeout": "5s",
                "ssl": {
                  "cacertfile": "/etc/emqx/certs/cacert.pem",
                  "certfile": "/etc/emqx/certs/cert.pem",
                  "enable": false,
                  "keyfile": "/etc/emqx/certs/key.pem"
                },
                "url": "http://127.0.0.1:8081"
              },
              "schema": {
                "$ref": "#/components/schemas/exhook.server_config"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/exhook.detail_server_info"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Already exists",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "500": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_RPC"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad RPC",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "ExHook"
        ]
      }
    },
    "/gateways/lwm2m/clients/{clientid}/lookup": {
      "get": {
        "description": "Look up a resource",
        "parameters": [
          {
            "example": "urn:oma:lwm2m:oma:2",
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "example": "/3/0/7",
            "in": "query",
            "name": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "example": "discover",
            "in": "query",
            "name": "action",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "clientid": {
                      "example": "urn:oma:lwm2m:oma:2",
                      "type": "string"
                    },
                    "path": {
                      "example": "/3/0/7",
                      "type": "string"
                    },
                    "action": {
                      "example": "discover",
                      "type": "string"
                    },
                    "codeMsg": {
                      "example": "reply_not_received",
                      "type": "string"
                    },
                    "content": {
                      "items": {
                        "$ref": "#/components/schemas/lwm2m.resource"
                      },
                      "type": "array"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "CLIENT_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Client not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "List Client's Resources",
        "tags": [
          "LwM2M Gateways"
        ]
      }
    },
    "/rules/{id}/metrics": {
      "get": {
        "description": "Get a rule's metrics by given Id",
        "parameters": [
          {
            "example": "my_rule_id",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_rule_api_schema.rule_metrics"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Rule not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Get Metric",
        "tags": [
          "Rules"
        ]
      }
    },
    "/slow_subscriptions": {
      "delete": {
        "description": "Clear current data and re count slow topic",
        "parameters": [],
        "responses": {
          "204": {
            "description": "No Content"
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Slow Subscriptions"
        ]
      },
      "get": {
        "description": "View slow topics statistics record data",
        "parameters": [
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "data": {
                      "items": {
                        "$ref": "#/components/schemas/slow_subscribers_statistics.record"
                      },
                      "type": "array"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Slow Subscriptions"
        ]
      }
    },
    "/gateways/{name}": {
      "get": {
        "description": "Get the gateway configurations",
        "parameters": [
          {
            "description": "Gateway Name.<br/><br/>It's enum with `stomp`, `mqttsn`, `coap`, `lwm2m`, `exproto`",
            "example": "stomp",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "coap_gateway": {
                    "summary": "A simple CoAP gateway config",
                    "value": {
                      "connection_required": false,
                      "enable": true,
                      "enable_stats": true,
                      "heartbeat": "30s",
                      "idle_timeout": "30s",
                      "listeners": [
                        {
                          "bind": "5683",
                          "max_conn_rate": 1000,
                          "max_connections": 1024000,
                          "name": "default",
                          "type": "udp"
                        }
                      ],
                      "mountpoint": "coap/",
                      "name": "coap",
                      "notify_type": "qos",
                      "publish_qos": "coap",
                      "subscribe_qos": "coap"
                    }
                  },
                  "exproto_gateway": {
                    "summary": "A simple ExProto gateway config",
                    "value": {
                      "enable": true,
                      "enable_stats": true,
                      "handler": {
                        "address": "http://127.0.0.1:9001"
                      },
                      "idle_timeout": "30s",
                      "listeners": [
                        {
                          "bind": "7993",
                          "max_conn_rate": 1000,
                          "max_connections": 1024000,
                          "name": "default",
                          "type": "tcp"
                        }
                      ],
                      "mountpoint": "exproto/",
                      "name": "exproto",
                      "server": {
                        "bind": "9100"
                      }
                    }
                  },
                  "lwm2m_gateway": {
                    "summary": "A simple LwM2M gateway config",
                    "value": {
                      "auto_observe": false,
                      "enable": true,
                      "enable_stats": true,
                      "idle_timeout": "30s",
                      "lifetime_max": "86400s",
                      "lifetime_min": "1s",
                      "listeners": [
                        {
                          "bind": "5783",
                          "max_conn_rate": 1000,
                          "max_connections": 1024000,
                          "name": "default",
                          "type": "udp"
                        }
                      ],
                      "mountpoint": "lwm2m/",
                      "name": "lwm2m",
                      "qmode_time_window": "22s",
                      "translators": {
                        "command": {
                          "topic": "dn/#"
                        },
                        "notify": {
                          "topic": "up/notify"
                        },
                        "register": {
                          "topic": "up/resp"
                        },
                        "response": {
                          "topic": "up/resp"
                        },
                        "update": {
                          "topic": "up/resp"
                        }
                      },
                      "update_msg_publish_condition": "always",
                      "xml_dir": "/etc/emqx/lwm2m_xml"
                    }
                  },
                  "mqttsn_gateway": {
                    "summary": "A simple MQTT-SN gateway config",
                    "value": {
                      "broadcast": true,
                      "enable": true,
                      "enable_qos3": true,
                      "enable_stats": true,
                      "gateway_id": 1,
                      "idle_timeout": "30s",
                      "listeners": [
                        {
                          "bind": "1884",
                          "max_conn_rate": 1000,
                          "max_connections": 1024000,
                          "name": "default",
                          "type": "udp"
                        }
                      ],
                      "mountpoint": "mqttsn/",
                      "name": "mqttsn",
                      "predefined": [
                        {
                          "id": "1001",
                          "topic": "pred/1001"
                        },
                        {
                          "id": "1002",
                          "topic": "pred/1002"
                        }
                      ]
                    }
                  },
                  "stomp_gateway": {
                    "summary": "A simple STOMP gateway config",
                    "value": {
                      "enable": true,
                      "enable_stats": true,
                      "frame": {
                        "max_body_length": 65535,
                        "max_headers": 10,
                        "max_headers_length": 1024
                      },
                      "idle_timeout": "30s",
                      "listeners": [
                        {
                          "bind": "61613",
                          "max_conn_rate": 1000,
                          "max_connections": 1024000,
                          "name": "default",
                          "type": "tcp"
                        }
                      ],
                      "mountpoint": "stomp/",
                      "name": "stomp"
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.exproto"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.lwm2m"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.coap"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.mqttsn"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.stomp"
                    }
                  ]
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Get gateway",
        "tags": [
          "Gateways"
        ]
      },
      "put": {
        "description": "Update the gateway basic configurations and running status.<br/><br/>Note: The Authentication and Listener configurations should be updated by other special APIs.",
        "parameters": [
          {
            "description": "Gateway Name.<br/><br/>It's enum with `stomp`, `mqttsn`, `coap`, `lwm2m`, `exproto`",
            "example": "stomp",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "coap_gateway": {
                  "summary": "A simple CoAP gateway config",
                  "value": {
                    "connection_required": false,
                    "enable": true,
                    "enable_stats": true,
                    "heartbeat": "30s",
                    "idle_timeout": "30s",
                    "mountpoint": "coap2/",
                    "notify_type": "qos",
                    "publish_qos": "coap",
                    "subscribe_qos": "coap"
                  }
                },
                "exproto_gateway": {
                  "summary": "A simple ExProto gateway config",
                  "value": {
                    "enable": true,
                    "enable_stats": true,
                    "handler": {
                      "address": "http://127.0.0.1:9001"
                    },
                    "idle_timeout": "30s",
                    "mountpoint": "exproto2/",
                    "server": {
                      "bind": "9100"
                    }
                  }
                },
                "lwm2m_gateway": {
                  "summary": "A simple LwM2M gateway config",
                  "value": {
                    "auto_observe": false,
                    "enable": true,
                    "enable_stats": true,
                    "idle_timeout": "30s",
                    "lifetime_max": "86400s",
                    "lifetime_min": "1s",
                    "mountpoint": "lwm2m2/",
                    "qmode_time_window": "22s",
                    "translators": {
                      "command": {
                        "topic": "dn/#"
                      },
                      "notify": {
                        "topic": "up/notify"
                      },
                      "register": {
                        "topic": "up/resp"
                      },
                      "response": {
                        "topic": "up/resp"
                      },
                      "update": {
                        "topic": "up/resp"
                      }
                    },
                    "update_msg_publish_condition": "always",
                    "xml_dir": "/etc/emqx/lwm2m_xml"
                  }
                },
                "mqttsn_gateway": {
                  "summary": "A simple MQTT-SN gateway config",
                  "value": {
                    "broadcast": true,
                    "enable": true,
                    "enable_qos3": false,
                    "enable_stats": true,
                    "gateway_id": 1,
                    "idle_timeout": "30s",
                    "mountpoint": "mqttsn2/",
                    "predefined": [
                      {
                        "id": "1003",
                        "topic": "pred/1003"
                      }
                    ]
                  }
                },
                "stomp_gateway": {
                  "summary": "A simple STOMP gateway config",
                  "value": {
                    "enable": true,
                    "enable_stats": true,
                    "frame": {
                      "max_body_length": 655350,
                      "max_headers": 100,
                      "max_headers_length": 10240
                    },
                    "idle_timeout": "30s",
                    "mountpoint": "stomp2/"
                  }
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.update_exproto"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.update_lwm2m"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.update_coap"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.update_mqttsn"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.update_stomp"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.exproto"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.lwm2m"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.coap"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.mqttsn"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.stomp"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Gateway configuration updated"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Load or update the gateway confs",
        "tags": [
          "Gateways"
        ]
      }
    },
    "/nodes": {
      "get": {
        "description": "List EMQX nodes",
        "parameters": [],
        "responses": {
          "200": {
            "description": "List all EMQX nodes",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/emqx_mgmt_api_nodes.node_info"
                  },
                  "type": "array"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Nodes"
        ]
      }
    },
    "/authorization/sources/{type}": {
      "delete": {
        "description": "Delete source",
        "parameters": [
          {
            "description": "Authorization type",
            "in": "path",
            "name": "type",
            "required": true,
            "schema": {
              "enum": [
                "http",
                "mongodb",
                "redis",
                "built_in_database",
                "mysql",
                "postgresql",
                "file"
              ],
              "type": "string"
            },
            "summary": "source_type"
          }
        ],
        "responses": {
          "204": {
            "description": "Deleted successfully"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Authorization"
        ]
      },
      "get": {
        "description": "Get a authorization source",
        "parameters": [
          {
            "description": "Authorization type",
            "in": "path",
            "name": "type",
            "required": true,
            "schema": {
              "enum": [
                "http",
                "mongodb",
                "redis",
                "built_in_database",
                "mysql",
                "postgresql",
                "file"
              ],
              "type": "string"
            },
            "summary": "source_type"
          }
        ],
        "responses": {
          "200": {
            "description": "Authorization source",
            "summary": "source",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/emqx_authz_api_schema.file"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_authz_api_schema.postgresql"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_authz_api_schema.mysql"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_authz_api_schema.built_in_database"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_authz_api_schema.redis_cluster"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_authz_api_schema.redis_sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_authz_api_schema.redis_single"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_authz_api_schema.mongo_sharded"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_authz_api_schema.mongo_rs"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_authz_api_schema.mongo_single"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_authz_api_schema.http_post"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_authz_api_schema.http_get"
                    }
                  ]
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Authorization"
        ]
      },
      "put": {
        "description": "Update source",
        "parameters": [
          {
            "description": "Authorization type",
            "in": "path",
            "name": "type",
            "required": true,
            "schema": {
              "enum": [
                "http",
                "mongodb",
                "redis",
                "built_in_database",
                "mysql",
                "postgresql",
                "file"
              ],
              "type": "string"
            },
            "summary": "source_type"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.file"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.postgresql"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.mysql"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.built_in_database"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.redis_cluster"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.redis_sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.redis_single"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.mongo_sharded"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.mongo_rs"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.mongo_single"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.http_post"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.http_get"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Authorization source updated successfully"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Authorization"
        ]
      }
    },
    "/gateways/{name}/authentication/import_users": {
      "post": {
        "description": "Import users into the gateway authenticator (only supports built_in_database)",
        "parameters": [
          {
            "description": "Gateway Name.<br/><br/>It's enum with `stomp`, `mqttsn`, `coap`, `lwm2m`, `exproto`",
            "example": "stomp",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "multipart/form-data": {
              "schema": {
                "properties": {
                  "filename": {
                    "format": "binary",
                    "type": "string"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Imported"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Import users",
        "tags": [
          "Gateway Authentication"
        ]
      }
    },
    "/api_key": {
      "get": {
        "description": "Return api_key list",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "name": {
                      "description": "Unique and format by [a-zA-Z0-9-_]",
                      "example": "EMQX-API-KEY-1",
                      "type": "string"
                    },
                    "api_key": {
                      "description": "TODO:uses HMAC-SHA256 for signing.",
                      "example": "a4697a5c75a769f6",
                      "type": "string"
                    },
                    "expired_at": {
                      "default": "infinity",
                      "description": "No longer valid datetime",
                      "example": "2021-12-05T02:01:34.186Z",
                      "oneOf": [
                        {
                          "oneOf": [
                            {
                              "description": "epoch-second",
                              "example": 1640995200,
                              "type": "integer"
                            },
                            {
                              "example": "2022-01-01T00:00:00.000Z",
                              "format": "date-time",
                              "type": "string"
                            }
                          ]
                        },
                        {
                          "enum": [
                            "infinity"
                          ],
                          "type": "string"
                        }
                      ]
                    },
                    "created_at": {
                      "description": "ApiKey create datetime",
                      "example": "2021-12-01T00:00:00.000Z",
                      "oneOf": [
                        {
                          "description": "epoch-second",
                          "example": 1640995200,
                          "type": "integer"
                        },
                        {
                          "example": "2022-01-01T00:00:00.000Z",
                          "format": "date-time",
                          "type": "string"
                        }
                      ]
                    },
                    "desc": {
                      "example": "Note",
                      "type": "string"
                    },
                    "enable": {
                      "description": "Enable/Disable",
                      "type": "boolean"
                    },
                    "expired": {
                      "description": "Expired",
                      "type": "boolean"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "API Keys"
        ]
      },
      "post": {
        "description": "Create new api_key",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "name": {
                    "description": "Unique and format by [a-zA-Z0-9-_]",
                    "example": "EMQX-API-KEY-1",
                    "type": "string"
                  },
                  "expired_at": {
                    "default": "infinity",
                    "description": "No longer valid datetime",
                    "example": "2021-12-05T02:01:34.186Z",
                    "oneOf": [
                      {
                        "oneOf": [
                          {
                            "description": "epoch-second",
                            "example": 1640995200,
                            "type": "integer"
                          },
                          {
                            "example": "2022-01-01T00:00:00.000Z",
                            "format": "date-time",
                            "type": "string"
                          }
                        ]
                      },
                      {
                        "enum": [
                          "infinity"
                        ],
                        "type": "string"
                      }
                    ]
                  },
                  "desc": {
                    "example": "Note",
                    "type": "string"
                  },
                  "enable": {
                    "description": "Enable/Disable",
                    "type": "boolean"
                  },
                  "expired": {
                    "description": "Expired",
                    "type": "boolean"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/api_key.app"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "API Keys"
        ]
      }
    },
    "/listeners/{id}/start": {
      "post": {
        "description": "Start the listener on all nodes.",
        "parameters": [
          {
            "$ref": "#/components/parameters/listeners.listener_id"
          }
        ],
        "responses": {
          "200": {
            "description": "Updated"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST",
                        "BAD_LISTENER_ID"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Listeners"
        ]
      }
    },
    "/banned": {
      "get": {
        "description": "List all currently banned client IDs, usernames and IP addresses.",
        "parameters": [
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "data": {
                      "items": {
                        "$ref": "#/components/schemas/emqx_mgmt_api_banned.ban"
                      },
                      "type": "array"
                    },
                    "meta": {
                      "$ref": "#/components/schemas/public.meta"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Banned"
        ]
      },
      "post": {
        "description": "Add a client ID, username or IP address to the blacklist.",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx_mgmt_api_banned.ban"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "data": {
                      "items": {
                        "$ref": "#/components/schemas/emqx_mgmt_api_banned.ban"
                      },
                      "type": "array"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "ALREADY_EXISTS",
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request, possibly due to wrong parameters or the existence of a banned object.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Banned"
        ]
      }
    },
    "/trace/{name}/log": {
      "get": {
        "description": "view trace log",
        "parameters": [
          {
            "$ref": "#/components/parameters/trace.name"
          },
          {
            "$ref": "#/components/parameters/trace.bytes"
          },
          {
            "$ref": "#/components/parameters/trace.position"
          },
          {
            "$ref": "#/components/parameters/trace.node"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "items": {
                      "example": "TEXT-LOG-ITEMS",
                      "type": "string"
                    },
                    "meta": {
                      "properties": {
                        "bytes": {
                          "default": 1000,
                          "description": "Maximum number of bytes to send in response",
                          "maximum": 2147483647,
                          "minimum": 0,
                          "type": "integer"
                        },
                        "position": {
                          "default": 0,
                          "description": "Offset from the current trace position.",
                          "type": "integer"
                        }
                      },
                      "type": "object"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad input parameter",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "NODE_ERROR"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Trace Name or Node Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Requested chunk size too big",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Trace"
        ]
      }
    },
    "/trace/{name}": {
      "delete": {
        "description": "Delete specified trace",
        "parameters": [
          {
            "$ref": "#/components/parameters/trace.name"
          }
        ],
        "responses": {
          "204": {
            "description": "Delete successfully"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Trace Name Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Trace"
        ]
      }
    },
    "/trace/{name}/stop": {
      "put": {
        "description": "Stop trace by name",
        "parameters": [
          {
            "$ref": "#/components/parameters/trace.name"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/trace.trace"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Trace Name Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Trace"
        ]
      }
    },
    "/listeners/{id}/restart": {
      "post": {
        "description": "Restart listeners on all nodes.",
        "parameters": [
          {
            "$ref": "#/components/parameters/listeners.listener_id"
          }
        ],
        "responses": {
          "200": {
            "description": "Updated"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST",
                        "BAD_LISTENER_ID"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Listeners"
        ]
      }
    },
    "/mqtt/retainer/message/{topic}": {
      "delete": {
        "description": "Delete matching messages.",
        "parameters": [
          {
            "description": "Topic.",
            "in": "path",
            "name": "topic",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": ""
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Unsupported backend.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Retainer"
        ]
      },
      "get": {
        "description": "Lookup a message by a topic without wildcards.",
        "parameters": [
          {
            "description": "Topic.",
            "in": "path",
            "name": "topic",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Details of the message.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/retainer.message"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Unsupported backend.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Viewed message doesn't exist.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Retainer"
        ]
      }
    },
    "/rule_events": {
      "get": {
        "description": "List all events can be used in rules",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_rule_api_schema.rule_events"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "List All Events Can Be Used In Rule",
        "tags": [
          "Rules"
        ]
      }
    },
    "/clients/{clientid}/unsubscribe": {
      "post": {
        "description": "Unsubscribe",
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx_mgmt_api_clients.unsubscribe"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Unsubscribe OK"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "CLIENTID_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Client ID not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Clients"
        ]
      }
    },
    "/plugins/install": {
      "post": {
        "description": "Upload a plugin tarball (plugin-vsn.tar.gz).Follow [emqx-plugin-template](https://github.com/emqx/emqx-plugin-template) to develop plugin.",
        "parameters": [],
        "requestBody": {
          "content": {
            "multipart/form-data": {
              "encoding": {
                "plugin": {
                  "contentType": "application/gzip"
                }
              },
              "schema": {
                "properties": {
                  "plugin": {
                    "format": "binary",
                    "type": "string"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "UNEXPECTED_ERROR",
                        "ALREADY_INSTALLED",
                        "BAD_PLUGIN_INFO"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Install a new plugin",
        "tags": [
          "Plugins"
        ]
      }
    },
    "/gateways/lwm2m/clients/{clientid}/read": {
      "post": {
        "description": "Send a read command to a resource",
        "parameters": [
          {
            "example": "urn:oma:lwm2m:oma:2",
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "example": "/3/0/7",
            "in": "query",
            "name": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "CLIENT_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "clientid not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Read Value from a Resource Path",
        "tags": [
          "LwM2M Gateways"
        ]
      }
    },
    "/banned/{as}/{who}": {
      "delete": {
        "description": "Remove a client ID, username or IP address from the blacklist.",
        "parameters": [
          {
            "description": "Ban method, which can be client ID, username or IP address.",
            "example": "username",
            "in": "path",
            "name": "as",
            "required": true,
            "schema": {
              "enum": [
                "clientid",
                "username",
                "peerhost"
              ],
              "type": "string"
            },
            "summary": "Ban Method"
          },
          {
            "description": "Ban object, specific client ID, username or IP address.",
            "example": "Badass",
            "in": "path",
            "name": "who",
            "required": true,
            "schema": {
              "type": "string"
            },
            "summary": "Ban Object"
          }
        ],
        "responses": {
          "204": {
            "description": "Delete banned success"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "The banned object was not found in the blacklist.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Banned"
        ]
      }
    },
    "/configs_reset/{rootname}": {
      "post": {
        "description": "Reset the config entry specified by the query string parameter `conf_path`.<br/>- For a config entry that has default value, this resets it to the default value;<br/>- For a config entry that has no default value, an error 400 will be returned",
        "parameters": [
          {
            "example": "sysmon",
            "in": "path",
            "name": "rootname",
            "required": true,
            "schema": {
              "enum": [
                "zones",
                "persistent_session_store",
                "log",
                "trace",
                "limiter",
                "sysmon",
                "sys_topics",
                "alarm",
                "dashboard"
              ],
              "type": "string"
            }
          },
          {
            "description": "The config path separated by '.' character",
            "example": "os.sysmem_high_watermark",
            "in": "query",
            "name": "conf_path",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Rest config successfully"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NO_DEFAULT_VALUE",
                        "REST_FAILED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "403": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "REST_FAILED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Configs"
        ]
      }
    },
    "/mqtt/retainer": {
      "get": {
        "description": "View config",
        "parameters": [],
        "responses": {
          "200": {
            "description": "The config content",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/retainer.retainer"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Config not found.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Retainer"
        ]
      },
      "put": {
        "description": "Update retainer config.",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/retainer.retainer"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Update configs successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/retainer.retainer"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "UPDATE_FAILED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Update config failed",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Retainer"
        ]
      }
    },
    "/listeners/{listener_id}/authentication/{id}/status": {
      "get": {
        "description": "Get authenticator status from listener authentication chain.",
        "parameters": [
          {
            "description": "Listener ID.",
            "example": "tcp:default",
            "in": "path",
            "name": "listener_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "status_metrics": {
                    "summary": "Authn status metrics",
                    "value": {
                      "metrics": {
                        "failed": 0,
                        "nomatch": 0,
                        "rate": 0,
                        "rate_last5m": 0,
                        "rate_max": 0,
                        "success": 0,
                        "total": 0
                      },
                      "node_error": [],
                      "node_metrics": [
                        {
                          "metrics": {
                            "failed": 0,
                            "matched": 0,
                            "nomatch": 0,
                            "rate": 0,
                            "rate_last5m": 0,
                            "rate_max": 0,
                            "total": 0
                          },
                          "node": "emqx@127.0.0.1"
                        }
                      ],
                      "node_resource_metrics": [
                        {
                          "metrics": {
                            "failed": 0,
                            "matched": 0,
                            "rate": 0,
                            "rate_last5m": 0,
                            "rate_max": 0,
                            "success": 0
                          },
                          "node": "emqx@127.0.0.1"
                        }
                      ],
                      "node_status": [
                        {
                          "node": "emqx@127.0.0.1",
                          "status": "connected"
                        }
                      ],
                      "resource_metrics": {
                        "failed": 0,
                        "matched": 0,
                        "rate": 0,
                        "rate_last5m": 0,
                        "rate_max": 0,
                        "success": 0
                      },
                      "status": "connected"
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_schema.metrics_status_fields"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Listener Authentication"
        ]
      }
    },
    "/authorization/cache": {
      "delete": {
        "description": "Clean all authorization cache in the cluster.",
        "parameters": [],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Authorization"
        ]
      }
    },
    "/listeners/{listener_id}/authentication": {
      "get": {
        "description": "List authenticators for listener authentication.",
        "parameters": [
          {
            "description": "Listener ID.",
            "example": "tcp:default",
            "in": "path",
            "name": "listener_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": [
                  {
                    "algorithm": "hmac-based",
                    "mechanism": "jwt",
                    "secret": "mysecret",
                    "secret_base64_encoded": false,
                    "use_jwks": false,
                    "verify_claims": {
                      "username": "${username}"
                    }
                  },
                  {
                    "backend": "built_in_database",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "user_id_type": "username"
                  },
                  {
                    "backend": "http",
                    "body": {
                      "password": "${password}",
                      "username": "${username}"
                    },
                    "connect_timeout": 5000,
                    "enable_pipelining": 100,
                    "headers": {
                      "content-type": "application/json"
                    },
                    "mechanism": "password_based",
                    "method": "post",
                    "pool_size": 8,
                    "request_timeout": 5000,
                    "ssl": {
                      "enable": false
                    },
                    "url": "http://127.0.0.1:18083"
                  },
                  {
                    "backend": "mongodb",
                    "collection": "users",
                    "database": "example",
                    "filter": {
                      "username": "${username}"
                    },
                    "is_superuser_field": "is_superuser",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "password_hash_field": "password_hash",
                    "salt_field": "salt",
                    "server": "127.0.0.1:27017"
                  },
                  {
                    "backend": "redis",
                    "cmd": "HMGET ${username} password_hash salt",
                    "database": 0,
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "redis_type": "single",
                    "server": "127.0.0.1:6379"
                  }
                ],
                "schema": {
                  "items": {
                    "oneOf": [
                      {
                        "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
                      },
                      {
                        "$ref": "#/components/schemas/authn-jwt.jwks"
                      },
                      {
                        "$ref": "#/components/schemas/authn-jwt.public-key"
                      },
                      {
                        "$ref": "#/components/schemas/authn-jwt.hmac-based"
                      },
                      {
                        "$ref": "#/components/schemas/authn-http.post"
                      },
                      {
                        "$ref": "#/components/schemas/authn-http.get"
                      },
                      {
                        "$ref": "#/components/schemas/authn-redis.sentinel"
                      },
                      {
                        "$ref": "#/components/schemas/authn-redis.cluster"
                      },
                      {
                        "$ref": "#/components/schemas/authn-redis.standalone"
                      },
                      {
                        "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                      },
                      {
                        "$ref": "#/components/schemas/authn-mongodb.replica-set"
                      },
                      {
                        "$ref": "#/components/schemas/authn-mongodb.standalone"
                      },
                      {
                        "$ref": "#/components/schemas/authn-postgresql.authentication"
                      },
                      {
                        "$ref": "#/components/schemas/authn-mysql.authentication"
                      },
                      {
                        "$ref": "#/components/schemas/authn-builtin_db.authentication"
                      }
                    ]
                  },
                  "type": "array"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Listener Authentication"
        ]
      },
      "post": {
        "description": "Create authenticator for listener authentication.",
        "parameters": [
          {
            "description": "Listener ID.",
            "example": "tcp:default",
            "in": "path",
            "name": "listener_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "jwt": {
                  "summary": "JWT authentication",
                  "value": {
                    "algorithm": "hmac-based",
                    "mechanism": "jwt",
                    "secret": "mysecret",
                    "secret_base64_encoded": false,
                    "use_jwks": false,
                    "verify_claims": {
                      "username": "${username}"
                    }
                  }
                },
                "password_based:built_in_database": {
                  "summary": "Built-in password_based authentication",
                  "value": {
                    "backend": "built_in_database",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "user_id_type": "username"
                  }
                },
                "password_based:http": {
                  "summary": "password_based authentication through external HTTP API",
                  "value": {
                    "backend": "http",
                    "body": {
                      "password": "${password}",
                      "username": "${username}"
                    },
                    "connect_timeout": 5000,
                    "enable_pipelining": 100,
                    "headers": {
                      "content-type": "application/json"
                    },
                    "mechanism": "password_based",
                    "method": "post",
                    "pool_size": 8,
                    "request_timeout": 5000,
                    "ssl": {
                      "enable": false
                    },
                    "url": "http://127.0.0.1:18083"
                  }
                },
                "password_based:mongodb": {
                  "summary": "password_based authentication with MongoDB backend",
                  "value": {
                    "backend": "mongodb",
                    "collection": "users",
                    "database": "example",
                    "filter": {
                      "username": "${username}"
                    },
                    "is_superuser_field": "is_superuser",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "password_hash_field": "password_hash",
                    "salt_field": "salt",
                    "server": "127.0.0.1:27017"
                  }
                },
                "password_based:redis": {
                  "summary": "password_based authentication with Redis backend",
                  "value": {
                    "backend": "redis",
                    "cmd": "HMGET ${username} password_hash salt",
                    "database": 0,
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "redis_type": "single",
                    "server": "127.0.0.1:6379"
                  }
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.jwks"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.public-key"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.hmac-based"
                  },
                  {
                    "$ref": "#/components/schemas/authn-http.post"
                  },
                  {
                    "$ref": "#/components/schemas/authn-http.get"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.standalone"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.replica-set"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.standalone"
                  },
                  {
                    "$ref": "#/components/schemas/authn-postgresql.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mysql.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-builtin_db.authentication"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "jwt": {
                    "summary": "JWT authentication",
                    "value": {
                      "algorithm": "hmac-based",
                      "mechanism": "jwt",
                      "secret": "mysecret",
                      "secret_base64_encoded": false,
                      "use_jwks": false,
                      "verify_claims": {
                        "username": "${username}"
                      }
                    }
                  },
                  "password_based:built_in_database": {
                    "summary": "Built-in password_based authentication",
                    "value": {
                      "backend": "built_in_database",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "user_id_type": "username"
                    }
                  },
                  "password_based:http": {
                    "summary": "password_based authentication through external HTTP API",
                    "value": {
                      "backend": "http",
                      "body": {
                        "password": "${password}",
                        "username": "${username}"
                      },
                      "connect_timeout": 5000,
                      "enable_pipelining": 100,
                      "headers": {
                        "content-type": "application/json"
                      },
                      "mechanism": "password_based",
                      "method": "post",
                      "pool_size": 8,
                      "request_timeout": 5000,
                      "ssl": {
                        "enable": false
                      },
                      "url": "http://127.0.0.1:18083"
                    }
                  },
                  "password_based:mongodb": {
                    "summary": "password_based authentication with MongoDB backend",
                    "value": {
                      "backend": "mongodb",
                      "collection": "users",
                      "database": "example",
                      "filter": {
                        "username": "${username}"
                      },
                      "is_superuser_field": "is_superuser",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "password_hash_field": "password_hash",
                      "salt_field": "salt",
                      "server": "127.0.0.1:27017"
                    }
                  },
                  "password_based:redis": {
                    "summary": "password_based authentication with Redis backend",
                    "value": {
                      "backend": "redis",
                      "cmd": "HMGET ${username} password_hash salt",
                      "database": 0,
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "redis_type": "single",
                      "server": "127.0.0.1:6379"
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.jwks"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.public-key"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.hmac-based"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.post"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.get"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.replica-set"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-postgresql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mysql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-builtin_db.authentication"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "409": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "ALREADY_EXISTS"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "ALREADY_EXISTS",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Listener Authentication"
        ]
      }
    },
    "/api_key/{name}": {
      "delete": {
        "description": "Delete the specific api_key",
        "parameters": [
          {
            "$ref": "#/components/parameters/api_key.name"
          }
        ],
        "responses": {
          "204": {
            "description": "Delete successfully"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "API Keys"
        ]
      },
      "get": {
        "description": "Return the specific api_key",
        "parameters": [
          {
            "$ref": "#/components/parameters/api_key.name"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "name": {
                      "description": "Unique and format by [a-zA-Z0-9-_]",
                      "example": "EMQX-API-KEY-1",
                      "type": "string"
                    },
                    "api_key": {
                      "description": "TODO:uses HMAC-SHA256 for signing.",
                      "example": "a4697a5c75a769f6",
                      "type": "string"
                    },
                    "expired_at": {
                      "default": "infinity",
                      "description": "No longer valid datetime",
                      "example": "2021-12-05T02:01:34.186Z",
                      "oneOf": [
                        {
                          "oneOf": [
                            {
                              "description": "epoch-second",
                              "example": 1640995200,
                              "type": "integer"
                            },
                            {
                              "example": "2022-01-01T00:00:00.000Z",
                              "format": "date-time",
                              "type": "string"
                            }
                          ]
                        },
                        {
                          "enum": [
                            "infinity"
                          ],
                          "type": "string"
                        }
                      ]
                    },
                    "created_at": {
                      "description": "ApiKey create datetime",
                      "example": "2021-12-01T00:00:00.000Z",
                      "oneOf": [
                        {
                          "description": "epoch-second",
                          "example": 1640995200,
                          "type": "integer"
                        },
                        {
                          "example": "2022-01-01T00:00:00.000Z",
                          "format": "date-time",
                          "type": "string"
                        }
                      ]
                    },
                    "desc": {
                      "example": "Note",
                      "type": "string"
                    },
                    "enable": {
                      "description": "Enable/Disable",
                      "type": "boolean"
                    },
                    "expired": {
                      "description": "Expired",
                      "type": "boolean"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "API Keys"
        ]
      },
      "put": {
        "description": "Update the specific api_key",
        "parameters": [
          {
            "$ref": "#/components/parameters/api_key.name"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "expired_at": {
                    "default": "infinity",
                    "description": "No longer valid datetime",
                    "example": "2021-12-05T02:01:34.186Z",
                    "oneOf": [
                      {
                        "oneOf": [
                          {
                            "description": "epoch-second",
                            "example": 1640995200,
                            "type": "integer"
                          },
                          {
                            "example": "2022-01-01T00:00:00.000Z",
                            "format": "date-time",
                            "type": "string"
                          }
                        ]
                      },
                      {
                        "enum": [
                          "infinity"
                        ],
                        "type": "string"
                      }
                    ]
                  },
                  "desc": {
                    "example": "Note",
                    "type": "string"
                  },
                  "enable": {
                    "description": "Enable/Disable",
                    "type": "boolean"
                  },
                  "expired": {
                    "description": "Expired",
                    "type": "boolean"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "name": {
                      "description": "Unique and format by [a-zA-Z0-9-_]",
                      "example": "EMQX-API-KEY-1",
                      "type": "string"
                    },
                    "api_key": {
                      "description": "TODO:uses HMAC-SHA256 for signing.",
                      "example": "a4697a5c75a769f6",
                      "type": "string"
                    },
                    "expired_at": {
                      "default": "infinity",
                      "description": "No longer valid datetime",
                      "example": "2021-12-05T02:01:34.186Z",
                      "oneOf": [
                        {
                          "oneOf": [
                            {
                              "description": "epoch-second",
                              "example": 1640995200,
                              "type": "integer"
                            },
                            {
                              "example": "2022-01-01T00:00:00.000Z",
                              "format": "date-time",
                              "type": "string"
                            }
                          ]
                        },
                        {
                          "enum": [
                            "infinity"
                          ],
                          "type": "string"
                        }
                      ]
                    },
                    "created_at": {
                      "description": "ApiKey create datetime",
                      "example": "2021-12-01T00:00:00.000Z",
                      "oneOf": [
                        {
                          "description": "epoch-second",
                          "example": 1640995200,
                          "type": "integer"
                        },
                        {
                          "example": "2022-01-01T00:00:00.000Z",
                          "format": "date-time",
                          "type": "string"
                        }
                      ]
                    },
                    "desc": {
                      "example": "Note",
                      "type": "string"
                    },
                    "enable": {
                      "description": "Enable/Disable",
                      "type": "boolean"
                    },
                    "expired": {
                      "description": "Expired",
                      "type": "boolean"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "API Keys"
        ]
      }
    },
    "/clients/{clientid}/subscriptions": {
      "get": {
        "description": "Get client subscriptions",
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/emqx_mgmt_api_subscriptions.subscription"
                  },
                  "type": "array"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "CLIENTID_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Client ID not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Clients"
        ]
      }
    },
    "/configs": {
      "get": {
        "description": "Get all the configurations of the specified node, including hot and non-hot updatable items.",
        "parameters": [
          {
            "description": "Node's name: If you do not fill in the fields, this node will be used by default.",
            "example": "emqx@127.0.0.1",
            "in": "query",
            "name": "node",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "zones": {
                      "description": "A zone is a set of configs grouped by the zone <code>name</code>.<br/>For flexible configuration mapping, the <code>name</code> can be set to a listener's <code>zone</code> config.<br/>NOTE: A built-in zone named <code>default</code> is auto created and can not be deleted.",
                      "properties": {
                        "$name": {
                          "$ref": "#/components/schemas/broker.zone"
                        }
                      },
                      "type": "object"
                    },
                    "log": {
                      "$ref": "#/components/schemas/emqx_conf_schema.log"
                    },
                    "limiter": {
                      "description": "Settings for the rate limiter.",
                      "$ref": "#/components/schemas/limiter.limiter"
                    },
                    "sysmon": {
                      "$ref": "#/components/schemas/broker.sysmon"
                    },
                    "sys_topics": {
                      "description": "System topics configuration.",
                      "$ref": "#/components/schemas/broker.sys_topics"
                    },
                    "alarm": {
                      "$ref": "#/components/schemas/broker.alarm"
                    },
                    "dashboard": {
                      "description": "Configuration for EMQX dashboard.",
                      "summary": "Dashboard",
                      "$ref": "#/components/schemas/dashboard.dashboard"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "500": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_NODE"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Configs"
        ]
      }
    },
    "/clients": {
      "get": {
        "description": "List clients",
        "parameters": [
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          },
          {
            "description": "Node name",
            "example": "emqx@127.0.0.1",
            "in": "query",
            "name": "node",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "User name",
            "in": "query",
            "name": "username",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "zone",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Client's IP address",
            "example": "127.0.0.1",
            "in": "query",
            "name": "ip_address",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The current connection status of the client, the possible values are connected,idle,disconnected",
            "in": "query",
            "name": "conn_state",
            "required": false,
            "schema": {
              "enum": [
                "connected",
                "idle",
                "disconnected"
              ],
              "type": "string"
            }
          },
          {
            "description": "Whether the client uses a new session",
            "in": "query",
            "name": "clean_start",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Client protocol version",
            "in": "query",
            "name": "proto_ver",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Fuzzy search `clientid` as substring",
            "in": "query",
            "name": "like_clientid",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Fuzzy search `username` as substring",
            "in": "query",
            "name": "like_username",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Search client session creation time by greater than or equal method, rfc3339 or timestamp(millisecond)",
            "in": "query",
            "name": "gte_created_at",
            "required": false,
            "schema": {
              "oneOf": [
                {
                  "description": "epoch-millisecond",
                  "example": 1640995200000,
                  "type": "integer"
                },
                {
                  "example": "2022-01-01T00:00:00.000Z",
                  "format": "date-time",
                  "type": "string"
                }
              ]
            }
          },
          {
            "description": "Search client session creation time by less than or equal method, rfc3339 or timestamp(millisecond)",
            "in": "query",
            "name": "lte_created_at",
            "required": false,
            "schema": {
              "oneOf": [
                {
                  "description": "epoch-millisecond",
                  "example": 1640995200000,
                  "type": "integer"
                },
                {
                  "example": "2022-01-01T00:00:00.000Z",
                  "format": "date-time",
                  "type": "string"
                }
              ]
            }
          },
          {
            "description": "Search client connection creation time by greater than or equal method, rfc3339 or timestamp(epoch millisecond)",
            "in": "query",
            "name": "gte_connected_at",
            "required": false,
            "schema": {
              "oneOf": [
                {
                  "description": "epoch-millisecond",
                  "example": 1640995200000,
                  "type": "integer"
                },
                {
                  "example": "2022-01-01T00:00:00.000Z",
                  "format": "date-time",
                  "type": "string"
                }
              ]
            }
          },
          {
            "description": "Search client connection creation time by less than or equal method, rfc3339 or timestamp(millisecond)",
            "in": "query",
            "name": "lte_connected_at",
            "required": false,
            "schema": {
              "oneOf": [
                {
                  "description": "epoch-millisecond",
                  "example": 1640995200000,
                  "type": "integer"
                },
                {
                  "example": "2022-01-01T00:00:00.000Z",
                  "format": "date-time",
                  "type": "string"
                }
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "data": {
                      "items": {
                        "$ref": "#/components/schemas/emqx_mgmt_api_clients.client"
                      },
                      "type": "array"
                    },
                    "meta": {
                      "$ref": "#/components/schemas/public.meta"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "INVALID_PARAMETER"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Invalid parameters",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Clients"
        ]
      }
    },
    "/gateways/{name}/authentication/users": {
      "get": {
        "description": "Get the users for the authenticator (only supported by <code>built_in_database</code>).",
        "parameters": [
          {
            "description": "Gateway Name.<br/><br/>It's enum with `stomp`, `mqttsn`, `coap`, `lwm2m`, `exproto`",
            "example": "stomp",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Page number of the results to fetch.",
            "example": 1,
            "in": "query",
            "name": "page",
            "schema": {
              "default": 1,
              "minimum": 1,
              "type": "integer"
            }
          },
          {
            "description": "Results per page(max 1000)",
            "example": 50,
            "in": "query",
            "name": "limit",
            "schema": {
              "default": 100,
              "maximum": 1000,
              "minimum": 1,
              "type": "integer"
            }
          },
          {
            "description": "Fuzzy search using user ID (username or clientid), only supports search by substring.",
            "example": "test_",
            "in": "query",
            "name": "like_user_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Is superuser",
            "in": "query",
            "name": "is_superuser",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "data": [
                    {
                      "user_id": "user1"
                    },
                    {
                      "is_superuser": true,
                      "user_id": "user2"
                    }
                  ],
                  "meta": {
                    "count": 300,
                    "limit": 20,
                    "page": 0
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_users"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "List users for gateway authenticator",
        "tags": [
          "Gateway Authentication"
        ]
      },
      "post": {
        "description": "Add user for the authenticator (only supports built_in_database).",
        "parameters": [
          {
            "description": "Gateway Name.<br/><br/>It's enum with `stomp`, `mqttsn`, `coap`, `lwm2m`, `exproto`",
            "example": "stomp",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "regular_user": {
                  "summary": "Regular user",
                  "value": {
                    "password": "******",
                    "user_id": "user1"
                  }
                },
                "super_user": {
                  "summary": "Superuser",
                  "value": {
                    "is_superuser": true,
                    "password": "******",
                    "user_id": "user2"
                  }
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authn_api.request_user_create"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "regular_user": {
                    "summary": "Regular user",
                    "value": {
                      "user_id": "user1"
                    }
                  },
                  "super_user": {
                    "summary": "Superuser",
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Add user for gateway authenticator",
        "tags": [
          "Gateway Authentication"
        ]
      }
    },
    "/users/{username}/change_pwd": {
      "post": {
        "description": "Change dashboard user password",
        "parameters": [
          {
            "description": "Dashboard Username",
            "example": "admin",
            "in": "path",
            "name": "username",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "old_pwd": {
                    "description": "Old password",
                    "type": "string"
                  },
                  "new_pwd": {
                    "description": "New password",
                    "type": "string"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Update user password successfully"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST",
                        "ERROR_PWD_NOT_MATCH"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Login failed. Bad username or password",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "USER_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Dashboard user not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Dashboard"
        ]
      }
    },
    "/gateways/{name}/clients": {
      "get": {
        "description": "Get the gateway client list",
        "parameters": [
          {
            "description": "Gateway Name",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Match the client's node name",
            "example": "",
            "in": "query",
            "name": "node",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Match the client's ID",
            "example": "",
            "in": "query",
            "name": "clientid",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Match the client's Username",
            "example": "",
            "in": "query",
            "name": "username",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Match the client's ip address",
            "example": "",
            "in": "query",
            "name": "ip_address",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Match the client's connection state",
            "example": "",
            "in": "query",
            "name": "conn_state",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Match the client's protocol version",
            "example": "",
            "in": "query",
            "name": "proto_ver",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Match the client's clean start flag",
            "example": "",
            "in": "query",
            "name": "clean_start",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Use sub-string to match client's ID",
            "example": "",
            "in": "query",
            "name": "like_clientid",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Use sub-string to match client's username",
            "example": "",
            "in": "query",
            "name": "like_username",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Match the session created datetime greater than a certain value",
            "example": "",
            "in": "query",
            "name": "gte_created_at",
            "required": false,
            "schema": {
              "oneOf": [
                {
                  "description": "epoch-millisecond",
                  "example": 1640995200000,
                  "type": "integer"
                },
                {
                  "example": "2022-01-01T00:00:00.000Z",
                  "format": "date-time",
                  "type": "string"
                }
              ]
            }
          },
          {
            "description": "Match the session created datetime less than a certain value",
            "example": "",
            "in": "query",
            "name": "lte_created_at",
            "required": false,
            "schema": {
              "oneOf": [
                {
                  "description": "epoch-millisecond",
                  "example": 1640995200000,
                  "type": "integer"
                },
                {
                  "example": "2022-01-01T00:00:00.000Z",
                  "format": "date-time",
                  "type": "string"
                }
              ]
            }
          },
          {
            "description": "Match the client socket connected datetime greater than a certain value",
            "example": "",
            "in": "query",
            "name": "gte_connected_at",
            "required": false,
            "schema": {
              "oneOf": [
                {
                  "description": "epoch-millisecond",
                  "example": 1640995200000,
                  "type": "integer"
                },
                {
                  "example": "2022-01-01T00:00:00.000Z",
                  "format": "date-time",
                  "type": "string"
                }
              ]
            }
          },
          {
            "description": "Match the client socket connected datatime less than a certain value",
            "example": "",
            "in": "query",
            "name": "lte_connected_at",
            "required": false,
            "schema": {
              "oneOf": [
                {
                  "description": "epoch-millisecond",
                  "example": 1640995200000,
                  "type": "integer"
                },
                {
                  "example": "2022-01-01T00:00:00.000Z",
                  "format": "date-time",
                  "type": "string"
                }
              ]
            }
          },
          {
            "description": "Match the lwm2m client's endpoint name",
            "example": "",
            "in": "query",
            "name": "endpoint_name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Use sub-string to match lwm2m client's endpoint name",
            "example": "",
            "in": "query",
            "name": "like_endpoint_name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Match the lwm2m client registered lifetime greater than a certain value",
            "example": "",
            "in": "query",
            "name": "gte_lifetime",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Match the lwm2m client registered lifetime less than a certain value",
            "example": "",
            "in": "query",
            "name": "lte_lifetime",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Page number of the results to fetch.",
            "example": 1,
            "in": "query",
            "name": "page",
            "schema": {
              "default": 1,
              "minimum": 1,
              "type": "integer"
            }
          },
          {
            "description": "Results per page(max 1000)",
            "example": 50,
            "in": "query",
            "name": "limit",
            "schema": {
              "default": 100,
              "maximum": 1000,
              "minimum": 1,
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "data": {
                      "oneOf": [
                        {
                          "items": {
                            "$ref": "#/components/schemas/emqx_gateway_api_clients.exproto_client"
                          },
                          "type": "array"
                        },
                        {
                          "items": {
                            "$ref": "#/components/schemas/emqx_gateway_api_clients.lwm2m_client"
                          },
                          "type": "array"
                        },
                        {
                          "items": {
                            "$ref": "#/components/schemas/emqx_gateway_api_clients.coap_client"
                          },
                          "type": "array"
                        },
                        {
                          "items": {
                            "$ref": "#/components/schemas/emqx_gateway_api_clients.mqttsn_client"
                          },
                          "type": "array"
                        },
                        {
                          "items": {
                            "$ref": "#/components/schemas/emqx_gateway_api_clients.stomp_client"
                          },
                          "type": "array"
                        }
                      ]
                    },
                    "meta": {
                      "$ref": "#/components/schemas/public.meta"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "List gateway's clients",
        "tags": [
          "Gateway Clients"
        ]
      }
    },
    "/gateways/{name}/authentication/users/{uid}": {
      "delete": {
        "description": "Delete the user for the gateway authenticator (only supports built_in_database)",
        "parameters": [
          {
            "description": "Gateway Name.<br/><br/>It's enum with `stomp`, `mqttsn`, `coap`, `lwm2m`, `exproto`",
            "example": "stomp",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "User ID",
            "example": "test_username",
            "in": "path",
            "name": "uid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "User Deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Delete user for gateway authenticator",
        "tags": [
          "Gateway Authentication"
        ]
      },
      "get": {
        "description": "Get user info from the gateway authenticator (only supports built_in_database)",
        "parameters": [
          {
            "description": "Gateway Name.<br/><br/>It's enum with `stomp`, `mqttsn`, `coap`, `lwm2m`, `exproto`",
            "example": "stomp",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "User ID",
            "example": "test_username",
            "in": "path",
            "name": "uid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "regular_user": {
                    "summary": "Regular user",
                    "value": {
                      "user_id": "user1"
                    }
                  },
                  "super_user": {
                    "summary": "Superuser",
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Get user info for gateway authenticator",
        "tags": [
          "Gateway Authentication"
        ]
      },
      "put": {
        "description": "Update the user info for the gateway authenticator (only supports built_in_database)",
        "parameters": [
          {
            "description": "Gateway Name.<br/><br/>It's enum with `stomp`, `mqttsn`, `coap`, `lwm2m`, `exproto`",
            "example": "stomp",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "User ID",
            "example": "test_username",
            "in": "path",
            "name": "uid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "regular_user": {
                  "summary": "Update regular user",
                  "value": {
                    "password": "******"
                  }
                },
                "super_user": {
                  "summary": "Update user and promote to superuser",
                  "value": {
                    "is_superuser": true,
                    "password": "******"
                  }
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authn_api.request_user_update"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "regular_user": {
                    "summary": "Regular user",
                    "value": {
                      "user_id": "user1"
                    }
                  },
                  "super_user": {
                    "summary": "Superuser",
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Update user info for gateway authenticator",
        "tags": [
          "Gateway Authentication"
        ]
      }
    },
    "/gateways/{name}/listeners/{id}/authentication/import_users": {
      "post": {
        "description": "Import users into the gateway authenticator (only supports built_in_database)",
        "parameters": [
          {
            "description": "Gateway Name.<br/><br/>It's enum with `stomp`, `mqttsn`, `coap`, `lwm2m`, `exproto`",
            "example": "stomp",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Listener ID",
            "example": "stomp:tcp:def",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "multipart/form-data": {
              "schema": {
                "properties": {
                  "filename": {
                    "format": "binary",
                    "type": "string"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Imported"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Import users",
        "tags": [
          "Gateway Authentication"
        ]
      }
    },
    "/rules/{id}/metrics/reset": {
      "put": {
        "description": "Reset a rule metrics",
        "parameters": [
          {
            "example": "my_rule_id",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Reset Success"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Rule not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Reset Rule Metrics",
        "tags": [
          "Rules"
        ]
      }
    },
    "/gateways/{name}/listeners/{id}/authentication/users": {
      "get": {
        "description": "Get the users for the authenticator (only supported by <code>built_in_database</code>)",
        "parameters": [
          {
            "description": "Gateway Name.<br/><br/>It's enum with `stomp`, `mqttsn`, `coap`, `lwm2m`, `exproto`",
            "example": "stomp",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Listener ID",
            "example": "",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Page number of the results to fetch.",
            "example": 1,
            "in": "query",
            "name": "page",
            "schema": {
              "default": 1,
              "minimum": 1,
              "type": "integer"
            }
          },
          {
            "description": "Results per page(max 1000)",
            "example": 50,
            "in": "query",
            "name": "limit",
            "schema": {
              "default": 100,
              "maximum": 1000,
              "minimum": 1,
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "regular_user": {
                    "summary": "Regular user",
                    "value": {
                      "user_id": "user1"
                    }
                  },
                  "super_user": {
                    "summary": "Superuser",
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "List authenticator's users",
        "tags": [
          "Gateway Listeners"
        ]
      },
      "post": {
        "description": "Add user for the authenticator (only supports built_in_database)",
        "parameters": [
          {
            "description": "Gateway Name.<br/><br/>It's enum with `stomp`, `mqttsn`, `coap`, `lwm2m`, `exproto`",
            "example": "stomp",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Listener ID",
            "example": "",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "regular_user": {
                  "summary": "Regular user",
                  "value": {
                    "password": "******",
                    "user_id": "user1"
                  }
                },
                "super_user": {
                  "summary": "Superuser",
                  "value": {
                    "is_superuser": true,
                    "password": "******",
                    "user_id": "user2"
                  }
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authn_api.request_user_create"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "regular_user": {
                    "summary": "Regular user",
                    "value": {
                      "user_id": "user1"
                    }
                  },
                  "super_user": {
                    "summary": "Superuser",
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Add user for an authenticator",
        "tags": [
          "Gateway Listeners"
        ]
      }
    },
    "/license": {
      "get": {
        "description": "Get license info",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "sample_license_info": {
                    "value": {
                      "customer": "Foo",
                      "customer_type": 10,
                      "deployment": "bar-deployment",
                      "email": "contact@foo.com",
                      "expiry": false,
                      "expiry_at": "2295-10-27",
                      "max_connections": 10,
                      "start_at": "2022-01-11",
                      "type": "trial"
                    }
                  }
                },
                "schema": {
                  "example": {},
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "License info",
        "tags": [
          "License"
        ]
      },
      "post": {
        "description": "Update a license key",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "license_key": {
                  "summary": "License key string",
                  "value": {
                    "connection_high_watermark": "80%",
                    "connection_low_watermark": "75%",
                    "key": "xxx"
                  }
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_license_schema.key_license"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "sample_license_info": {
                    "value": {
                      "customer": "Foo",
                      "customer_type": 10,
                      "deployment": "bar-deployment",
                      "email": "contact@foo.com",
                      "expiry": false,
                      "expiry_at": "2295-10-27",
                      "max_connections": 10,
                      "start_at": "2022-01-11",
                      "type": "trial"
                    }
                  }
                },
                "schema": {
                  "example": {},
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad license key",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Update license",
        "tags": [
          "License"
        ]
      }
    },
    "/authorization/settings": {
      "get": {
        "description": "Get authorization settings",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "deny_action",
                    "no_match"
                  ],
                  "properties": {
                    "no_match": {
                      "default": "allow",
                      "description": "Default access control action if the user or client matches no ACL rules,<br/>or if no such user or client is found by the configurable authorization<br/>sources such as built_in_database, an HTTP API, or a query against PostgreSQL.<br/>Find more details in 'authorization.sources' config.",
                      "enum": [
                        "allow",
                        "deny"
                      ],
                      "summary": "Authorization no match",
                      "type": "string"
                    },
                    "deny_action": {
                      "default": "ignore",
                      "description": "The action when the authorization check rejects an operation.",
                      "enum": [
                        "ignore",
                        "disconnect"
                      ],
                      "summary": "Authorization deny action",
                      "type": "string"
                    },
                    "cache": {
                      "$ref": "#/components/schemas/broker.authz_cache"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Authorization"
        ]
      },
      "put": {
        "description": "Update authorization settings",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "required": [
                  "deny_action",
                  "no_match"
                ],
                "properties": {
                  "no_match": {
                    "default": "allow",
                    "description": "Default access control action if the user or client matches no ACL rules,<br/>or if no such user or client is found by the configurable authorization<br/>sources such as built_in_database, an HTTP API, or a query against PostgreSQL.<br/>Find more details in 'authorization.sources' config.",
                    "enum": [
                      "allow",
                      "deny"
                    ],
                    "summary": "Authorization no match",
                    "type": "string"
                  },
                  "deny_action": {
                    "default": "ignore",
                    "description": "The action when the authorization check rejects an operation.",
                    "enum": [
                      "ignore",
                      "disconnect"
                    ],
                    "summary": "Authorization deny action",
                    "type": "string"
                  },
                  "cache": {
                    "$ref": "#/components/schemas/broker.authz_cache"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "deny_action",
                    "no_match"
                  ],
                  "properties": {
                    "no_match": {
                      "default": "allow",
                      "description": "Default access control action if the user or client matches no ACL rules,<br/>or if no such user or client is found by the configurable authorization<br/>sources such as built_in_database, an HTTP API, or a query against PostgreSQL.<br/>Find more details in 'authorization.sources' config.",
                      "enum": [
                        "allow",
                        "deny"
                      ],
                      "summary": "Authorization no match",
                      "type": "string"
                    },
                    "deny_action": {
                      "default": "ignore",
                      "description": "The action when the authorization check rejects an operation.",
                      "enum": [
                        "ignore",
                        "disconnect"
                      ],
                      "summary": "Authorization deny action",
                      "type": "string"
                    },
                    "cache": {
                      "$ref": "#/components/schemas/broker.authz_cache"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Authorization"
        ]
      }
    },
    "/gateways/lwm2m/clients/{clientid}/write": {
      "post": {
        "description": "Send a write command to a resource",
        "parameters": [
          {
            "example": "urn:oma:lwm2m:oma:2",
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "example": "/3/0/7",
            "in": "query",
            "name": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "example": "Integer",
            "in": "query",
            "name": "type",
            "required": true,
            "schema": {
              "enum": [
                "Integer",
                "Float",
                "Time",
                "String",
                "Boolean",
                "Opaque",
                "Objlnk"
              ],
              "type": "string"
            }
          },
          {
            "example": 123,
            "in": "query",
            "name": "value",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "CLIENT_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Clientid not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Write a Value to Resource Path",
        "tags": [
          "LwM2M Gateways"
        ]
      }
    },
    "/configs/log": {
      "get": {
        "description": "Get the sub-configurations under *log*",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_conf_schema.log"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "config not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Configs"
        ]
      },
      "put": {
        "description": "Update the sub-configurations under *log*",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx_conf_schema.log"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_conf_schema.log"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "UPDATE_FAILED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "403": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "UPDATE_FAILED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Configs"
        ]
      }
    },
    "/rules/{id}": {
      "delete": {
        "description": "Delete a rule by given Id from all nodes in the cluster",
        "parameters": [
          {
            "example": "my_rule_id",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Delete rule successfully"
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Delete Cluster Rule",
        "tags": [
          "Rules"
        ]
      },
      "get": {
        "description": "Get a rule by given Id",
        "parameters": [
          {
            "example": "my_rule_id",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_rule_api_schema.rule_info"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Rule not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Get Rule",
        "tags": [
          "Rules"
        ]
      },
      "put": {
        "description": "Update a rule by given Id to all nodes in the cluster",
        "parameters": [
          {
            "example": "my_rule_id",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx_rule_api_schema.rule_creation"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_rule_api_schema.rule_info"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Invalid Parameters",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Update Cluster Rule",
        "tags": [
          "Rules"
        ]
      }
    },
    "/exhooks/{name}/hooks": {
      "get": {
        "description": "Get the hooks information of server",
        "parameters": [
          {
            "description": "The Exhook server name",
            "example": "default",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/exhook.list_hook_info"
                  },
                  "type": "array"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "ExHook"
        ]
      }
    },
    "/bridges": {
      "get": {
        "description": "List all created bridges",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": [
                  {
                    "cql": "insert into mqtt_msg(topic, msgid, sender, qos, payload, arrived, retain) values (${topic}, ${id}, ${clientid}, ${qos}, ${payload}, ${timestamp}, ${flags.retain})",
                    "enable": true,
                    "keyspace": "mqtt",
                    "local_topic": "local/topic/#",
                    "name": "foo",
                    "password": "******",
                    "pool_size": 8,
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "sync",
                      "worker_pool_size": 8
                    },
                    "servers": "127.0.0.1:9042",
                    "type": "cassandra",
                    "username": "root"
                  },
                  {
                    "batch_value_separator": ", ",
                    "database": "mqtt",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "foo",
                    "password": "******",
                    "pool_size": 8,
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "async",
                      "worker_pool_size": 8
                    },
                    "server": "127.0.0.1:8123",
                    "sql": "INSERT INTO mqtt_test(payload, arrived) VALUES ('${payload}', ${timestamp})",
                    "type": "clickhouse",
                    "username": "default"
                  },
                  {
                    "aws_access_key_id": "root",
                    "aws_secret_access_key": "******",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "foo",
                    "pool_size": 8,
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "sync",
                      "worker_pool_size": 8
                    },
                    "table": "mqtt",
                    "template": "",
                    "type": "dynamo",
                    "url": "http://127.0.0.1:8000"
                  },
                  {
                    "pubsub_topic": "mytopic",
                    "service_account_json": {
                      "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                      "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                      "client_email": "test@myproject.iam.gserviceaccount.com",
                      "client_id": "123812831923812319190",
                      "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/test%40myproject.iam.gserviceaccount.com",
                      "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQI...",
                      "private_key_id": "kid",
                      "project_id": "myproject",
                      "token_uri": "https://oauth2.googleapis.com/token",
                      "type": "service_account"
                    }
                  },
                  {
                    "connector": "hstreamdb:connector",
                    "direction": "egress",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "demo",
                    "payload": "${payload}",
                    "type": "hstreamdb"
                  },
                  {
                    "database": "example_database",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "demo",
                    "password": "******",
                    "precision": "ms",
                    "resource_opts": {
                      "batch_size": 100,
                      "batch_time": "20ms"
                    },
                    "server": "127.0.0.1:8086",
                    "ssl": {
                      "enable": false
                    },
                    "type": "influxdb_api_v1",
                    "username": "example_username",
                    "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,bool=${payload.bool}"
                  },
                  {
                    "bucket": "example_bucket",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "demo",
                    "org": "examlpe_org",
                    "precision": "ms",
                    "resource_opts": {
                      "batch_size": 100,
                      "batch_time": "20ms"
                    },
                    "server": "127.0.0.1:8086",
                    "ssl": {
                      "enable": false
                    },
                    "token": "example_token",
                    "type": "influxdb_api_v2",
                    "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,uint_value=${payload.uint_key}u,bool=${payload.bool}"
                  },
                  {
                    "authentication": {
                      "mechanism": "plain",
                      "password": "******",
                      "username": "username"
                    },
                    "bootstrap_hosts": "localhost:9092",
                    "connect_timeout": "5s",
                    "enable": true,
                    "kafka": {
                      "buffer": {
                        "memory_overload_protection": true,
                        "mode": "hybrid",
                        "per_partition_limit": "2GB",
                        "segment_bytes": "100MB"
                      },
                      "compression": "no_compression",
                      "max_batch_bytes": "896KB",
                      "max_inflight": 10,
                      "message": {
                        "key": "${.clientid}",
                        "timestamp": "${.timestamp}",
                        "value": "${.}"
                      },
                      "partition_count_refresh_interval": "60s",
                      "partition_strategy": "random",
                      "required_acks": "all_isr",
                      "topic": "kafka-topic"
                    },
                    "local_topic": "mqtt/local/topic",
                    "metadata_request_timeout": "4s",
                    "min_metadata_refresh_interval": "3s",
                    "socket_opts": {
                      "nodelay": true,
                      "recbuf": "1024KB",
                      "sndbuf": "1024KB"
                    }
                  },
                  {
                    "authentication": {
                      "mechanism": "plain",
                      "password": "******",
                      "username": "username"
                    },
                    "bootstrap_hosts": "localhost:9092",
                    "connect_timeout": "5s",
                    "enable": true,
                    "kafka": {
                      "max_batch_bytes": "896KB",
                      "offset_commit_interval_seconds": 5,
                      "offset_reset_policy": "latest"
                    },
                    "key_encoding_mode": "none",
                    "metadata_request_timeout": "4s",
                    "min_metadata_refresh_interval": "3s",
                    "socket_opts": {
                      "nodelay": true,
                      "recbuf": "1024KB",
                      "sndbuf": "1024KB"
                    },
                    "topic_mapping": [
                      {
                        "kafka_topic": "kafka-topic-1",
                        "mqtt_topic": "mqtt/topic/1",
                        "payload_template": "${.}",
                        "qos": 1
                      },
                      {
                        "kafka_topic": "kafka-topic-2",
                        "mqtt_topic": "mqtt/topic/2",
                        "payload_template": "v = ${.value}",
                        "qos": 2
                      }
                    ],
                    "value_encoding_mode": "none"
                  },
                  {
                    "database": "mqtt",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "foo",
                    "password": "******",
                    "pool_size": 8,
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "async",
                      "worker_pool_size": 8
                    },
                    "server": "127.0.0.1:5432",
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                    "type": "matrix",
                    "username": "root"
                  },
                  {
                    "collection": "mycol",
                    "database": "mqtt",
                    "enable": true,
                    "mongo_type": "rs",
                    "name": "mongodb_rs_demo",
                    "password": "******",
                    "pool_size": 8,
                    "r_mode": "safe",
                    "replica_set_name": "rs",
                    "servers": "localhost:27017, localhost:27018",
                    "srv_record": false,
                    "type": "mongodb_rs",
                    "username": "myuser",
                    "w_mode": "safe"
                  },
                  {
                    "collection": "mycol",
                    "database": "mqtt",
                    "enable": true,
                    "mongo_type": "sharded",
                    "name": "mongodb_sharded_demo",
                    "password": "******",
                    "pool_size": 8,
                    "servers": "localhost:27017, localhost:27018",
                    "srv_record": false,
                    "type": "mongodb_sharded",
                    "username": "myuser",
                    "w_mode": "safe"
                  },
                  {
                    "collection": "mycol",
                    "database": "mqtt",
                    "enable": true,
                    "mongo_type": "single",
                    "name": "mongodb_single_demo",
                    "password": "******",
                    "pool_size": 8,
                    "server": "localhost:27017",
                    "srv_record": false,
                    "type": "mongodb_single",
                    "username": "myuser",
                    "w_mode": "safe"
                  },
                  {
                    "clean_start": true,
                    "egress": {
                      "local": {
                        "topic": "emqx/#"
                      },
                      "remote": {
                        "payload": "${payload}",
                        "qos": "${qos}",
                        "retain": false,
                        "topic": "from_emqx/${topic}"
                      }
                    },
                    "enable": true,
                    "ingress": {
                      "local": {
                        "payload": "${payload}",
                        "qos": "${qos}",
                        "retain": "${retain}",
                        "topic": "from_aws/${topic}"
                      },
                      "remote": {
                        "qos": 1,
                        "topic": "aws/#"
                      }
                    },
                    "keepalive": "300s",
                    "max_inflight": 100,
                    "mode": "cluster_shareload",
                    "name": "mqtt_example",
                    "password": "******",
                    "proto_ver": "v4",
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 104857600,
                      "query_mode": "sync"
                    },
                    "retry_interval": "15s",
                    "server": "127.0.0.1:1883",
                    "ssl": {
                      "enable": false
                    },
                    "type": "mqtt",
                    "username": "foo"
                  },
                  {
                    "database": "test",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "foo",
                    "password": "******",
                    "pool_size": 8,
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "async",
                      "worker_pool_size": 1
                    },
                    "server": "127.0.0.1:3306",
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, FROM_UNIXTIME(${timestamp}/1000))",
                    "type": "mysql",
                    "username": "root"
                  },
                  {
                    "database": "mqtt",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "foo",
                    "password": "******",
                    "pool_size": 8,
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "async",
                      "worker_pool_size": 8
                    },
                    "server": "127.0.0.1:5432",
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                    "type": "pgsql",
                    "username": "root"
                  },
                  {
                    "command_template": [
                      "LPUSH",
                      "MSGS",
                      "${payload}"
                    ],
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "redis_bridge",
                    "password": "******",
                    "pool_size": 8,
                    "redis_type": "cluster",
                    "resource_opts": {},
                    "servers": [
                      "127.0.0.1:6379"
                    ],
                    "ssl": {
                      "enable": false
                    },
                    "type": "redis_cluster"
                  },
                  {
                    "command_template": [
                      "LPUSH",
                      "MSGS",
                      "${payload}"
                    ],
                    "database": 1,
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "redis_bridge",
                    "password": "******",
                    "pool_size": 8,
                    "redis_type": "sentinel",
                    "resource_opts": {
                      "batch_size": 1,
                      "batch_time": "20ms"
                    },
                    "sentinel": "mymaster",
                    "servers": [
                      "127.0.0.1:26379"
                    ],
                    "ssl": {
                      "enable": false
                    },
                    "type": "redis_sentinel"
                  },
                  {
                    "command_template": [
                      "LPUSH",
                      "MSGS",
                      "${payload}"
                    ],
                    "database": 1,
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "redis_bridge",
                    "password": "******",
                    "pool_size": 8,
                    "redis_type": "single",
                    "resource_opts": {
                      "batch_size": 1,
                      "batch_time": "20ms"
                    },
                    "server": "127.0.0.1:6379",
                    "ssl": {
                      "enable": false
                    },
                    "type": "redis_single"
                  },
                  {
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "foo",
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "sync",
                      "worker_pool_size": 1
                    },
                    "server": "127.0.0.1:9876",
                    "template": "",
                    "topic": "TopicTest",
                    "type": "rocketmq"
                  },
                  {
                    "database": "test",
                    "driver": "ms-sql",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "bar",
                    "password": "******",
                    "pool_size": 8,
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "async",
                      "worker_pool_size": 1
                    },
                    "server": "127.0.0.1:1433",
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload) values ( ${id}, ${topic}, ${qos}, ${payload} )",
                    "type": "sqlserver",
                    "username": "sa"
                  },
                  {
                    "database": "mqtt",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "foo",
                    "password": "taosdata",
                    "pool_size": 8,
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "sync",
                      "worker_pool_size": 8
                    },
                    "server": "127.0.0.1:6041",
                    "sql": "insert into t_mqtt_msg(ts, msgid, mqtt_topic, qos, payload, arrived) values (${ts}, ${id}, ${topic}, ${qos}, ${payload}, ${timestamp})",
                    "type": "tdengine",
                    "username": "root"
                  },
                  {
                    "database": "mqtt",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "foo",
                    "password": "******",
                    "pool_size": 8,
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "async",
                      "worker_pool_size": 8
                    },
                    "server": "127.0.0.1:5432",
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                    "type": "timescale",
                    "username": "root"
                  },
                  {
                    "body": "${payload}",
                    "connect_timeout": "15s",
                    "enable": true,
                    "enable_pipelining": 100,
                    "local_topic": "emqx_webhook/#",
                    "max_retries": 3,
                    "method": "post",
                    "name": "webhook_example",
                    "pool_size": 4,
                    "pool_type": "random",
                    "request_timeout": "15s",
                    "resource_opts": {
                      "auto_restart_interval": 15000,
                      "health_check_interval": 15000,
                      "inflight_window": 100,
                      "max_buffer_bytes": 104857600,
                      "query_mode": "async",
                      "worker_pool_size": 1
                    },
                    "ssl": {
                      "enable": false
                    },
                    "type": "webhook",
                    "url": "http://localhost:9901/messages/${topic}"
                  }
                ],
                "schema": {
                  "items": {
                    "oneOf": [
                      {
                        "$ref": "#/components/schemas/bridge_sqlserver.get"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_cassa.get"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_rocketmq.get"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_dynamo.get"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_clickhouse.get"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_tdengine.get"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_matrix.get"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_timescale.get"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_redis.get_cluster"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_redis.get_sentinel"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_redis.get_single"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_influxdb.get_api_v2"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_influxdb.get_api_v1"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_hstreamdb.get"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_mongodb.get_single"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_mongodb.get_sharded"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_mongodb.get_rs"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_pgsql.get"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_mysql.get"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_kafka.get_producer"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_kafka.get_consumer"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_gcp_pubsub.get"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_mqtt.get"
                      },
                      {
                        "$ref": "#/components/schemas/bridge_webhook.get"
                      }
                    ]
                  },
                  "type": "array"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "List All Bridges",
        "tags": [
          "Bridges"
        ]
      },
      "post": {
        "description": "Create a new bridge by type and name",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "cassandra": {
                  "summary": "Cassandra Bridge",
                  "value": {
                    "cql": "insert into mqtt_msg(topic, msgid, sender, qos, payload, arrived, retain) values (${topic}, ${id}, ${clientid}, ${qos}, ${payload}, ${timestamp}, ${flags.retain})",
                    "enable": true,
                    "keyspace": "mqtt",
                    "local_topic": "local/topic/#",
                    "name": "foo",
                    "password": "******",
                    "pool_size": 8,
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "sync",
                      "worker_pool_size": 8
                    },
                    "servers": "127.0.0.1:9042",
                    "type": "cassandra",
                    "username": "root"
                  }
                },
                "clickhouse": {
                  "summary": "Clickhouse Bridge",
                  "value": {
                    "batch_value_separator": ", ",
                    "database": "mqtt",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "foo",
                    "password": "******",
                    "pool_size": 8,
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "async",
                      "worker_pool_size": 8
                    },
                    "server": "127.0.0.1:8123",
                    "sql": "INSERT INTO mqtt_test(payload, arrived) VALUES ('${payload}', ${timestamp})",
                    "type": "clickhouse",
                    "username": "default"
                  }
                },
                "dynamo": {
                  "summary": "DynamoDB Bridge",
                  "value": {
                    "aws_access_key_id": "root",
                    "aws_secret_access_key": "******",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "foo",
                    "pool_size": 8,
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "sync",
                      "worker_pool_size": 8
                    },
                    "table": "mqtt",
                    "template": "",
                    "type": "dynamo",
                    "url": "http://127.0.0.1:8000"
                  }
                },
                "gcp_pubsub": {
                  "summary": "GCP PubSub Bridge",
                  "value": {
                    "pubsub_topic": "mytopic",
                    "service_account_json": {
                      "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                      "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                      "client_email": "test@myproject.iam.gserviceaccount.com",
                      "client_id": "123812831923812319190",
                      "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/test%40myproject.iam.gserviceaccount.com",
                      "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQI...",
                      "private_key_id": "kid",
                      "project_id": "myproject",
                      "token_uri": "https://oauth2.googleapis.com/token",
                      "type": "service_account"
                    }
                  }
                },
                "hstreamdb": {
                  "summary": "HStreamDB Bridge",
                  "value": {
                    "connector": "hstreamdb:connector",
                    "direction": "egress",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "demo",
                    "payload": "${payload}",
                    "type": "hstreamdb"
                  }
                },
                "influxdb_api_v1": {
                  "summary": "InfluxDB HTTP API V1 Bridge",
                  "value": {
                    "database": "example_database",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "demo",
                    "password": "******",
                    "precision": "ms",
                    "resource_opts": {
                      "batch_size": 100,
                      "batch_time": "20ms"
                    },
                    "server": "127.0.0.1:8086",
                    "ssl": {
                      "enable": false
                    },
                    "type": "influxdb_api_v1",
                    "username": "example_username",
                    "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,bool=${payload.bool}"
                  }
                },
                "influxdb_api_v2": {
                  "summary": "InfluxDB HTTP API V2 Bridge",
                  "value": {
                    "bucket": "example_bucket",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "demo",
                    "org": "examlpe_org",
                    "precision": "ms",
                    "resource_opts": {
                      "batch_size": 100,
                      "batch_time": "20ms"
                    },
                    "server": "127.0.0.1:8086",
                    "ssl": {
                      "enable": false
                    },
                    "token": "example_token",
                    "type": "influxdb_api_v2",
                    "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,uint_value=${payload.uint_key}u,bool=${payload.bool}"
                  }
                },
                "kafka": {
                  "summary": "Kafka Producer Bridge",
                  "value": {
                    "authentication": {
                      "mechanism": "plain",
                      "password": "******",
                      "username": "username"
                    },
                    "bootstrap_hosts": "localhost:9092",
                    "connect_timeout": "5s",
                    "enable": true,
                    "kafka": {
                      "buffer": {
                        "memory_overload_protection": true,
                        "mode": "hybrid",
                        "per_partition_limit": "2GB",
                        "segment_bytes": "100MB"
                      },
                      "compression": "no_compression",
                      "max_batch_bytes": "896KB",
                      "max_inflight": 10,
                      "message": {
                        "key": "${.clientid}",
                        "timestamp": "${.timestamp}",
                        "value": "${.}"
                      },
                      "partition_count_refresh_interval": "60s",
                      "partition_strategy": "random",
                      "required_acks": "all_isr",
                      "topic": "kafka-topic"
                    },
                    "local_topic": "mqtt/local/topic",
                    "metadata_request_timeout": "4s",
                    "min_metadata_refresh_interval": "3s",
                    "socket_opts": {
                      "nodelay": true,
                      "recbuf": "1024KB",
                      "sndbuf": "1024KB"
                    }
                  }
                },
                "kafka_consumer": {
                  "summary": "Kafka Consumer Bridge",
                  "value": {
                    "authentication": {
                      "mechanism": "plain",
                      "password": "******",
                      "username": "username"
                    },
                    "bootstrap_hosts": "localhost:9092",
                    "connect_timeout": "5s",
                    "enable": true,
                    "kafka": {
                      "max_batch_bytes": "896KB",
                      "offset_commit_interval_seconds": 5,
                      "offset_reset_policy": "latest"
                    },
                    "key_encoding_mode": "none",
                    "metadata_request_timeout": "4s",
                    "min_metadata_refresh_interval": "3s",
                    "socket_opts": {
                      "nodelay": true,
                      "recbuf": "1024KB",
                      "sndbuf": "1024KB"
                    },
                    "topic_mapping": [
                      {
                        "kafka_topic": "kafka-topic-1",
                        "mqtt_topic": "mqtt/topic/1",
                        "payload_template": "${.}",
                        "qos": 1
                      },
                      {
                        "kafka_topic": "kafka-topic-2",
                        "mqtt_topic": "mqtt/topic/2",
                        "payload_template": "v = ${.value}",
                        "qos": 2
                      }
                    ],
                    "value_encoding_mode": "none"
                  }
                },
                "matrix": {
                  "summary": "Matrix Bridge",
                  "value": {
                    "database": "mqtt",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "foo",
                    "password": "******",
                    "pool_size": 8,
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "async",
                      "worker_pool_size": 8
                    },
                    "server": "127.0.0.1:5432",
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                    "type": "matrix",
                    "username": "root"
                  }
                },
                "mongodb_rs": {
                  "summary": "MongoDB (Replica Set) Bridge",
                  "value": {
                    "collection": "mycol",
                    "database": "mqtt",
                    "enable": true,
                    "mongo_type": "rs",
                    "name": "mongodb_rs_demo",
                    "password": "******",
                    "pool_size": 8,
                    "r_mode": "safe",
                    "replica_set_name": "rs",
                    "servers": "localhost:27017, localhost:27018",
                    "srv_record": false,
                    "type": "mongodb_rs",
                    "username": "myuser",
                    "w_mode": "safe"
                  }
                },
                "mongodb_sharded": {
                  "summary": "MongoDB (Sharded) Bridge",
                  "value": {
                    "collection": "mycol",
                    "database": "mqtt",
                    "enable": true,
                    "mongo_type": "sharded",
                    "name": "mongodb_sharded_demo",
                    "password": "******",
                    "pool_size": 8,
                    "servers": "localhost:27017, localhost:27018",
                    "srv_record": false,
                    "type": "mongodb_sharded",
                    "username": "myuser",
                    "w_mode": "safe"
                  }
                },
                "mongodb_single": {
                  "summary": "MongoDB (Standalone) Bridge",
                  "value": {
                    "collection": "mycol",
                    "database": "mqtt",
                    "enable": true,
                    "mongo_type": "single",
                    "name": "mongodb_single_demo",
                    "password": "******",
                    "pool_size": 8,
                    "server": "localhost:27017",
                    "srv_record": false,
                    "type": "mongodb_single",
                    "username": "myuser",
                    "w_mode": "safe"
                  }
                },
                "mqtt_example": {
                  "summary": "MQTT Bridge",
                  "value": {
                    "clean_start": true,
                    "egress": {
                      "local": {
                        "topic": "emqx/#"
                      },
                      "remote": {
                        "payload": "${payload}",
                        "qos": "${qos}",
                        "retain": false,
                        "topic": "from_emqx/${topic}"
                      }
                    },
                    "enable": true,
                    "ingress": {
                      "local": {
                        "payload": "${payload}",
                        "qos": "${qos}",
                        "retain": "${retain}",
                        "topic": "from_aws/${topic}"
                      },
                      "remote": {
                        "qos": 1,
                        "topic": "aws/#"
                      }
                    },
                    "keepalive": "300s",
                    "max_inflight": 100,
                    "mode": "cluster_shareload",
                    "name": "mqtt_example",
                    "password": "******",
                    "proto_ver": "v4",
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 104857600,
                      "query_mode": "sync"
                    },
                    "retry_interval": "15s",
                    "server": "127.0.0.1:1883",
                    "ssl": {
                      "enable": false
                    },
                    "type": "mqtt",
                    "username": "foo"
                  }
                },
                "mysql": {
                  "summary": "MySQL Bridge",
                  "value": {
                    "database": "test",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "foo",
                    "password": "******",
                    "pool_size": 8,
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "async",
                      "worker_pool_size": 1
                    },
                    "server": "127.0.0.1:3306",
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, FROM_UNIXTIME(${timestamp}/1000))",
                    "type": "mysql",
                    "username": "root"
                  }
                },
                "pgsql": {
                  "summary": "PostgreSQL Bridge",
                  "value": {
                    "database": "mqtt",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "foo",
                    "password": "******",
                    "pool_size": 8,
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "async",
                      "worker_pool_size": 8
                    },
                    "server": "127.0.0.1:5432",
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                    "type": "pgsql",
                    "username": "root"
                  }
                },
                "redis_cluster": {
                  "summary": "Redis Cluster Bridge",
                  "value": {
                    "command_template": [
                      "LPUSH",
                      "MSGS",
                      "${payload}"
                    ],
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "redis_bridge",
                    "password": "******",
                    "pool_size": 8,
                    "redis_type": "cluster",
                    "resource_opts": {},
                    "servers": [
                      "127.0.0.1:6379"
                    ],
                    "ssl": {
                      "enable": false
                    },
                    "type": "redis_cluster"
                  }
                },
                "redis_sentinel": {
                  "summary": "Redis Sentinel Bridge",
                  "value": {
                    "command_template": [
                      "LPUSH",
                      "MSGS",
                      "${payload}"
                    ],
                    "database": 1,
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "redis_bridge",
                    "password": "******",
                    "pool_size": 8,
                    "redis_type": "sentinel",
                    "resource_opts": {
                      "batch_size": 1,
                      "batch_time": "20ms"
                    },
                    "sentinel": "mymaster",
                    "servers": [
                      "127.0.0.1:26379"
                    ],
                    "ssl": {
                      "enable": false
                    },
                    "type": "redis_sentinel"
                  }
                },
                "redis_single": {
                  "summary": "Redis Single Node Bridge",
                  "value": {
                    "command_template": [
                      "LPUSH",
                      "MSGS",
                      "${payload}"
                    ],
                    "database": 1,
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "redis_bridge",
                    "password": "******",
                    "pool_size": 8,
                    "redis_type": "single",
                    "resource_opts": {
                      "batch_size": 1,
                      "batch_time": "20ms"
                    },
                    "server": "127.0.0.1:6379",
                    "ssl": {
                      "enable": false
                    },
                    "type": "redis_single"
                  }
                },
                "rocketmq": {
                  "summary": "RocketMQ Bridge",
                  "value": {
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "foo",
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "sync",
                      "worker_pool_size": 1
                    },
                    "server": "127.0.0.1:9876",
                    "template": "",
                    "topic": "TopicTest",
                    "type": "rocketmq"
                  }
                },
                "sqlserver": {
                  "summary": "Microsoft SQL Server Bridge",
                  "value": {
                    "database": "test",
                    "driver": "ms-sql",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "bar",
                    "password": "******",
                    "pool_size": 8,
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "async",
                      "worker_pool_size": 1
                    },
                    "server": "127.0.0.1:1433",
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload) values ( ${id}, ${topic}, ${qos}, ${payload} )",
                    "type": "sqlserver",
                    "username": "sa"
                  }
                },
                "tdengine": {
                  "summary": "TDengine Bridge",
                  "value": {
                    "database": "mqtt",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "foo",
                    "password": "taosdata",
                    "pool_size": 8,
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "sync",
                      "worker_pool_size": 8
                    },
                    "server": "127.0.0.1:6041",
                    "sql": "insert into t_mqtt_msg(ts, msgid, mqtt_topic, qos, payload, arrived) values (${ts}, ${id}, ${topic}, ${qos}, ${payload}, ${timestamp})",
                    "type": "tdengine",
                    "username": "root"
                  }
                },
                "timescale": {
                  "summary": "Timescale Bridge",
                  "value": {
                    "database": "mqtt",
                    "enable": true,
                    "local_topic": "local/topic/#",
                    "name": "foo",
                    "password": "******",
                    "pool_size": 8,
                    "resource_opts": {
                      "auto_restart_interval": "60s",
                      "batch_size": 1,
                      "batch_time": 0,
                      "health_check_interval": "15s",
                      "max_buffer_bytes": 268435456,
                      "query_mode": "async",
                      "worker_pool_size": 8
                    },
                    "server": "127.0.0.1:5432",
                    "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                    "type": "timescale",
                    "username": "root"
                  }
                },
                "webhook_example": {
                  "summary": "WebHook",
                  "value": {
                    "body": "${payload}",
                    "connect_timeout": "15s",
                    "enable": true,
                    "enable_pipelining": 100,
                    "local_topic": "emqx_webhook/#",
                    "max_retries": 3,
                    "method": "post",
                    "name": "webhook_example",
                    "pool_size": 4,
                    "pool_type": "random",
                    "request_timeout": "15s",
                    "resource_opts": {
                      "auto_restart_interval": 15000,
                      "health_check_interval": 15000,
                      "inflight_window": 100,
                      "max_buffer_bytes": 104857600,
                      "query_mode": "async",
                      "worker_pool_size": 1
                    },
                    "ssl": {
                      "enable": false
                    },
                    "type": "webhook",
                    "url": "http://localhost:9901/messages/${topic}"
                  }
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/bridge_sqlserver.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_cassa.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_rocketmq.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_dynamo.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_clickhouse.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_tdengine.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_matrix.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_timescale.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_redis.post_cluster"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_redis.post_sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_redis.post_single"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_influxdb.post_api_v2"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_influxdb.post_api_v1"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_hstreamdb.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mongodb.post_single"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mongodb.post_sharded"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mongodb.post_rs"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_pgsql.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mysql.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_kafka.post_producer"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_kafka.post_consumer"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_gcp_pubsub.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_mqtt.post"
                  },
                  {
                    "$ref": "#/components/schemas/bridge_webhook.post"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "cassandra": {
                    "summary": "Cassandra Bridge",
                    "value": {
                      "cql": "insert into mqtt_msg(topic, msgid, sender, qos, payload, arrived, retain) values (${topic}, ${id}, ${clientid}, ${qos}, ${payload}, ${timestamp}, ${flags.retain})",
                      "enable": true,
                      "keyspace": "mqtt",
                      "local_topic": "local/topic/#",
                      "name": "foo",
                      "password": "******",
                      "pool_size": 8,
                      "resource_opts": {
                        "auto_restart_interval": "60s",
                        "batch_size": 1,
                        "batch_time": 0,
                        "health_check_interval": "15s",
                        "max_buffer_bytes": 268435456,
                        "query_mode": "sync",
                        "worker_pool_size": 8
                      },
                      "servers": "127.0.0.1:9042",
                      "type": "cassandra",
                      "username": "root"
                    }
                  },
                  "clickhouse": {
                    "summary": "Clickhouse Bridge",
                    "value": {
                      "batch_value_separator": ", ",
                      "database": "mqtt",
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "foo",
                      "password": "******",
                      "pool_size": 8,
                      "resource_opts": {
                        "auto_restart_interval": "60s",
                        "batch_size": 1,
                        "batch_time": 0,
                        "health_check_interval": "15s",
                        "max_buffer_bytes": 268435456,
                        "query_mode": "async",
                        "worker_pool_size": 8
                      },
                      "server": "127.0.0.1:8123",
                      "sql": "INSERT INTO mqtt_test(payload, arrived) VALUES ('${payload}', ${timestamp})",
                      "type": "clickhouse",
                      "username": "default"
                    }
                  },
                  "dynamo": {
                    "summary": "DynamoDB Bridge",
                    "value": {
                      "aws_access_key_id": "root",
                      "aws_secret_access_key": "******",
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "foo",
                      "pool_size": 8,
                      "resource_opts": {
                        "auto_restart_interval": "60s",
                        "batch_size": 1,
                        "batch_time": 0,
                        "health_check_interval": "15s",
                        "max_buffer_bytes": 268435456,
                        "query_mode": "sync",
                        "worker_pool_size": 8
                      },
                      "table": "mqtt",
                      "template": "",
                      "type": "dynamo",
                      "url": "http://127.0.0.1:8000"
                    }
                  },
                  "gcp_pubsub": {
                    "summary": "GCP PubSub Bridge",
                    "value": {
                      "pubsub_topic": "mytopic",
                      "service_account_json": {
                        "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                        "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                        "client_email": "test@myproject.iam.gserviceaccount.com",
                        "client_id": "123812831923812319190",
                        "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/test%40myproject.iam.gserviceaccount.com",
                        "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQI...",
                        "private_key_id": "kid",
                        "project_id": "myproject",
                        "token_uri": "https://oauth2.googleapis.com/token",
                        "type": "service_account"
                      }
                    }
                  },
                  "hstreamdb": {
                    "summary": "HStreamDB Bridge",
                    "value": {
                      "connector": "hstreamdb:connector",
                      "direction": "egress",
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "demo",
                      "payload": "${payload}",
                      "type": "hstreamdb"
                    }
                  },
                  "influxdb_api_v1": {
                    "summary": "InfluxDB HTTP API V1 Bridge",
                    "value": {
                      "database": "example_database",
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "demo",
                      "password": "******",
                      "precision": "ms",
                      "resource_opts": {
                        "batch_size": 100,
                        "batch_time": "20ms"
                      },
                      "server": "127.0.0.1:8086",
                      "ssl": {
                        "enable": false
                      },
                      "type": "influxdb_api_v1",
                      "username": "example_username",
                      "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,bool=${payload.bool}"
                    }
                  },
                  "influxdb_api_v2": {
                    "summary": "InfluxDB HTTP API V2 Bridge",
                    "value": {
                      "bucket": "example_bucket",
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "demo",
                      "org": "examlpe_org",
                      "precision": "ms",
                      "resource_opts": {
                        "batch_size": 100,
                        "batch_time": "20ms"
                      },
                      "server": "127.0.0.1:8086",
                      "ssl": {
                        "enable": false
                      },
                      "token": "example_token",
                      "type": "influxdb_api_v2",
                      "write_syntax": "${topic},clientid=${clientid} payload=${payload},${clientid}_int_value=${payload.int_key}i,uint_value=${payload.uint_key}u,bool=${payload.bool}"
                    }
                  },
                  "kafka": {
                    "summary": "Kafka Producer Bridge",
                    "value": {
                      "authentication": {
                        "mechanism": "plain",
                        "password": "******",
                        "username": "username"
                      },
                      "bootstrap_hosts": "localhost:9092",
                      "connect_timeout": "5s",
                      "enable": true,
                      "kafka": {
                        "buffer": {
                          "memory_overload_protection": true,
                          "mode": "hybrid",
                          "per_partition_limit": "2GB",
                          "segment_bytes": "100MB"
                        },
                        "compression": "no_compression",
                        "max_batch_bytes": "896KB",
                        "max_inflight": 10,
                        "message": {
                          "key": "${.clientid}",
                          "timestamp": "${.timestamp}",
                          "value": "${.}"
                        },
                        "partition_count_refresh_interval": "60s",
                        "partition_strategy": "random",
                        "required_acks": "all_isr",
                        "topic": "kafka-topic"
                      },
                      "local_topic": "mqtt/local/topic",
                      "metadata_request_timeout": "4s",
                      "min_metadata_refresh_interval": "3s",
                      "socket_opts": {
                        "nodelay": true,
                        "recbuf": "1024KB",
                        "sndbuf": "1024KB"
                      }
                    }
                  },
                  "kafka_consumer": {
                    "summary": "Kafka Consumer Bridge",
                    "value": {
                      "authentication": {
                        "mechanism": "plain",
                        "password": "******",
                        "username": "username"
                      },
                      "bootstrap_hosts": "localhost:9092",
                      "connect_timeout": "5s",
                      "enable": true,
                      "kafka": {
                        "max_batch_bytes": "896KB",
                        "offset_commit_interval_seconds": 5,
                        "offset_reset_policy": "latest"
                      },
                      "key_encoding_mode": "none",
                      "metadata_request_timeout": "4s",
                      "min_metadata_refresh_interval": "3s",
                      "socket_opts": {
                        "nodelay": true,
                        "recbuf": "1024KB",
                        "sndbuf": "1024KB"
                      },
                      "topic_mapping": [
                        {
                          "kafka_topic": "kafka-topic-1",
                          "mqtt_topic": "mqtt/topic/1",
                          "payload_template": "${.}",
                          "qos": 1
                        },
                        {
                          "kafka_topic": "kafka-topic-2",
                          "mqtt_topic": "mqtt/topic/2",
                          "payload_template": "v = ${.value}",
                          "qos": 2
                        }
                      ],
                      "value_encoding_mode": "none"
                    }
                  },
                  "matrix": {
                    "summary": "Matrix Bridge",
                    "value": {
                      "database": "mqtt",
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "foo",
                      "password": "******",
                      "pool_size": 8,
                      "resource_opts": {
                        "auto_restart_interval": "60s",
                        "batch_size": 1,
                        "batch_time": 0,
                        "health_check_interval": "15s",
                        "max_buffer_bytes": 268435456,
                        "query_mode": "async",
                        "worker_pool_size": 8
                      },
                      "server": "127.0.0.1:5432",
                      "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                      "type": "matrix",
                      "username": "root"
                    }
                  },
                  "mongodb_rs": {
                    "summary": "MongoDB (Replica Set) Bridge",
                    "value": {
                      "collection": "mycol",
                      "database": "mqtt",
                      "enable": true,
                      "mongo_type": "rs",
                      "name": "mongodb_rs_demo",
                      "password": "******",
                      "pool_size": 8,
                      "r_mode": "safe",
                      "replica_set_name": "rs",
                      "servers": "localhost:27017, localhost:27018",
                      "srv_record": false,
                      "type": "mongodb_rs",
                      "username": "myuser",
                      "w_mode": "safe"
                    }
                  },
                  "mongodb_sharded": {
                    "summary": "MongoDB (Sharded) Bridge",
                    "value": {
                      "collection": "mycol",
                      "database": "mqtt",
                      "enable": true,
                      "mongo_type": "sharded",
                      "name": "mongodb_sharded_demo",
                      "password": "******",
                      "pool_size": 8,
                      "servers": "localhost:27017, localhost:27018",
                      "srv_record": false,
                      "type": "mongodb_sharded",
                      "username": "myuser",
                      "w_mode": "safe"
                    }
                  },
                  "mongodb_single": {
                    "summary": "MongoDB (Standalone) Bridge",
                    "value": {
                      "collection": "mycol",
                      "database": "mqtt",
                      "enable": true,
                      "mongo_type": "single",
                      "name": "mongodb_single_demo",
                      "password": "******",
                      "pool_size": 8,
                      "server": "localhost:27017",
                      "srv_record": false,
                      "type": "mongodb_single",
                      "username": "myuser",
                      "w_mode": "safe"
                    }
                  },
                  "mqtt_example": {
                    "summary": "MQTT Bridge",
                    "value": {
                      "clean_start": true,
                      "egress": {
                        "local": {
                          "topic": "emqx/#"
                        },
                        "remote": {
                          "payload": "${payload}",
                          "qos": "${qos}",
                          "retain": false,
                          "topic": "from_emqx/${topic}"
                        }
                      },
                      "enable": true,
                      "ingress": {
                        "local": {
                          "payload": "${payload}",
                          "qos": "${qos}",
                          "retain": "${retain}",
                          "topic": "from_aws/${topic}"
                        },
                        "remote": {
                          "qos": 1,
                          "topic": "aws/#"
                        }
                      },
                      "keepalive": "300s",
                      "max_inflight": 100,
                      "mode": "cluster_shareload",
                      "name": "mqtt_example",
                      "password": "******",
                      "proto_ver": "v4",
                      "resource_opts": {
                        "auto_restart_interval": "60s",
                        "health_check_interval": "15s",
                        "max_buffer_bytes": 104857600,
                        "query_mode": "sync"
                      },
                      "retry_interval": "15s",
                      "server": "127.0.0.1:1883",
                      "ssl": {
                        "enable": false
                      },
                      "type": "mqtt",
                      "username": "foo"
                    }
                  },
                  "mysql": {
                    "summary": "MySQL Bridge",
                    "value": {
                      "database": "test",
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "foo",
                      "password": "******",
                      "pool_size": 8,
                      "resource_opts": {
                        "auto_restart_interval": "60s",
                        "batch_size": 1,
                        "batch_time": 0,
                        "health_check_interval": "15s",
                        "max_buffer_bytes": 268435456,
                        "query_mode": "async",
                        "worker_pool_size": 1
                      },
                      "server": "127.0.0.1:3306",
                      "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, FROM_UNIXTIME(${timestamp}/1000))",
                      "type": "mysql",
                      "username": "root"
                    }
                  },
                  "pgsql": {
                    "summary": "PostgreSQL Bridge",
                    "value": {
                      "database": "mqtt",
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "foo",
                      "password": "******",
                      "pool_size": 8,
                      "resource_opts": {
                        "auto_restart_interval": "60s",
                        "batch_size": 1,
                        "batch_time": 0,
                        "health_check_interval": "15s",
                        "max_buffer_bytes": 268435456,
                        "query_mode": "async",
                        "worker_pool_size": 8
                      },
                      "server": "127.0.0.1:5432",
                      "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                      "type": "pgsql",
                      "username": "root"
                    }
                  },
                  "redis_cluster": {
                    "summary": "Redis Cluster Bridge",
                    "value": {
                      "command_template": [
                        "LPUSH",
                        "MSGS",
                        "${payload}"
                      ],
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "redis_bridge",
                      "password": "******",
                      "pool_size": 8,
                      "redis_type": "cluster",
                      "resource_opts": {},
                      "servers": [
                        "127.0.0.1:6379"
                      ],
                      "ssl": {
                        "enable": false
                      },
                      "type": "redis_cluster"
                    }
                  },
                  "redis_sentinel": {
                    "summary": "Redis Sentinel Bridge",
                    "value": {
                      "command_template": [
                        "LPUSH",
                        "MSGS",
                        "${payload}"
                      ],
                      "database": 1,
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "redis_bridge",
                      "password": "******",
                      "pool_size": 8,
                      "redis_type": "sentinel",
                      "resource_opts": {
                        "batch_size": 1,
                        "batch_time": "20ms"
                      },
                      "sentinel": "mymaster",
                      "servers": [
                        "127.0.0.1:26379"
                      ],
                      "ssl": {
                        "enable": false
                      },
                      "type": "redis_sentinel"
                    }
                  },
                  "redis_single": {
                    "summary": "Redis Single Node Bridge",
                    "value": {
                      "command_template": [
                        "LPUSH",
                        "MSGS",
                        "${payload}"
                      ],
                      "database": 1,
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "redis_bridge",
                      "password": "******",
                      "pool_size": 8,
                      "redis_type": "single",
                      "resource_opts": {
                        "batch_size": 1,
                        "batch_time": "20ms"
                      },
                      "server": "127.0.0.1:6379",
                      "ssl": {
                        "enable": false
                      },
                      "type": "redis_single"
                    }
                  },
                  "rocketmq": {
                    "summary": "RocketMQ Bridge",
                    "value": {
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "foo",
                      "resource_opts": {
                        "auto_restart_interval": "60s",
                        "batch_size": 1,
                        "batch_time": 0,
                        "health_check_interval": "15s",
                        "max_buffer_bytes": 268435456,
                        "query_mode": "sync",
                        "worker_pool_size": 1
                      },
                      "server": "127.0.0.1:9876",
                      "template": "",
                      "topic": "TopicTest",
                      "type": "rocketmq"
                    }
                  },
                  "sqlserver": {
                    "summary": "Microsoft SQL Server Bridge",
                    "value": {
                      "database": "test",
                      "driver": "ms-sql",
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "bar",
                      "password": "******",
                      "pool_size": 8,
                      "resource_opts": {
                        "auto_restart_interval": "60s",
                        "batch_size": 1,
                        "batch_time": 0,
                        "health_check_interval": "15s",
                        "max_buffer_bytes": 268435456,
                        "query_mode": "async",
                        "worker_pool_size": 1
                      },
                      "server": "127.0.0.1:1433",
                      "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload) values ( ${id}, ${topic}, ${qos}, ${payload} )",
                      "type": "sqlserver",
                      "username": "sa"
                    }
                  },
                  "tdengine": {
                    "summary": "TDengine Bridge",
                    "value": {
                      "database": "mqtt",
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "foo",
                      "password": "taosdata",
                      "pool_size": 8,
                      "resource_opts": {
                        "auto_restart_interval": "60s",
                        "batch_size": 1,
                        "batch_time": 0,
                        "health_check_interval": "15s",
                        "max_buffer_bytes": 268435456,
                        "query_mode": "sync",
                        "worker_pool_size": 8
                      },
                      "server": "127.0.0.1:6041",
                      "sql": "insert into t_mqtt_msg(ts, msgid, mqtt_topic, qos, payload, arrived) values (${ts}, ${id}, ${topic}, ${qos}, ${payload}, ${timestamp})",
                      "type": "tdengine",
                      "username": "root"
                    }
                  },
                  "timescale": {
                    "summary": "Timescale Bridge",
                    "value": {
                      "database": "mqtt",
                      "enable": true,
                      "local_topic": "local/topic/#",
                      "name": "foo",
                      "password": "******",
                      "pool_size": 8,
                      "resource_opts": {
                        "auto_restart_interval": "60s",
                        "batch_size": 1,
                        "batch_time": 0,
                        "health_check_interval": "15s",
                        "max_buffer_bytes": 268435456,
                        "query_mode": "async",
                        "worker_pool_size": 8
                      },
                      "server": "127.0.0.1:5432",
                      "sql": "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))",
                      "type": "timescale",
                      "username": "root"
                    }
                  },
                  "webhook_example": {
                    "summary": "WebHook",
                    "value": {
                      "body": "${payload}",
                      "connect_timeout": "15s",
                      "enable": true,
                      "enable_pipelining": 100,
                      "local_topic": "emqx_webhook/#",
                      "max_retries": 3,
                      "method": "post",
                      "name": "webhook_example",
                      "pool_size": 4,
                      "pool_type": "random",
                      "request_timeout": "15s",
                      "resource_opts": {
                        "auto_restart_interval": 15000,
                        "health_check_interval": 15000,
                        "inflight_window": 100,
                        "max_buffer_bytes": 104857600,
                        "query_mode": "async",
                        "worker_pool_size": 1
                      },
                      "ssl": {
                        "enable": false
                      },
                      "type": "webhook",
                      "url": "http://localhost:9901/messages/${topic}"
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/bridge_sqlserver.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_cassa.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_rocketmq.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_dynamo.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_clickhouse.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_tdengine.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_matrix.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_timescale.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_redis.get_cluster"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_redis.get_sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_redis.get_single"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_influxdb.get_api_v2"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_influxdb.get_api_v1"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_hstreamdb.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mongodb.get_single"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mongodb.get_sharded"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mongodb.get_rs"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_pgsql.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mysql.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_kafka.get_producer"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_kafka.get_consumer"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_gcp_pubsub.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_mqtt.get"
                    },
                    {
                      "$ref": "#/components/schemas/bridge_webhook.get"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "ALREADY_EXISTS"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bridge already exists",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Create Bridge",
        "tags": [
          "Bridges"
        ]
      }
    },
    "/listeners_status": {
      "get": {
        "description": "List all running node's listeners live status. group by listener type",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": [
                  {
                    "enable": false,
                    "ids": [
                      "tcp:demo"
                    ],
                    "node_status": [
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "current_connections": 11,
                          "max_connections": 1024000,
                          "running": true
                        }
                      },
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "current_connections": 10,
                          "max_connections": 1024000,
                          "running": true
                        }
                      }
                    ],
                    "status": {
                      "current_connections": 21,
                      "max_connections": 2048000,
                      "running": true
                    },
                    "type": "tcp"
                  },
                  {
                    "enable": false,
                    "ids": [
                      "ssl:default"
                    ],
                    "node_status": [
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "current_connections": 31,
                          "max_connections": "infinity",
                          "running": true
                        }
                      },
                      {
                        "node": "emqx@127.0.0.1",
                        "status": {
                          "current_connections": 40,
                          "max_connections": "infinity",
                          "running": true
                        }
                      }
                    ],
                    "status": {
                      "current_connections": 71,
                      "max_connections": "infinity",
                      "running": true
                    },
                    "type": "ssl"
                  }
                ],
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/listeners.listener_type_status"
                  },
                  "type": "array"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Listeners"
        ]
      }
    },
    "/monitor": {
      "get": {
        "description": "List monitor data.",
        "parameters": [
          {
            "description": "The latest N seconds data. Like 300 for 5 min.",
            "example": 300,
            "in": "query",
            "name": "latest",
            "required": false,
            "schema": {
              "minimum": 1,
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/emqx_dashboard_monitor_api.sampler"
                  },
                  "type": "array"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_RPC"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad RPC",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Metrics"
        ]
      }
    },
    "/logout": {
      "post": {
        "description": "Dashboard user logout",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "username": {
                    "description": "Dashboard Username",
                    "example": "admin",
                    "maxLength": 100,
                    "type": "string"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Dashboard logout successfully"
          },
          "401": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_USERNAME_OR_PWD"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Login failed. Bad username or password",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Dashboard"
        ]
      }
    },
    "/authorization/sources/built_in_database/rules/all": {
      "delete": {
        "description": "Delete rules for 'all'",
        "parameters": [],
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Authorization"
        ]
      },
      "get": {
        "description": "Show the list of rules for 'all'",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "password_based:built_in_database": {
                    "summary": "All",
                    "value": {
                      "rules": [
                        {
                          "action": "publish",
                          "permission": "allow",
                          "topic": "test/toopic/1"
                        },
                        {
                          "action": "subscribe",
                          "permission": "allow",
                          "topic": "test/toopic/2"
                        },
                        {
                          "action": "all",
                          "permission": "deny",
                          "topic": "eq test/#"
                        }
                      ]
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authz_api_mnesia.rules"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Authorization"
        ]
      },
      "post": {
        "description": "Create/Update the list of rules for 'all'.",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "password_based:built_in_database": {
                  "summary": "All",
                  "value": {
                    "rules": [
                      {
                        "action": "publish",
                        "permission": "allow",
                        "topic": "test/toopic/1"
                      },
                      {
                        "action": "subscribe",
                        "permission": "allow",
                        "topic": "test/toopic/2"
                      },
                      {
                        "action": "all",
                        "permission": "deny",
                        "topic": "eq test/#"
                      }
                    ]
                  }
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authz_api_mnesia.rules"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Updated"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad rule schema",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Authorization"
        ]
      }
    },
    "/listeners/{listener_id}/authentication/{id}/users": {
      "get": {
        "description": "List users in authenticator in listener authentication chain.",
        "parameters": [
          {
            "description": "Listener ID.",
            "example": "tcp:default",
            "in": "path",
            "name": "listener_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          },
          {
            "description": "Is superuser",
            "in": "query",
            "name": "is_superuser",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "data": [
                    {
                      "user_id": "user1"
                    },
                    {
                      "is_superuser": true,
                      "user_id": "user2"
                    }
                  ],
                  "meta": {
                    "count": 300,
                    "limit": 20,
                    "page": 0
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_users"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Listener Authentication"
        ]
      },
      "post": {
        "description": "Create users for authenticator in listener authentication chain.",
        "parameters": [
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Listener ID.",
            "example": "tcp:default",
            "in": "path",
            "name": "listener_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "regular_user": {
                  "summary": "Regular user",
                  "value": {
                    "password": "******",
                    "user_id": "user1"
                  }
                },
                "super_user": {
                  "summary": "Superuser",
                  "value": {
                    "is_superuser": true,
                    "password": "******",
                    "user_id": "user2"
                  }
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authn_api.request_user_create"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "regular_user": {
                    "summary": "Regular user",
                    "value": {
                      "user_id": "user1"
                    }
                  },
                  "super_user": {
                    "summary": "Superuser",
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Listener Authentication"
        ]
      }
    },
    "/rule_engine": {
      "get": {
        "description": "Get rule engine configuration.",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_rule_api_schema.rule_engine"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Get configuration",
        "tags": [
          "Rules"
        ]
      },
      "put": {
        "description": "Update rule engine configuration.",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx_rule_api_schema.rule_engine"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_rule_api_schema.rule_engine"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Invalid request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Update configuration",
        "tags": [
          "Rules"
        ]
      }
    },
    "/clients/{clientid}/keepalive": {
      "put": {
        "description": "Set the online client keepalive by seconds",
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx_mgmt_api_clients.keepalive"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_clients.client"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "CLIENTID_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Client ID not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "Clients"
        ]
      }
    }
  },
  "servers": [
    {
      "url": "/api/v5"
    }
  ]
}
